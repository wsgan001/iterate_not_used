第么＜L＞章

离线应用与客户端存储

本章内容

□进行离线检测

□使用离线缓存

□在浏览器中保存数据

■持离线Web应用开发是HTML5的另一个重点。所谓离线Web应用，就是在设备不能L

X网的情况下仍然可以运行的应用。HTML5把离线应用作为重点，主要是基于开发人员的 心愿。前端开发人员一直希望Web应用能够与传统的客户端应用同场竞技，起码做到只要设备有电 就能使用。

开发离线Web应用需要几个步骤。首先是确保应用知道设备是否能上网，以便下一步执行正确的 操作。然后，应用还必须能访问一定的资源（图像、JavaScript, CSS等），只有这样彳能正常工作。最 后，必须有一块本地空间用于保存数据，无论能否上网都不妨碍读写。HTML5及其•相关的API让开发 离线应用成为现实。

23.1离线检测

开发离线应用的第一步是要知道设备是在线还是离线,HTML5为此定义了一个navigator.onLine 属性，这个属性值为true表示设备能上网，值为false衷示设备离线。这个属性的关键是浏览器必须 知道设备能否访问网络，从而返回iE确的值。实际应用中，navigator.onLine在不同浏览器间还有 些小的差异。

□    IE6+和Safari 5+能够正确检测到网络已断Jf,并将navigator .onLine的值转换为false。

□    Firefox■和Opera 10.64■支持navigator.onLine属性,但你必须手工选中菜单项“文件Web 开发人员（设置）—脱机工作”才能让浏览器正常工作。

□    Chrome 11及之前版本始终将navigator.onLine属性设置为true。这是一个有待修隻的 bug①。

由于存在上述兼容性问题，单独使用navigator.onLine属性不能确定网络是否连通。即便如此， 在请求发生错误的情况下，检測这个属性仍然是赞用的。以下是检測该属性状态的示例。

if （navigator.onLine）{ //正常工作

} else {

//执行离线状态时的任务

①译个 bug 在 2011 年 10 月已被修复(http://c<xJe.googlc.com/p/chromium/issucs/detail?id=7469 )o

OnLineExampleOl .htm

除navigator.onLine属性之外，为了更好地确定网络是否可用，HTML5还定义了两个事件： online和offline。汽网络从离线变为在线或者从在线变为离线时，分别触发这两个事件。这两个事 件在window对象上触发。

EventUtil.addHandler(window, "online", function(){ alert("Online");

});

EventUtil.addHandler(window, "offline", function{){ alert{"Offline");

});

OnlineEventsExampleO 1 .htm

为了检测应用是否离线，在页面加载后，最好先通过navigator .onLine取得初始的状态。然后， 就是通过上述两个事件来确定网络连接状态是否变化。当上述事件触发吋，navigator.onLine属性 的值也会改变，不过必须要手工轮询这个埔性冰能检测到网络状态的变化。

支持离线检测的浏览器有 IE 6+(只支持 navigator. onLine 厲性)、Firefox 3、Safari 4、Opera 10.6、 Chrome、iOS 3.2 版 Safari 和 Android 版 WebKit。

23.2应用缓存

HTML5的应用缓存(application cache),或者简称为appcache，是专门为开发南线Web应用而设计 的。Appcache就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个 描述文件(manifestfile),列出要下载和缓存的资源。下面是一个简单的描述文件示例。

CACHE MANIFEST

\#Ccmment

file.js

file.css

在赴简单的情况下，描述文件中列出的都是需要下载的资源，以备离线时使用。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-115.jpg)

 

设置描述文件的选项非常多，本书不打算详细解释每一个选项。要了解这些选项，

推荐读老阅读 HTML5Doctor 中的文章 “Go offline with application cache”，网址为 <http://html5doctor.com/go-offline-with-application-cachec>,

要将描述文件与页面关联起来，可以在<html>巾的manifest域性中指定这个文件的路径，例如： <html manifest?/offline.manifest•>

以上代码告诉页面，/offline.manifest中包含着描述文件。这个文件的MIME类型必须是 text/cache-manifest®o

①描述文件的扩嵌名以前推荐用manifest,但现在推荐的是appcache。

虽然应用缓存的意图是确保离线时资源吋用，但也有相应的JavaScript API让你知道它都在做什么。 这个API的核心j是applicationCache对象，这个对象有一个status属性，属性的值是常量，表示 应用缓存的如下当前状态。

□    0：无缓存，即没有与页面相关的应用缓存。

□    1:闲置，即应用缓存未得到更新。

□    2:检査中，即正在下载描述文件并检査更新。

□    3：下载中，即应用缓存正在下载描述文件中指定的资源。

□    4:更新完成，即应用缓存已经更新f资源，而且所有资源都已下载完毕，可以通过swapeacheO 来使用丁。

□    5:废弃，即应用缓存的描述文件已经不存在了，因此页面无法再访问应用缓存。

应用缓存还有很多相关的事件，表示其状态的改变。以下是这些事件。

□    checking：在浏览器为应用缓存査找更新时触发。

□    error：在检查更新或下载资源期间发生错误时触发。

□    noupdate：在检査描述文件发现文件无变化时触发。

□    downloading:在开始下载应用缓存资源时触发。

□    progress：在文件下载应用缓存的过程中持续不断地触发。

□    updateready:在页面新的应用缓存下载完毕且可以通过swapCache ()使用时触发。

□    cached:在应用缓存完整可用时触发。

--般来讲，这些事件会随着页面加载按上述顺序依次触发。不过，通过调用update ()方法也可以 手工干预，让应用缓存为检查更新而触发k述事件。

applicationCache.update()?

updated 一经调用，应用缓存就会去检査描述文件是否更新(触发checking事件)，然后就像页 面刚刚加载一样，继续执行后续操作。如果触发了 cached事件，就说明应用缓存已经准备就绪，不会 再发生其他操作了。如果触发了 updateready事件，则说明新版本的应用缓存已经可用，而此时你需 要调用swapCache ()来启用新应用缓存。

EventU匕il.addHandler{applicationCache, "updateready■z function(){ applicationCache.swapCache();

});

支持 HTML5 应用缓存的浏览器有 Firefox 3+、Safari 4+、Opera 10.6、Chrome、iOS 3.2+版 Safari 及Android版WebKit。在Firefox 4及之前版本中调用swapCache {)会抛出错误。

23.3数据存储

随着Web应用程序的出现，也产生了对于能够直接在客户端上存储用户信息能力的要求。想法很 合乎逻辑，属于某个特定用户的信息应该存在该用户的机器1:。无论是登录信息、偏好设定或其他数据， Web应用提供者发现他们在找各种方式将数据存在客户端上。这个问题的第一个方案是以cookie的形式 出现的，cookie是原来的网景公司创造的。一份题为“Persistent Client State: HTTP Cookes”(持久客户 端状态：HTTP Cookies )的标准中对cookie机制进行了阐述(该标准还可以在这里.看到： [http://curl.haxx.se/rfc/cookie_spec.html)](http://curl.haxx.se/rfc/cookie_spec.html)%e3%80%82%e4%bb%8a%e5%a4%a9%ef%bc%8ccookie%e5%8f%aa%e6%98%af%e5%9c%a8%e5%ae%a2%e6%88%b7%e7%ab%af%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae%e7%9a%84%e5%85%b6%e4%b8%ad%e4%b8%80%e7%a7%8d%e9%80%89%e9%a1%b9'%e3%80%82)[。今天，cookie只是在客户端存储数据的其中一种选项'。](http://curl.haxx.se/rfc/cookie_spec.html)%e3%80%82%e4%bb%8a%e5%a4%a9%ef%bc%8ccookie%e5%8f%aa%e6%98%af%e5%9c%a8%e5%ae%a2%e6%88%b7%e7%ab%af%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae%e7%9a%84%e5%85%b6%e4%b8%ad%e4%b8%80%e7%a7%8d%e9%80%89%e9%a1%b9'%e3%80%82)

23.3.1 Cookie

HTTP Cookie,通常直接叫做cookie,最初是苻客户端用于存储会话信息的。该杨准要求服务器对 任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分，其中包含会话信息。例如，这种服务器响 应的头可能如下：

HTTP/1.1 200 0K

Content-type: texc/html

Set-Cookie: name=value

Other-header: other-header-value

这个HTTP响应设置以name为名称、以value为值的一个cookie,名称和值在传送时都必须是 URL编码的。浏览器会存储这样的会话信息，并在这之后，通过为毎个请求添加Cookie HTTP头将信 息发送冋服务器，如下所示：

GET /index.html HTTP/1.1 Cookie: name=value Other-header: other-header-value

发送回服务器的额外信息可以用于唯一验证客户来自于发送的哪个请求。

1.限制

cookie在性质上是绑定在特定的域名下的。当设定了一个cookie后，再给创建它的域名发送请求时, 都会包含这个cookie。这个限制确保r储存在cookie中的信息只能让批准的接受者访问，而无法被K他 域访问。

由于cookie是存在客户端汁算机上的，还加人了一些限制确保cookie不会被恶意使用，同时不会占 据太多磁盘空间。每个域的cookie总数是冇限的，不过浏览器之间各有不同。如下所示。

□    TE6以及更低版本限制每个域名最多20个cookie。

□    IE7和之后版本毎个域名最多50个。IE7最初是支持每个域名最大20个cookie,之后被微软的 一个补丁所更新。

口 Firefox限制每个域最多50个cookie。

□    Opefa限制每个域最多30个cookie,

□    Safari和Chrome对于毎个域的cookie数盘限制没有硬性规定。

汽超过单个域名限制之后还要冉设置cookie,浏览器就会淸除以前设背的cookie。IE和Opera会删 除最近域少使用过的（LRU, Least Recently Used） cookie,腾出空间给新没置的cookie。Firefox看上去 好像是随机决定要清除哪个cookie,所以考虑cookie限制非常重要，以免出现不可预期的后果。

23

 

浏览器中对于cookie的尺寸也有限制。大多数浏览器都奋大约4096B （加减丨）的长度限制。为了 最佳的浏览器兼容性，最好将整个cookie长度限制在4095B （含4095 ）以内。尺寸限制影响到一个域 下所有的cookie,而并非每个cookie中■独限制。

如果你尝试创建超过最大尺寸限制的cookie,那么该cookie会被悄无声息地£•掉。注意，虽然一个 字符通常占用一字节，但是多字节悄况则布不同。

\2. cookie的构成

cookie出浏览器保存的以下几块信息构成。

□名称:一个唯确定cookie的名称。cookie名称是不区分大小写的，所以myCookie和MyCookie 被认为是同一个cookie。然而，实践中最好将cookie名称看作是区分大小写的，因为某些服务

器会这样处理cookieo cookie的名称必须是经过URL编码的c,

□值：储存在cookie中的字符申值。值必须被URL编码、

□域：cookie对于哪个域是有效的。所有向该域发送的W求中都会包含这个cookie信息。这个值 可以包含子域（subdomain,如[www.wrox](http://www.wrox). com）,也可以不包含它（如.wrox.com,则对于wrox.com 的所有子域都有效）。如果没有明确设定，那么这个域会被认作来G设置cookie的那个域。

□路径：对于指定域中的那个路径，成该向服务器发送cookie。例如，你可以指定cookie只有从 <http://ww.wrox.coin/books/> 中才能访问，那么 <http://www.wrox.com> 的页面就不会发 送cookie信息，即使请求都是来自同一个域的。

□失效时间：表示cookie何吋应该被删除的吋间戳（也就是，何时应该停止向服务器发送这个 cookie ）„默认悄况下，浏览器会话钻束时即将所有cookie删除；不过也可以自已设置删除时间。 这个值是个GMT格式的日期（Wdy, DD-Mon-YYYY HH:MM:SS GMT）,用于指定应该删除 cookie的准确吋间。因此，cookie可在浏览器关闭耵依然保存在用户的机器上。如果你设®的失 效日期是个以前的时间，则cookie会被立刻删除。

□安全标志：指定后，cookie只有在使用SSL连接的时候冰发送到服务器。例如，cookie信息只 能发送给https: //www.wrox.com,而 <http://www.wrox.com> 的请求则不能发送 cookie。

毎一段位息都作为Set-Cookie头的一部分，使用分号加空格分隔每一段，如下例所示。

HTTP/1.1 200 OK Content-type： text/html

Set-Cookie: namervalue; expiressMon, 22-Jan-07 07:10:24 GMT； domain~.wrox.com

Other-header: other-header-value

该头信息指定了一个叫做name的cookie,它会在格林威治时间2007年1月22日7:10:24失效，同 时对于 [www.wrox.com](http://www.wrox.com) 和 wrox.com 的任何了•域（如 p2p.wrox.com ）都有效o

secure你志是cookie中唯---■个非名值对儿的部分，貫接包含一个secure单词。如下：

HTTP/X.1 200 0K Content-type： text/html

Set-Cookie： name-value； domain%.wrox.com; paths/; secure

Other-header: other-header-value

这里，创建了一个对于所有wrox.com的子域和域名下（由path参数指定的）所冇页面都有效的 cookie。W为设置丫 secure标志，这个《）okic只能通过SSL连接才能传输》

尤K要注意，域、路径、失效时间和secure标志都是服务器给浏览器的指示，以指定何时应该发 送cookie。这些参数并不会作为发送到服务器的cookie信息的--部分，只布名值对儿才会被发送。

\3. JavaScript 中的 cookie

在JavaScript中处埋cookie有些复杂,因为龙众所周知的整脚的接口，即BOM的document. cookie 属性。这个属性的独特之处在于它会W为使用它的方式不同而表现出不同的行为。当用米获取属性值时， document, cookie返回当前页面可用的（根据cookie的域、路裕、失效时间和安全设S ）所有cookie 的字符串，一系列由分马隔开的名值对儿，如下例所示。

namel=valuel；nane2=value2；nanie3：.value3

所也名字和值都是经过URL编码的，所以必须使用decodeURIComponent （）来解码。

当用于设S值的时候，document - cookie属性町以设置为一个新的cookie字符申。这个cookie字 符节会被解释并添加到现有的cookie集合中。设置document. cookie并不会覆盖cookie,除设凭的

cookie的名称已经存在。设晋cookie的格式如下，和Set-Cookie头中使用的格式一样。

name=value； expires-expiration__time； pach=domain_path; domain=domain_name，- secure

这些参数中，只有cookie的名字和值足必需的。下面是一个简单的例子。

document.cookie = "name=Nicholasu;

这段代码创建了一个叫name的cookie,值为Nicholas。当客户端每次向服务器端发送请求的时 候，都会发送这个cookie;当浏览器关闭的时候，它就会被删除。虽然这段代码没问题，但因为这里正 好名称和值都无需编码，所以最好每次设置cookie时都像下面这个例子巾一样使用encodeURI-Component()o

document.cookie = encodeURIComponent("name") + *=" + encodelJRIComponent ("Nicholas");

要给被创建的cookie指定额外的信息，只要将参数追加到该字符串，和Set-Cookie头中的格式 一样，如下所示。

document.cookie = encodeUR工Component{"name"> + "=" +

encodeURIComponent("Nicholasn} + **; domains.wrox.com; path-/";

由于JavaScript中读写cookie不是非常直观，常常需要写--些函数来简化cookie的功能，基本的 cookie操作冇三种：读取、写人和删除。它们在CookieUtil对象中如下表示。

var CookieUtil = {

get: function (name){

var cookieName = encodeURIComponent(name) + ■=",

cookieStart = document.cookie.indexOf(cookieName), cookieValue = null;

if

 

(cookieStart > var cookieEnd if (cookieEnd cookieEnd

}

cookieValue -

 

-1) {

=document.cookie.indexOf(r, cookieStart); ==_1){

-document-cookie.length;

decodeURIComponent(document.cookie.substring{cookieStart + cookieName.length, cookieEnd));

return cookieValue；

23

 

set: function (name, value, expires, path, domain, secure) { var cookieText = encodeURIComponent(name) +    +

encodeURIComponent(value)?

if (expires instanceof Date) {

cookieText += "; expires:” 十 expires.toGMTString();

}

if

 

(path) {

cookieText += "； paths

path；

 

if (domain) {

cookieText += domains" + domain；

}

if (secure) {

cookieText += ni secure";

}

document.cookie = cookieText;

)z

unset: function (name, path, domain, secure){

this.set{name, "", new Date(0)# path, domain, secure);

}

);

 

CoofaeUtil.js

CookieUtil.get ()方法根据cookie的名字获取相应的值。它会在document.cookie字符串中査 找cookie名加上等于号的位罝。如果找到了，那么使用indexOfO査找该位置之后的第一个分号(表 示了该cookie的结束位置)。如果没有找到分号，则表示该cookie是字符串中的最后一个，则余下的字 符串都是cookie的值。该值使用decodcURIComponent ()进行解码并最后返回。如果没有发现cookie, 则返冋null。

CookieUtil.set ()方法在页面上设置一个cookie,接收如下几个参数：cookie的名称，cookie的值, 可选的用于指定cookie何时应被删除的Date对象，cookie的可选的URL路径，可选的域，以及可选的 表示是否要添加secure标志的布尔值。参数是按照它们的使用频率排列的，只有头两个是必需的。在 这个方法中，名称和值都使用encodeURIComponent ()进行了URL编码，并检査其他选项。如果expires 参数是Date对象，那么会使用Date对象的toGMTString 0方法正_确格式化Date对象，并添加到 expires选项上。方法的其他部分就是构造cookie字符率并将其设置到document. cookie中。

没有删除已有cookie的直接方法。所以，需要使用相同的路径、域和安全选项再次设置cookie,并 将失效时间设置为过去的时间。CookieUtil.unset (＞方法可以处理这种事情。它接收4个参数：要删 除的cookie的名称、可选的路径参数、可选的域参数和可选的安全参数。

这些参数加上空字符串并设置失效时间为1970年1月1日(初始化为0ms的Date对象的值)，传 给CookieUtil. set () o这样就能确保删除cookie。

可以像下面这样使用上述方法。

〃设置 cookie

CookieUtil.set("name", "Nicholas")；

CookieUtil.set("book", "Professional JavaScript");

//读取cookie的值

alert(CookieUtil.get("name")); alert(CookieUtil.get(■book"));

 

//"Nicholas"

//"Professional JavaScript"

 

//制險 cookie

CookieUtil.unset("name*); CookieUtil.unset("book")；

//设置cookie,包括它的路径、域、失效日期

CookieUti1.set("name", "Nicholas", "/books/projs/*, "www.wrox.com”， new Date("January lr 2010"))?

//刪除呐則设置的cookie

CookieUtil.unset("name", •/books/projs/", "www.wrox.com")；

//设置安全的cookie

CookieUtil.set("name"# "Nicholas", null, null, null, true);

CookieExampleOl. htm

这些方法通过处理解析、构造cookie字符串的任务令在客户端利用cookie存储数据更加简单。

4.子 cookie

为了绕开浏览器的单域名下的cookie数限制，一些开发人员使用了一种称为子cookie (subcookie) 的概念。子cookie是存放在单个cookie中的更小段的数据。也就是使用cookie值来存储多个名称值对 儿。子cookie最常见的的格式如下所示。

name=namel=valuel&name2=value2&naine3=value3&naine4=value4&name5=value5

子cookie—般也以査询字符串的格式进行格式化。然后这些值可以使用单个cookie进行存储和访 问，而非对每个名称-值对儿使用不同的cookie存储。最后网站或者Web应用程序可以无需达到单域名 cookie上限也可以存储更加结构化的数据。

为了更好地操作子cookie，必须建立一系列新方法。子cookie的解析和序列化会因子cookie的期望 用途而略有不同并更加复杂些。例如，要获得一个子cookie,首先要遵循与获得cookie—样的基本步骤， 但是在解码cookie值之前，需要按如下方法找出子cookie的信息。

var SubCookieUtil {

get： function (name, sxibName) {

var subCookies = this.getAll(name)； if (subCookies){

return subCookies[subName];

} else {

return null;

)

getAll: function(name){

23

 

var cookieName = encodeURIComponent(name) + "=•,

cookieStart = document.cookie.indexOf(cookieName), cookieValue = null,

cookieEnd,

subCookies,

parts#

result = {};

if (cookieStart > -1){

cookieEnd = document.cookie.indexOf(";", cookieStart)； if (cookieEnd == -1){

cookieEnd = document.cookie.length；

}

cookieValue = document.cookie.substring(cookieStart +

cookieName.length, cookieEnd);

if (cookieValue.length > 0){

subCookies = cookieValue.split("&");

for (i=0, Len=subCookies.length; i < len; i++){ parts = subcookies[i].split("=•}; result[decodeUR工Component(parts(0])J =

decodeUR工Component(parts[1])；

return result;

}

}

return null?

//省略了更多代码

SubCookieUtil.js

获取子cookie的方法有两个：get (}和getAll () o其中get {)获取单个子cookie的值，getAll () 获取所有子cookie并将它们放人一个对象中返回，对象的属性为子cookie的名称，对应值为子cookie 对应的值。get ()方法接收两个参数：cookie的名字和子cookie的名字3它其实就是调用getAll ()获 取所有的子cookie,然后只返冋所需的那一个(如果cookie不存在则返冋mill )。

SubCookieUtil. getAll ()方法和CookieUtil .get ()在解析cookie值的方式上非常相似。区别 在于cookie的值并非立即解码，而是先根据&字符将子cookie分割岀来放在一个数组中，每一个子cookie W根据等于号分割，这样在parts数组屮的前一部分便是子cookie名，后一部分则是子cookie的值。 这两个项目都要使用decodeURIComponent ()来解码，然后放人result X寸象中，最后作为方法的返 回值。如果cookie不存在，则返回null。

可以像下面这样使用上述方法：

//假设 document .cookie=data=name=Nicholas&book=Professional%20JavaScript //取符全部子cookie

var data = SubCookieUtil.getAll("data")；

alert(data.name); //"Nicholas”

alert(data.book)；    //Professional JavaScript"

//逐个获取子cookie

alert(SubCookieUtil.get("data", "name"))； //"Nicholas"

alert(SubCookieUtil.get("data", "book")); //-Professional JavaScript"

SubCookiesExampleOl .hfm

要设置子cookie,也有两种方法：set(>和setAll(>。以下代码展姑了它们的构造。

var SubCookieUtil = {

Bet: function (name, BubName, value, expiresr path, domain, secure) { var subcookies ■ this.getAll(name) || {};

subcookies[subName] = value;

this.set All(name, subcookies# expires, path, domain, secure)t

BeCAllt function(name, subcookies, expires, path, domain, secure){

var cookieText = encodeURIComponent(name) + aubcookieParts = new Array(),

BuJbMaae;

for (subName in subcookies){

if (subName.length > 0 && subcookies.hasOwnProperty(subName))( subcookleParta.push(encodeURIComponent (subNiune) + **■" +

encodeUHIComponent(subcookies[subName]))；

}

}

if (cookieParts.length > 0){

cookieText ♦= aubcookieParts. join(w&**);

if (expires instazxceof Date) {

cookieText +■ ”！ expires*!K + expires. toQMTString();

\>

if (path) {

cookieText ♦囂";path*" + path/

)

i£ (domain) {

cookieText    domain*■ + domain；

}

if (secure) {

cookieText +« secure";

\>

} else {

cookieText += "; expires=R + (new Date(0)).toGKTString(}；

}

document.cookie =

 

cookieText;

 

｝，

 

23

 

//省略了更多代码

);

 

SubCookie Utiljs

这里的set U方法接收7个参数：cookie名称、子cookie名称、子cookie值、可选的cookie失效 口期或时间的Date对象、可选的cookie路社、可选的cookie域和可选的布尔secure杨志。所有的可 选参数都是作用于cookie本身而非子cookie。为了在同一个cookie中存储多个子cookie,路径、域和secure 标志必须一致；针对整个cookie的失效日期则可以在任何一个单独的子cookie写人的时候同时设置。在 这个方法中，第一步是获取指定cookie名称对应的所有子cookie。逻辑或操作符‘丁用'f当getAll (>

返回null时将subcookies设置为一个新对象。然后，在subcookies X寸象上设置好子cookie值并传给 setAll()o

而setAll ()方法接收6个参数：cookie名称、包含所有子cookie的对象以及和set (>中一样的4 个可选参数。这个方法使用for-in循环遍历第二个参数中的属性。为了确保确实是要保存的数据，使 用了 hasOwnPropertyO方法，来确保只有实例属性被序列化到子cookie中。由于可能会存在展性名 为空字符串的情况，所以在把属性名加人结果对象之前还要检丧一下屈性名的长度。将每个子cookie 的名值对儿都存人subcookieParts数组中，以便稍后可以使用join()方法以&号组合起来。剩下的 方法则和 CookieUtil. set ()—样。

可以按如下方式使用这些方法。

//做设 document .cookie=data=name=Nicholas&book=Professional%20 JavaScript

/ /设篁两个cookie

SubCookieUtil.set("data", "name", ■Nicholas");

SubCookieUtil.set("data", "book", "Professional JavaScript")；

//设JL全部子cookie和失效日期

SubCookieUtil.setAll("data", { name： "Nicholas", book： "Professional JavaScript" }, new Date("January 1, 2010"))；

//修改2字的值，并飧改cookie的失效日期

SubCookieUtil.set("data", "name", "Michael", new Date("February 1, 2010"});

SubCookiesExantpleO 1. htm

子cookie的最后一组方法是用丁-删除子cookie的。普通cookie可以通过将失效时间设置为过去的 时间的方法来删除,但是子cookie不能这样做。为了删除一个子cookie,首先必须获取包含在某个cookie 中的所有子cookie,然后仅删除需要删除的那个子cookie,然后再将余下的子cookie的值保存为cookie 的值。请看以下代码。

var SubCookieUtil = {

//这篁省略了更多代码

unset: function (name, subName, path, domain, secure){ var subcookies = this. getA.11 (name); if (subcookies)(

delete subcookies[subName];

this.setAll(name, subcookies, null, path/ domain, secure)t

\>

unsetAll: function(name, path, domain, secure){

this.setAll(name, null, new Oate(O)/ path, domain, secure);

}

}?

SubCookie Util.js

这里定义的两个方法用于两种不同的0的。unset ()方法用T删除某个cookie中的单个子cookie 而不影响其他的；而unset All ()方法则等同于CookieUtil.unset ()，用于删除整个cookie。和set ()

及setAllU—样，路径、域和secure标志必须和之前创建的cookie包含的内容一致。这两个方法可 以像下面这样使用。

//仅劑除名为name的子cookie

SubCookieUtil.unset("data"# "name”};

//刑除整个cookie

SubCookieUtil.unsetAll{"data");

如果你担心开发中可能会达到单域名的cookie上限，那么子cookie可是一个非常有吸引力的备选方 案。不过，你需要更加密切关注cookie的长度，以防超过单个cookie的长度限制。

5.关于cookie的思考

还有一类cookie被称为“HTTP专有cookie”。HTTP专有cookie可以从浏览器或者服务器设置，但 是只能从服务器端读取，因为JavaScript无法获取HTTP专有cookie的值。

由于所有的cookie都会山浏览器作为请求头发送，所以在cookie中存储大量信息会影响到特定域的 请求性能。cookie信息越大，完成对服务器请求的时间也就越长。尽管浏览器对cookie进行了大小限制， 不过最好还是尽可能在cookie中少存储信息，以避免影响性能。

cookie的性质和它的局限使得其并不能作为存储大量信息的理想手段，所以又出现了其他方法。

一定不要在cookie中存储重要和敏感的数据。cookie数据并非存储在一个安全环 境中，其中包含的任何数据都可以被他人访问。所以不要在cookie中存储诸如信用卡 号或者个人地址之类的数据。23.3.2 IE用户数据

在1E5.0中，微软通过一个自定义行为引人了持久化用户数据的概念。用户数据允许每个文档最多 128KB数据，每个域名最多1MB数据:，要使用持久化用户数据，首先必须如下所示，使用CSS在某个 元索上指定userData行为：

<div style="behavior：url(#default#userData)w id= *dataStore"></div>

一旦该元索使用了 userData行为，那么就可以使用setAttribute (}方法在上面保存数据了。 为了将数据提交到浏览器缓存屮，还必须调用save ()方法并告诉它要保存到的数据空间的名字。数据 空间名字可以完全任意，仅用丁-区分不同的数据集。请看以下例子。

23

 

var dataStore = document.getElementByTd("dataStore"); dataStore.setAttribute("name", "Nicholas"); dataStore.setAttribute("book", *Professional JavaScript，)； dataStore.save("flooklnfo");

UserDataExampleO 1. htm

在这段代码中，<div>元索上存人了两部分信息。在用setAttribute (>存储了数据;i后，调用了 saveO方法，指定了数据空间的名称为Booklnfo。下一•次页面载人之后，可以使用load()方法指定 同样的数据空间名称来获取数据，如下所示。

dataStore.load("Booklnfo")；

alert (dataStore.getAttribute ("name")}; /"Nicholas’

alert(dataStore.getAttribute("book"))； //"Professional JavaScript

UserDataExampleOl. htm

对load()的调用获取了 Bookinfo数据空间中的所有信息，并且使数据可以通过元素访问；只有 到载人确切完成之后数据方能使用。如果getAttribute ()调用了不存在的名称或者是尚未载人的名 程，则返回null。

你可以通过removeAttributeO方法明确指定要删除某元素数据，只要指定属性名称。删除之后， 必须像下面这样再次调用saveO来提交更改。

dataStore.removeAttribute(■name")； dataStore.removeAttribute(■book"); dataSzore.save("BookInfo");

UserDataExampleOl • htm

这段代码删除了两个数据属性，然后将更改保存到缓存中。

对IE用户数据的访问限制和对cookie的限制类似。要访问某个数据空间，脚本运行的页面必须来 自同一个域名，在同一个路径下，并使用与迸行存储的脚本同样的协议。和cookie不同的是，你无法将 用户数据访问限制扩展到更多的客户。还有一点不同，用户数据默认是可以跨越会话持久存在的，同时 也不会过期；数据需要通过removeAttributeO方法专门进行删除以释放空间。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-116.jpg)

 

和cookie—样，IE用户数据并非安全的，所以不能存放敏感信息。

23.3.3 Web存储机制

Web Storage最早是在Web超文本应用技术工作组(WHAT-WG)的Web应用1.0规范中描述的。 这个规范的最初的工作最终成为了 HTML5的-部分。Web Storage的H的是克服由cookie带来的一些限 制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage的两个主要目 标是：

□提供一种在cookie之外存储会话数据的途径；

□提供一种存储大量可以跨会话存在的数据的机制。

最初的Web Storage规范包含了两种对象的定义：sessionStorage和globalStorage。这两个 对象在支持的浏览器中都是以windows对象属性的形式存在的，支持这两个属性的浏览器包括1E8+、 Firefox 3.5+、Chrome 4+和 Opera 10.5+。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-117.jpg)

 

Firefox 2和3基于早期规范的内容部分实现了 Web Storage,盗时只实现了 global Storage,没有实现 localStorage。

\1. Storage 类型

Storage类型提供最大的存储空间(㈥浏览器而异)来存储名值对儿。Storage的实例与X-他对 象类似，有如下方法。

□ clear ()：删除所有值；Firefox中没有实现。

□    getltem(name):根据指定的名字name获取对应的值。

□    key (index):获得index位置处的值的名字。

□    removeltem(name):删除由name指定的名值对儿。

□    setltem(name, value):为指定的name设置一个对应的值。

其中，getltem() , removeltem()和setltem()方法可以直接调用，也可通过Storage对象间 接调用。因为每个项目都是作为属性存储在该对象上的，所以可以通过点语法或者方括号语法访问属性 来读取值，设置也一样，或者通过delete操作符进行删除。不过，我们还建议读者使用方法而不是属 性来访问数据，以免某个键会意外重写该对象t已经存在的成员。

还可以使用length属性来判断有多少名值对儿存放在Storage对象中。俱无法判断对象中所有 数据的大小，不过IE8提供了一个remainingspace属性，用于获取还可以使用的存储空间的字节数。

Storage类型只能存储字符串。非字符率的数据在存储之前会被转换成字符串

\2. aeBsionStorage 对象

sessionStorage对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭。这个对象 就像会话cookie,也会在浏览器关闭后消失。存储在sessionStorage中的数据可以跨越页面刷新而 存在，同时如果浏览器支持，浏览器崩溃并'歌启之后依然可用(Firefox和WebKit都支持，IE则不行)。

因为seesionStoragdf象绑定于某个服务器会话，所以当文件在本地运行的时候是不可用的。存 储在sessionStorage巾的数据只能由最初给对象存储数据的页面访问到，所以对多贞面应用有限制。

由于sessionStorage对象其实足Storage的一个实例，所以可以使用setltem()或者_在接设 置新的属性来存储数捍。下面是这两种方法的例子。

//使用方法存储数据

I    sessionStorage.setltem(•name", "Nicholas*);

//使用爲性存储数据

sessionStorage.book = "Professional JavaScript"；

SessionStorageExampleO I.him

不同浏览器写人数据方面略冇不同。Firefox和WebKit实现/•同步写入，所以添加到存储空间中的 数据是立刻被提交的。而IE的实现则是异步写人数据，所以在设置数据和将数据实际写人磁盘之间可 能有一些延迟。对于少量数据而言，这个差异是可以忽略的。对于大量数据，你会发现要比其他浏 览器更快地恢复执行，因为它会跳过实际的磁盘写人过程。

23

 

在IE8中可以强制把数据写人磁盘：在设置新数据之前使用begin (＞方法，并且在所有设S完成之 后调用commit ()方法。看以下例子。

//只适用于IE8 sessionStorage.begin()； sessionStorage.name = "Nicholas"; sessionStorage.book = "Professional JavaScript"; sessionStorage.commit{)；

这段代奶确保了 name和book的值在调用commit {)之后立刻被写人磁盘。调用begin (＞是为了 确保在这段代砰执行的时候不会发生其他磁盘写人操作。对丁少量数据而言，这个过程不是必需的；不

过，对于大量数据(如文档之类的)可能就要考虑这种事务形式的方法了。

sessionStorage中有数据时，可以使用getltem(}或者通过直接访问属性名来获取数据。两种

方法的例子如下。

//使用方法块取數掘

| var name = sessionStorage.getltem("name")；

//使用爲性读取数据

var book = sessionStorage.book;

SessionStorageExampleOl. htm

还可以通过结合length属性和key ()方法來迭代sessionStorage中的值，如下所示。

for (var i=0, len = sessionStorage.length； i < len? i++){ var key = sessionStorage.key(i)； var value = sessionStorage.getltem{key); alert(key + ■=■ + value)；

}

SessionStorageExampleOI. htm

它是这样遍历sessionStorage中的名值对儿的：首先通过key (〉方法获取指定位置上的名字， 然后再通过getltem ()找出对应该名字的值。

还可以使用for-in循环来迭代sessionStorage中的值：

for (var key in sessionStorage){

var value = sessionStorage.getltem(key)； alert(key + *=* + value)；

)

每次经过掮环的时候，key被设置为sessionStorage中下一个名字，此时不会返回任何内置方 法或length属性。

要从 sessionStorage 中删除数据，可以使用 delete 操作符删除对象属性，也可调用 removeltem()方法。以下是这些方法的例子。

//使用delete刪除一个值一在WebKit中无效 delete sessionStorage.name;

//使用方法涮除一个值 sessionStorage.removeltern("book")；

SessionStorageExampleOI. htm

在撰写本书时，delete操作符在WebKit中无法刪除数据，remove Item ()则可以在各种支持的浏 览器中正确运行。

sessionStorage对象应该主要用于仅针对会话的小段数据的存储。如果需要跨越会话存储数据， 那么 globalStorage 或者 localStorage 更为合适。

\3. globalStorage 对象

Firefox2中实现了 globalStorage对象。作为最初的Web Storage规范的一部分，这个对象的目 的是跨越会话存储数据，但有特定的访问限制。要使用globalStorage,首先要指定哪些域可以访问

该数据。可以通过方括号标记使用属性来实现，如以下例子所示。

//保存数据

globalStoraget"wrox.com"].name = *NicholasB;

//获取数据

var name = globalStorage[*wrox.com"].name；

GlobalStorageExampleOl. htm

在这里，访问的是针对域名wrox.com的存储空间。globalStorage对象不是Storage的实例， 而具体的globalStorage [nwrox.com。」"才是o这个存储空间对于wrox.com及其所有子域都是可以 访问的。可以像下面这样指定子域名。

//保存数採

globalStorage [ "[www.wrox](http://www.wrox). com,r ] .name = "Nicholas'1;

//获取数据

var name = globalStorage("www.wrox.com"].name；

GlobaiStora琴 eExampleOl、htm

这里所指定的存储空间只能由来自www.wrox.com的页面访问，其他子域名都不行。

某些浏览器允许更加宽泛的访问限制，比如只根据顶级域名进行限制或者允许全局访问，如下面例

子所示。

//存倚数据，任何人都可以访问一不要这样做！ globalStorageIw *].name = "Nicholas"；

//存饋数据，可以让任何以.net结足的域名访问一不要这样做! globalStoragef"net * J.name = "Nicholas";

虽然这些也支持，但是还是要避免使用这种可宽泛访问的数据存储，以防止出现潜在的安全问题。 考虑到安全问题，这些功能在未来可能会被删除或者是被更严格地限制，所以不应依赖于这类功能。当 使用globalStorage的时候一定要指定~个域名。

对globalStorage空间的访问，是依据发起请求的页面的域名、协议和端口来限制的。例如，如 果使用HTTPS协议在wrox.com中存储了数据，那么通过HTTP访问的wrox.com的页面就不能访问 该数据。同样，通过80端U访问的页面则无法与同一个域同样协议但通过8080端口访问的页面共享数 据。这类似于Ajax请求的同源策略。

23

 

globalStorage的每个属性都是storage的实例。因此，可以像如下代码中这样使用。

globalStorage["wvw.wrox.com"J.name 二"Nicholas"；

globalStorage["www.wrox.com0].book - *Professional JavaScript";

globalStorage["www.wrox.com”.removeItem("name");

var book = globalStorage["www.wrox.com*].getltem("book");

GlobaiStorageExampleO 1. htm

如果你事先不能确定域名，那么使用location.host作为属性名比较安全。例如:

globalStorage[location.host].name = "Nicholas"；

var book = globalStorage[location.host],getltem{"book");

GlobalStorageExampleOl. htm

如果不使用removelteiM）或者delete删除，或者用户未清除浏览器缓存，存储在 globalStorage属性中的数据会一直保留在磁盘上。这让globalStorage非常适合在客户端存储文 档或者长期保存用户偏好设置。

\4. localStorage 对象

localStorage对象在修订过的HTML 5规范中作为持久保存客户端数据的方案取代了 globalStorage。与globalStorage不同，不能给localStorage指定任何访问规则；规则事先就 设定好了。要访问同一个localStorage对象，页面必须来自同一个域名（子域名无效），使用同■-种 协议，在同一个端口上。这相当于globalStorage [location.host]。

出于localStorage是Storage的实例，所以可以像使用sessionStorage 一样来使用它。下 面是一些例子。

//使用方法存铺数据

localStorage.setltem（"name", "Nicholas"J;

//使用為性存姑数挺

localStorage.book = "Professional JavaScript";

//使用方法读取数据

var name = localStorage .getItem ("naine")；

//使用属性读取数据

var book = localStorage.book;

LocalStorageExampleOL htm

存储在localStorage中的数据和存储在globalStorage中的数据一样，都遵循相同的規则： 数据保留到通过JavaScript删除或者是用户清除浏览器缓存。

为了兼容只支持globalStorage的浏览器，可以使用以下函数。

function getLocalStoragie () {

if (typeof localStorage =- "object"){

return localStorage;

} else if (typeof globalStorage == ■object”{ return globalStorage{location.host]；

} else {

throw new Error("Local storage not available.")；

}

}

GlobalA ndLocalStorageExampleOl. htm

然后，像下面这样调用一次这个函数，就可以正常地读写数据r。 var storage getLocalStorage（｝；

GlobalA ndLocalStorageExampleO I.htm

在确定了使用哪个Storage对象之后，就能在所有支持Web Storage的浏览器中使用相同的存取规 则操作数据了。

\5. storage 事件

对Storage对象进行任何修改，都会在文档h触发storage事件。当通过属性或setltem()方 法保存数据，使用delete操作符或removeltem()删除数据：或者调用clear ()方法时，都会发生该 事件=这个事件的event对象有以下属性。

□    domain：发生变化的存储空间的域名。

□    key：设置或者删除的键名。

□    newValue：如果是设置值，则是新值；如果是删除键，则是null。

□    oldValue：键被更改之前的值。

在这四个属性中，IE8和Fircfox只实现了 domain属性。在撰写本书的时候，WebKit尚不支持 storage 事件：

以下代码展示了如何侦听storage事件：

EventUtil.addHandler(document, "storage", function(event){

alert("Storage changed for " + event.domain)；

});

StorageEventExampleOl. htm

无论对 sessionStorage、globalStorage 还是 localStorage 进行操作，都会触发 storage 事件，但不作区分。

6.限制

与其他客户端数据存储方案类似，Web Storage同样也有限制。这些限制因浏览器而异。一般来说, 对存储空间大小的限制都是以每个来源(协议、域和端U)为单位的。换句话说，每个来源都有固定大 小的空间用于保存6己的数据。考虑到这个限制，就要注意分析和控制每个来源中有多少页面需要保存 数据。

对于localStorage而言，大多数桌面浏览器会没置每个来源5MB的阪制。Chrome和Safari对超 个来源的限制是2.5MB。而iOS版Safari和Android版WebKit的限制也是2.5MB。

对sessionStorage的限制也是因浏览器而样。有的浏览器对sessionStorage的大小没有限制， 但 Chrome、Safari、iOS 版 Safari 和 Android 版 WebKit 都有限制，也都是 2.5MB。IE8+利I Opera 对 sessionStorage 的限制是 5MB。

23

 

有关 Web Storage 的限制，请参考 http:〃dev-test.nemikor.com/web-storage/support-test/。

23.3.4 IndexedDB

Indexed Database API,或者简称为IndexedDB,是在浏览器中保存结构化数据的一种数据库。 IndexedDB是为了替代目前已被谈弃的Web SQL Database API (因为已废弃，所以本书未介绍)而出现 的。IndexedDB的思想是创建一套API,方便保存和读取JavaScript对象，同时还支持査询及搜索。

IndexedDB设计的操作完全是异步进行的。因此，大多数操作会以请求方式进行，但这些操作会在 后期执行，然后如果成功则返回结果，如果失败则返回错误。差不多每一次IndexedDB操作，都需要你 注册onerror或onsuccess事件处理程序，以确保适.当地处理结果。

在得到完整支持的情况下，IndexedDB将是一个作为API宿主的全局对象。由于API仍然可能有

变化，浏览器也都使用提供商前缀，因此这个对象在IE10中叫msIndexedDB,在Firefox 4中叫

mozindexedDB,在Chrome中叫webkitlndexedDB。为了淸楚起见，本节示例中将使用IndexedDB,

而实际上每个示例前面都应该加上下面这行代码.•

var indexedDB = window.indexedDB II window.msIndexedDB I I window.mozindexedDB II window.webkit IndexedDB;

I ndexedDB Example。I，htm

1.数据库

IndexedDB就是一个数据库，与MySQL或Web SQL Database等这些你以前可能用过的数据库类似。 IndexedDB最大的特色是使用对象保存数据，而不是使用表来保存数据。一个IndexedDB数据库，就是 一-组位于相同命名空间下的对象的集合。

使用IndexedDB的第一步是打开它，即把要打开的数据库名传给indexDB.open ()。如果传人的 数据库已经存在，就会发送一个打开它的请求；如果传入的数据库还不存在，就会发送一个创建并打开 它的请求。总之，调用indexDB.open( ＞会返回一个IDBRequest对象，在这个对象上可以添加onerror 和onsuccess瘠件处理程序。先来肴--个例子。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-118.jpg)

 

var request, database；

request = indexedDB.open("admin")；

request.onerror = function(event){

alert("Something bad happened while trying to open: * +

event.target.errorCode)；

};

request.onsuccess = function(event){ database = event.target.result;

}；

IndexedDBExampleOl ,htm

在这两个事件处理程序屮，event .target都指向request对象，因此它们可以互换使用。如果响 应的是onsuccess事件处理程序，那么event • target. result中将存-个数据库实例对象(IDBData-base)，这个对象会保存在database变量中。如果发生了错误，那event.target.errorCode中将 保存一个错误码，表示问题的性质。以下就是可能的错误码(这个错误码适合所有操作)。

□    IDBDatabaseException.UNKNOWN^ERR(l):意外错误，无法归类。

□    IDBDatabaseException.NON_TRANSIENT_ERR(2):操作不合法。

□    IDBDatabaseException. NOT_FOUND_ERR(3):未发现要操作的数据库。

□    IDBDatabaseException.C0NSTRAINT_ERR(4):违反了数据库约束。

□工DBDaLabaseException.bATA_ERR(5):提供给事务的数据不能满足要求。

口 IDBDatabaseException.NOTjlLI/OWED_ERR(6):操作不合法。

□    IDBDatabaseException.TRANSACTI0N_INACTIVE_ERR(7):试图重用已完成的事务。

□    IDBDatabaseException.ABORT_ERR(8)：请求中断，未成功。

□    IDBDatabaseException.READ_0NLY_ERR(9):试图在只读模式下写入或修改数据。

□    IDBDatabaseException.TIMEOUT_ERR(10)：在有效时间内未完成操作n

□    IDBDatabaseException.QUOTA_ERR(ll)：磁盘空间不足。

默认情况下，ImlexedDB数据库是没有版本号的，最好一开始就为数据库指定一个版本号。为此，

可以调用setVersionO方法，传人以字符串形式表示的版本号。同样，调用这个方法也会返W—个请

求对象，需要你再指定事件处理程序。

if.(database.version != "1.0"){

I    request = database.setVersion(H1.0");

request.onerror = function(event){

alert("Something bad happened while trying to set version: " +

event.target.errorCode)；

}；

request.onsuccess = function(event){

alert("Database initialization complete. Database name： " + database.name +

", Version： " + database-version)；

}；

} else {

alert("Database already initialized. Database name： • + daIabase.name +

■, Version： " + database.version);

}

IndexedDBExampleOl .htm

这个例+尝试把数据库的版本号设置为1.0。第一行先检测version属性，看是否已经为数据库设 置了相应的版本号。如果没有，就调用setVersionU创建修改版本的请求。如果请求成功，显示一条 消息，表示版本修改成功。（在真实的项目开发中，你应该在这里建立对象存储空间。详细内容请看下 —节。）

如果数据库的版本号已经被没fi为1.0,则显示一条消息，说明数据库已经初始化过了。总之，通 过这种模式，就能知道你想使用的数据库是否已经设置了适当的对象存储空间。在整个Web应用中， 随着对数据库结构的更新和修改，可能会产生很多个不同版本的数据库。

2.对象存储空间

在建立了与数据库的连接之后，下一步就是使用对象存储空间' 如果数据库的版本与你传人的版 本不匹配，那可能就需要创建一个新的对象存储空间。在创建对象存储空间之前，必须要想清楚你想要 保存什么数据类型。

假设你要保存的用户记录由用户名、密码等组成，那么保存一条记录的对象应该类似如下所示：

var user =（

username: "007", firstNarae: "James", lastName: .Bond., password: *foo"

23

 

};

有了这十对象，很容易想到username属性可以作为这个对象存储空间的键。这个username必须 全局唯一，而且大多数时候都要通过这个键来访问数据。这一点非常重要，因为在创建对象存储空间时， 必须指定这么一个键。以下是就是为保存上述用户记录而创建对象存储空间的示例。

var score = db.createObjectStore{"users*, { keyPath： "username" }）；

IndexedDBExampleO2. htm

①有关系数据库经验的读者，可以把这里的对象存悌空间（objcctstmge）想象成表，而把其中保存的对象想象成表中 的记录。

其中第二个参数中的keyPath属性，就是空间中将要保存的对象的-个属性，而这个属性将作为 存储空间的键来使用。

好，现在有了一个对存储空间的引用。接下来可以使用add()或put ()方法来向其中添加数据。这 两个方法都接收-个参数，即要保存的对象，然后这个对象就会被保存到存储空间中。这两个方法的区 别在空间中已经包含键值相同的对象时会体现出来。在这种情况下，add()会返回错误，而put<)则会 重写原有对象。简单地说，可以把add (>想象成插人新值，把put (>想象成更新原有的值。在初始化对 象伴储空间时，可以使用类似下面这样的代科。

//users中保存着一批用户对象 I var i=0,

len - users.length;

while(i < len){

store.add{users[i++]);

}

!ndexedDBExampleO2. htm

每次调用add ()或put ()都会创建一个新的针对这个对象存储空间的更新请求。如果想验证请求是 否成功完成，可以把返回的请求对象保存在一个变量中，然后再指定onerror或onsuccess事件处理 程序。

//users 中保存着一拉用户对象 var i=0f

request, requests =[】，

len = users.length;

while(i < len){

request « store.add(users[i++]); request.onerror = function(){

//处理醤误

}；

request.onsuccesa > function(){

//处现成功

};

requests.push(request);

}

创建了对象存储空间并向其中添加了数据之后，就该査询数据了。

3.事务

跨过创建对象存储空间这一步之后，接下来的所有操作都是通过事务来完成的。在数据库对象上调 用transaction (>方法卩J以创建事务。任何时候，只要想读取或修改数据，都要通过事务来组织所有 操作。在最简单的情况下，可以像下面这样创建事务®。

var transaction = db.transaction()；

如果没有参数，就只能通过事务来读取数据庵中保存的对象。最常见的方式是传人要访问的一或多 个对象存储空间。

①以下示例代码中的db即前面示例代码中的database, IE文中提到的“数据痄对象”也是指它。

var transaction = db.transaction(■usGrs*}7

这样就能保证只加载users存储空间中的数据，以便通过事务进访问。如果要访问多个对象存 储空间，也可以在第-个参数的位置上传人字符串数组。

var transaction = db.transaction([* users"f "anotherStore"3);

如前所述，这些事务都是以只读方式访问数据。要修改访问方式，必须在创建事务时传人第二个参 数，这个参数表系访问模式，用工DBTransaction接口定义的如下常量表示：READ_ONLY ( 0 )表示只 读，READ_WRTTE ( 1 )表示读写，VERSION_CHANGE ( 2 )表示改变。IE10+和 Firefox 4+实现的是 IDBTransaction，但在Chrome中则叫webkitlDBTransaction,所以使用下面的代码可以统一接口：

| var 工 DBTransaction = window. IDBTrans act ion II window, webkit 工 DBTrans.act ion;

lndexedDBExampleO3. htm

有了这行代码，就可以更方便地为transactions指定第二个参数了。

var transaction = db.transact ion("users", IDBTransaction.READ_WRITE)?

IndexedDBExampleO3.htm

这个事务能够读写users存储空间。

取得了事务的索引后，使用objectStoreU方法并传人存储空间的名称，就可以访问特定的存储 空间。然后，可以像以前一样使用add G和put ()方法，使用get()可以取得值，使用deleted可以 删除对象，而使用clear ()则可以删除所有对象。get ()和delete ()方法都接收一个对象键作为参数， 而所有这5个方法都会返回一个新的请求对象。例如：

var request = db.transaction("users").objectStore("users").get("007")； i    request.onerror - function(event){

alert("Did not get the object 1")；

}；

request.onsuccess = function(event){ var result = event.target.result; alert(result.firstName); //"James"

)?

IndexedDBExampleO2. htm

 

23

 

因为一个事务可以完成任何多个请求，所以事务对象本身也有車件处理程序：onerror和 oncompleteo这两个事件可以提供事务级的状态信息。

transaction.onerror = function(event){

//整个事务都被取消了

};

transaction.oncomplete = function(event){

//整个事务都成功完成了

}；

注意，通过oncomplete事件的事件对象(event )访问不到get <)请求返回的任何数据。必须在 和应请求的onsuccess事件处理程序中才能访问到数据。

4.使用游标查询

使用事务町以直接通过已知的键检索单个对象。而在需要检索多个对象的情况下，则需要在事务内 部创建游标。游标就是一指向结果集的指针。与传统数据库査询不同，游标并不提前收集结果。游标指 针会先指向结果中的第-项，在接到査找下一项的指令时，才会指向下一项。

在对象存储空间上调用openCursorO方法可以创建游标。与IndexedDB中的其他操作一样， openCursor {)方法返回的是一个请求对象，因此必须为该对象指定onsuccess和onerror事件处理 程序。例如：

var store = db.transaction("users").objectStore("users"), request = store.openCursor(>;

request.onsuccess = function(event){

//处理成功

request.onerror = function(event){ //处理失败

}；

IndexedDBExample04. htm

在onsuccess事件处理程序执行时，可以通过event .target .result取得存储空间中的下一个 对象。在结果集中有下一项时，这个属性中保存一个IDBCursor的实例，在没有下-项时，这个属性 的值为null。iDBCursor的实例有以下几个质性。

口 direction:数值，表示游标移动的方向。默认值为IDBCursor .NEXT ( 0 ),表示下一项。 IDBCursor.NEXT_NO_DUPLICATE ( 1 )表示下一个不電复的项，DBCursor.PREV ( 2 )表示前 一项，而IDBCursor. PREV_NO_DUPLICATE丧示前一个不重复的项。

□    key：对象的键c

□    value：实际的对象。

□    primaryKey:游标使用的键。可能是对象键，也可能是索引键(稍后讨论索引键)。

要检索某一个结果的信息，可以像下面这样：

request.onsuccess = function(event){ var cursor = event.target.result; if (cursor) { //必須要检查

console.log(■Key: " + cursor.key + ", Value: • +

JSON.stringify(cursor.value));

}.

}；

请记住,这个例丁•中的cursor.value是一个对象,这也是为什么在.Si示它之前先将它转换成JSON 字符串的原因。

使用游标可以更新个别的记录。调用update ()方法可以用指定的对象更新3前游标的value。与 其他操作一样，调用update ()方法也会创建一个新请求，因此如果你想知道结果，就要为它指定 onsuccess和onerror事件处理程序。

request.onsuccess = function(event){ var cursor 冷 event.target.result,

value.

updateRequest;

| if (cursor) { //必坝要检査if {cursor»key == "foo"){ value 醒 cursor.value； value.password = "magic!"; | //取碍当前的值 ✓ /更新密码                                   |                |      |
| ------------------------------------------------------------ | ------------------------------------------------------------ | -------------- | ---- |
|                                                              | updateRequest = cursor.update(value); updateRequest.onsuccess * function()(//处攻成功 | //清求保存更新 |      |
| x                                                            | I rupdateReqeust.onerror ■ function(){"处覆失败＞；          |                |      |
| l})；                                                        |                                                              |                |      |

此时，如果调用delete ()方法，就会删除相应的记录。与updated—样，调用delete (》也返 回一个清求O

request.onsuccess = function(event)( var cursor = event.target.result,

value,

deleteRequest;

if (cursor) {    //必相要检全

if (cursor.key =* "foo"){

d«leteRequest ■ cursor.delete () ；    //请求删除当对5(

deleteRequeet.onsuccess « £unction(){

//处理成功

}：

deleteReouest.onerror = function(){

//处攻失败

};

如果当前事务没有修改对象存储空间的权限，update ()和delete ()会抛出错误。

默汄情况下，每个游标只发起一次请求。要想发起另一次请求，必须调用下面的一个方法。

□    continue (key):移动到结果集中的下一项。参数key是可选的，不指定这个参数，游标移动 到下一项；指定这个参数，游标会移动到指定键的位置。

23

 

□    advance (count):向前移动count指定的项数。

这两个方法都会导致游标使用相同的请求，因此相同的 onsuccess和onerror事件处理程序也会 得到®用。例如，下面的例子遍历了对象存储空间中的所有项。

request.onsuccess = function(event){ var cursor = event.target.result; if (cursor) { //必須要检査

console-log("Key: • + cursor.key + ■# Value： • + JSON.stringify(cursor.value));

cursor.continue() ； /✓移动到下一項 } else {

console.loy("Done I")；

}

}?

调用continued会触发另一次W求，进而W次调用onsuccess事件处理程序a在没有更多项可 以迭代时，将最括•-次调用onsuccess事件处理程序，此时event .target. result的值为null。

5.键范围

使用游标总让人觉得不那么理想，因为通过游标査找数据的方式太有限了。键范围(keyrange)为 使用游标增添了一些灵活性。键范围由IDBKeyRange的实例表示。支持标准IDBKeyRange类型的浏 览器存IE10+和Firefox 4+, Chrome中的名字叫webk it IDBKeyRange。与使用IndexedDB中的其他类 型一样，你最好先声明一个本地的类型，同时要考虑到不同浏览器中的差异。

var 工DBKeyRange = window.IDBKeyRange II window.webkitIDBKeyRange;

有四种定义键范围的方式。第--种是使用only ()方法，传人你想要取得的对象的键。 var onlyRange = IDBKeyRange.only("007");

这个范围可以保证只取得键为•• 007 »的对象。使用这个范围创建的游标与直接访问存储空间并调用 get <"007-)差不多。

第二种定义键范围的方式是指定结果集的下界。下界表泌游标开始的位置。例如，以下键范围可以 保证游标从键为”007 ••的对象开始，然后继续向前移动，直至最后一个对象。

//从鍵为-007■•的对象开始，然后可以移动到：®后

var lowerRange =工DBKeyRange.lowerBound("007");

如果你想忽略键为”007”的对象，从它的下一个对象开始，那么可以传人第二个参数true:

//从键为-ocn-的对象的下一个对象开始，然后可以移动到最后 var lowerRange = IDBKeyRange.lowerBound{”007", true)；

第三种定义键范围的方式是指定结果集的上界，也就是指定游标不能超越哪个键。指定上界使用 upperRange()^&o下面这个键范围可以保证游标从头开始，到取得键为-ace”的对象终止o

//从头开始，到键为*ace、的对象为止

var upperRange = IDBKeyRange.upperBound("ace");

如果你不想包含键为指定值的对象，同样，传人第二个参数true:

//从头开始，到键为"ace”的对象的上一个对象为止

var upper Range    IDBKeyRange. upperBound (" ace" r true)；

第四种定义键范闱的方式一没错，就是同时指定上、下界，使用bound()方法。这个方法可以接 收4个参数：表示下界的键、表示上界的键、可选的表示是否跳过下界的布尔值和可选的表示是否跳过 上界的布尔值。以下是几个例子。

//从健为"007“的对象开始，到键为"ace*的对象为止

var boundRangc = IDBKeyRange.bound("007n, "ace”};

//从键为”007"的对象的下一个对象开始，到键为”aceM的对象为止 var boundRange = IDBKeyRange.bound("007", ”ace", true};

//从犍为"OO7•的对象的下一个对象开始，到犍为”ace”的对象的上一个对象为止 var boundRange = IDBKeyRange.bound("007", "ace”， true, true);

//从健为”007”的对象开始，到键为'ace•的对象的上一个对象为止

var boundRange = IDBKeyRange.bound("007■z "ace*, false, true);

无论如何，在定义键范m之后，把它传给openCursorO方法，就能得到一个符合相应约朿条件的 游标。

var store = db. transaction (''users *) . obj ectStore (* users"),

range - IDBKeyRange. bound (007 n, "ace"); request ■ store.openCursor(r抑ge};

request.onsuccess = function(event){ var cursor = event.target.result； if (cursor) { //必场要检查

console.log("Key："十 cursor.key + ", Value： " +

JSON.stringify(cursor.value))；

cursor. continue () t //移动到下一項 )else {

console.log("Done!">/

)

}；

这个例子输出的对象的键为"007 »到”ace”，比I?-节最后那个例子输出的值少•-些。

6.设定游标方向

实际上，openCursorO可以接收两个参数。第一个参数就是刚刚看到的IDBKeyRange的实例， 第二个是表示方向的数值常景。作为第二个参数的常量是前面讲査询时介绍的iDBCursor中的常量。 Fire f«w4 +和Chrome的实现乂有不同，因此第-步还是在本地消除差异：

var IDBCursor = window.IDBCursor 丨I window.webkitIDBCursor；

正常情况下，游标都是从存储空间的第一项开始，调用continued或advance ()前进到最后一 项。游标的畎认方向值是IDBCursor.NEXT。如果对象存储空间中有重复的项，而你想让游标跳过那些 重复的项，可以为openCursor传人IDBCursor.NEXT_NO_DUPLICATE作为第二个参数：

var store = db.transaction("users").objectStore("users"),

reouest ■ store.openCursor(nullr IDBCursor.NEXT_NO_DUPLICATB)/

注意，openCursor <)的第一个参数是null,表示使用默认的键范围，即包含所有对象„这个游 标可以从存储空间中的第一个对象开始，逐个迭代到最后一个对象一但会跳过重复的对象。

当然，也可以创建一个游标，让它在对象存储空间中向后移动，即从最后-个对象开始，逐个迭 代，直至第一个对象。此时，要'•传人的常量是IDBCursor. PREV和IDBCursor . PREV_NO_DUPLICATEo 例如：

23

 

var store = db.transaction("users").objectStore("users"),

request ■ store.openCursor(null, IDBCursor.PREV>;

IndexedDBExampleO5.htm

使用 IDBCursor. PREV 或 IDBCursor. PREV_NO_DUPL I CATE 打开游标时，毎次调用 continue () 或advanced,都会在存储空间中向后而不是向前移动游标。

7.索引

对于某些数据，可能需要为一个对象存储空间指定多个键。比如，若要通过用户ID和用户名两种 方式来保存用户资料，就需要通过这两个键来存取记录。为此，可以考虑将用户ID作为主键，然后为

用户名创建索引。

要创建索引，首先引用对象存储空间，然后调用createlndexO方法，如下所示。

var store = db.transaction("users").objectStore(”users"),

index = store.createlndex("username11, "username", { unique: false));

createlndexO的第一个参数是索引的名字，第二个参数是索引的属性的名字，第三个参数是一 个包含unique属性的选项(options)对象。这个选项通常都必须指定，因为它表示键在所有记录中 是否唯一。因为username有可能重复，所以这个索引不是唯-的。

createlndex ()的返囲值是lD3Index的实例。在对象存储空间上调用in＜iex(＞方法也能返回同 一个实例。例如，要使用一个已经存在的名为^username”的索引，可以像下面这样取得该索引=

var score = db. transact i on ("users") . ob;'ecLStore ("users"),

index s Btore.index("uBername");

索引其实与对象#储空间很相似。在索引上调用openCursorO方法也可以创逑新的游标，除了将 來会把索引键而非主键保存在event.resulc.key属性中之外，这个游标与在对象存储空间上调用 openCursor ()返回的游标完全一样。来看下面的例子。

var store = db.transaction("users").objectStore{^users"),

index ■ store.index( nuBemamen), request = index.openCursor():

request.onsuccess = function(event){

//处理成功

}；

在索引上也能创建一个特殊的只返回毎条记录主键的游标，那就要调用openKeyCursorO方法。 这个方法接收的参数与openCursor ()相同。而最大的不同在于，这种情况下event. result .key中 仍然保存着索引键，而event.result.value中保存的则是主键，而不再是整个对象。

var store = db. transaction ("users11) .objectStore ("users") f

index = store.index("username"), request = index.openKeyCursor();

request.onsuccess - function(event){

//处理成功

// event .result .key 中保存索引镜，而 event .result .value 中保存主被

};

同样，使用get (＞方法能够从索引中取得一个对象，只要传人相应的索引键即可；当然，这个方法 也将返回一个请求。

var store = db.transaction{"users").objectStore("users"),

index ■ store.index{"username"), request «： index.get ( "007");

request.onsuccess = function(event){

//处理成功

};

request.onerror = function(event){

//处理失败

}；

要根据给定的索引键取得主键，可以使用getKey()方法。这个方法也会创建一个新的请求，但 event»result. value等于主键的值，而不是包含整个对象。

var store = db.transaction("users").objectStore("users"),

index 置 store. index("UBernaxne "), request ■ index.getKey("007 M)；

request.onsuccess = function(event){

//处理成功

//event.result.key 中保存索引鍵， 而 event.result.value 中保存主键

}?

在这个例子的onsuccess事件处理程序中，event .result .value中保存的是用户ID。

任何时候，通过IDBIMex对象的下列屈性都可以取得有关索引的相关信息。

□    name：索引的名字。

□    key Path：传人crcatelndex ()中的属性路径。

□    object Store：索引的对象存储空间。

□    unique：表示索引键是否唯一的布尔值。

另外，通过对象存储对象的indexName属性可以访问到为该空间建立的所有索弓|。通过以下代码 就可以知道根据存储的对象逮立了哪些索引D

var score = db.transaction("users").objectStore("users"),

indexNames = store. indexNaunea, index, i = 0,

len - indexNames.length;

while(i < len){

index ■ store.index(IndexNames[i++]);

console.I09(nIndex name： " ♦ index.name 4- ", KeyPath: • + index.keyTAth ♦ ", Unique: " + index.unique)；

)

以上代码遍历了每个索引，在控制台中输出了它们的信息:，

在对象存储空间上调用deletelndexf)方法并传人索引的名字可以删除索引。

var store = db.transaction("users").objectStore("users");

store.deleteIndex("username")/

23

 

因为删除索引不会影响对象存储空间中的数据，所以这个操作没有任何回调函数。

8.并发问题

虽然网页中的IntlexedDB提供的是异步API,但仍然存在并发操作的问题。如果浏览器的两个不同 的标签页打开了同一个页面，那么_个页面试图更新另一个页面尚未准备就绪的数据库的问题就有可能 发生。把数据库设置为新版本有可能导致这个问题。因此，只有当浏览器中仅有一个标签页使用数据库 的情况下，调用setVersion ()才能完成操作。

刚打开数据库时，要记着指定onversionchange事件处理程序。当同一个来源的另一个标签页调 用setVersionU时，就会执行这个回调函数。处理这个事件的最佳方式是立即关闭数据库，从而保证 版本更新顺利完成。例如：

var request, database；

request = indexedDB.open{"admin")； request.onsuccess = function(event){

database = event.target.result;

database.onversionchange a function(){ database.close{);

}j

};

好次成功打开数据库，都应该指定onversionchange事件处理程序。

调用setVersionO时，指定请求的onblocked事件处理程序也很電要。在你想要更新数据库的 版本但另一个标签页已经打开数据库的情况下，就会触发这个事件处理程序。此时，S好先通知用户关 闭其他标签贞，然后再重新调用setVersionO。例如：

var request    database.setVersion("2.0");

request.onblocked = function(){

alert("Please close all other tabs and try again."}?

\>;

request.onsuccess = function(){

//处理成功，继续

}；

请记住，其他标签M中的onversi onchange事件处理程序也会执呼f „

通过指定这些事件处理程序，就能确保你的Web应用妥善地处理好IndexedDB的并发问题。

9.限制

对IndexedDB的限制很多都与对Web Storage的类似。首先，IndexedDB数据库只能由同源(相同 协议、域名和端口)页面操作，因此不能跨域共享倍息。换句话说，www.wrox.com与p2p.wrox.com 的数据库是完全独立的。

其次，每个来源的数据库占用的磁盘爷间也有限制。Fkefox 4+目前的上限是每个源50MB,而 Chrome的限制是5MB。移动没备上的Firefox最多允许保存5MB,如果超过/■这个配额，将会清求 用户的许可、

Firefox还布另外一■个限制，即不允许本地文件访问IndexedDB。Chrome没有这个限制。如果你在 本地运行本书的示例，请使用Chrome。

23.4小结

禽线web应/H和冉户端存儲数据的能力Xf未来的Web成用越来越®要3浏览器a经能够检测到用 户是卉离线，并触发JavaScript事件以便应用做出处理。可以指定在应用缓存中保存哪些文件以便离线 时使用u对于应用缓存的状态及变化，也有相应的JavaScript API可以调用检测。

本书还讨论了客户端存俺的以下几方面内容。

□以前，这种存储只能使用cookie完成，cookie是一小块可以客户端设置也可以在服务器端设置 的信息，毎次发起诸求时都会传送它。

□在 JavaScript 中通过 document. cookie 可以访问 cookie。

□ cookie的限制使其可以存储少疳数据，然而对于大敢数据效率很低。

IE发明了一种叫做用户数据的行为，可以应用到页面的某个元素上，它有以下特点。

口 一旦应用后，该元素便可以从一个命名数据空间中载人数据，然后可以通过getAttribute()、 setAttribute ()和 removeAttribute ()方法访问。

□数据必须明确使用save!)方法保存到命名数据空间中，以便能在会话之间持久化数据。

Web Storage定义了两种用于存储数据的对象：sessionStorage和localStorage。前者严格用 于在•个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除；后者用于跨会话持久化数据并 遵循跨域安全策略。

indexedDB是一种类似SQL数据库的结构化数据存储机制。但它的数据不是保存在表中，而是保存 在对象存储空间中。创建对象存储空间时，需要定义一个键，然后就可以添加数据。可以使用游标在对 象存储空间中査询特定的对象。而索引则是为了提髙查询速度而基于特定的属性创建的。

有了以上这些选择，就可以在客户端机器上使用JavaScript存储大fl数据了。但你必须小心，不要 在客户端存储敏感数据，因为数据缓存不会加密：，

第么1章

最佳实践

 

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-119.jpg)

 

本章内容

□可维护的代码 □保证代码性能 口部署代码

g从2000以来，Web开发方面的种种规范、条例正在髙速发展。Web开发过去曾是荒芜地带， S里面东西还都凑合，而现在已经演化成了完整的研究规范，并建立了种种最佳实践。随着简

单的网站成长为更加复杂的Web应用，同时Web爱好者成为了有收人的专业人士，Web开发的世界充 满了各种关T-最新技术和开发方法的信息。尤其是JavaScript,它从大量的研究和推断中获益。JavaScript 的最佳实践分成若f-类，并在开发过程的不同点上进行处理。