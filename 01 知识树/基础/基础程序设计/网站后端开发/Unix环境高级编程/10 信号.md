### 第10章

##### 10.1引言

信号是软件中断。很多比较重要的应用程序都需处理信号。信号提供了一种处理异步事件的 方法，例如，终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个 程序。

UNIX系统的早期版本就已经提供信号机制，但是送些系统（如V7）所提供的信号模型并不 可靠。信号可能丢失，而且在执行临界区代码时，进程很难关闭所选择的信号。4.3BSD和SVR3 对信号模型都做了更改，增加了可靠信号机制。但是Berkeley和AT&T所做的更改之间井不兼容。

幸运的是，POSDC1对可靠信号例程进行了标准化，这正是本章所要说明的。

本章先对信号机制进行综述，并说明每种信号的一般用法。然后分析早期实现的问题。在分 析存在的问题之后再说明解决这些问题的方法，这种安排有助于加深对改进机制的理解。本章也 包含了很多并非完全正确的实例，这样做的目的是为了对其不足之处进行讨论。

###### 10.2信号概念

首先，每个信号都有一个名字。这些名字都以3个字符SIG开头。例如，SIGABRT是夭折 信号，当进程调用abort函数时产生这种信号。SIGALRM是闹钟信号，由alarm函数设置的定 时器超时后将产生此信号。V7有15种不同的信号，SVR4和4.4BSD均有31种不同的信号。 FreeBSD 8.0 支持 32 种信号，Mac OS X 10.6.8 以及 Linux 3.2.0 都支持 31 种信号，而 Solaris 10 UK] 支持40种信号。但是，FreeBSD、Linux和Solaris作为实时扩展都支持另外的应用程序定义的信 号。虽然本书不包括POSIX实时扩展（有关信息请参阅Gallmeister[1995]）,但是SUSv4已经把 实时信号接口移至基础规范说明中。

在头文件＜3191^1上＞中，信号名都被定义为正整数常量（信号编号）。

实际上，实现将各信号定义在另一个头文件中，但是该头文件又包括在＜3^!131上＞中。内核包

括对用户级应用程序有意义的头文件，这被认为是一种不好的形式，所以如若应用程序和内核两者都 需使用同一定义，那么就将有关信息放置在内核头文件中，然后用户级头文件再包括该内核头文件。

j于是，FreeBSD8.0和MacOSX 10.6.8将信号定义在＜sys/signal.h＞中，Linux3.2.0将信号定义在 I ＜bits/si_gnum.h＞中，Solaris 10将信号定义在〈sys/iso/signal-iso.h〉1^

不存在编号为0的信号。在10.9节中将会看到，kill函数对信号编号0有特殊的应用。

POSIX.1将此种信号编号值称为空信号。

很多条件可以产生信号。

•当用户按某些终端键时，引发终端产生的信号。在终端上按Delete键（或者很多系统中 的Ctrl+C键）通常产生中断信号（SIGINT）。这是停止一个已失去控制程序的方法。（第 18章将说明此信号可被映射为终端上的任一字符。）

•硬件异常产生信号：除数为0、无效的内存引用等。这些条件通常由硬件检测到，并通知 内核。然后内核为该条件发生时正在运行的进程产生适当的信号。例如，对执行一个无 效内存引用的进程产生SIGSEGV信号。

•进程调用kill（2）函数可将任意信号发送给另一个进程或进程组。自然，对此有所限制： 接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级 用户。

•用户可用kill（l）命令将信号发送给其他进程。此命令只是kill函数的接口。常用此命 令终止一个失控的后台进程。

•当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号。这里指的不是 硬件产生条件（如除以0），而是软件条件。例如SIGURG （在网络连接上传来带外的数 据）、SIGPIPE （在管道的读进程已终止后，一个进程写此管道）以及SIGALRM （进程 所设置的定时器已经超时）。

信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能简单地测 试一个变量（如errno）来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请

[314]执行下列操作\

在某个信号出现时，可以告诉内核按下列3种方式之一进行处理，我们称之为信号的处理或 与信号相关的动作，

（1）    忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。 它们是SIGKILL和SIGSTOP。这两种信号不能被忽略的原因是：它们向内核和超级用户提供了 使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号（如非法内存引用或 除以0），则进程的运行行为是未定义的。

（2）    捕捉信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用 户函数中，可执行用户希望对这种事件进行的处理。例如，若正在编写一个命令解释器，它将用 户的输入解释为命令并执行之，当用户用键盘产生中斷信号时，很可能希望该命令解释器返回到 主循环，终止正在为该用户执行的命令。如果捕捉到SIGCHLD信号，则表示一个子进程已经终 止，所以此信号的捕捉函数可以调用waitpid以取得该子进程的进程ID以及它的终止状态。又 例如，如果进程创建了临时文件，那么可能要为SIGTERM信号编写一个信号捕捉函数以清除临 时文件（SIGTERM是终止信号，kill命令传送的系统默认信号是终止信号〉。注意，不能捕捉 SIGKILL 和 SIGSTOP 信号=

（3）    执行系统默认动作。图10-1给出了对每一种信号的系统默认动作。注意，对大多数信号 的系统默认动作是终止该进程。

图10-1列出了所有信号的名字，说明了哪咎系统支持此信号以及对于这些信号的系统默认动 作。在SUS列中，表示此种信号定义为基本POSIX.1规范部分，“XSI”表示该信号定义在 XSI扩展部分。

在系统默认动作列，“终止+cOre”表示在进程当前工作目录的core文件中复制了该进程的内

存映像(该文件名为core,由此可以看出这种功能很久之前就是UNIX的一部分)。大多数UNIX 系统调试程序都使用core文件检査进程终止时的状态。

| 名字       | 说明                    | ISOC SUS | FreeBSD8.0 | Linux3.2.0 | Mac OS X 10.6.8 | Solaris10 | 默认动作     |
| ---------- | ----------------------- | -------- | ---------- | ---------- | --------------- | --------- | ------------ |
| SIGABRT    | 异常终止(abort)         |          |            |            |                 |           | 终止+core    |
| SIGRLRM    | 定时器超时(alarm)       |          |            |            |                 |           | 终止         |
| SIGBUS     | 硬件故障                |          |            |            |                 |           | 终止+core    |
| SIGCANCEL  | 线程库内部使用          |          |            |            |                 |           | 忽略         |
| SIGCHLD    | 子进程状态改变          |          |            |            |                 |           | 忽略         |
| SIGCONT    | 使暂停进程继续          |          |            |            |                 |           | 继续/忽略    |
| SIGEMT     | 硬件故障                |          |            |            |                 |           | 络止+core    |
| SIGFPE     | 算术异常                | • •      |            |            |                 |           | 终止+core    |
| SIGFREEZE  | 检査点冻结              |          |            |            |                 |           | 忽略         |
| SIGHUP     | 连接断开                |          |            |            |                 |           | 终止         |
| SIGILL     | 非法硬件指令            | • •      |            |            |                 |           | 终止+core    |
| SIGINFO    | 键盘状态请求            |          |            |            |                 |           | 忽略         |
| SIGINT     | 终端中断符              | • •      |            |            |                 |           | 终止         |
| SIGIO      | 异步I/O                 |          |            |            |                 |           | 终止/忽略    |
| SIGIOT     | 硬件故障                |          |            |            |                 |           | 缕止+core    |
| SIGJVM1    | Java虚拟机内部使用      |          |            |            |                 |           | 忽略         |
| SIGJVM2    | Java虚拟机内部使用      |          |            |            |                 |           | 忽略         |
| SIGKILL    | 终止                    | •        |            |            |                 |           | 终止         |
| SIGLOST    | 资源丢失                |          |            |            |                 |           | 终止         |
| SIGLWP     | 线程库内部使用          | •        |            |            |                 |           | 终止/忽略    |
| SIGPIPE    | 写至无读进程的管道      | •        |            |            |                 |           | 终止         |
| SIGPOLL    | 可轮询事件(poll)        |          |            |            |                 |           | 终止         |
| SIGPROF    | 梗概时间超时Csetitimer) |          |            |            |                 |           | 终止         |
| SIGPWR     | 电源失效/重启动         |          |            |            |                 |           | 终止/忽略    |
| SIGQUIT    | 终端退出符              | •        |            |            |                 |           | 终止+core    |
| SIGSEGV    | 无效内存引用            | • •      |            |            |                 |           | 终止+core    |
| SIGSTKFLT  | 协处理器找故障          |          |            |            |                 |           | 终止         |
| SXGSTOP    | 停止                    | •        |            |            |                 |           | 停止进程     |
| SIGSYS     | 无效系统调用            | XSI      |            |            |                 |           | 终止+core    |
| SIGTERM    | 终止                    | • •      |            |            |                 |           | 终止         |
| SIGTHAW    | 检査点解冻              |          |            |            |                 |           | 忽略         |
| SIGTHR     | 线程库内部使用          |          |            |            |                 |           | 忽略         |
| SIGTRAP    | 硬件故障                | XSI      |            |            |                 |           | 终止+core    |
| SIGTSTP    | 终端停止符              |          |            |            |                 |           | 停止进程     |
| SIGTTIN    | 后台读控制tty           |          |            |            |                 |           | 停止进程     |
| SIGTTOU    | 后台写向控制tty         |          |            |            |                 |           | 停止进程     |
| SIGURG     | 紧急情况(套接字〕       |          |            |            |                 |           | 忽略         |
| SIGUSR1    | 用户定义信号            |          |            |            |                 |           | 终止         |
| SIGUSR2    | 用户定义信号            |          |            |            |                 |           | 终止         |
| SIGVTALRM  | 虚拟时间闹钟(setitimer) | XSI      |            |            |                 |           | 终止         |
| SIGWAITING | 线程库内部使用          |          |            |            |                 |           | 忽略         |
| SIGWINCH   | 终端窗口大小改变        |          |            |            |                 |           | 忽略         |
| SIGXCPU    | 超过CPU 限制(setrlimit) | XSI      |            |            |                 |           | 终■止+COTC   |
| SIGXFSZ    | 超过文細麵制(setrlimit) | XSI      |            |            |                 |           | 终止■止+core |
| SIGXRES    | 超过资源控制            |          |            |            |                 |           | 忽略         |

图10-1 UNIX系统信号

产生core文件是大多数UNIX系统的实现功能。虽然该功能不是POSIX.1的组成部分，但在 'Single UNIX Specification XSI的扩展部分中，这一功能作为一个潜在的特定实现的动作被提及。

1 在不同的实现中，core文件的名字可能不同。例如，在FreeBSD 8.0中，core丈件名为

cmtZname.core,其中c/m/nome是接收到信号的进程所执■行的命令名。在Mac OS X 10.6.8中，core 文件名是core.pid,其中，pirf是接收到信号的进程的ID。（这些系统允许经sysctl参教S&置core

_,    ,文件名0 在 Linux 3.2.0 中，core 文件名通过/proc/sys/kernel/core_pattern 进行配置0）

315

?    大多数实现在相应进程的工作目录中包含core文件项；但Mac OS X将所有core文件都放置

316    在/cores目录中。

在下列条件下不产生core文件：（a）进程是设置用户ID的，而且当前用户并非程序文件的 所有者：（b）进程是设置组ID的，而且当前用户并非读程序文件的组所有者：（c）用户没有写当 前工作目录的权限；（d）文件已存在，而且用户对该文件设有写权限；（e）文件太大（回忆7.11节中 的RLIMIT_CORE限制）core文件的权限（假定该文件在此之前并不存在）通常是用户读/写， 但Mac OS X只设置为用户读。

在图10^1说明中的“硬件故障”对应于实现定义的硬件故障。这些名字中有很多取自UNIX系统 早先在PDP-11上的实现。请查看你所使用系统的手册，以确切地弄清楚这整信号对应于哪些错误类型。

下面较详细地逐一说明这些信号。

SIGABRT 调用abort函数时（见10.17节）产生此信号。进程异常终止。

SIGALRM 当用alarm函数设置的定时器超时时，产生此信号。详细情况见10.10节。 若由Setitimer（2）函数设置的间隔时间已经超时时，也产生此信号。

SIGBUS 指示一个实现定义的硬件故障。当出现某些类型的内存故障时（如14.8节中 说明的），实现常常产生此种信号。

SIGCANCEL这是Solaris线程库内部使用的信号。它不适用于一般应用。

SIGCHLD    在一个进程终止或停止时，SIGCHLD信号被送给其父进程。按系统默认，将忽

略此信号。如果父进程希望被告知其子进程的这种状态改变，则应捕捉此信号。 信号捕捉函数中通常要调用-•种wait函数以取得子进程ID和其终止状态。 System V的早期版本有一个名为SIGCLD （无H）的类似信号。这一信号具有 与其他信号不同的语义，SVR2的手册页警告在新的程序中尽量不要使用这种 信号。（令人奇怪的是，在SVR3和SVR4版的手册页中，该警告消失了。〉应 用程序应当使用标准的SIGCHLD信号，但应了解，为了向后兼容，很多系统 定义了与SIGCHLD等同的SIGCLD。如果有使用SIGCLD的软件，需要查阅 系统手册，了解它具体的语义。10.7节将讨论这两个信号。

SIGCONT    此作业控制信号发送给需要继续运行，但当前处于停止状态的进程。如果接

收到此信号的进程处于停止状态，则系统默认动作是使该进程继续运行；否 则默认动作是忽略此信号。例如，全屏编辑程序在捕捉到此信号后，使用信

岡    号处理程序发出重新绘制终端屏幕的通知。关于进一步的情况见10.21节。

SIGEMT 指示一个实现定义的硬件故障。

; EMT这一名宇来自PDP-11的仿真器陷入（emulatortrap）指令。并非所有平台都支持此 :'信号。例如，Linux只对SPARC、MIPS和PA_R1SC等系统结构支持SIGEMT。

SIGFPE    此信号表示一个算术运算异常，如除以0、浮点溢出等。

SIGFREEZE此信号仅由Solaris定义。它用于通知进程在冻结系统状态之前需要采取特定 动作，例如当系统进入休眠或挂起状态时可能需要做这种处理。

SIGHUP    如果终端接口检测到一个连接断开，则将此信号送给与该终端相关的控制进程

（会话首进程）。见图9-13,此信号被送给session结构中pleader字段所 指向的进程，仅当终端的CLOCAL标志没有设置时，在上述条件下才产生此信 号。（如果所连接的终端是本地的，则设置该终端的CLOCAL标志。它告诉终端 驱动程序忽略所有调制解调器的状态行。第18章将说明如何设置此标志。）

注意，接到此信号的会话首进程可能在后台，作为一个例子，请参见图9-7。

这医别于由终端正常产生的几个信号（中断、退出和挂起），这些信号总是传 递给前台进程组。

如果会话首进程终止，也产生此信号。在这种情况，此信号送给前台进程组 中的每一个进程。

通常用此信号通知守护进程（见第13章）再次读取它们的配置文件。选用SIGHUP 的理由是，守护进程不会有控制终端，通常决不会接收到这种信号。

SIGILL    此信号表示进程已执行一条非法硬件指令。

1 4.3BSD的abort函数产生此信号。现在该函数产生SIGABRT信号。

SIGINFO    这是一种BSD信号，当用户按状态键（一般采用Ctrl+T）时，终端驱动程序

产生此信号并发送至前台进程组中的每一个进程（见图9-9）„此信号通常造 成在终端上显示前台进程组中各进程的状态信息。

1 虽然Alpha平台将SIGINFO定义为与SIGPWR具有相同值，但是Linux并不支持SIGINFO !信号。这更多是因为需要对OSF/1开发的软件提供某种往度的兼容。    [3181

SIGINT    当用户按中断键（一般采用Delete或Ctrl4€）时，终端驱动程序产生此信号

并发送至前台进程组中的每一个进程（见图9-9〉，当一个进程在运行时失控， 特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它。

SIGIO    此信号指示一个异步I/O事件。在14.5.2节中将对此进行讨论。

| 在困10-1中，对SIGIO的系统默认动作是终止或忽略。遣憾的是，这依赖于系统。在 :System V中，SIGIO与SIGPOLL相同，其默认动作是终止此进程。在BSD中，其默认动 1作是忽略此信号。

Linux 3.2.0和Solaris 10将SIGIO定义为与SIGPOLL具有相同值，所以默认行为是终 !止该进程。在FreeBSD 8.0和Mac OS X 10.6.8中，默认行为是忽略该信号。

SIGIOT    这指示一个实现定义的硬件故障。

1OT这个名字来自于PDP-11,它是PDP-11计算机“输入/榆出TRAP”（ input/ouiput TRAP）指

令的缩写。System V的早期版本，由abort函数产生此信号。该函数现在产生SIGABRT信号。 FreeBSD 8.0、Linux 3.2,0、Mac OS X 10.6.8 和 Solaris 10 将 SIGIOT 定义为与 SIGABRT

具相同值。

SIGJVM1 Solaris上为Java虚报机预留的一个信号。

SIGJVM2    Solaris上为Java虚拟机预留的另一个信号。

SIGKILL    这是两个不能被捕捉或忽略信号中的一个。它向系统管理员提供了一种可以

杀死任一进程的可靠方法。

SIGLOST 运行在Solaris NFSV4客户端系统中的进程，恢复阶段不能重新获得锁，此时 将由这个信号通知该进程。

SIGLWP    此信号由Solaris线程库内部使用，并不做一般使用。在FreeBSD中，SIGLWP

是SIGTHR的别名。

SIGPIPE    如果在管道的读进程已终止时写管道，则产生此信号。15.2节将说明管道。当

类型为SOCK_STREAM的套接字已不再连接时，进程写该套接字也产生此信 号。我们将在第16章说明套接字。

SIGPOLL    这个信号在SUSv4中已被标记为弃用，将来的标准可能会将此信号移除。当

在一个可轮询设备上发生一个特定事件时产生此信号。14.4.2节将说明poll 函数和此信号，它起源于SVR3,与BSD的SIGIO和SIGURG信号接近。

； 在Linux和Solaris中，SIGPOLL定义为与SIGIO具有相同值。

SIGPROF    这个信号在SUSV4中已被标记为弃用，将来的标准可能会将此信号移除。当

setitimer（2）函数设置的梗概统计间隔定时器（profiling interval timer）已经 超时时产生此信号。

SIGPWR    这是一种依赖于系统的信号。它主要用于具有不间断电源（UPS）的系统。如

果电源失效，则UPS起作用，而且通常软件会接到通知。在这种情况下，系 统依靠蓄电池电源继续运行，所以无须做任何处理，但是如果蓄电池也将不 能支持工作，则软件通常会再次接到通知，此时，系统必项使其各部分都停 止运行。这时应当发送SIGPWR信号》在大多数系统中，接到蓄电池电压过 低信息的进程将信号SIGPWR发送给init进程，然后由init处理停机操作。 j Solaris 10和有些Linux版本在inittab文件中有两个记录项用于此种目的：powerfail

；以及 powerwait （或 powerokwait ）0

在图10~1中，我们将SIGPWR的跃认动作标记为“终止或忽略”。遣螝的是，这种默认动 j作依赖于系统。Linux对此的默认动作是终止相关进程，而Solaris的默认动作是忽略该信号。

SIGQUIT    当用户在终端上按退出键（一般采用Ctri+U时，中断驱动程序产生此信号，

并发送给前台进程组中的所有进程（见图9-9）。此信号不仅终止前台进程组 （如SIGINT所做的那样），同时产生一个core文件。

SIGSEGV    指示进程进行了一次无效的内存引用（通常说明程序有错，比如访问了一个

未经初始化的指针）。

名字 SEGV 代表“段违例”（segmentation violation ）。

SIGSTKFLT此信号仅由Linux定义。它出现在Linux的早期版本，企图用于数学协处理器 的栈故障。该信号并非由内核产生，但仍保留以向后兼容。

SIGSTOP    这是一个作业控制信号，它停止一个进程。它类似于交互停止信号（SIGTSTP），

但是SIGSTOP不能被捕捉或忽略-

SIGSYS



该信号指示一个无效的系统调用。由于某种未知原因，进程执行了一条机器

指令，内核认为这是一条系统调用，但该指令指示系统调用类型的参数却是 无效的。这种情况是可能发生的，例如.若用户编写了一道使用新系统调用 的程序，然后运行该程序的二进制可执行代码，而所用的操作系统却是不支 持该系统调用的较早版本，于是就出现上述情况D    [320]

SIGTERM 这是由命令发送的系统默认终止信号。由于该信号是由应用程序捕获 的，使用SIGTERM也让程序有机会在退出之前做好清理工作，从而优雅地终 止（相对于SIGKILL而言。SIGKILL不能被捕捉或者忽略）。

SIGTHAW    此信号仅由Solaris定义。在被挂起的系统恢复时，该信号用于通知相关进程，

它们需要采取特定的动作。

SIGTHR    FreeBSD线程库预留的信号，它的值定义或与SIGLWP相同。

SIGTRAP    指示一个实现定义的硬件故障。

1    此信号名来自于PDP-11的TRAP指令。当执行断点指令时，实现常用此信号将控制转

I移至调试程序。

SIGTSTP 交互停止信号，当用户在终端上按挂起键（一般采用Ctrl+Z）时，终端驱动 程序产生此信号。该信号发送至前台进程组中的所有进程（参见图9-9），

j    遣憾的是，停止具有不同的含义。当讨论作业控制和信号时，我们谈及停止和继续作业。

；但是，终端驱动程序一直使用术语“停止”表示用Ctrt+S字符终止终端输出，为了继续启动

该终端输出，则用Ctrl+Q字符。为此，终端驱动程序称产生交互停止信号的字符为挂起字符，

而非停止字符。

SIGTTIN    当一个后台进程组进程试图读其控制终端时，终端驱动程序产生此信号（见

9.8节中对此问题的讨论）。在下列例外情形下不产生此信号：（a）读进程忽略 或阻塞此信号；（b）读进程所属的进程组是孤儿进程组，此时读操作返回出 错，errno设置为EI0。

SIGTTOU



SIGURG

SIGUSR1

SIGUSR2

SIGVTALRM

SIGWAITING



当一个后台进程组进程试图写其控制终端时，终端驱动程序产生此信号（见 9.8节对此问题的讨论）。与上面所述的SIGTTIN信号不同，一个进程可以选 择允许后台进程写控制终端。第18章将讨论如何更改此选项。

如果不允许后台进程写，则与SIGTTIN相似，也有两种特殊情况：（a）写进 程忽略或阻塞此信号；（b）写进程所属进程组是孤儿进程组。在第2种情况下 不产生此信号，写操作返回出错，errno设置为EI0。

不论是否允许后台进程写，一些除写以外的下列终端操作也能产生SIGTTOU 信号，如 tcsetattr、tcsendbreak-. tcdrain、tcflush、tcf low 以 及tcsetpgrp。第18章将说明这些终端操作。

此信号通知进程已经发生一个紧急情况。在网络连接上接到带外的数据时， 可选择地产生此信号。

这是一个用户定义的信号，可用于应用程序。

这是另一个用户定义的信号，与SIGUSR1相似，可用于应用程序。

当一个由Setitimer（2）函数设置的虚拟间隔时间已经超时时，产生此信号。 此信号由Solaris线程库内部使用，不做他用。

SIGWINCH    内核维持与每个终端或伪终端相关联窗口的大小。进程可以用ioctl函数（见

18.12节）得到或设置窗口的大小。如果进程用ioctl的设置窗口大小命令 更改了窗口大小，则内核将SIGWINCH信号发送至前台进程组。

SIGXCPU Single UNIX Specification的XSI扩展支持资源限制的概念（见7.11节）。如果 进程超过了其软CPU时间限制，则产生此信号。

； 在图10-1中，对于SIGXCPU的默认动作说明为“终止或终止+core”。该默认动作依赖 于操作系统。Linux 3.2.0和Solaris 10支持的默认动作是终止并劍建core文件；FreeBSD 8.0

:和Mac OS X 10.6.8支持的默认动作是终止且不产生core文件。Single UNIX Specification要 求该默认动作是，异常终止该进程，是否刽建core文件则留给实现决定。

SIGXFSZ    如果进程超过了其软文件长度限制（见7.11节），则产生此信号。

如同SIGXCPU 一样，针对SIGXFSZ的默认动作依赖于操作系统。Linux3.2.0 Solaris

■ 10对此信号的默认动作是终止并创建core文件。FreeBSD 8.0和Mac OS X 10.6.8支持的默 认动作是终止且不产生core文件d Sii^le UNIX Specification要求该默认动作是弃常终止该进 程，是否创建core文件则留给实现决定。

SIGXRES 此信号仅由Solaris定义。可选择地使用此信号以通知进程超过了预配置的资源值。

Solaris资源限制机制是一种通用设施，用于接制在独立应用集之间共享资源的使用。

##### 10.3 函数 signal

UNIX系统信号机制最简单的接口是signal函数。

\#include <signal.h>

void （*signal （int signo, void    （int））） lint），-

返囲值：若成功，返回以前的信号处理配置：若出错，返回SIG ERR

signal函数由ISO C定义。因为ISO C不涉及多进桎、进程组以及终端I/O等，所以它对 I信号的定义非常含糊，以致于对UNIX系統而言几乎毫无用处。

（ 从UNIX System V派生的实现支持signal函数，但该函数提供旧的不可靠信号语义（10.4 !节将说明这些旧的语义）。提供此函数主要是为了向后兼容要求此旧语义的应用程序，新应用程序 ;不应使用这些不可靠信号。

, 4.4BSD也提供signal函数，但它是按照sigaction函数定义的（10.14节将说明 j sigaction函数），所以在4.4BSD之下使用它提供新的可靠信号语义。目前大多数系统遵摘这 f种策略，但Solaris 10沿用System V signal函數的语义。

]    因为signal的语义与实现有关，所以最好使用sigaction函数代替signal &教。在10.14

节讨论sigaction函教时，提供了使用该函数的signal的一个实现。本书中的所有实例均使

'用图]0-18中给出的signal函数，这样不管使用何种平台都可以有一致的语义。

signo参数是图10-1中的信号名。June的值是常量SIG_IGN>常量SIG.DFL或当接到此信 号后要调用的函数的地址，如果指定SIG_IGN，则向内核表示忽略此信号（记住有两个信号SIGKILL 和SIGSTOP不能忽略）。如果指定SIG_DFL，则表示接到此信号后的动作是系统默认动作（见图10-1

中的最后一列)。当指定函数地址时，则在信号发生时，调用该函数，我们称这种处理为捕捉该信号， 称此函数为信号处理租序(signal handler)或信号捕捉函数(signal-catching function)o

signal函数原型说明此函数要求两个参数，返回一个函数指针，而该指针所指向的函数无 返回值(void)。第一个参数signo是一个整型数，第二个参数是函数指针，它所指向的函数需 要一个整型参数，无返回值。signal的返回值是一个函数地址，该函数有一个整型参数(即最 后的(int))。用自然语言来描述也就是要向信号处理程序传送一个整型参数，而它却无返回值。 当调用signal设置信号处理程序时，第二个参数是指向该函数(也就是信号处理程序)的指针。 signal的返回值则是指向在此之前的信号处理程序的指针。

'    很多系统用附加的依赖于实现的参教来谓用信号处理程序。10.14节将对此做进一步说明。

本节开头所示的signal函数原型太复杂了，如果使用下面的typedef[Plauger 1992]，则 可使其简单一些。

typedef void Sigfunc(int);

然后，可将signal函数原型写成：

Sigfunc *signal(int, Sigfunc *);

我们已将此typedef包括在apue.h文件中(见附录B)，并随本章中的函数一起使用。

如果査看系统的头文件<3191^1』>，则很可能会找到下列形式的声明：

\#define SIG_ERR (void (”<))-1 tdefine SIG_DFL (void (”<))0 #define SIG_IGN (void (”⑴1

这些常量可用于表示“指向函数的指针，该函数要求一个整型参数，而且无返回值”。signal的 第二个参数及其返回值就可用它们表示。这些常量所使用的3个值不一定是-1、0和1,但它们 必须是3个值而决不能是任一函数的地址。大多数UNIX系统使用上面所示的值。

獨■实例

图10-2给出了一个简单的信号处理程序，它捕捉两个用户定义的信号并打印信号编号。10.10 节将说明pause函数，它使调用进程在接到一信号前挂起。

\#include "apue.h"

static void sig_usr(int); Z* one handler for both signals */

int

main(void)

{

if (signal(SIGUSR1, sig_usr) == SIG_ERR) err_sys("can't catch SIGUSR1""

if (signal{SIGUSR2, sig_usr) == SIG_ERR) err_sys("can't catch SIGUSR2");

for (;;) pause {);

static void sig_usr(int signo)



/* argument is signal number */

if (signo == SIGUSR1)

printf("received SIGUSRl\n");

else if (signo == SIGUSR2)

printf("received SIGUSR2\n");

else

err_dump("received signal %d\n", signo);

13241    图10-2捕捉SIGUSR1和SIGUSR2的简单程序

我们使该程序在后台运行，并且用kill(l)命令将信号发送给它。注意，在UNIX系统中，

杀死(kill)这个术语是不恰当的。kill(l)命令和kill(2)函数只是将一个信号发送给一个进程 或进程组。该信号是否终止进程则取决于该信号的类型，以及进程是否安排了捕捉该信号。

$ ./a.out &

[1]    7216

$ kill -USR1 7216 received SIGUSR1 $ kill -USR2 7216 received SIGUSR2 $ kill 7216



在后台启动进程

作业控制shell打印作业编号和进程ID 向该进程发送SIGUSR1

向该进程发送SIGUSR2

向该进程发送SIGTERM

[1] + Terminated ./a.out

因为执行图10-2程序的进程不捕捉SIGTERM信号，而对该信号的系统默认动作是终止，所 以当向该进程发送SIGTERM信号后，该进程就终止。    •

1.程序启动

当执行一个程序时，所有信号的状态都是系统默认或忽略，通常所有信号都被设置为它们的默 认动作，除非调用exec的进程忽略该信号。确切地讲，exec函数将原先设置为要捕捉的信号都 更改为默认动作，其他信号的状态则不变(一个进程原先要捕捉的信号，当其执行一个新程序后， 就不能再捕捉了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义)-

一个具体例子是一个交互shell如何处理针对后台进程的中断和退出信号。对于一个非作业控 制shell,当在后台执行一个进程时，例如：

cc main.c &

shell自动将后台进程对中断和退出信号的处理方式设置为忽略，于是，当按下中断字符时就不会 影响至U后台进程。如果没有做这样的处理，那么当按下中断字符时，它不但终止前台进程，也终 止所有后台进程，

很多捕捉这两个信号的交互程序具有下列形式的代码：

void sig_int(int), sig_quit(int); if (signal(SIGINT, SIG_IGN) != SIG_IGN)

signal(SIGINT, sig_int); if (signal(SIGQOIT, SIGJCGN) != SIG_IGN)

signal(SIGQUIT, sig_quit);

[325]这样处理后，仅当SIGINT和SIGQUIT当前未被忽略时，进程才会捕捉它们。

从signal的这两个调用中也可以看到这种函数的限制，不改变信号的处理方式就不能确定

信号的当前处理方式。我们将在本章的稍后部分说明使用sigaction函数可以确定一个信号的 处理方式，而无需改变它。

2.进程创建

当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制 了父进程内存映像，所以信号捕捉函数的地址在子进程中是有意义的。

10-4不可靠的信号

在早期的UNIX版本中(如V7),信号是不可靠的。不可靠在这里指的是，信号可能会丢失：

一个信号发生了，但进程却可能一直不知道这一点。同时，进程对信号的控制能力也很差，它能 捕捉信号或忽略它。有时用户希望通知内核阻塞某个信号：不要忽略该信号，在其发生时记住它，

然后在进程做好了准备时再通知它。这种阻塞信号的能力当时并不具备。

4.2BSD对信号机制进行了更改，提供了被称为可靠信号的机制。然后，SVR3也修改了信号 '机制，提供了 System V可靠信号机制。POSIX.1选择了 BSD模型作为其标准化的基础。

早期版本中的一个向题是在进程每次接到信号对其进行处理时，随即将该信号动作重置为默 认值(在前面运行图10-2程序时，每种信号只捕捉一次，从而回避了这一点)。在描述这些早期 系统的编程书籍中，有一个经典实例，它与如何处理中断信号相关，其代碍与下面所示的相似：

int sig_int();    /* my signal handling function */

signal(SIGINT, sig_int); Z* establish handler */

sig^int (J

{

signal(SIGINT, sig_int);    /* reestablish handler for next time */

:    /* process the signal ... */

I

C由于早期的C语言版本不支持ISO C的void数据类型，所以将信号处理程序声明为int类型。)

这段代码的一个问题是：在信号发生之后到信号处理程序调用signal函数之间有一个时间r—,

窗口。在此段时间中，可能发生另一次中断信号。第二个信号会造成执行默认动作，而对中断信I* 号的默认动作是终止该进程。这种类型的程序段在大多数情况下会正常工作，使得我们认为它们 是正确无误的，而实际上却并非如此。

这些早期版本的另一个问题是：在进程不希望某种信号发生时，它不能关闭该信号。进程能 做的一切就是忽略该信号。有时希望通知系统“阻止下列信号发生，如果它们确实产生了，请记 住它们。”能够显现这种缺陷的的一个经典实例是下列程序段，它捕捉一个信号，然后设置一个 表示该信号已发生的标志：

int sig^int();    /* my signal handling function */

int sig_int_flag;    /* set nonzero when signal occurs */

main ()

signal(SIGINT, sig_int);    /* establish handler */

while (sig_int_flag == 0)

pause(》；    /* go to sleep, waiting for signal */

}

sig_int ()

signal(SIGINT, sig_int); sig_int_flag = 1;



/* reestablish handler for next time */ /* set flag for main loop to examine */

其中，进程调用pause函数使自己休眠，直到捕捉到一个信号。当捕捉到信号时，信号处理程 序将标志sig_int_fiag设置为非0值。从信号处理程序返回后，内核自动将该进程唤醒，它 检测到该标志为非0,然后执行它所需做的，但是这里有一个时间窗口，在此窗口中操作可能失误。 如果在测试sig_int_flag之后、调用pause之前发生信号，则此进程在调用pause时可能 将永久体眠（假定此信号不会再次产生），于是，这次发生的信号也就丢失了。这是另一个例子， 某段代码并不正确，但是大多数时间却能正常工作。要査找并排除送种类型的问题很困难。

10.5中断的系统调用

早期UNIX系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信 号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其errno设置为EINTR。这 样处理是因为一个信号发生了，进程捕捉到它，这意味着已经发生了某种事情，所以是个好机会 应当唤醒阻塞的系统调用。

[327]    在这里，我们必须区分系统调用和函也当捕捉到某个信号时，枝中断的是内核中执行的系统调用。

为了支持这种特性，将系统调用分成两类：低速系统调用和其他系统调用，低速系统调用是 可能会使迸程永远阻塞的-类系统调用，包括：

•如果某些类型文件（如读管道、终端设备和网络设备）的数据不存在，则读操作可能会 使调用者永远阻塞；

•如果这些数据不能被相同的类型文件立即接受，则写操作可能会使调用者永远阻塞：

•在某种条件发生之前打开某些类型文件，可能会发生阻塞（例如要打开一个终端设备， 需要先等待与之连接的调制解调器应答）；

• pause函数（按照定义，它使调用进程休眠直至捕捉到一个信号）和wait函数；

•某些ioctl操作；

•某些进程间通信函数（见第15章）。

在这些低速系统调用中，一个值得注意的例外是与磁盘I/O有关的系统调用。虽然读、写一 个磁盘文件可能暂时阻塞调用者（在磁盘驱动程序将请求排入队列，然后在适当时间执行请求期 间），但是除非发生硬件错误，I/O操作总会很快返回，并使调用者不再处于阻塞状态。

可以用中断系统调用这种方法来处理的一个例子是：一个进程启动了读终端操作，而使用该 终端设备的用户却离开该终端很长时间。在这种情况下，进程可能处于阻塞状态几个小时甚至数 天，除非系统停机，否则一直如此。

； 对于中断的read、write系统调用，POSIX.1的语义在该标准的2001版有所改变。对于如 何处理已read、write部分数据責的相应系统调用，早期版本允许实现自行选择。如若read 系统调用已接收并传送数据至应用程序缓冲区，但尚未接收到应用程序请求的全部数据，此时被

:中断，操作系统可以认为该系统调用失败，并将errno设置为EINTR;另一种处理方式是允许 :该系统调用成功返回，返回值是已接收到的数据量。与此类似，如若write巳传输了应用程序缓

冲区中的部分数据，然后被中断，操作系统可以认为该系统调用失败，并将errno设置为EINTR;

；另一种处理方式是允许该系统调用成功返回，返回值是已写部分的数据量。历史上，从SystemV 派生的实政将这种系统调用视为失败，而BSD派生的实现则处理为部分成功返回。2001版POSDC1 标准采用BSD风格的语义。

与被中断的系统调用相关的问题是必须显式地处理出错返回。典型的代码序列(假定进行一 个读操作，它被中断，我们希望重新启动它)如下：

again:

if ((n = read(fd, buf, BUFFSIZE)) < 0) { if (errno == EINTR)

goto again； /* just an interrupted system call */

/* handle other errors */

}    画

为了帮助应用程序使其不必处理被中断的系统调用，4.2BSD引进了某些被中断系统调用的自

动重启动。自动重启动的系统调用包括：ioctl、read、readv、write、writev、wait和 waitpid.如前所述，其中前5个函数只有对低速设备进行操作时才会被信号中断。而wait和 waitpid在捕捉到信号时总是被中断。因为这种自动重启动的处理方式也会带来问题，某些应用 程序并不希望这些函数被中断后重启动。为此4.3BSD允许进程基于每个信号禁用此功能。

POS1X.1要求只有中断信号的SA_RESTART标志有效时，实現才重启动系统调用。在10.14

\节将看到，sigaction函數使用这个标志允许应用程序请求重启动被中断的系就讶用。

历史上，使用signal函数建立信号处理程序时，对于如何处理被中断的系洗调用，各种实

i现的做法各不相同。SystemV的默认工作方式是从不重启动系统调用。而BSD则重启动枝信号中 :断的系统调用。FreeBSD 8.0、Linux 3.2.0和Mac OS X 10.6.8中，当信号处理程序是用signal :函数时，被中断的系统调用会重启动。但Solaris 10的默认方式是出错返回，将errno设置为

E工NTR。使用用户自己实现的signal函教(见图10-18)可以避免必须处理这些差异的麻烦。

4.2BSD引入自动重启动功能的一个理由是：有时用户并不知道所使用的输入、输出设备是否 是低速设备。如果我们编写的程序可以用交互方式运行，则它可能读、写终端低速设备。如果在 程序中捕捉信号，而且系统并不提供重启动功能，则对每次读、写系统调用就要进行是否出错返 回的测试，如果是被中断的，则再调用读、写系统调用。

图10-3列出了几种实现所提供的与信号有关的函数及它们的语义。

| 函数                                     | 系统                                                     | 信号处理程 序仍被安装 | 阻塞信号 的能力 | 被中断用 的自动重启动？ |
| ---------------------------------------- | -------------------------------------------------------- | --------------------- | --------------- | ----------------------- |
| signal                                   | ISOC、POSIX.1                                            | 未说明                | 未说明          | 未说明                  |
| V7、SVR2、SVR3                           |                                                          |                       | 从不            |                         |
| SVR4、Solaris                            |                                                          |                       | 从不            |                         |
| 4.2BSD                                   | •                                                        | •                     | 总是            |                         |
| 4.3BSD' 4.4BSD、FreeBSD, Linux. Mac OS X | •                                                        | •                     | 默认            |                         |
| sigaction                                | POSK.l、4+4BSD、SVR4、FreeBSD、Linux、 Mac OS X、Solaris | -                     | •               | 可选                    |

图10-3几种信号实现所提供的功能

应当了解，其他厂商提供的UNIX系统可能不同于图10-3中所示的情况，例如，SunOS 4.1.2 中的sigaction默认方式是重启动被中断的系统调用，这与列在图10-3中的各平台不同。

在图10-18中，提供了我们自己的signal函数版本，它自动地尝试重启动被中断的系统调 用（除SIGALRM信号外）。在图10-19中则提供了另一个函数Signal_intr，它不进行重启动。

在14.4节说明select和poll函数时，还将更多涉及被中断的系统调用。


10.6可重入函数

进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中 断，它首先执行该信号处理程序中的指令。如果从信号处理程序返回（例如没有调用exit或 longjmp）,则继续执行在捕捉到信号时进程正在执行的正常指令序列（这类似于发生硬件中断 时所做的）。但在信号处理程序中，不能判断捕捉到信号时进程执行到何处。如果进程正在执行 malloc,在其堆中分配另外的存储空间，而此时由于捕捉到信号而插入执行该信号处理程序， 其中又调用malloc，这时会发生什么？又例如，若进程正在执行getpwnam （见6.2节）这种 将其结果存放在静态存储单元中的函数，其间插入执行信号处理程序，它又调用这样的函数，这 时又会发生什么呢？在malloc例子中，可能会对进程造成破坏，因为malloc通常为它所分配 的存储区维护一个链表，而插入执行信号处理程序时，进程可能正在更改此链表。在getpwnam 的例子中，返回给正常调用者的信息可能会被返回给信号处理程序的信息覆盖。

Single UNIX Specification说明了在信号处理程序中保证调用安全的函数。这些函数是可重入 的并被称为是异步信号安全的（async-signalsafe）。除了可重入以外，在信号处理操作期间，它会 阻塞任何会引起不一致的信号发送a图1（M列出了这些异步信号安全的函数。没有列入图10-4中

| abort         | faccessat   | linkat            | select      | socketpair       |
| ------------- | ----------- | ----------------- | ----------- | ---------------- |
| accept        | fchmod      | listen            | sem_post    | stat             |
| access        | fchraodat   | Iseek             | send        | symlink          |
| aio_error     | fchown      | lstat             | sendmsg     | symlinkat        |
| aio_return    | fchownat    | mkdir             | sendto      | tcdrain          |
| aio_suspend   | fcntl       | mkdirat           | setgid      | tcflow           |
| alarm         | fdatasync   | mkfifo            | setpgid     | tcflush          |
| bind          | fexecve     | mkfifoat          | setsid      | tcgetattr        |
| cfgetispeed   | fork        | mknod             | setsockopt  | tcgetpgrp        |
| cfgetospeed   | fstat       | mknodat           | setuid      | tcsendbreak      |
| cfsetispeed   | fstatat     | open              | shutdown    | tcsetattr        |
| cfsetospeed   | fsync       | openat            | sigaction   | tcsetpgrp        |
| chdir         | ftruncate   | pause             | sigaddset   | time             |
| chmod         | futimens    | pipe              | sigdelset   | timer_getoverrun |
| chown         | getegid     | poll              | sigemptyset | timer_gettime    |
| clock_gettime | geteuid     | posix_trace_event | sigfillset  | timer_settime    |
| close         | getgid      | pselect           | sigismember | times            |
| connect       | getgroups   | raise             | signal      | umask            |
| creat         | getpeername | read              | sigpause    | uname            |
| dup           | getpgrp     | readlink          | sigpending  | unlink           |
| dup2          | getpid      | readlinkat        | sigprocmask | ulinkat          |
| execl         | getppid     | recv              | sigqueue    | utime            |
| execle        | getsockname | recvfrom          | sigset      | utimensat        |
| execv         | getsockopt  | recvmsg           | sigsuspend  | utimes           |
| execve        | getuid      | rename            | sleep       | wait             |
| Exit          | kill        | renameat          | socketmark  | waitpid          |
| exit          | link        | rmdir             | socket      | write            |

图104信号处理程序可以调用的可重入函数

的大多数函数是不可重入的，因为（a）已知它们使用静态数据结构；（b）它们调用malloc或 free； （c）它们是标准I/O函数。标准I/O库的很多实现都以不可重入方式使用全局数据结构。

注意，虽然在本书的某些实例中，信号处理程序也调用了 printf函数，但这并不保证产生所期 望的结果，信号处理程序可能中断主程序中的printf函数调用》

应当了解，即使信号处理程序调用的是图l（b4中的函数，但是由于每个线程只有一个errno 变量（回忆1.7节对errno和线程的讨论），所以信号处理程序可能会修改其原先值。考虑一个 信号处理程序，它恰好在main刚设置errno之后被调用。如果该信号处理程序调用read这类p 函数，则它可能更改errno的值，从而取代了刚由main设置的值。因此，作为一个通用的规则， 当在信号处理程序中调用图104中的函数时，应当在调用前保存errno,在调用后恢复errno。1~1 （应当了解，经常被捕捉到的信号是SIGCHLD，其信号处理程序通常要调用一种wait函数，而 各种wait函数都能改变errno。）

注意，图1（M没有包括longjmp （7.10节）和siglongjmp （10,15节\这是因为主例程 以非可重入方式正在更新一个数据结构时可能产生信号。如果不是从信号处理程序返回而是调用 siglongjmp,那么该数据结构可能是部分更新的。如果应用程序将要做更新全局数据结构这样 的事情，而同时要捕捉某些信号，而这些信号的处理程序又会引起执行siglongjmp,则在更新 这种数据结构时要阻塞此类信号。

、实例

图1〜5给出了一段程序，这段程序从信号处理程序myjlarm调用非可重入函数getpwnam，

而my_alarm每抄钟被调用一?欠。10.10节中将说明alarm函数。在该程序中调用alarm函数 使得每抄产生一次SIGALRM信号。    [3Ti~|

\#include "apue.h"

\#include <pwd.h>

static void

my_alarm（int signo）

i

struct passwd *rootptr;

printf("in signal handler\n")；

if Urootptr * getpwnainC'root")) == NULL) err_sys("getpwnam(root) error");

alarm (1);

int

main (void)

{

struct passwd *ptr;

signal(SIGALRM, my_alarm); alarm ⑴； for ( ; ; ) {

if {{ptr = getpwnam("sar")) =- NULL) err_sys("getpwnam error");

if (strcmp(ptr->pw_name, "sar") != 0)

printf("return value corrupted!, pw_name = %s\n", ptr->pw_name)，-

图10-5在信号处理程序中调用不可再入函数

运行该程序时，其结果具有随机性。通常，在信号处理程序经多次迭代返回时，该程序 将由SIGSEGV信号终止。检査core文件，从中可以看到main函数己调用getpwnam，但 当getpwnam调用free时，信号处理程序中断了它的运行，并调用getpwnam,进而再次调 用free。在信号处理程序调用free而主程序也在调用free时，malloc和free维护的数 据结构就出现了损坏，偶然，此程序会运行若干秒，然后因产生SIGSEGV信号而终止。在捕捉 到信号后，若main函数仍正确运行，其返回值却有时错误，有时正确。

从此实例中可以看出，如果在信号处理程序中调用一个非可重入函数，则其结果是不可预 知的。    •

10.7 SXGCLD 语义

SIGCLD和SIGCHLD这两个信号很容易被混淆。SIGCLD （没有H）是System V的一个信号 名，其语义与名为SIGCHLD的BSD信号不同。POSIX.1采用BSD的SIGCHLD信号。

画    BSD的SIGCHLD信号语义与其他信号的语义相类似。子进程状态改变后产生此信号，父进

程需要调用一个wait函数以检测发生了什么。

System V处理SIGCLD信号的方式不同于其他信号。如果用signal或sigset （早期设置 信号配置的，与SRV3兼容的函数）设置信号配置，则基于SVR4的系统继承了这一具有问题色 彩的传统（即兼容性限制）。对于SIGCLD的早期处理方式是：

（1）如果进程明确地将该信号的配置设置为SIG„IGN,则调用进程的子进程将不产生僵死进 程。注意，这与其默认动作（SIG_DFL） “忽略”（见图10-1）不同。子进程在终止时，将其状态 丢弃。如果调用进程随后调用一个wait函数，那么它将阻塞直到所有子进程都终止，然后该wait 会返回-1，并将其errno设置为ECHILD。（此信号的默认配置是忽略，但这不会使上述语义起 作用。必须将其配置明确指定为SIG_IGN才可以。）

I POSIX.I并未说明在SIGCHLD被忽略时应产生的后果，所以这种行为是允许的。Single UNIX ）Specification的XSI扩展选项要求对于SIGCHLD支持这种行为。

' 如果SIGCHLD被忽略，4.4BSD总是产生僵死进程。如果要避免僵死进程，则必须等待子进 .程。在SVR4中，如果调用signal或sigset将SIGCHLD的配置设置为忽略，则决不会产生 ，僵死进程。本书讨论的4种平台在此方面都追随SVR4的行为。

使用sigaction可设置SA_NOCLDWAIT标志（见图10-6 ）以避免进程僵死。本书讨论的4 :种平台都支持这一点。

（2）如果将SIGCLD的配置设置为捕捉，则内核立即检査是否有子进程淮备好被等待，如果 是这样，则调用SIGCLD处理程序。

第2种方式改变了为此信号编写处理程序的方法，这一点可在下面的实例中看到。

、实例

10.4节曾提到，进入信号处理程序后，首先要调用signal函数以重新设置此信号处理程序 （在信号被重置为其默认值时，它可能会丢失，立即重新设置可以减少此窗口时间）。图10-6展示 了这一点。但此程序不能在某些传统的System V平台上正常工作。程序一行行地不断重复输出 “SIGCLD received",最后进程用完其桟空间并异常终止

\#include

tinclude

static void



"apue.h"

<sys/wait.h>

sig_cld{int);



int

main ()

{

pid_t pid;

if (signal(SIGCLD, sig_cld) == SIG_ERR) perror{"signal error"H

if ((pid = fork⑴ < 0)[ perror("fork error");

} else if (pid == 0) {    /* child */

sleep(2);

_exit (0);

}

pause (); /* parent */ exit (0};

static void

sig_cld(int signo) /* interrupts pause() */

f

pid_t    pid;

int    status;

printf {"SIGCLD received\n")

if (signal(SIGCLD, sig_cld) = SIG_ERR) /* reestablish handler */ perror("signal error");

if ((pid = wait(Sstatus)) < 0)    /* fetch child status */

perror{"wait error");

printf("pid = %d\n", pid);

图10-6不能正常工作的System V SIGCLD处理程序

因为基于BSD的系统通常并不支持早期System V的SIGCLD语义，所以FreeBSD 8.0和Mac OS X 10.6.8并没有出现此问题。Linux 3.2.0也没有出现此问题，其原因是，虽然SIGCLD和 SIGCHLD定义为相同的值，但当一个进程要排捕捉SIGCHLD,并且已经有进粒灌备好由其父进

,程等待时，该系统并不调用SIGCHLD信号的处理程序。Solaris 10在此种情况时确实调用读信号 j处理程序，但在内核中增加了避免此问题的代码。

I 虽然本书说明的所有4种平台都解决了这一问题，但是应当意识到没有解决这一问题的平台 [334]    U如A1X）依然存在。

此程序的问题是：在信号处理程序的开始处调用signal，按照上述第2种方式，内核 检查是否有需要等待的子进程（因为我们正在处理一个SIGCLD信号，所以确实有这种子进 程），所以它产生另一个对信号处理程序的调用。信号处理程序调用signal,整个过程再 次重复，

为了解决这一问题，应当在调用wait取到子进程的终止状态后再调用signal。此时仅当 其他子进程终止，内核才会再次产生此种信号。

;    如果为SIGCHLD建立了一个信号处理租序，又存在一个已终止但父进程尚未等待它的进程，

:则是否会产生信号？ POS1X.1对此没有做说明。这就允许前面所述的工作方式。但是，POS1X.1 ，在信号发生时并没有将信号处理重置为其默认值（假定正调用POSIX.1的sigaction函數设置 '其釔置），于是在SIGCHLD处理程序中也就不必再为该信号指定一个信号处理租序。    •」

务必了解你所用的系统实现中SIGCHLD信号的语义。也应了解在某些系统 S工GCHLD为SIGCLD或反之。更改这种信号的名字使你可以编译为另一个系统编写的程序，但是 如果这一程序使用该信号的另一种语义，程序有可能不会正常工作。

在本书说明的4种平台上，只有Linux 3.2.0和Solaris 10定义了 SIGCLD, SIGCLD等同于 SIGCHLDo

10.8可靠信号术语和语义

我们需要先定义一些在讨论信号时会用到的术语。首先，当造成信号的事件发生时，为进程 产生一个信号（或向一个进程发送一个信号）。事件可以是硬件异常（如除以0）、软件条件（如 alarm定时器超时）、终端产生的信号或调用kill函数。当一个信号产生时，内核通常在进程 表中以某种形式设置一个标志。

当对信号采取了这种动作时，我们说向进程递送了一个信号。在信号产生（generation）和递 送（delivery）之间的时间间隔内，称信号是未决的（pending）。

进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号，而且对该信号的动作 是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到垓进程对此信号解除 了阻塞，或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时（而不 是在产生该信号时），才决定对它的处理方式。于是进程在信号递送给它之前仍可改变対该信号

[335]的动作。进程调用sigpending函数（见10.13节）来判定哪些信号是设置为阻塞并处于未决状 态的。

如果在进程解除对某个信号的阻塞之前，这种信号发生了多次，那么将如何呢？ POSIX.1允 许系统递送该信号一次或多次。如果递送该信号多次，则称这些信号进行了排队。但是除非支持 POSIX.1实时扩展，否则大多数UNIX并不对信号排队，而是只递送这种信号一次。

| SUSv4中，实时信号功能已经移至基础規范的实时扩展部分。随着时间的推移，更多的系统 即使不支持实时扩展，也会支持信号排队。我们将在10.20节中进一步讨论排队信号。

1 SVR2的手册页称，在进程执行SIGCLD信号处理程序期间，该信号是用排队方式处理的，

虽然在概念层次这可能是真的，但实际并非如此。内核是按照10.7节中所述方式产生此信号。SVR3

'的手册页对此做了修改，它指明在进程执行SIGCLD信号处理程序期间，忽略SIGCLD信号。SVR4 J手册页删除了有关部分。

1    AT&T[1990e]中的 SVR4sigaction（2）手册页称 SA_SIGINFO 标志（见图 10-16）使信号可

■靠地排队，这是不正确的。表面上内核部分地实现了此功能，但在SVR4中并不起作用。令人不

可思议的是，SVID （ System V接口定义〉对这种可靠队列并未做同样的声明。

如果有多个信号要递送给一个进程，那将如何呢？ POSK.1并没有规定这些信号的递送顺序。但 是POSDC1基础部分建议：在其他信号之前递送与进程当前状态有关的信号，如SIGSEGV。

每个进程都有一个信号屏蔽字（signal mask）,它规定了当前要阻塞递送到该进程的信号集。対 于每种可能的信号，该屏蔽字中都有一位与之对应。対于某种信号，若其对应位已设置，则它当前是 被阻塞的。进程可以调用sigprocmask （在10.12节中说明）来检测和更改其当前信号屏蔽字。

信号编号可能会超过一个整型所包含的二进制位数，因此POSIX.1定义了一个新数据类型 sigset.t,它可以容纳一个信号集。例如，信号屏蔽字就存放在其中一个信号集中。10.11节将 说明对信号集进行操作的5个函数。

##### 10-9 函数 kill 和 raise

kill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。

raise最初是由ISO C定义的。后来，为了与1SOC标准保持一致，POSIX.1也包括了该函

数。但是POSIX.1扩展了 raise的規范，使其可处理线程（12.8中讨论线程如何与信号交互）。

因为ISOC并不涉及多进租，所以它不能定义以进程ID作为其参数（如kill函数）的函数。[336]

\#include <signal.h>

int kill (pid_t pid, int signo);

int raise (int signo)；

两个函数返回值：若成功，返回0;若出错，返回-I

调用

raise（signo）;

等价于调用

kill（getpidt）, signo）; kill的pZrf参数有以下4种不同的情况。

pid>Q    将该信号发送给进程ID为/wW的进程。

pid=0    将该信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组ID

等于发送进程的进程组ID）,而且发送进程具有权限向这些进程发送信号。这 里用的术语“所有进程”不包括实现定义的系统进程集。对于大多数UNIX系 统，系统进程集包括内核进程和init （pid为I）。

pid<0    将该信号发送给其进程组ID等于/»7/绝对值，而且发送进程具有权限向其发送

信号的所有进程。如前所述，所有进程并不包括系统进程集中的进程。

pid^-\    将该信号发送给发送进程有权限向它们发送信号的所有进程。如前所述，所有

进程不包括系统进程集中的进程。

如前所述，进程将信号发送给其他进程需要权限。超级用户可将信号发送给任一进程。对于 非超级用户，其基本规则是发送者的实际用户1D或有效用户ID必须等于接收者的实际用户ID 或有效用户ID。如果实现支持_POSIX_SAVED_IDS （如POSIX.1现在要求的那样），则检査接收 者的保存设置用户ID （而不是有效用户ID）。在对权限进行测试时也有一个特例：如果被发送的 信号是SIGCONT,则进程可将它发送给属于同一会话的任一其他进程。

POSIX.1将信号编号0定义为空信号。如果参数是0,则kill仍执行正常的错误检查， 但不发送信号。这常被用来确定一个特定进程是否仍然存在。如果向一个并不存在的进程发送空 信号，则kill返回-1，errno被设置为ESRCH。但是，应当注意，UNIX系统在经过一定时间

[337]后会重新使用进程ID,所以一个现有的具有所给定进程ID的进程并不一定就是你所想要的进程。

还应理解的是，测试进程是否存在的操作不是原子操作。在kill向调用者返回测试结果时，

原来已存在的被测试进程此时可能已经终止，所以这种测试并无多大价值。

如果调用kill为调用进程产生信号，而且此信号是不被阻塞的，那么在kill返回之前，

hgno或者某个其他未决的、非阻塞信号被传送至该进程。（对于线程而言，还有一些附加条件； 详细情况见12.8节。）

##### 10.10 函数 alarm 和 pause

使用alarm函数可以设置一个定时器（闹钟时间），在将来的某个时刻该定时器会超时。当 定时器超时时，产生SIGALRM信号。如果忽略或不捕捉此信号，则其默认动作是终止调用该 alarm函数的进程。

\#include <unistd.h>

unsigned int alarm (unsigned int seconds、••

返回值，0或以前设置的闹钟时间的余留秒数

参数wcom*的值是产生信号SIGALRM需要经过的时钟秒数。当这一时刻到达时，信号由内 核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一个时间间隔。

早期的UNIX系统实现曾提出警告，这种信号可能比预定值提前Is发送。POSIX.1则不允许 这样做。

每个进程只能有一个闹钟时间。如果在调用alarm时，之前己为读进程注册的闹钟时间还没有超 时，则该闹钟时间的余留值作为本次alarm函数调用的值返回。以前注册的闹钟时间则被新值代替。

如果有以前注册的尚未超过的闹钟时间，而且本次调用的secwi也值是0,则取消以前的闹钟 时间，其余留值仍作为alarm函数的返回值。

虽然SIGALRM的默认动作是终止进程，但是大多数使用闹钟的进程捕捉此信号。如果此时 进程要终止，则在终止之前它可以执行所需的清理操作。如果我们想捕捉SIGALRM信号，则必 须在调用alarm之前安装该信号的处理程序。如果我们先调用alarm,然后在我们能够安装

SIGALRM处理程序之前已接到该信号，那么进程将终止。 pause函数使调用进程挂起直至捕捉到一个信号。

| #include <unistd.h> |                              |
| ------------------- | ---------------------------- |
| int pause(void);    | 返回值：-1，errno设置为EINTR |

只有执行了一个信号处理程序并从其返回时，pause才返回。在这种情况下，pause返回-1, errno设置为E工NTR。

为■实例

使用alarm和pause，进程可使自己休眠一段指定的时间。图10-7中的sleepl函数看似 提供了这种功能(其实这里面存在问题，我们很快就会看到)。

\#include    <signal.h>

ttinclude    <unistd.h>

static void

sig_alrm(int signo)

t

/* nothing to do, just return to wake up the pause */

»

unsigned int

sleepl(unsigned int seconds)

if (signal(SIGALRM, sig_alrm) == SIG_ERR) return(seconds);

alarmfseconds)，-    /* start the timer */

pause();    /* next caught signal wakes us up */

return(alarm(O));    /* turn off timer, return unslept time */

J

图10-7 sleep简化而不完整的实现

程序中的sleepl函数看起来与将在10.19节中说明的sleep函数类似，但这种简单实现有 以下3个问题。

(1)    如果在调用sleepl之前，调用者已设置了闹钟，则它被sleepl函数中的第一次alarm 调用擦除。可用下列方法更正这一点：检査第一次调用alarm的返回值，如其值小于本次调用 alarm的参数值，则只应等到已有的闹钟超时。如果之前设置的闹钟超时时间晚于本次设置值，

则在sleepl函数返回之前，重置此闹钟，使其在之前闹钟的设定时间再次发生超时。

(2)    该程序中修改了对SIGALRM的配置。如果编写了一个函数供其他函数调用，则在该函 数被调用时先要保存原配置，在该函数返回前再恢复原配置。更正这一点的方法是：保存signal 函数的返回值，在返回前重置原配置。

(3)    在第一次调用alarm和pause之间有一个宽争条件。在一个繁忙的系统中，可能alarm 在调用pause之前超时，并调用了信号处理程序。如果发生了这种情况，则在调用pause后，

如果没有捕捉到其他信号，调用者将永远被挂起。    [339]

sleep的早期实现与图10-7程序类似，但更正了第1个和第2个问题。有两种方法可以更正第

3个问题。第一种方法是使用setjmp,下一个实例将说明这种方法。另一种方法是棚sigprocnask 和sigsuspend，10.19节将说明这种方法。    H9

SVR2中的sleep实现使用了 setjmp和longjmp （见7.10节），以避免前一个实例的第3 个问题中说明的竞争条件。此函数的一个简化版本称为Sleep2,示于图10-8中（为了缩短实例 程序的长度，程序中没有处理上面所说的第1个和第2个问题）。

\#include #include #include



<setjmp.h>

<3ignal.h>

<unistd.h>

static jmp__buf env_alrm;

static void

sig_alrm(int signo)

(

longjmp{env_alrm, 1);

unsigned int

sleep2(unsigned int seconds)

if (signal(SIGALRM, 3ig_alrm) return(seconds);



==SIG_ERR)

start the timer */

next caught signal wakes us up */

turn off timer, return unslept time */

图10-8 sleep的另一个不完善的实现

在此函数中，已避免了图10-7中具有的竞争条件。即使pause从未执行，在发生SIGALRM 时，sleep2函数也返回。

但是，sleeP2函数中却有另一个难以察觉的问题，它涉及与其他信号的交互。如果SIGALRM 中断了某个其他信号处理程序，则调用longjmp会提早终止该信号处理程序。图10-9显示了这 种情况。SIGINT处理程序中包含了 for循环语句，它在作者所用系统上的执行时间超过5s，也 就是大于Sleep2的参数值，这正是我们想要的。整型变量k说明为volatile,这样就阻止了

[340]优化编译程序去除循环语句。

番include "apue.h1

| unsigned intstatic void | sleep2(unsigned int); sig_int (int)，- |
| ----------------------- | -------------------------------------- |
| intmain(void)           |                                        |

unsigned int unslept;

if (signal(SIGINT, sig_int) == SIG_ERR) err_sys("signal(SIGINT) error");

unslept = sleep2{5);

printf("sleep2 returned: %u\n", unslept); exit (0);

}

static void

sig_int(int signo)

{

int    i, j;

volatile int    k;

\*    Tune these loops to run for more than 5 seconds

\*    on whatever system this test program is run.

*/

printf("\nsig_int starting\n");

for (i = 0; i < 300000; i++) for (j = 0; j < 4000; j++)

k += i * j;

printf("sig_int finished\n");

图10-9在一个捕捉其他信号的程序中调用sleeP2 执行图10-9中的程序，可以通过键入中断字符来中断休眠，运行结果如下：

$ ./a.out

*C    键入中断字符

sig_int starting sleep2 returned: 0

从中可见sleeP2函数所引起的longjmp使另一个信号处理程序sig_int提早终止，即使它未 完成也会如此。如果将SVR2的sleep函数与其他信号处理程序一起使用，就可能碰到这种情况， 见习题10.3。

sleepl和sleep2函数的这两个实例是告诉我们在涉及信号时需要有精细而周到的考虑。下面 几节将说明解决送壁问题的方法，使我们能够可靠地、在不影响其他代码段的情况下处理信号。    [Kl

■实例

除了用来实现sleep函数外，alarm还常用于对可能阻塞的操作设置时间上限值。例如，

程序中有一个读低速设备的可能阻塞的操作(见10.5节)，我们希望超过一定时间量后就停止执 行该操作。图10-10实现了这一点，它从标准输入读一行，然后将其写到标准输出上。

\#include "apue.h"

static void sig_alrm(int);

int

main(void)

int

n?



Char    line[MAXLINE];

if (signal(SIGALRM, sig_alrm) == SIG_ERR) err_sys("signal(SIGALRM) error");

alarm{10);

if ((n = read(STDIN_FILENO, line, MAXLINE)) < 0) err_sys("read error");

alarm{0);

write(STDOUT_FILENO， line, n);

exit(0);

static void

sig_alrm(int signo)

(

/* nothing to do, just return to interrupt the read */

}

图10-10带时间限制调用read

这种代码序列在很多UNIX应用程序中都能见到，但是这种程序有两个问题：

(1)    图10-10中的程序具有与图10-7中的程序相同的问题：在第一次alarm调用和read 调用之间有一个竞争条件。如果内核在这两个函数调用之间使进程阻塞，不能占用处理机运行， 而其时间长度又超过闹钟时间，则read可能永远阻塞，大多数这种类型的操作使用较长的闹钟 时间，例如1分钟或更长一点，使这种问题不会发生，但无论如何这是一个竞争条件。

(2)    如果系统调用是自动重启动的，则当从SIGALRM信号处理程序返回时，read并不被中 [342]断。在这种情形下，设置时间限制不起作用。

在这里我们确实需要中断慢速系统调用。我们将在10.14节对此进行详细讨论。    ■穀

、实例

让我们用longjmp再实现前面的实例。使用这种方法无需担心一个慢速的系统调用是否被 中断，见图10-11。

肴include "apue.h"

\#include <setjmp.h>

static void    sig_alrm(int)；

static jmp_buf    env_alrm;

int

main(void)

{

int    n;

char    linefMAXLINE];

if (signal(SIGALRM, sig_alrra) == SIG_ERR) err_sys("signal(SIGALRM) error");

if {setjmp(env_alrm) != 0)

err_quit("read timeout");

alarm(10);

if {(n = read(STDIN_FILENO, line, MAXLINE)) < 0) err_sys("read error")；

alarm(O);

write(5TD0UT_FILEN0, line, n); exit (0);

}

static void

sig_alrm(int signo)

{

longjmp tenv_alrm, 1);

图10-11使用longjmp，带时间限制调用read

不管系统是否重新启动被中断的系统调用，该程序都会如所预期的那样工作。但是要知道， 该程序仍旧有和图10-8中的程序相同的与其他信号处理程序交互的问题。

如果要对I/O操作设置时间限制，则如上所示可以使用longjmp,当然也要清楚它可能有与 其他信号处理程序交互的问题。另一种选择是使用select或poll函数，14.4.1节和14.4.2节 将对它们进行说明。

##### 10.11信号集

我们需要有一■个能表示多个信号-信号集(signal set)的数据类塑。我们将在sigprocmask

(下一节中说明)类函数中使用这种数据类型，以便告诉内核不允许发生该信号集中的信号。如 前所述，不同的信号的编号可能超过一个整型量所包含的位数，所以一般而言，不能用整型量中 的一位代表一种信号，也就是不能用一个整型量表示信号集。POSIX.1定义数据类型SigSet_t 以包含一个信号集，并且定义了下列5个处理信号集的函数。

\#include <signal.h>

int sigemptyset {sigset_t *sel);

int sigfillset (sigset_t *set、；

int sigaddset (sigset_t *set, int signo};

int sigdelset (sigset_t * set, int signo}:

4个函数返回值：若成功，返回0:若出错，返回-1

int sigismember (const sigset_t *set, int sign。、：

返回值：若真，返回1:若假，返回0

函数sigemptyset |刀始化由se/指向的信号集，清除其中所有信号。函数sigfillset初 始化由s权指向的信号集，使其包括所有信号。所有应用程序在使用信号集前，要对该信号集调 用sigemptyset或sigfillset 一次。送是因为C编译程序将不轼初值的外部变量和静态变 量都初始化为0,而这是否与给定系统上信号集的实现相对应却并不清楚。

一旦已经初始化了一个信号集，以后就可在该信号集中增、删特定的信号。函数sigaddset

将一个信号添加到己有的信号集中，sigdelset则从信号集中删除一个信号。对所有以信号集 作为参数的函数，总是以信号集地址作为向其传送的参数。

■实现

如果实现的信号数目少于一个整型量所包含的位数，则可用一位代表一个信号的方法实现信号集。 例如，本书的后续部分都假定一种实现有31种信号和32位整型。sigemptyset函数将整型设置为0, sigfillset函数则将整型中的各位都设置为1。这两个函数可以在<Signal.h>头文件中实现为宏：

番define sigemptyset(ptr) ([1](#bookmark9) [2](#bookmark10)(ptr) = 0)

\#define sigfillset(ptr) ([2](#bookmark10)(ptr) = ' (sigset_t)0, 0)

注意，除了设置信号集中各位为1外，sigfillset必须返回0,所以使用C语言的逗号算符，

[344]它将逗号算符后的值作为表达式的值返回，

使用送种实现，sigaddset开启一位(将该位设置为1)，sigdelset则类闭一位(将该

位设置为0): sigismember测试一个指定的位。因为没有信号编号为0,所以从信号编号中减 1以得到要处理位的位编号数。图10-12给出了这些函数的实现。

return(-1);

}

return((*set & (1 « (signo - 1))) != 0);

}

图 10-12 sigaddset、sigdelset 和 sigismember 的实现 也可将这3个函数在＜3191131.11＞中实现为各一行的宏，但是POSIX.1要求检査信号编号参

数的有效性，如果无效则设置errno。在宏中实现这一点比函数要难。

##### 10.12 函数 sigprocmask

10.8节曾提及一个进程的信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集。调用函 数sigprocmask可以检测或更改，或同时进行检测和更改进程的信号屏蔽字。

\#include <signal.h>

int sigprocmask (int how, const sigset_t * restrict set, sigset_t * restrict oset) !

返回值：若成功，返回(h若出错，返回-1

首先，若是非空指针，那么进程的当前信号屏蔽字通过(W故返回，

其次，若5过是一个非空指针，则参数few指示如何修改当前信号屏蔽字。图10-13说明了

Aow可选的值。SIG_BLOCK是或操作，而SIG_SETMASK则是赋值操作。注意，不能阻塞SIGKILL 和SIGSTOP信号。

| how         | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| SIG_BLOCK   | 该进程新的信号屏蔽字是其当前信号屏蔽字和Jef指向信号集的并集。包含了希 望阻塞的附加信号 |
| SIG_UNBLOCK | 该进程新的信号屏蔽字是其当前信号屏蔽字和所指向信号集补集的交集。set包 含了希望解除阻塞的信号 |
| SIG SETMASK | 该进程新的信号屏蔽是指向的值                                 |

图10-13用sigprocmask更改当前信号屏蔽字的方法

如果ser是个空指针，则不改变该进程的信号屏蔽字，Aow的值也无意义。

在调用sigprocmask后如果有任何未决的、不再阻塞的信号，则在sigprocmask返回前，

至少将其中之一递送给该进程。

sigprocmask是仅为单线程进程定义的。处理多线程进程中信号的屏蔽使用另一个函数。

:我们将在12.8节中对此进行讨论。

■实例

图1CH4程序是一个函数，它打印调用进程信号屏蔽字中的信号名＜■图10＞20中的程序和图10-22 中的程序将调用此函数。    [346]

sigset_t sigset; int    errno_save;

errno_save = errno?    /* we can be called by signal handlers */

if (sigprocmask(0, NULL, ssigset) < 0) {

err_ret{"sigprocmask error");

} else {

printf("%s", str); if (sigismember(Ssigset,

printf(" SIGINT"); if (sigismember(Ssigset,

printf(" SIGQUIT"); if (sigismember(&sigset,

printf(" SIGUSR1"); if (sigismember(Ssigset,

printf (" SIGALRM*');

SIGINT))

SIGQUIT)}

SIGOSR1)}

SIGALRM))



remaining signals can go here */

errno = errno_save;

)



/* restore errno */



图10-14为进程打印信号屏蔽字

为了节省空间，没有对图10-1中列出的每一种信号测试该屏蔽字（见习题10.9）。

##### 10.13 函数 sigpending

sigpending函数返回一信号集，对于调用进程而言，其中的各信号是阻塞不能递送的，因 而也一定是当前未决的。该信号集通过set参数返回。

♦include <signal.h>

int sigpending(sigset_t *set)；

返回值：若成功，返回0;若出错，返回-1

、实例

图10-15展示了很多前面说明过的信号功能。

err_sys("can't catch SIGQUIT");

\* Block SIGQUIT and save current signal mask.

*/

sigemptyset(finewmask);

sigaddset(&newraask, SIGQUIT);

if (sigprocmask(SXG_BLOCK, &newmask, &oldmask) < 0) err_sys("SIG_BLOCK error");

sleep(5);    /* SIGQUIT here will remain pending */

if (sigpending(Spendmask) < 0> err_sys("sigpending error");

if (sigismember(spendmask, SIGQUIT)) printf (•’\nSIGQUIT pending\n");

\* Restore signal mask which unblocks SIGQUIT.

*/

if (sigprocmask(SIG_SETMASK, soldmask, NULL) < 0) err_sys{"SIG_SETMASK error");

printf("SIGQUIT unblocked\n");

sleep(5);    /* SIGQUIT here will terminate with core file */

exit(0);

static void

sig_quit{int signo)

{

printf("caught SIGQUIT\n");

if (signal(SIGQUIT, SIG_DFL> == SIG_ERR)

err_sys (’’can’t reset SIGQUIT");

图10-15信号设置和sigprocmask实例    13481

进程阻塞SIGQUIT信号，保存了当前信号屏蔽字(以便以后恢复)，然后休眠5秒。在此期

间所产生的退出信号SIGQUIT都被阻塞，不递送至该进程，直到该信号不再被阻塞。在5秒休 眠结束后，检查该信号是否是未袂的，然后将SIGQUIT设置为不再阻塞。

注意，在设置SIGQUIT为阻塞时，我们保存了老的屏蔽字。为了解際対该信号的阻塞，用 老的屏蔽字重新设置了进程信号屏蔽字(SIG_SETMASK)o另一种方法是用SIGJJNBLOCK使阻 塞的信号不再阻塞。但是，应当了解如果编写一个可能由其他人使用的函数，而且需要在函数中 阻塞一个信号，则不能用SIG_UNBLOCK简单地解除对此信号的阻塞，这是因为此函数的调用者 在调用本函数之前可能也阻塞了此信号。在这种情况下必须使用SIG_SETMASK将信号屏蔽字恢 复为先前的值，这样也就能继续阻塞该信号。10.18节的system函数部分有这样的一个例子。

在休眠期间如果产生了退出信号，那么此时该信号是未决的，但是不再受阻塞|所以在 sigprocmask返回之前，它被递送到调用进程。从程序的输出中可以看到这一点：SIGQUIT处 理程序(sig^quit)中的printf语句先执行，然后再执行sigprocmask之后的printf语句。

然后该进程再休眠5秒。如果在此期间再产生退出信号，那么因为在上次捕捉到该信号时，

已将其处理方式设置为默认动作，所以这一次它就会使该进程终止，在下列输出中，当我们在终 端键入退出字符Ctrl+\时，终端打印^\ (终端退出字符)：

? ./a.out

A\

SIGQUIT pending caught SIGQUIT SIGQUIT unblocked A\Quit(coredump)

$ ./a.out



产生信号一次｛在5s之内) 从sleep返回后 在信号处理程序中 从sigprocmask返回后

再次产生信号

产生信号10次(在5s之内)

SIGQUIT pending caught SIGQUIT SIGQUIT unblocked A\Quit(coredump)

只产生信号一次

再产生信号



shell发现其子进程异常终止时输出QUIT (coredump)信息。注意，第二次运行该程序时， 在进程休眠期间使SIGQUIT信号产生了 10次，但是解除了对该信号的阻塞后，只向进程传送一 次SIGQUIT。从中可以看出在此系统上没有将信号进行排队。

##### 10-14 函数 sigaction

sigaction函数的功能是检查或修改(或检查并修改)与指定信号相关联的处理动作。此函 !349j数取代了 UNIX早期版本使用的signal函数。在率节末尾用sigaction函数实现了 signal。

\#include 〈signal.h>

int sigaction (int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);

返回值：若成功，返回0:若出错.返回-1

其中，参数打gno是要检测或修改其具体动作的信号编号。若指针非空，则要修改其动作。 如果^指针非空，则系统经由oact指针返回该信号的上一个动作。此函数使用下列结构，

struct sigaction ｛

void    (*sa_handler) (int); /* addr of signal handler, */

/* or SIG_IGN, or SIG_DFL */

sigset_t sa_mask;    /* additional signals to block */

int    sa_flags;    /* signal options. Figure 10.16 */

/* alternate handler */

void (*sa_sigaction) (int, siginfo_t *, void *);

｝；

当更改信号动作时，如果sa_handler字段包含一个信号捕捉函数的地址(不是常量 SIG_IGN或SIG_DFL)，则sa_mask字段说明了一个信号集，在调用该信号捕捉函数之前，这 一信号集要加到进程的信号屏蔽字中。仅当从信号捕捉函数返回时再将进程的信号屏蔽字恢复为 原先值-这样，在调用信号处理程序时就能阻塞某些信号。在信号处理程序被调用时，操作系统 建立的新信号屏蔽字包括正被递送的信号。因此保证了在处理一个给定的信号时，如果这种信号 再次发生，那么它会被阻塞到对前一个信号的处理结束为止。回忆10.8节，若同一种信号多次发 生，通常并不将它们加入队列，所以如果在某种信号被阻塞时，它发生了 5次，那么对这神信号

解除阻塞后，其信号处理函数通常只会被调用一次（上一个例子已经说明了这种特性）。

一旦対给定的信号设置了一个动作，那么在调用sigaction显式地改变它之前，该设置就

一直有效。这种处理方式与早期的不可靠信号机制不同，符合POSIX.1在这方面的要求。

act结构的sa_flags字段指定对信号进行处理的各个选项。图10-16详细列出了这些选项

的意义。若该标志已定义在基本POSIX.1标准中，那么SUS列包含“•”：若该标志定义在基本 POSIX.1标准的XSI扩展中，那么该列包含“XSI”。

| 选项         | SUS  | FreeBSD Linux 8.0    3.2.0 | Mac OSX 10.6.8 | Solaris10 | 说钥                                                         |
| ------------ | ---- | -------------------------- | -------------- | --------- | ------------------------------------------------------------ |
| SA_INTERRUPT |      |                            |                |           | 由此信号中断的系统调用不自动重启 动（XSI对于sigaction的就认处理方 式）.详见10.5节 |
| SA_NOCLDSTOP |      |                            |                |           | 若是SIGCHLD，当子进程停止（作 业控制），不产生此信号。当子进程终止 时，仍旧产生此信号（但请参阅下面说 明的SA NOCLDWAIT选项）。若已设置 此标志，则当停止的进程继续运行时，作为XSI扩展，不产生SIGCHLD信号 |
| SA_NOCLDWAIT |      |                            |                |           | 若Wgno是SIGCHLD,则当调用进程 的子进程终止时.不创建僵死进程•若 调用进程随后调用wait，则阻塞到它所 有子进程都终止，此时返回-1, errno 设置为ECHILD （见10.7节） |
| SA_NODEFER   |      |                            |                |           | 当捕捉到此信号时，在执行其信号捕 捉函数时，系统不自动阻塞此信号（除 非sa mask包括了此信号）。注意，此 种类型的操作对应于早期的不可靠信号 |
| SA_ONSTACK   | XSI  | • •                        |                | •         | 若用sigaltstack（2）已声明了一个 替换栈，则此信号递送给替换桟上的进程 |
| SA_RESETHAND |      |                            |                |           | 在此信号捕捉函数的入口处，将此信号 的处理方式重置为SIG_DFL，井清除SA SIGINFO标志。注意.此种类型的信 号对应于早期的不可靠信号。但是，不能 自动重置SIGILL和SIGTRAP这两个信 号的紀量。设置此禄志使sigaction的 行为如同设置了 SA_NODErER标志 |
| SA_RESTART   | •    | • •                        |                |           | 由此信号中断的系统调用自动重启动 （参见10.5节）              |
| SA_SIGINFO   |      |                            |                |           | 此选项对信号处理程序提供了附加信 息：一个指向siginfo结构的指针以及 一个指向进程上下文标识符的指针 |

图10-16处理每个信号的可选标志（sa_flags）

[1](#footnote1)

\#include    <signal.h>

\#include    <errno.h>

/[2](#bookmark10)

\* <signal.h> usually defines NSIG to include signal number 0.

*/

\#define SIGBAD(signo){(signo) <= 0 || (signo) >= NSIG) int

sigaddset(sigset_t [2](#bookmark10)set, int signo)

if (SIGBAD(signo)) { errno = EINVAL; return(-l);

}

[2](#footnote2)

set [= 1 << (signo - 1);    /[2](#bookmark10) turn bit on [2](#bookmark10)/

return <0);

}

int

sigdelset(sigset_t [2](#bookmark10)set, int signo)

f

if (SIGBAD(signo))    {

errno = EINVAL; return{-1)7

1

*set &= -(1 « (signo - 1));    /[2](#bookmark10) turn bit off [2](#bookmark10)/

return(0);

int

sigismember(const sigset_t [2](#bookmark10)set, int signo) {

if (SIGBAD(signo))( errno = EINVAL;

\#include "apue.h"

\#include <errno.h>

void

pr_mask(const char *str) #include "apue.h"

static void sig_quit(int);

int

main (void)

1

sigset_t newmask, oldmask, pendmask;

if (signal(SIGQUIT, sig_quit) == SIG_ERR>



sa_sigaction字段是一个替代的信号处理程序，在sigaction结构中使用了 SA_SIGINFO 标志时，使用该信号处理程序。对于sa_sigaction字段和sa_handler字段两者，实现可能 使用同一存储区，所以应用只能一次使用这两个字段中的一个=    ®

通常，按下列方式调用信号处理程序：

void handler（int signo）;

但是，如果设置了 SA_SIGINFO标志，那么按下列方式调用信号处理程序：

void handler （int signo, siginfo_t ★info, void * context）；

siginfo结构包含了信号产生原因的有关信息。该结构的大致样式如下所示。符合POSDC1的 所有实现必须至少包括sijigno和si_COde成员。另外，符合XSI的实现至少应包含下列字段：

struct siginfo {

int    si_signo;

int    si_errno;

int    si_code;

pid_t    si_pid;

uid_t    si_uid;

void    *si_addr;

int    si_status;

union sigval si_value;



/* signal number */

/* if nonzero, errno value from <errno.h> */ /* additional info (depends on signal) */

/* sending process ID */

/* sending process real user ID */

/* address that caused the fault */

/* exit value or signal number */

/* application-specific value */

/* possibly other fields also */



sigval联合包含下列字段:

int sival_int； void *sival_ptr;

应用程序在递送信号时，在si_value. sival_int中传递一个整型数或者在si_value. sival_ptr 中传递一个指针值。

图10-17示出了对于各种信号的si_code值，这些信号是由Single UNIX Specification定义 的。注意.实现可定义附加的代码值。

若信号是SIGCHLD，则将设置si_pid、si_status和si_uid字段。若信号是SIGBUS、 SIGILL、SIGFPE或SIGSEGV，则si_addr包含造成故障的根源地址：该地址可能并不准确。 Si_errnO字段包含错误编号，它对应于造成信号产生的条件，并由实现定义。

信号处理程序的参数是无类型指针，它可被强制类型转换为ucontext_t结构类型, 该结构标识信号传递时进程的上下文。该结构至少包含下列字段：

ucontext_t

sigset_t

stack_t

mcontext_t



★uc_link;

uc_sigmask;

uc_stack;

uc_mcontext;



/* pointer to context resumed when */

/* this context returns */

/* signals blocked when this context */ /* is active */

/* stack used by this context */

/* machine-specific representation of */ /* saved context */



uc_stack字段描述了当前上下文使用的桟，至少包括下列成员:



void *ss_sp; size_t ss_size; int ss_flags;



/* stack base or pointer */ /* stack size */

/* flags */

351

/

353



当实现支持实时信号扩展时，用SA_SIGINFO标志建立的信号处理程序将造成信号可靠地排 队。一些保留信号可由实时应用使用＜,如果信号由sigqueue函数产生，郎么siginfo结构能 包含应用特有的数据（参见10.20节乂

■实例：signal函数

现在用sigaction实现signal函数。很多平台都是这样做的（POSIX.I的基础阐述部好 也说明这是POSIX所希望的）》另一方面，有些系统支持老的不可靠信号语义signal函数，

其目的是实现二进制向后兼容。除非特殊地要求老的不可靠语义（为了向后兼容），否则应当使 用下面的signal实现，或者直接调用sigaction （可以在调用sigaction时指定 SA_RESETHAND和SA_NODEFER选项以实现老语义的signal函数）＜,本书中所有调用signal 的实例均调用图10-18中实现的函数。

| 信号    | 代码                                                         | 原因                                                         |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| SIGILL  | ILLjLLOPCILL_ILLOPNXLL_ILLADRILL_ILLTRPILL_PRVOPCILL_PRVREGILL_COPROCILL BADSTK | 非法操作码 非法操作数 非法地址模式 非法陷入 特权操作码 特权寄存器 协处理器出错 内部栈出错 |
| SIGFPE  | FPE_INTDIVFPE_INTOVFFPE_FLTDIVFPE_FLTOVFFPE_FLTUNDFPE_FLTRESFPE_FLTINVFPE FLTSUB | 整数除以0 整数溢出 浮点除以0 浮点向上溢出 浮点向下溢出 浮点不精确结果 无效浮点操作 下标超出范围 |
| SIGSEGV | SEGV_MAPERRSEGV ACCERR                                       | 地址不映射至对象 对于映射对象的无效权限                      |
| SIGBUS  | BUS_ADRALNBUS_ADRERRBUS OBJERR                               | 无效地址对齐 不存在的物理地址 对象特定硬件错                 |
| SIGTRAP | TRAP_BRKPTTRAP TRACE                                         | 进程断点陷入 进程跟踪陷入                                    |
| SIGCHLD | CLD_EXITEDCLD^KILLEDCLD_DUMPEDCLD_TRAPPEDCLD_STOPPEDCLD CONTINUED | 子进程已终止子进程已异常终止（无core）子进程已异常终止（有core）被跟踪子进程已陷入 子进程已停止停止的子进程已继续 |
| Any     | SI_USERSI_QUEUESI_TIMERSI_ASYNCIOSI MESGQ                    | kill发送的信号 sigqueue发送的信号tiraer_settime设置的定时器超时（实时扩展） 异步I/O淸求完成（实时扩展）—条消息到达消息队列（实时扩展） |

图 10-17 siginfo_t 代码值

\#include "apue.h"

/* Reliable version of signal。，using POSIX sigaction (). Sigfunc *

signal(int signo, Sigfunc *func)

(

struct sigaction act, oact;

act.sa_handler = func; sigemptyset(&act.sa_mask); act.sa_flags = 0;

if (signo == SIGALRM) 1 #ifdef SA_INTERRUPT

act.sa_flags 1= SA_INTERRUPt；

ttendif

} else {

act.sa_flags I= sa_restart；

}

if {sigaction(signo, Sact, Soact) < 0} return (SIG_ERR);

return(oact.sa_handler);

J

图1048用sigaction实现的signal国数

注意，必须用sigemptyset函数初始化act结构的sa_mask成员。不能保证act.sa_mask=0 会做同样的事情。

对除SIGALRM以外的所有信号，我们都有意尝试设置SA_RESTART标志，于是被这些信号 中断的系统调用都能自动重启动。不希望重启动由SIGALRM信号中断的系统调用的原因是：我 们希望対I/O操作可以设置时间限制（请回忆有关图10-10的讨论）。

某些早期系统（如SunOS）定义了 SA_INTERRUPT标志。这些系统的默认方式是重新启动 被中断的系统调用，而指定此标志则使系统调用被中断后不再重启动。Linux定义SA_INTERRUPT 标志，以便与使用该标志的应用程序兼容。但是，如若信号处理程序是用sigaction设置的， 那么其默认方式是不重新启动系统调用。Single UNIX Specification的XSI扩展规定，除非说明了

[5^1 SA_RESTART标志，否则sigaction函数不再重启动被中断的系统调用。

曬实例：signal_intr函数

圈10-19给出的是signal函数的另一种版本，它力图阻止被中断的系统调用重启动。

\#include "apue.h"

Sigfunc *

signal_intr（int signo, Sigfunc *func）

{

struct sigaction act, oact;

act.sa_handler = func; sigemptyset(&act.sa_mask); act.sa_flags = 0;

\# i fdef SA_INTERRU PT

ct.sa_flags |= SA_INTERRUPT;

\#endif

if (sigaction(signo, &act, &oact> < 0} return(SXG_ERR);

return(oact.sa_handler);

}

图 10-19 signal_intr 函数

如果系统定义了 SA_INTERRUPT标志，那么为了提髙可移植性，我们在sa_flags中增加 该标志，这样也就阻止了被中断的系统调用的重启动。

##### 10-15 函数 sigsetj呼和 sxglongjmp

7.10节说明了用于非局部转移的setjmp和longjmp函数。在信号处理程序中经常调用 longjmp函数以返回到程序的主循环中，而不是从该处理程序返回。图10-8和图10-11中已经出 现了这种情况D

但是，调用longjmp有一个问题。当捕捉到一个信号时，进入信号捕捉函数，此时当前信号 被自动地加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断诶信号处理程序。如果用 lcmgjmp跳出信号处理程序，那么，对此进程的信号屏蔽字会发生什么呢？

在FreeBSD 8.0和Mac OS X 10.6.8中，setjmp和longjmp保存和恢复信号屏蔽字。但是，

]Linux 3.2.0和Solaris 10并不执行这种操作，虽然Linux支持提供BSD行为的选项。FreeBSD 8.0 j和Mac OS X 10.6.8提供函数_56七jmp *_longjmp,它4门也不保存和恢复信号昇获字。

为了允许两种艰式并存，POSIX.1并没有指定setjmp和longjmp对■信号屏蔽字的作用，

而是定义了两个新函数sigsetjmp和siglongjmp。在信号处理程序中进行非局部转務时应当 使用这两个函数。    [355]

\#include <setjmp.h>

int sigset jmp (sigjmp_buf env, int savemask);

返回值：若直接调用，返回0:若从siglongjmp调用返回，则返回非0

void siglongjmp (sigjmp buf e”v, int vg/>;

这两个函数和setjmp、longjmp之间的唯一区别是sigsetjmp增加了一个参数。如果 似vewosi非0，则sigset jmp在env中保存进程的当前信号屏蔽字。调用siglongjmp时，如果带 非0 savemast的sigsetjmp调用已经保存了 env，则siglongjmp从其中恢复保存的信号屏蔽字。

实例

图10-20中的程序演示了在信号处理程序被调用时，系统所设置的信号屏蔽字如何自动地包 括刚被捕捉到的信号。此程序也示例说明了如何使用sigsetjmp和siglongjmp函数。

\#include "apue.h"

\#include <setjmp.h>

\#include <time.h>

static void

sig_usrl(int); sig_alrm(int); jmpbuf ; canjump;



static void

static sigjmp_buf

static volatile sig_atomic_t int

main(void)

{

if {signal(SIGUSR1, sig_usrl) == SIG_ERR) err_sys ("signal {SXGUSR1) error")，-

if (signal(SIGALRM, sig_alrm) == SIG_ERR> err_sys("signal(SIGALRM) error");

pr^mask("starting main: ");    /* Figure 10,14 */

if (sigsetjmp(jmpbuf, 1)) {

pr_mask("ending main:");

exit (0);

can jump = 1;    /* now sigsetjmpO is OK */

for (;;) pause ();

i

13561 static void

sig_usrl(int signo)

{

time_t starttime;

if {canjump == 0)

return;    /* unexpected signal, ignore */

pr_mask("starting sig_usrl:");

alarm(3);    /* SIGALRM in 3 seconds */

starttime = time(NULL);

for ( ; ; )    /* busy wait for 5 seconds */

if {time(NULL) > starttime + 5,

break;

pr_mask ("finishing sig__usrl:");

canjump = 0;

siglongjmp(jmpbuf, 1);" jump back to main, don't return */

static void

sig_alrm(int signo)

{

pr_mask("in sig_alrm:

图 10-20 信号屏蔽、sigsetjmp 和 siglongjmp 实例 此程序演示了另一种技术，只要在信号处理程序中调用siglongjmp就应使用这种技木。

仅在调用sigsetjmp之后才将变量canjump设置为非0值。在信号处理程序中检测此变量， 仅当它为非0值时才调用siglongjmp。这提供了一种保护机制，使得在jmpbuf （跳转缓冲） 尚未由sigsetjmp初始化时，防止调用信号处理程序。（在本程序中，siglongjmp之后程序 很快就结束，但是在较大的程序中，在siglongjmp之后的较长一段时间内，信号处理程序可 能仍旧被设置乂在一般的C代码中（不是信号处理程序），对于longjmp并不需要这种保护措 施。但是，因为信号可能在任何时候发生，所以在信号处理程序中，需要这种保护措施。

在程序中使用了数据类型sig_^tOmic_t,这是由ISO C标准定义的变量类型，在写这种类 型变量时不会被中断。这意味着在具有虚拟存储器的系统上，这种变量不会跨越页边界，可以用 一条机器指令对其进行访问。这种类型的变量总是包括ISO类型修饰符volatile,其原因是：该 变量将由两个不同的控制线程~main函数和异步执行的信号处理程序访问。图10-21显示了此 程序的执行时间顺序。可将图10-21分成三部分：左面部分（对应于main）,中间部分（sig_usrl）

和右面部分（sig_alrm）o在进程执行左面部分时，信号屏蔽字是0 （没有信号是阻塞的）。而执 行中间部分时，其信号屏蔽字是SIGUSR1。执行右面部分时，信号屏蔽字是SIGUSR1 I SIGALRM。

r^n    固



signal(} signal() pr_mask()

slgset } pause()

SIGUSR1 递送



sig_usrl



pr mask() alarm (j time{) time() t.iine()



SIGALBH 递送



从信号处理程序中返回



8ig alrra I

pr_mask() return{)



sigsetjmp() PrekitS(k)(}



pr mask() Bxglbngjmp()



图10-21处理两个信号的实例程序的时间顺序 执行图10-20程序，得到下面的输出：



$ ./a.out 6

starting main:

[1]    531

$ kill -USR1 531

starting sig_usrl: SIGUSR1 $ in sig_alrm: SIGOSR1 SIGALRM finishing sig_usrl: SIGUSR1 ending main:



在后台启动进程

作业控制shell打印其进程tD 向该进程发送SIGUSR1



键入回车



[1] + Done



./a.out &



该输出与我们所期望的相同：当调用一个信号处理程序时，被捕捉到的信号加到进程的当前信号 屏蔽字中。当从信号处理程序返回时，恢复原来的屏蔽字。另外，siglongjmp恢复了由 sigset jmp所保存的信号屏蔽字。

如果在Linux中将图10-20程序中的sigsetjmp和siglongjmp好别替换成setjmp和 long jmp （在FreeBSD中，则替换成_361: jmp和_10叫：）11^），则最后一行输出变成：

ending main: SIGUSR1

这意味着在调用setjmp之后执行main函数时，其SIGUSR1是阻塞的。这多半不是我们所 希望的。    ■"* S58]

##### 10.16 函数 sigsuspend

上面已经说明，更改进程的信号屏蔽字可以阻塞所选择的信号，或解除对它们的阻塞。使用这种 技术可以保护不希望由信号中断的代码临界区。如果希望对一个信号解除阻塞，然后pause以等待 以前被阻塞的信号发生，则又将如何呢？假定信号是SIGINT,实现这一点的一种不正确的方法是：

sigset_t newmask, oldmask; sigemptyset (finewmask) sigaddset{&newmask, SIGINT)；

/* block SIGINT and save current signal mask */ if (sigprocmask(SIG_BLOCK, Snewmask, Soldmask) < 0)

err_sys("SXG_BLOCK error");

/* critical region of code */

/* restore signal mask, which unblocks SIGINT */ if (sigprocmask(SIG—SETMASK, Soldmask, NULL) < 0)

err^sys("SIG_SETMASK error");

/* window is open */

pause();    /* wait for signal to occur */

/* continue processing */

如果在信号阻塞时，产生了信号，那么该信号的传递就被推迟直到对它解除了阻塞。对应用 程序而言，该信号好像发生在解除对SIGINT的阻塞和pause之间(取决于内核如何实现信号)、 如果发生了这种情况，或者如果在解除阻塞时刻和pause之间确实发生了信号，那么就会产生 问题。因为可能不会再见到该信号，所以从这种意义上讲，在此时间窗口中发生的信号丢失了， 这样就使得pause永远阻塞。这是早期的不可靠信号机制的另一个问题。

为了纠正此问题，需要在一个原子操作中先恢复信号屏蔽字，然后使进程休眠。这种功能是 由sigsuspend函数所提供的-

♦include <signal.h>

int sigsuspend (const sigset_t *sigmask);

返回值：-1.并将errno设置为EINTR

进程的信号屏蔽字设置为由5初《0^指向的值。在捕捉到一个信号或发生了一个会终止该进 程的信号之前，该进程被挂起。如果捕捉到一个信号而且从该信号处理程序返回，则sigsuspend 返回，并且该进程的信号屏蔽字设置为调用sigsuspend之前的值。

注意，此函数没有成功返回值。如果它返回到调用者，则总是返回-1,并将errno设置为 [359] eintr (表示一个被中断的系统调用)。

■实例

图10-22显示了保护代码临界区，使其不被特定信号中断的正确方法。 番include "apue.h"

static void sig_int(int);

int

main{void)

sigset_t newmask, oldmask, waitmask;

pr_mask("program start:");

if (signal(SIGINT, sig_int) == SIG_ERR) err_sys("signal(SIGINT) error");

sigemptyset(&waitmask); sigaddset(Swaitmask, SIGUSRl); sigemptyset(&newmask); sigaddset(finewmask, SIGINTJ;

/*

\*    Block SIGINT and save current signal mask.

*/

if {sigprocmask(SIG_BLOCK, &newma3k, &oldmask) < 0) err_sys (，，SIG_BLOCK error");

Z*

\*    Critical region of code.

*/

pr_mask("in critical region:");

/*

\*    Pause, allowing all signals except SIGUSRl.

*/

if (sigsuspend(Swaitmask) != -1) err_sys("sigsuspend error");

pr_mask("after return from sigsuspend:");

/*

\*    Reset signal mask which unblocks SIGINT.

*/

if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0) err_sys{"SIG_SETMASK error")?

\*    And continue processing ...

*/

pr__mask ("program exit:");

exit(0);

1

static void

sig_int(int signo)

{

pr_mask("\nin sig_int:

J_

图10-22保护临界区不被信号中断    胃］

注意，当sigsuspend返回时，忘将信号屏蔽字设置为调用它之前的值。在本例中，SIGINT

信号将被阻塞=因此将信号屏蔽恢复为之前保存的值(oldnask)。

运行图10-22中的程序得到下面的输出，

$ ./a.out

program start:

in critical region: SIGINT

AC    键入中断字符

in sig.int: SIGINT SIGUSR1

after return from sigsuspend: SIGINT

program exit:

在调用sigsuspend时，将SIGUSRI信号加到了进程信号屏蔽字中，所以当运行该信号处理程 序时，我们得知信号屏蔽字已经改变了。从中可见，在sigsxispend返回时，它将信号屏蔽字 恢复为调用它之前的值。

■实例

sigsuspend的另一种应用是等待一个信号处理程序设置一个全局变量。图10-23中的程序 用于捕捉中断信号和退出信号，但是希望仅当捕捉到退出信号时，才唤醒主例程。 tinclude "apue.h"

volatile sig_atomic_t quitflag;    /* set nonzero by signal handler */

static void

sig_inC(int signo) /* one signal handler for SIGINT and SIGQUIT */

{

if {signo == SIGINT)

printf("\ninterrupt\nn);

else if (signo == SIGQUIT)

quitflag = 1; /* set flag for main loop */

int

main(void)

{

sigset_t newmask, oldmask, zeromask;

if (signal(SIGINT, sig_int) == SIG—ERR) err_sys("signal(SIGINT) error”)；

if (signal(SIGQUIT, sig_int) == SIG_ERR) err_sys("signal(SIGQUIT) error");

sigemptyset(Szeromask); sigemptyset (SnewmasJc); sigaddset(Snewmask, SIGQUIT};

/*

\* Block SIGQUIT and save current signal mask.

*/

if (sigprocmask(SIG_BLOCK, snewmask, &oldmask) < 0) err_sys{"SIG_BLOCK error");

while (quitflag == 0)

sigsuspend《&zeromask);

\*    SIGQUIT has been caught and is now blocked; do whatever */

quitflag = 0;

/*

\*    Reset signal mask which unblocks SIGQUIT.

*/

if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0) err_sys("SIG_SETMASK error");

exit(0);

图10-23用sigsuspend等待一个全局变量被设置

此程序的样本输出是：

$ ./a.out

*C    键入中断字符

interrupt

*c    再次键入中断字符

interrupt

*C    再一次

interrupt

*\ $    用退出符终止

■葑

考虑到支持ISO C的非POSIX系统与POSIX系统两者之间的可移植性，在一个信号处理程 序中唯一应当做的是为sig_atomic_t类型的变量蛾一个值。POSK.1规定得更多一些，它详细

:说明了在一个信号处理程序中可以安全地调用的函数列表(见图1(M),但是如果这样来编写代码，

则它们可能不会正确地在非POSEX系统上运行。

、实例

可以用信号实现父、子进程之间的同步，这是信号应用的另一个实例。图10-24给出了 8.9 节中提到的5个例程的实现，它们是TELLWA工T、TELL_PARENT、TELL„CHILD> WAXT_PARENT 和 WAIT_CHILD=,    13621

\#include "apue-h"

static volatile sig_atomic_t sigflag; /* set nonzero by sig handler */ static sigset_t newmask, oldmask, zeroroask;

static void

sig_usr(int signo) /* one signal handler for SIGUSRl and SIGUSR2 */

t

sigflag = 1;

void

TELL_WAIT(void)

{

if (signal(SIGUSRl, sig_usr) == SIG_ERR) err_sys("signal(SIGUSRl) error");

if {signal(SIGUSR2, sig_usr) == SIG_ERR) err_sys{"signal(SIGUSR2) error");

sigemptyset(fizeromask); sigemptyset(&newmask); sigaddset(&newmask, SIGUSRl)； sigaddset(Snewmask, SIGUSR2);

/* Block SIGUSRl and SIGDSR2, and save current signal mask */ if (sigprocmask(SIG_BLOCK# &newmask, &oldmask) < 0)

err_sys("SIG_BLOCK error");

}

void

TELL_PARENT(pid_t pid)

kill(pid, SIGUSR2);    /* tell parent we're done */

}

void

WAIT_PARENT(void)

while (sigflag == 0)

sigsuspend(&zeromask); /* and wait for parent */ sigflag = 0;

/* Reset signal mask to original value */ if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)

err_sys<MSIG_SETMASK error");

void

TELL_CHILD(pid_t pid)

kill(pid, SIGUSRl);    /* tell child we're done */

void

| 363 | WAIT_CHILD(void)

{

while (sigflag == 0)

sigsuspend(fizeromask) ; /* and wait for child */ sigflag = 0；

/* Reset signal mask to original value */ if (sigprocmask(SIG_SETMASK, Soldmask, NOLL) < 0)

err_sys("SIG_SETMASK error");

图10-24父子进程可用来实现同歩的例程

其中使用了两个用户定义的信号：SIGUSRl由父进程发送给子进程，SIGUSR2由子进程发 送给父进程。图15-7显示了使用管道的这5个函数的另一种实现。

如果在等待信号发生时希望去休眠，则使用sigsuspend函数是非常适当的（正如在前面 两个例子中所示），但是如果在等待信号期间希望调用其他系统函数，那么将会怎样呢？遗憾的

是，在单线程环境下对此问题没有妥善的解决方法。如果可以使用多线程，则可专门安排一个线 程处理信号(见12.8节中的讨论)。

如果不使用线程，那么我们能尽力做到最好的是，当信号发生时，在信号捕捉程序中对一个 全局变量置1。例如，若我们捕捉SIGINT和SIGALRM这两种信号，并用signal_intr函数 设置这两个信号的处理程序，使得它们中断任一被阻塞的慢速系统调用。当进程阻塞在调用read 函数等待慢速设备输入时，很可能发生这两种信号(如果设置闹钟以阻止永远等待输入，那么対 于SIGALRM信号，这种情况尤其会发生)。处理这种问题的代码类似于下面所示：

if (intr_flag)    /* flag set by our SIGINT handler */

handle_intr();

if (alrm_flag)    /* flag set by our SIGALRM handler */

handle_alrm();

/* signals occurring in here are lost */ while (read( ... ) < 0) {

if (errno == EINTR) { if (alrm_flag)

handle_alrm(); else if (intr_flag)

handle_intr();

} else {

/* some other error */

}

} else if (n == 0J {

/* end of file */

} else {

/* process input */

1    1364|

在调用read之前测试各全局标志，如果read返回一■个中断的系统调用错误，则再次进行 测试。如果在前两个if语句和后随的read调用之间捕捉到两个信号中的任意一个，则问题就 发生了。正如代码中的注释所指出的，在此处发生的信号丢失了。调用信号处理程序，它们设置 了相应的全局变量，但是read决不会返回(除非某些数据已准备好可读)。

我们希望实现下列操作步骤。

(1)    阻塞 SIGINT 和 SIGALRM。

(2)    测试两个全局变量以判别是否发生了一个信号，如果已发生则对此进行处理。

(3)    调用read (或任何其他系统函数)并解除对这两个信号的阻塞，这两个操作应当是一 个原子操作。

仅当第(3〉步是pause操作时，sigsuspend函数才能帮助我们。

##### 10-17 函数 abort

前面己提及abort函数的功能是使程序异常终止。

| #include <stdlib.h> |                |
| ------------------- | -------------- |
| void abort(void);   | 此函数不返回值 |

此函数将SIGABRT信号发送给调用进程(进程不应忽略此信号)。ISOC规定，调用abort

将向主机环境递送一个未成功终止的通知，其方法是调用raise （SIGABRT）函数。

ISO C要求若捕捉到此信号而且相应信号处理程序返回，abort仍不会返回到其调用者。如

果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、_Exit、longjmp 或 siglongjmp （10.15 节讨论了 longjmp 和 siglongjmp 之间的区别）。POSK.1 也说明 abort 并不理会进程对此信号的阻塞和忽略。

让进程捕捉SIGABRT的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不 在信号处理程序中终止自己，POSK.1声明当信号处理程序返回时，abort终止该进程。

ISO C针对此函数的规范将下列问题留由实现决定：是否要冲洗输出流以及是否要删除临时 文件（见5.13节）。POSIX.1的要求则更进一步，它要求如果abort调用终止进程，则它对所 有打开标准I/O流的效果应当与进程终止前对每个流调用fclose相同。

System V的早期版本中，abort函数产生SIGIOT信号。更进一步，进程忽略此信号或者捕 ®    捉它并从信号处理程序返回，这都是可能的，在返回情况下，abort返回到它的调用者。

4.3BSD产生SIGILL信号。在此之前，该函数解除对此信号的阻塞，将其配置恢复为SIG_DFL （终止并创建core文件）。这阻止一个进程忽略或捕捉此信号。

历史上，abort的各种实现在如何处理标准I/O流方面是并不相同的。对于保护性的程序设 :计以及为提高可移植性，如果希望冲洗标准I/O流，则在调用abort之前要执行这种操作。在 :err_dump函数中实现了这一点（见附彔B）。

因为大多数UNIX系统tmpfile （临时文件）的实现在创建该文件之后立即调用unlink, 所以ISO C关于临时丈件的警告通常与我们无关。

图10-25中的abort函数是按POSIX.1说明实现的。

♦include <signal.h> #include <stdio.h>

\#include <stdlib.h> ♦include <unistd.h>

void

/* POSIX-style abort() function */



mask;

action;



abort(void)

i

sigset_t

struct sigaction

/* Caller can't ignore SIGABRT, if so reset to default */ sigaction(SIGABRT, NULL, Saction);

(action.sa_handler == SIG_IGN) { action.sa_handler = SIG_DFL; sigaction(SIGABRT, faction, NULL);



if



}

if



(action.sa_handler == SIG_DFL)

fflush(NULL);    /* flush all open stdio streams */

/* Caller can't block SIGABRT; make sure it’s unblocked */ sigfillset(&mask);

sigdelset(&mask, SIGABRT" /* mask has only SIGABRT turned off */

sigprocmask(SIG_SETMASK, &mask, NULL);

kill(getpidf), SIGABRT);    /* send the signal */

/* If we're here, process caught SIGABRT and returned */ fflush(NULL);    /* flush all open stdio streams */

action.sa_handler = SIG_DFL;

sigaction(SIGABRT, Saction, NULL};    /* reset to default */

sigprocmask(SIG_SETMASK, Smask, NULL);    /* just in case ... */

kill (getpid() , SIGABRT)，-    /* and one more time */

exit(1); /* this should never be executed ... */

J_

图 10-25 abort 的 POSIX.l 实现    1刪

首先査看是否将执行默认动作，若是则冲洗所有标准I/O流。这并不等价于对所有打开的流

调用fclose (因为只冲洗，并不关闭它们)，但是当进程终止时，系统会关闭所有打开的文件。

如果进程捕捉此信号并返回，那么因为进程可能产生了更多的输出，所以再一次冲洗所有的流。

不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调在这种情况下，

任何未冲洗的内存中的标准I/O缓存都被丢弃。我们假定捕捉此信号，而且_exit的调 用者并不想要冲洗缓冲区。

回忆10.9节，如果调用kill使其为调用者产生信号，并且如果该信号是不被阻塞的(图10-25 中的程序保证做到这一点)，则在kill返回前读信号(或某个未决、未阻塞的信号)就被传送给 了该进程。哉们阻塞除SIGABRT外的所有信号，这样就可知如果对kill的调用返回了，则该 进程一定已捕捉到该信号，并且也从该信号处理程序返回。

##### 10-18 函数 system

8.13节已经有了一个system函数的实现，但是该版本并不执行任何信号处理。POSIX.l要 求system忽略S1GINT和SIGQUIT，阻塞SIGCHLD。在给出一个正确地处理这些信号的一个 版本之前，先说明为什么要考虑信号处理。

、实例

图10-26中的程序使用8.13节中的system版本，用其调用ed(l)编辑器。(ed编辑器很久 以来就是UNIX的组成部分。在这里使用它的原因是：它是捕捉中断和退出信号的交互式程序。 若从shell调用ed，并键入中断字符，则它捕捉中断信号并打印问号。ed程序对退出信号的处理 方式设置为忽略。)

图10-26中的程序用于捕捉SIGINT和SIGCHLD信号。若调用它则可得：

5 ./a.out

a    将正文追加至编辑器缓冲区

Here is one line of text

.    行首的点停止追加方式

l,$p    打印缓冲K中的第一行至最后一行，以便观察其内容

Here is one line of text w temp.foo    将缓冲E写至一文件

25    编辑器称写了 25个字节

q    离开编辑器

caught SIGCHLD

当编辑器终止时，系统向父进程（a.out进程）发送SIGCHLD信号。父进程捕捉它，执行其处 理程序sig_chid，然后从信号处理程序返回。但是若父进程正捕捉SIGCHLD信号（因为它创

[367]建了子进程，所以应当这样做以便了解它的子进程在何时终止），那么正在执行system函数时， 应当阻塞对父进程递送SIGCHLD信号。实际上，选就是POSIX.1所说明的。否则，当system创 建的子进程结束时，system的调用者可能错误地认为，它自己的一个子进程结束了。于是，调 用者将会调用一种wait函数以获得子进程的终止状态，这样就阻止了 system函数获得子进程 的终止状态，并将其作为它的返回值。

\#include "apue.h" static void

sig_int(int signo)

(

printf("caught SIGINT\n");

static void

sig_chld(int signo)

printf("caught SIGCHLD\n");

} int

main(void)

{

if (signal{SIGINT, sig_int) == SIG_ERR) err_sys("signal(SIGINT) error");

if (signal(SIGCHLD, sig_chld) == SIG_ERR) err_sys("signal(SIGCHLD) error");

if (system("/bin/ed") < 0)

err_sys ["systemO error");

exit{0);

图10-26用syetem调用ed编辑器

如果再次执行该程序，在这次运行时将一个中断信号传送给编辑器，则可得:

$ ./a.out

a

hello, world

1,$P

hello, world

w temp.foo

13

AC

•9

caught SIGINT

q

caught SIGCHLD



将正文追加至编辑器缓冲区

行首的点停止追加方式

打印缓冲区中的第一行至最后一行，以便观察其内容

将缓冲区写至一文件

编辑器称写了 13个字节

键入中断符

编辑器捕捉信号，打印问号

父进程执行同一操作

离开编辑器

回忆9.6节可知，键入中断字符可使中断信号传送给前台进程组中的所有进程。图10-27展示了编

辑器正在运行时的各个进程的关系。

图10-27图10-26程序运行时的前台和后台进程组 在这一实例中，SIGINT被送给3个前台进程（shell进程忽略此信号）。从输出中可见，a.out

进程和ed进程捕捉该信号。但是，当用system运行另一个程序时，不应使父、子进程两者都 捕捉终端产生的两个信号：中断和退出。这两个信号只应发送给正在运行的程序：子进程。因为 由system执行的命令可能是交互式命令（如本例中的ed），以及因为system的调用者在程序 执行时放弃了控制，等待该执行程序的结束，所以system的调用者就不应接收这两个终端产生 的信号。这就是为什么POSIX.1规定system的调用者在等待命令完成时应当忽略这两个信号 的原因。

图10-28中的程序是system函数的另一个实现，它进行了所要求的信号处理。

^include

ttinclude

^include

\#include



<sys/wait.h> <errno.h> <signal.h> <unistd.h>

int

system(const char *cmdstring)    /* with appropriate signal handling */

{

pid_t    pid;

int    status;

struct    sigact土on    ignore,    saveintr,    savequit；

sigset_t    chldmask,    savemask;

if (cmdstring == NULL)

return ⑴；    /* always a command processor with UNIX */

ignore.sa_handler = SIG_IGN; /* ignore SIGINT and SIGQUIT */

sigemptyset(Signore.sa_mask);

[369]



ignore.sa_flags = 0;

if (sigaction(SIGINT, Signore, &saveintr) < 0) return(-1);

if (sigaction(SIGQUIT, signore, Ssavequit) < 0) return(-1);

sigemptyset(schldmask);    /* now block SIGCHLD */

sigaddset(schldmask, SIGCHLD);

if (sigprocraask(SIG_BLOCK, &chldmask, Ssavemask) < 0) return (-1) '•

if ((pid = fork()) < 0)(

status = -1;    /* probably out of processes */

} else if (pid == 0) {    /* child */

/* restore previous signal actions & reset signal mask */ sigaction(SIGINT, Ssaveintr, NULL);

sigaction(SIGQUIT, ssavequit, NULL); sigprocmask(SIG„SETMASK, Ssavemask, NULL);

execl("/bin/sh", "sh", "-c", cmdstring, (char *)0);

_exit(127)；    /* exec error */

} else {    /* parent */

while (waitpid(pid, &status, 0) < 0)

if {errno != EINTR} {

status = -1; /* error other than EINTR from waitpid() */ break;

1

}

/* restore previous signal actions & reset signal mask */ if (sigaction(SIGINT, &saveintr, NULL) < 0)

return(-1);

if (sigaction(SIGQUIT, Ssavequit, NULL) < 0) return(-1);

if (sigprocmask(SIG_SETMASK, Ssavemask, NULL) < 0) return(-1J;

return(status);

图10-28 system函数的POSIX.1正确实现

如果将图10-26中的程序与system函数的这一实现相链接，那么所产生的二进制代码与上 一个有缺陷的程序相比较，存在如下差别。

(1)    当我们键入中断字符或退出字符时，不向调用进程发送信号。

(2)    当ed命令终止时，不向调用进程发送SIGCHLD信号。作为替代，在程序末尾的 sigprocmask调用对SIGCHLD信号解除阻塞之前，SIGCHLD信号一直被阻塞。而对

® sigprocmask函数的这一次调用是在system函数调用waitpid获取子进程的终止状态之后。

! POS1X.1说明，在SIGCHLD未决期间，如若wait或waitpid返回了子进程的状悉，那么 ；SIGCHLD信号不应递送给该父进程，除非另一个子进程的状态也可用。FreeBSD 8.0、Mac OS X

10.6.8和Solaris 10都实现了这种语义，而Linux 3.2.0没有实现这种语义，在system函数调用了 waitpid后，SIGCHLD保持为未决；当解除了对此信号的阻塞后，它被递送至调用者。如果我

1们在图10-26的sig_chld函数中调用wait, Linux系统将返回-1,并将errno设置为ECHILD, 因为system曲数已取到子进程的终止状态。

很多较早的书中使用下列程序段，它忽略中断和退出信号：

if { {pid = fork()) < 0) {

err_sys("fork error");

}else if (pid == 0) {

/* child */ execl(...)；

_exit(127);

/* parent */

old_intr = signal(SIGINT, SIG_IGN); old_quit = signal(SIGQUIT, SIG_IGN);

waitpid(pid, fistatus, 0) signal(SIGINT, old_intr); signal (SIGQUIT, old_quit)，-

这段代码的问题是：在fork之后不能保证父进程述是子进程先运行。如果子进程先运行， 父进程在一段时间后再运行，那么在父进程将中断信号的处理更改为忽略之前，就可能产生这种 信号。由于这种原因，图10-28中在fork之前就改变对该信号的配置。

注意，子进程在调用execl之前要先恢复这两个信号的处理。如同8.10节中所说明的一样， 这就允许在调用者配置的基础上，execl可将它们的配置更改为默认值。 system的返回值

注意system的返回值，它是shell的终止状态，但shell的终止状态并不总是执行命令字符串进 程的终止状态。图8-23中有一堅例子，其结果正是我们所期望的。如果执行一条如date那样的简 单命令，其终止状态是0。执行shell命令exit 44,则得终止状态44。在信号方面又如何呢？

运行图8-24程序，并向正在执行的命令发送一些信号：

$ tsys "sloep 30"

ACnormal termination, exit status = 130    键入中断符

$ tsys "sleep 30"

A\sh: 946 Quit    键入退出符

normal termination, exit status = 131    间

当用中断信号终止sleep时，pr_exit函数(见图8-5)认为它正常终止.当用退出符杀死sleep 进程时，会发生同样的事情。终止状态130、131又是怎样得到的呢？原来Bourne shell有一个在 其文档中没有说清楚的特性，其终止状态是128加上一个信号编号，该信号终止了正在执行的命 令。用交互方式使用shell可以看到这一点，

$ sh    确保运行 Bourne shell

S sh -c "sleep 30"

*C    键入中断符

$ echo    $?    打印最后一条命令的终止状态

130

S sh -c "sleep 30"

A\sh: 962 Quit - core dumped    费入退出符

$ echo 9?    打印最后一条命令的终止状态

131

$ exit    离开 Bourne sheil

在所使用的系统中，SIGINT的值为2，SIGQUIT的值为3，于是给出shell终止状态130、131。

再试一个类似的例子，这一次将一个信号直接送给shell,然后观察system返回什么：

| 5 tsys "sleep 30" fi | 这一次在后台启动它 |        |               |       |                     |
| -------------------- | ------------------ | ------ | ------------- | ----- | ------------------- |
| 9257                 |                    |        |               |       |                     |
| S                    | pa -f              |        |               |       | 査看进程ID          |
|                      | □ ID               | PID    | PPID          | TTY   | TIME CMD            |
|                      | sar                | 9260   | 949           | pts/5 | 0:00 ps -f          |
|                      | sar                | 9258   | 9257          | pts/5 | 0:00 sh -c sleep 30 |
|                      | sar                | 949    | 947           | pts/5 | 0:01 /bin/sh        |
|                      | sar                | 9257   | 949           | pts/5 | 0:00 tsys sleep 30  |
|                      | sar                | 9259   | 9258          | pts/5 | 0:00 sleep 30       |
| $                    | kill -KILL 9258    |        | 杀死shell自身 |       |                     |
| abnormal             | termination,       | signal | number = 9    |       |                     |

从中可见，仅当shell本身异常终止时，system的返回值才报告一个异常终止。

其他的Shell在处理终端产生的信号（如SIGINT和SIGQUIT）时表现出来的行为各不相同。

'例如在bash和dash中，键入中断或退出符会导致带有对应信号編号的表示异常终止的退出状态。 ；但是，如果发现正在执行sleep的进程并直接给它发送信号，这样信号只会到达单个进程而不是 ,整个前台进程组。这些shell与Bourne shell类似，以正常终止状态128加上信号编号退出。

在编写使用system函数的程序时，一定要正确地解释返回值。如果直接调用fork、exec 13721和wait，则终止状态与调用system是不同的。


##### 10.19 函数 sleep、nanosleep 和 clock__nanosleep

在本书的很多例子中都已使用了 sheep函数，在图10-7程序和图10-8程序中有两个sleep的 实现，但它们都是有缺陷的。

Sinclude <unistd.h>

unsigned int sleep （unsigned int seconds）;

返回值：0或未休眠完的秒数

此函数使调用进程被挂起直到满足下面两个条件之一。

（1）    已经过了也所指定的墙上时钟时间。

（2）    调用进程捕捉到一个信号并从信号处理程序返回。

如同alarm信号一样，由于其他系统活动，实际返回时间比所要求的会迟一些。

在第1种情形，返回值是0。当由于捕捉到某个信号sleep提早返回时（第2种情形），返

冋值是未休眠完的秒数（所要求的时间减去实际休眠时间）。

尽管sleep可以用alarm函数（见10.10节）实现，但这并不是必需的。如果使用alarm,

则这两个函数之间可能相互影响。POSIX.1标准对这些相互影响并未做任何说明。例如，若先调用 alarmClO）,过了 3秒后又调用sleep（5），那么将如何呢？ sleep将在5秒后返回（假定在这段时间 内没有捕捉到另一个信号），但是否在2秒后又产生另一个SIGALRM信号呢？此细节与具体实现有关。

FreeBSD 8.0、Linux 3.2.0、Mac OS X 10.6.8 和 Solaris 10 用 nanosleep 函数实现 sleep,

:使sleep具体实现与信号和闹钟定时器相互独立。考虑到可移植性，不应对sleep的实現进行任何 '假定，但是如果屁合调用sleep和其他与时间有关的函数，则需了解它们之间可能产生的交互。

、实例

图］0-29给出的是一个POSIX.1 sleep函数的实现。此函数是图10-7程序的修改版，它可 靠地处理信号，避免了早期实现中的竞争条件，但是仍未处理与以前设置的闹钟的交互作用（正 如前面提到的，POSIX.1并未显式地对这些交互进行定义）。

^include "apue.h"

static void sig_alrm(int signo)

/* nothing to do, just returning wakes up sigsuspend() */

}

unsigned int

sleep(unsigned int seconds)

{

struct sigaction newact, oldact;

sigset_t    newmask, oldmask, suspmask;

unsigned int    unslept;

/* set our handler, save previous information */ newact.sa_handler = sig_alrm; sigemptyset(&newact.sa_mask); newact.sa_flags = 0;

sigaction(SIGALRM, snewact, soldact)；

/* block SIGALRM and save current signal mask */ sigemptyset(&newmask); sigaddset(Snewmask, SIGALRM); sigprocmask(SIG_BLOCK, Snewmask, &oldmask);

alarm(seconds}; suspmask = oldmask;

/* make sure SIGALRM isn't blocked */ sigdelset(fisuspmask, SIGALRM);

/* wait for any signal to be caught */ sigsuspend{&suspmask);

/* some signal has been caught, SIGALRM is now blocked */

unslept = alarm(0);

/* reset previous action */ sigaction(SIGALRM, Soldact, NULL);

/* reset signal mask, which unblocks SIGALRM */ sigprocmask(SIG_SETMASK, fioldmask, NULL); return{unslept);

J

图10_29 sleep的可靠实现

与图10-7相比，为了可靠地实现sleep,图10-29的代码比较长。程序中没有使用任何形式 的非局部转移（如图10-8中为了避免在alarm和pause之间的竞争条件所做的那样），所以对 处理SIGALRM信号期间可能执行的其他信号处理程序没有任何影响。    ■

nanosleep函数与sleep函数类似，但提供了纳秒级的精度。

♦include <time.h>

int nanosleep (const struct timespec *reqtp, struct timespec *remtp};

返回值：若休眠到要求的时间，返回0:若出错，返回-1

这个函数挂起调用进程，直到要求的时间己经超时或者某个信号中断了该函数。伊参数用 秒和纳秒指定了需要休眠的时间长度。如果某个信号中断了休眠间隔，进程并没有终止，remtp

参数指向的timespec结构就会被设置为未休眠完的时间长度。如果对未体眠完的时间并不感兴 趣，可以把该参数置为NULL。

如果系统并不支持纳秒这一精度，要求的时间就会取整。因为nanosleep函数并不涉及产 生任何信号，所以不需要担心与其他函数的交互，

nanosleep函数过去属于Single UNIX Specification的定时器选领，现已被移至SUSv4的基 础部分。

随着多个系统时钟的引入（回忆6.10节），需要使用相对于特定时钟的延迟时间来挂起调用 线程。clock_nanosleep函数提供了这种功能。

番include <time.h>

int clock_nanosleep(clockid_t dock_id, int flags,

const struct timespec *reqtp, struct timespec *remtp};

返回值：若休眠要求的时间，返回0:若出错，返回错误码

参数指定了计算延迟时间基于的时钟。时钟标识符列于图6-8中。flags参数用于控制延 迟是相对的还是绝对的。7/^职为0时表示休眠时间是相対的（例如，希望休眠的时间长度〉，如果加gs 值设置为TIMER_ABSTIME，表示休眠时间是绝对的（例如，希望休眠到时钟到达某个特定的时间）。 其他的参数re识p和与mawoj/eep函数中的相同。但是，使用绝对时间时，rem伊参数

未使用，因为没有必要。在时钟到达指定的绝对时间值以前，可以为其他的clOCk_nan0Sleep 调用复用re识p参数相同的值。

注意，除了出错返回，调用

clock_nanosleep（CLOCK_REALTIME, 0, reqtp, remtp>;

和调用

nanosleep（reqtp, remtp）;

的效果是相同的。使用相对休眠的问题是有些应用对休眠长度有精度要求，相对体眠时间会导致 实际休眠时间比要求的长。例如，某个应用程序希望按固定的时间间隔执行任务，就必须获取当 前时间，计算下次执行任务的时间，然后调用nanosleep。在获取当前时间和调用nanosleep 之间，处理器调度和抢占可能会导致相対体眠时间超过实际需要的时间间隔，即便分时进程调 度程序对休眠时间结束后是否会马上执行用户任务并没有给出保证，使用绝対时间还是改善了 精度。

1 在Single UNIX Specification的早期版本中，clock_nanosleep函数属于时钟选择选项，在 SUSv4中，该函数已移至基础部分。

##### 10.20 函数 sigqueue

在10.8节中，我们介绍了大部分UNIX系统不对信号排队。在POSIX.1的实时扩展中，有 些系统开始增加对信号排队的支持。在SUSv4中，排队信号功能已从实时扩展部分移至基础说 明部分。

通常一个信号带有一个位信息：信号本身。除了对信号排队以外，这些扩展允许应用程序在

递交信号时传递更多的信息（回忆10.14节）。这些信息嵌入在siginfo结构中。除了系统提供 的信息，应用程序还可以向信号处理程序传递整数或者指向包含更多信息的缓冲区指针。

使用排队信号必须做以下几个操作》

（1）    使用sigaction函数安装信号处理程序时指定SA_SIGINFO标志。如果没有给出这个 标志，信号会延迟，但信号是否进入队列要取决于具体实现。

（2）    在sigaction结构的sa_sigaction成员中（而不是通常的sa_handler字段）提 供信号处理程序。实现可能允许用户使用sa_handler字段，但不能获取sigqueue函数发送 出来的额外信息。

（3）    使用sigqueue函数发送信号。

\#include <signal.h>

int sigqueue (pid_t pid, int sigrto, const union sigval value);

返回值：若成功，返回0:若出错，返回-1

sigqueue函数只能把信号发送给单个进程，可以使用vfl/we参数向信号处理程序传递整数 和指针值，除此之外，sigqueue函数与kill函数类似。

信号不能被无限排队，回忆图2-9和图2-11中的SIGQUEUE_MAX限制，到达相应的限制以 后，sigqueue就会失败，将errno设为EAGAIN。

随着实时信号的增强，引入了用于应用程序的独立信号集。这些信号的编号在SIGRTMIN〜 SIGRTMAX之间，包括这两个限制值，注意，这些信号的默认行为是终止进程。

图10-30总结了排队信号在本书不同的实现中的行为上的差异。

Mac OS X 10.6.8并不支持sigqueue或者实时信号。在Solaris 10中，sigqueue在矣时库

librt 中。

| 行为                                         | SUS  | FreeBSD8.0 | Linux3.2.0 | Mac OSX 10.6.8 | Solaris10 |
| -------------------------------------------- | ---- | ---------- | ---------- | -------------- | --------- |
| 支持 sigqueue                                | •    |            |            |                | •         |
| 对在SIGRTMIN和SIGRTMAX之外的信号排队         | 可选 |            |            |                | •         |
| 即使调用者没使用SA SIGINFO标志，也对信号排队 | 可选 |            |            |                |           |

图10-30不同平台上排队信号的行为    [376]

10-21作业控制信号

在图10-1所示的信号中，POSIX.1认为有以下6个与作业控制有关。

SIGCHLD子进程已停止或终止=

SIGCONT如果进程已停止，则使其继续运行。

SIGSTOP停止信号（不能被捕捉或忽略）。

SIGTSTP交互式停止信号。

SIGTTIN后台进程组成员读控制终端。

SIGTTOU后台进程组成员写控制终端。

除SIGCHLD以外，大多数应用程序并不处理这些信号，交互式Shell则通常会处理这些信号 的所有工作。当键入挂起字符（通常是Ctrl+Z）时，SIGTSTP被送至前台进程组的所有进程。当

我们通知shell在前台或后台恢复运行一个作业时，shell向读作业中的所有进程发送SIGCONT信 号。与此类似，如果向一个进程递送了 SIGTTIN或SIGTTOU信号，则根据系统默认的方式，停 止此进程，作业控制shell 了解到这一点后就通知我们。

一个例外是管理终端的进程，例如，vi(l)编辑器。当用户要挂起它时，它需要能了解到这一 点，这样就能将终端状态恢复到vi启动时的情况。另外，当在前台恢复它时，它需要将终端状 态设置回它所希望的状态，并需要重新绘制终端屏幕。可以在下面的例子中观察到与vi类似的 程序是如何处理这种情况的。

在作业控制信号间有某些交互。当对一个进程产生4种停止信号(SIGTSTP、SIGSTOP、 SIGTTIN或SIGTTOU)中的任意一种时，对该进程的任一未决SIGCONT信号就被丢弃。与此 类似，当对一个进程产生SIGCONT信号时，对同一进程的任一未决停止信号被丢弃。

注意，如果进程是停止的，则SIGCONT的默认动作是继续该进程；否则忽略此信号。通常， 对该信号无需做任何事情。当对一个停止的进程产生一个SIGCONT信号时，该进程就继续，即 使该信号是被阻塞或忽略的也是如此。

■实例

图10-31中的程序演示了当一个程序处理作业控制时通常所使用的规范代码序列。该程序只 ._.是将其标准输入复制到其标准输出，而在信号处理程序中以注释形式给出了管理屏幕的程序所执

行的典型操作。

main《void)

i

int    n;

char    buf[BUFFSIZEJ;

\* Only catch SIGTSTP if we're running with a job-control shell. */

if (signal{SIGTSTP, SXG_IGN) == SIG_DFL) signal (SIGTSTP, siq_tstp)

while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0) if (write(STDOUT_FILENO, buf, n) != n)

err_sys("write error");

if (n < 0)

err_sys{"read error"};

exit (0);

J

图10-31如何处理SIGTSTP

当图10-31中的程序启动时，仅当SIGTSTP信号的配置是SIG_DFL,它才安排捕捉该信号。

其理由是：当此程序由不支持作业控制的shell （如/bin/sh）启动时，此信号的配置应当设置为[378] SIG_IGN。实际上，shell并不显式地忽略此信号，而是由init将送3个作业控制信号SIGTSTP、 SIGTTIN和SIGTTQU设置为SIG_IGN。然后，这种配置由所有登录shell继承。只有作业控制 shell才应将这3个信号重新设置为SIGJDFL。

当键入挂起字符时，进程接到SIGTSTP信号，然后调用该信号处理程序。此时，应当进行 与终端有关的处理：将光标移到左下角、恢复终端工作方式等。在将SIGTSTP重置为默认值（停 止该进程），并且解除了对此信号的阻塞之后，进程向自己发送同一信号SIGTSTP。因为正在处 理SIGTSTP信号，而在捕捉该信号期间系统自动地阻塞它，所以应当解除对此信号的阻塞。到 达这一点时，系统停止该进程。仅当某个进程（通常是正响应一个交互式fg命令的作业控制Shell）

向该进程发送一个SIGCONT信号时，该进程才继续。我们不捕捉SIGCONT信号。该信号的默 认配置是继续运行停止的进程，当此发生时，此程序如同从kill函数返回一样继续运行。当 此程序继续运行时，将SIGTSTP信号重置为捕捉，并且做我们所希望做的终端处理（如重新绘 制屏幕）。    ■

10.22信号名和编号

本节介绍如何在信号编号和信号名之间进行映射。某些系统提供数组 extern char *sys_siglist[];

数组下标是信号编号，数组中的元素是指向信号名符串的指针=

FreeBSD 8.0、Linux 3.2.0和Mac OS X 10.6.8都提供这种信号名数组。Solaris 10也提供信号

名數组，但该数组名是_sys_siglist。

可以使用psignal函数可移植地打印与信号编号对应的字符串。

\#include <signal.h>

void psignal (int sign。, const char *wjg);

字符串msg （通常是程序名）输出到标准错误文件，后面跟随一个冒号和一个空格，再后面 对该信号的说明，最后是一个换行符。如果m呀为NULL,只有信号说明部分输出到标准错误文 件，该函数类似于perror （1.7节）。

如果在sigaction信号处理程序中有siginfo结构，可以使用psiginfo函数打印信号 信息。

\#include <signal.h>

void psiginfo (const siginfo t *info, const char    ;

它的工作方式与psignal函数类似。虽然这个函数访问除信号编号以外的更多信息，但不 同的平台输出的这些额外信息可能有所不同。

如果只需要信号的字符描述部分，也不需要把它写到标准错误文件中（如可以写到曰志文件 中），可以使用strsignal函数，它类似于strerror （另见1.7节）。

\#include <string.h>

char * strsignal （int signo）;

返回值，指向描述该信号的字符串的指针 给出一个信号编号，strsignal将返回描述该信号的字符串。庾用程序可用该字符串打印 关于接收到信号的出错消息。

!    本书讨论的所有平台都提供psignal和strsignal轟数，但相互之间有些差别。在Solaris

賣10中，若信号编号无效，strsignal将返田一个空推针，而Fre曲SD 8.0、Linux 3.2.0和Mac OS | X 10.6.8则返回一个字符串，它指出信号编号是不可识别的。

:    只有 Linux 3.2.0 和 Solaris 10 支持 psiginfo 西数。

Solaris提供一对函数，一个函数将信号编号映射为信号名，另一个则反之。

\#include <signal.h>

int sig2str （int signo, char *str）;

int str2sig （const char *str, int *signop）;

两个函数的返回值，若成功，返回0;若出错，返回-1

在编写交互式程序，其中需接收和打印信号名和信号编号时，这两个函数是有用的。 sig2str函数将给定信号编号翻译成字符串，并将结果存放在对r指向的存储区。调用

者必须保证该存储区足够大，可以保存最长字符串，包括终止null字节。Solaris在 <signal.h>中包含了常量SIG2STR_MAX,它定义了最大字符串长度。该字符串包括不带 “SIG”前缀的信号名。例如，SIGKILL被翻译为字符串“KILL”，并存放在Wr指向的存储 缓冲区中。

str2sig函数将给出的信号名翻译成信号编号。该信号编号存放在■y/gw叩指向的整型中。 名字要么是不带“S1G”前缀的信号名，要么是表示十进制信号编号的字符串（如“9”）。

[38。| 往意f sig2str和str2sig与常用的函数做法不同，当定们失败时，并不设置errno。

##### 10.23小结

信号用于大多数复杂的应用程序中，理解进行信号处理的原因和方式对于髙级UNIX编程极 其重要。本章对UNIX信号进行了详细而且比较深入的介绍。首先说明了早期信号实现的问题以 及它们是如何显现出来的。然后介绍了 POSIX.1的可靠信号概念以及所有相关的函数。在此基础 上提供了 abort、system和sleep函数的POSIX.1实现。最后以观察分析作业控制信号以及 信号名和信号编号之间的转换结束。

习题

10.1删除图10-2程序中的for （;;）语句，结果会怎样？为什么？

10.2实现10.22节中说明的sig2str函数。

10.3画出运行图10-9程序时的桟喊情况。

10.4图10-11程序中利用setjmp和longjmp设置I/O操作的超时，下面的代码也常见用于此 种目的：

signal（SIGALRM, sig_alrm）; alarm（60）;

if （setjmp（env_alrm） != 0）（

/* handle timeout */

}

这段代码有什么错误？

10.5仅使用一个定时器（alarm或较髙精度的setitimer），构造一组函数，使得进程在该单 一定时器基础上可以设置任一数量的定时器。

10.6编写一段程序测试图10-24中父进程和子进程的同步函数，要求进程创建一个文件并向 文件写一个整数0,然后，进程调用fork,接着，父进程和子进程交替増加文件中的计 数器值，每次计数器值増加1时，打印是哪一个进程（子进程或父进程）进行了该增加 I操作。

10.7在图10-25中，若调用者捕捉了 SIGABRT并从该信号处理程序中返回，为什么不是仅仅调 而要恢复其默认设置并再次调用kill?

10.8为什么在siginfo结构（见10.14节）的si_uid字段中包括实际用户ID而非有效用 户ID?

10.9重写图10-14中的函数，要求它处理图10-1中的所有信号，每次循环处理当前信号屏蔽字

中的一个信号（并不是对每一个可能的信号都循环一次）。    [353

10.10编写一段程序，要求在一个无限循环中调用sleep<60》函数，每5分钟（即5次循环）

取当前的日期和时间，并打印tm_SeC字段。将程序执行一晚上，请解释其结果。有些程 序，如cron守护进程，每分钟运行一次，它是如何处理这类工作的？

10.11修改图3-5的程序，要求：（a）将BUFFSIZE改为100; （b）用signal_intr函数捕 捉SIGXFSZ信号量并打印消息，然后从信号处理程序中返回；（C）如果没有写满请求

的字节数，则打印write的返回值。将软资源限制RLIMIT_FS1ZE （见7.11节）更改为 1 024字节（在shell中设置软资源限制，如果不行就直接在程序中调用setrlimit）,然 后复制一个大于1024字节的文件，在各种不同的系统上运行新程序，其结果如何？为什么？

10.12编写一段调用fwrite的程序，它使用一个较大的缓冲区（约1GB），调用fwrite前调 用alarm使得1 s以后产生信号。在信号处理程序中打印捕捉到的信号，然后返回。fwrite

®    可以完成吗？结果如何？
