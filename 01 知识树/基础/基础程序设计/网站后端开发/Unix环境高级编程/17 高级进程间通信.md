### 第17章

#### 离级进程间通信

##### 17.1引言

前面两章讨论了 UNIX系统提供的各种IPC，其中包括管道和套接字。本章介绍一种髙级 IPC——UNIX域套接字机制，并说明它的应用方法。这种形式的IPC可以在同一计算机系统上运 行的两个进程之间传送打开文件描述符。服务进程可以使它们的打开文件描述符与指定的名字相 关联，同一系统上运行的客户进程可以使用这些名字与服务器进程汇聚。我们还会了解到操作系 统如何为每一个客户进程提供一个独用的IPC通道。

##### 17.2 UNIX域套接字

UNIX域套接字用于在同一台计算机上运行的进程之间的通信。虽然因特网域套接字可用于 同一目的，但UNIX域套接字的效率更高。UNIX域套接字仅仅复制数据，它们并不执行协议处 理，不需要添加或删除网络报头，无需计算校验和，不要产生顺序号，无需发送确认报文。

UNIX域套接字提供流和数据报两种接口。UNIX域数据报服务是可靠的，既不会丢失报文 也不会传递出错。UNIX域套接字就像是套接字和管道的混合。可以使用它们面向网络的域套接 字接口或者使用socketpair函数来创建一对无命名的、相互连接的UNIX域套接字。    岡

♦include <sys/socket.h>

int socketpair （int domain, int type, int protocol, int sod^"d[2]、；

返回值：若成功，返回0:若出错，返回-1

虽然接口足够通用，允许socketpair用于其他域，但一般来说操 作系统仅对UNIX域提供支持。

用户进程

| fd【O]   | fdlll  |      |      |
| -------- | ------ | ---- | ---- |
|          |        |      |      |
| 套接字丨 | 套接字 |      |      |



图17-1套接字对



一对相互连接的UNIX域套接字可以起到全双工管道的作用：两端对 读和写开放（见图17-1）。我们将其称为fd管道（fd-pipe），以便与普通 的半双工管道区分开来。

■实例：f d_pipe函数

图17-2展示了 fd_pipe函数，它使用socketpair函数来创建一 对相互连接的UNIX域流套接字。

井include "apue.h'1 ♦include <sys/socket.h>

\*    Returns a full-duplex pipe (a UNIX domain socket) with

\*    the two file descriptors returned in fd[0] and fd[l]. */

int

fd_pipe(int fd[2])

return(socketpair(AF_UNIX, SOCK_STREAM, 0, fd));

}

图17,2创建一个全双工管道

某些基于BSD的系统使用UNIX域套接字来实现管道。但当调用pipe时，第一描述符的写 |630l    j端和第二描述符的读端都是关闭的。为了得到全双工管道，必须直接调用socketpair。

s■实例：借助UNIX艇询XSI消息队列

15.6.4节曾经提到XSI消息队列的使用存在一个问题，即不能将它们和poll或者select 一起使用，这是因为它们不能关联到文件描述符，然而，套接字是和文件描述符相关联的，消息 到达时，可以用套接字来通知。对每个消息队列使用一个线程，每个线程都会在msgrcv调用中 阻塞。当消息到达时，线程会把它写入一个UNIX域套接字的一端。当poll指示套接字可以读 取数据时，应用程序会使用这个套接字的另外一端来接收这个消息。

图17-3中的程序说明了这个技术。main函数中创建了一些消息队列和UNIX域套接字，并

为每个消息队列开启了一个新线程。然后它在一个无限循环中用poll来轮询选择一个套接字端 点。当某个套接字可读时，程序可以从套接字中读取数据并把消息打印到标准输出上。

\#include ’• apue.h"

\#include <poll.h>

\#include <pthread.h>

\#include <sys/msg.h>

tinclude <sys/socket,h>

\#define NQ    3    /*    number of queues */

\#define MAXMSZ    512    /*    maximum message size */

\#define KEY    0x123    /*    key for first message queue    */

struct threadinfo { int qid; int fd;

}；

struct mymesg { long mtype; char mtext[MAXMSZ];

}；

void *

helper(void *arg)

int

struct mymesg



n;

m?



struct threadinfo *tip = arg;

for(；;) {

memset(&m, 0, sizeof(m));

if ((n = msgrcv(tip->qid, &m, MAXMS2, 0, MSG_NOERROR)) < 0) err_sys("msgrcv error")；

if (write(tip->fdr m.mtext, n) < 0) err_sys{"write error");

}

int

main()    [^T|



| int       |             | i, n, err;   |
| --------- | ----------- | ------------ |
| int       |             | fdI2];       |
| int       |             | qid[NQ];     |
| struct    | pollfd      | pfd[NQ];     |
| struct    | threadinfo  | ti[NQ];      |
| pthread_t | tid[NQ];    |              |
| char      |             | buf[MflXMSZ] |
| for (i    | =0; i < NQ; | i++) {       |

if ((qid[i] = msgget((KEY+i), IPC_CREAT|0666》)< 0) err_sys("msgget error");

printf("queue ID %d is %d\n", i, qid[i]);

if (socketpair(AF_UNIX, SOCK_DGRAM, 0, fd) < 0) err_sys("socketpair error");

pfd[i].fd = fd[0]； pfd[i).events = POLLIN; ti[i].qid = qid[i]; ti[i].fd = fd[l];

if ((err = pthread_create(£tid[i] , NULL, helper, Sti[i]))    != 0)

err_exit(err, "pthread_create error");

}

for (;;) {

if (poll(pfd, NQ, -1) < 0) err_sys("poll error"); for (i = 0; i < NQ; i++) {

if (pfd[i].revents & POLLIN) {

if ((n = read(pfd[i].fd, buf, sizeof(buf))) < 0)

err_sys{"read error"); buf[n] =0;

printf("queue id %d, message %s\n", qid[i], buf);

}

exit(0);

图17-3使用UNIX域套接字轮询XSI消息队列

注意，我们使用的是数据报（SOCK_DGRAM）套接字而不是流套接字》这样做可以保持消息 边界，以保证从套接字里一次只读取一条消息。

这种技术可以（非直接地）在消息队列中运用poll或者select,只要为每个队列分配一 个线程的开销以及每个消息额外复制两次（一次写入套接字，另一次从套接字里读取出来）的开 销是可接受的.这种技术就会使XSI消息队列的使用更加容易。

[«2]    使用图174中所示的程序给图17-3中所示的测试程序发送消息。

tinclude "apue.h" #include <sys/msg.h>

\#define MAXMSZ 512

struct mymesg { long mtype; char mtext[MAXMSZ];

int

main (int argc, char *argv[])

key_t key; long qid; size_t nbytes; struct mymesg m;

if (argc != 3}(

fprintf(stderr, "usage: sendmsg KEY message\n"); exit (1);

key = strtol(argv[1], NULL, 0); if ((qid = msgget(key, 0}) < 0)

err^sya("can't open queue key %s", argv[l]); raemset(&m, 0, sizeof(m)); strncpy(m.mtext, argv[2], MAXMSZ-1); nbytes = strlen(m.mtext)； m.mtype = 1;

if (msgsnd(qid, &m, nbytes, 0) < 0) err_sys{"can't send message");

exit(0);

J

图174给XSI消息队列发送消息

这个程序需要两个参数：消息队列关联的键值以及一个包含消息主体的字符串。发送消息到 服务器端时，它会打印如下信息：

$ . /pollmsg fi

[1] 12814

$ queue ID 0 is 196608

queue ID 1 is 196609

queue ID 2 is 196610

? ./sandmsg 0x123 "hellor wocld"

queue id 196608, message hello, world

$ .fsendmsg 0x124 "just a teat"



在后台运行服务器



给第一个队列发送一条消息



给第二个队列发送一条消息



queue id 196609, message just a test

$ ./sandmsg 0x125 "bye"    给第三个队列发送一条消息

queue id 196610, message bye    ■题 |6331

命名UNIX域套接字

虽然socketpair函数能创建一对相互连接的套接字，但是每一个套接字都没有名字。这 意味着无关进程不能使用它们。

在16.3.4节中学习了如何将一个地址绑定到一个因特网域套接字上。恰如因特网域套接字一 样，可以命名UNIX域套接字，并可将其用于告示服务。但是要注意，UNIX域套接字使用的地 址格式不同于因特网域套接字。

回忆16.3节，套接字地址格式会随实现而变。UNIX域套接字的地址由sockaddr_un结构 表示。在Linux 3.2.0和Solaris 10中，sockaddr_un结构在头文件＜sys/un. h＞中的定义 如下：

struct sockaddr_un {

/* AF^UNIX */ /* pathname */



sa_family_t sun_family; char    sun_path[108];

}；

但是在FreeBSD 8.0和Mac OS X 10.6.8中，sockaddr_un结构的定义如下:

struct sockaddr_un unsigned char sa_family_t char

sun_len; sun_family; sun_j>ath[104];



/* sockaddr length */ /* AF_UNIX */

/* pathname */



｝；

sockaddr_un结构的sun_path成员包含一个路授名。当我们将一个地址绑定到一个UNIX 域套接字时，系统会用该路径名创建一个S_IFSOCK类型的文件。

孩文件仅用于向客户进程告示套接字名字。该文件无法打开，也不能由应用程序用于 通信。

如果我们试图绑定同一地址时，该文件己经存在，那么bind请求会失败。当关闭套接字时， 并不自动删除该文件，所以必须确保在应用程序退出前，对该文件执行解除链接操作。

簿■实例

图17-5所示的程序是一个将地址绑定到UNIX域套接字的例子。

运行此程序时，bind请求成功执行。但是，若第二次运行该程序，则出错返回，其原因是 该文件己经存在。在删除该文件之前，该程序不会再成功运行。

| $ ./a.out                                      | 运行该程序         |
| ---------------------------------------------- | ------------------ |
| UNIX domain socket bound                       |                    |
| $ Is -1 foo.socket                             | 査看套接字文件     |
| srwxrw-xr-x 1 sar    0 May 18 00:44 foo.socket |                    |
| $ ./a.out                                      | 试图再次运行该程序 |
| bind failed: Address already in use            |                    |
| $ rm foo.socket                                | 刪除该套接字文件   |
| $ ./a.out:                                     | 第三次运行该程序   |
| UNIX domain socket bound                       | 现在成功啦         |

\#include "apue.h"

\#include <sys/socket.h>

\#include <sys/un.h>

int

main(void)

{

int fd, size; struct sockaddr_un un;

un.sun_family = AF_JJNIX?

strcpy{un.sun_path, "foo.socket");

if {(fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)

err_sys("socket failed");

size = offsetof(struct sockaddr_un, sun_path) + strlen{un.sun_path); if (bind(fd, (struct sockaddr *)&un, size) < 0)

err_sys("bind failed"); printf("UNIX domain socket bound\n")； exit(0);

图n-5将地址绑定到UNIX域套接字

确定绑定地址长度的方法是，先计算sun_path成员在sockaddr_un结构中的偏務量，然 后将结果与路径名长度(不包括终止null字符)相加。因为sockaddr_un结钩中sun_path之 前的成员与实现相笑，所以我们使用＜stddef .h＞头文件(包括在apue.h中)中的offsetof 宏计算sim_path成员从结构开始处的偏移量。如果査看＜社(1加匕11＞，则可见到类似于下列形 式的定义：

ttdefine offsetof(TYPE, MEMBER) ({int)S ((TYPE *)0)-＞MEM8ER)

假定该结构从地址0开始，此表达式求得成员起始地址的整型值，    •霧

###### 17,3唯一连接

634

I

635



服务器进程可以使用标准bind、listen和accept函数，为客户进程安排一个唯一 UNIX 域连接。客户进程使用connect与服务器进程联系。在服务器进程接受了 connect请求后，在 服务器进程和客户进程之间就存在了唯一连接。选种风格的操作与我们在图16-16和图16-17中 所示的对因特网域套接字的操作相同。

图17-6展示了客户进程和服务器进程存在连接之前二者的情形。服务器端把它的套接字绑定 到sockaddr.un的地址并监听新的连接请求。图17-7展示了在服务器端接受客户端连接请求后， 客户端和服务器端之间建立的唯一的连接。

现在，我们将开发3个函数，使用这些函数可以在运行于同一台计算机上的两个无关进程之 间创建唯一连接。这些函数模仿了在16.4节中讨论过的面向连接的套接字函数。这里，我们将 UNIX域套接字应用于底层通信机制。

原务器进程    客户进程

图17-6 connect之前的客户端    图17-7 connect之后的客户端

套接字和服务器端套接字    套接字和服务器端套接字

\#include "apue. h•’

int serv_listen（const char [1](#bookmark10) [2](#bookmark11)name）;

返回值：若成功，返回要监听的文件描述符：若出错，返回负值 int serv_accept {int listenfd, uid_t [2](#bookmark11)uidptr）；

返回值：若成功，返回新文件描述符；若出错，返回负值

int cli_conn（const char [2](#bookmark11)name}；

返回值：若成功，返回文件描述符：若出错，返回负值

服务器进程可以调用serv_listen函数（见图17-8）声明它要在一个众所周知的名字（文件 系统中的某个路径名）上监听客户进程的连接请求。当客户进程想要连接至服务器进程时，它们将 使用该名字。servjisten函数的返回值是用于接收客户进程连接请求的服务器UNIX域套接字。

服务器进程可以使用serv_accept函数（见图17-9）等待客户进程连接请求的到达。当一 个请求到达时，系统自动创建一个新的UNIX域套接字，并将它与客户端套接字连接，最后将这 个新套接字返回给服务器。此外，客户进程的有效用户ID存放在价指向的存储区中。

客户进程调用cli.conn函数（见图17-10）连接至服务器进程。客户进程指定的name参数 必须与服务器进程调用serv_listen函数时所用的名字相同。函数返回时，客户进程得到接连 至服务器进程的文件描述符。

图 17-8 给出了 serv_listen 函数。

struct sockaddr_un un;

if (strlen(name) >= sizeof(un.sun_path)) { errno = ENAMETOOLONG; return(-1,;

/* create a UNIX domain stream socket */

if ((fd = socket<AF_UNIX, SOCK_STREAM, 0)) < 0) return (-2);

unlink {name) ;    /* in case it already exists */

/* fill in socket address structure */

memset(&un, 0, sizeof(un));

un.sun_family = AF_UNIX;

strcpy(un.sun_path, name);

len = of fsetof (struct sockaddr_un, sun_path) + strlen (name)'•

/* bind the name to the descriptor */

if (bind(fd» {struct sockaddr *)&un, len) < 0) { rval = -3; goto errout;

}

if (listen(fd, QLEN) < 0) {    /* tell kernel we're a server */

rval = -4; goto errout;

}

return(fd);

errout:

err = errno; close(fd); errno = err; return(rval);

1

图 17-8 serv_listen 函数

首先，调用socket创建一个UNIX域套接字，然后将欲赋给套接字的众所周知的路径名填 入sockaddr.un结构。该结构是调用bind的参数。注意，不需要设置某些平台提供的sun.len 字段，因为操作系统会用传送给bind函数的地址长度设置该字段。

最后，调用listen函数（见16.4节）来通知内核该进程将作为服务器进程等待客户进程的 连接请求。当收到一个客户进程的连接请求后，服务器进程调用serv.accept函数（见图17-9）。

\#define STALE



\*    Wait for a client connection to arrive, and accept it.

\*    We also obtain the client's user ID from the pathname

\*    that it must bind before calling us.

\*    Returns new fd if all OK, <0 on error */

int

serv_accept(int listenfd, uid_t *uidptr)

int    clifd, err, rval;

socklen_t    len;

staletime;

struct    sockaddr_un un;

struct    stat    statbuf;

char    *name；

/* allocate enough space for longest name plus terminating null */ if ((name * malloc(sizeof(un.sun_path) + 1)) == NULL)

return(-1); len = sizeof(un);

if ((clifd = accept(listenfd, (struct sockaddr *)&un, &len)) < 0}( free(name);

return(-2);    /* often errno=EINTR, if signal caught */

)

/* obtain the client's uid from its calling address */

len -= of fsetof (struct sockaddr_un, sun_path); /* len of pathname */

memcpy{name, un.sun_path, len);

name[len] = 0;    /* null terminate */

if (stat (name, Sistatbuf) < 0) {

rval = -3; goto errout;

Hfdef S_ISSOCK    /* not defined for SVR4 */

if (S_ISSOCK(statbuf.st_mode) == 0) {

rval = -4;    /* not a socket */

goto errout;

J

释endif

rval = -6;    /* i-node is too old */

goto errout?

J

if (uidptr != NULL)

*uidptr = statbuf.st_uid; /[3](#bookmark14) [4](#bookmark15) return uid of caller [4](#bookmark15)/ unlink (name);    /[4](#bookmark15) we're done with pathname now [4](#bookmark15)/

free(name);

return(clifd);

errout:

err = errno; close(clifd); free(name); errno = err； return(rval);

l

图 17-9 serv_accept 函数

服务器进程在调用serv_accept中阻塞，等待一个客户进程调用cli_conn。从accept 返回时，返回值是连接到客户进程的崭新的描述狩，另外，accept函数也经由其第二个参数（指 向30^3<1€^_1^结构的指针）返回客户进程赋给其套接字的路極名（包含客户进程ID的名字）。 接着，程序复制这个路径名，并确保它是以null终止的（如果路径名占用了 SOckaddr_im结构 里的survpath成员所有的可用空间，那就没有空间存放终止mill字符）。然后，调用stat函 数验证：该路径名确实是一个套接字：其权限仅允许用户读、用户写以及用户执行。还要验证与 套接字相关联的3个时间参数不比当前时间早30秒。（回忆6.10节，time函数返回当前时间和 日期，用公元1970年1月1日00:00:00以来经过的秒数表示。）

如若通过了所有这些检验，则可认为客户进程的身份（其有效用户ID）是该套接字的所有者。 虽然这种检验并不完善，但这是对当前系统所能做到的最佳方案。（如若内核能通过accept的 参数返回有效用户ID，则会更好一些。）

客户进程调用cli_conn函数（见图17-10）对连到服务器进程的连接进行初始化。

/* create a UNIX domain stream socket */

if {(fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)

return(-1);

/* fill socket address structure with our address */ memset(&un, 0, sizeof(un)); un.sun_family = AF_DNIX；

sprintf (un.sunjpath, "%s%051d", CLI_PATH, (long)getpid());

len = offsetof(struct sockaddr_un, sun_path) + strlsn(un.sun_path);

unlink(un.sun_path);    /* in case it already exists */

if (bind(fd, (struct sockaddr *)&un, len) < 0) {

rval = -2； goto errout;

J

if (chmod(un.sun_path, CLI^PERM) < 0) { rval = -3； do_unlink = 1; goto errout;

/* fill socket address structure with server's address */ memset(&sun, 0, sizeof(sun)); sun.sun_family = AF_UNIX; strcpy(sun-sun_path, name);

len = offsetof(struct sockaddr_un, sun_path) + strlen(name); if (connect{fd, (struct sockaddr *)&sun, len) < 0) {

rval = -4; do_unlink = 1; goto errout;

J

return(fd);

errout:

err = errno; close{fd); if <do_unlink>

unlink(un.sun_path); errno = err; return(rval);

}

图 17-10 cli_conn 函数

调用socket函数创建UNIX域套接字的客户进程端，然后用客户进程专有的名字填入 sockaddr_un 结构。

此例中没让系统选择默认地址，其原因是，如果这样处理，服务器进程将不能区分各个客户 进程（如果不为UNIX域套接字显式地绑定名字，内核会代表我们隐式地练定一个地址且不会在 文件系统创建文件来表示这个套接字）。于是，我们绑定自己的地址，但在开发使用套接字的客 户端程序时通常并不采用送一步骤。

绑定的路径名的最后5个字抑来自客户进程ID。仅在该路径名已存在时调用unlink-然后， 调用bind将名字赋给客户进程套接字。送在文件系统中创建了一个套接字文件，所用的名字与 被绑定的路径名一样。棲着，调用chmod关闭除用户读、用户写以及用户执行以外的其他权限。

在Serv_aCCept中，服务器进程检验这些权限以及套接字用户ID以验证客户进程的身份。

岡 然后，必须填充另一个SOCJcaddr_un结构，这次用的是服务进程众所周知的路径名。最后，

调用connect函数初始化与服务进程的连接。

17.4传送文件描述符

在两个进程之间传送打开文件描述符的技术是非常有用的。因此可以对客户进程-服务器进程 应用进行不同的设计。它使一个进程（通常是服务器进程）能够处理打开一个文件所要做的一切 操作（包括将网络名翻译为网络地址、拨号调制解调器、协商文件锁等）以及向调用进程送回一 个描述符，该描述符可被用于以后的所有I/O函数。涉及打开文件或设备的所有细节对客户进程 而言都是透明的、

下面进一步说明从一个进程向另一个进程“传送一个打开文件描述符”的含义。回忆图3-8, 其中显示了两个进程，它们打开了同一文件。虽然它们共享同一个v节点，但每个进程都有它自 己的文件表项。

当一个进程向另一个进程传送一个打开文件描述符时，我们想让发送进程和接收进程共享同 一文件表项。图17-11显示了所期望的安排。

进酸领

0:1:2:3:

H,dfdH

文件状态标志 当前文件偏移量 v节点指针



文件表



v节点表 v节点信息



![img](UNIXaf83d8a7160b-68.png)



i节点信息 O支恥虔



，志文件指针

0:1:2:3:4:

|      |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |

图17-11从顶部进程传送一个打开文件至底部进程 在技术上，我们是将指向一个打开文件表项的指针从一个进程发送到另外一个进程。该指针

被分配存放在接收进程的第一个可用描述符项中。（注意，不要造成错觉，以为发送进程和接收 进程中的描述符编号是相同的，它们通常是不同的。〉两个进程井享同一个打开文件表，这与fork 之后的父进程和子进程共享打开文件表的情况完全相同（见图8-2）。

当发遽进程将描述符传送给接收进程后，通常会关闭读描述符。发送进程关闭该描述符并不会真的 关闭该文件或设备，其原因是读描述符仍被视为由接收进程打开(即使接收进程尚未接收到读描述符)。

下面定义本章用以没送和接收文件描述符的3个函数。本节后面会给出这3个函数的代码。

\#include "apue.h"

int send_fd(int fd, int fd_to_send)；

int send_err (int fd, int status, const char ★errmsg);

两个函数的返回值：若成功，返回0;若出错I返回-1

int recv_fd(int fd, ssize_t {*userfimc} (int, const void *, size_t));

返回值：若成功，返回文件描述符；若出错，返回负值

[6421



当一个进程(通常是服务器进程)想将一个描述符传送给另一个进程时，可以调用send_fd 或Send_err。等待接收描述符的进程(客户进程)调用reCV_fd。

send_fd使用沖代表的UNIX域套接字发送描述符fd」o_send。send_err使用片发选 errmsg以及后随的status字节。status的值应在-1^—255。

客户进程调用redfd接收描述符。如果一切正常(发送者调用了 send_fd)，则函数返回 值为非负描述符。舌贝U，返回值是由send_err发送的(-1 —255的一个负值)。另夕卜，如 果服务器进程发送了一条出错消息，则客户进程调用它自己的userfunc函数处理该消息。userjunc 的第一个参数是常量STDERR.FILENO,然后是指向出错消息的指针及其长度。userfunc函数的 返回值是己写的字节数或负的出错编号值。客户进程常将普通的write函数指定为userfunc.

我们实现用于这3个函数的我们自己制定的协议。为发送一个描述符，send_fd先发送2字 节0,然后是实际描述符。为了发送一条出错消息，send_err发送errmsg,然后是1字节0，岡 最后是字节的绝对值(1〜255)。recv_fd函数读取套接字中所有字节直至遇到皿11字符。 null字符之前的所有字符都传送给调用者的userfunc. recv_fd读取的下一个字节是状态(status)

字节。若状态字节为0,则表示一个描述符已传送过来，否则表示没有描述符可接收。

sencLerr函数在将出错消息写到套接字后，即调用send_fd函数，如图17-12所示。

♦include "apue.h"

\*    Used when we had planned to send an fd using send_fd{),

\*    but encountered an error instead. We send the error back

\*    using the send_fd()/recv_fd() protocol.

*/

int

send_err(int fd, int errcode, const char *msg)

{

int    n;

if ((n = strlen(msg)) > 0)

if (writen(fd, msg, n) != n) /* send the error message */ return(-1);

if (errcode >= 0)

errcode = -1;    /* must be negative */

if (send_fd(fd, errcode) < 0)

return(-1);

return (0);

}

图 17-12 send_err 函数

为了用UNIX域套接字交换文件描述符，调用sendmsg（2）和recvmsg（2）函数（见16.5节）。 这两个函数的参数中都有一个指向msghdr结构的指针，该结构包含了所有关于要发送或要接收 的消息的信息。该结构的定义大致如下：

struct msghdr {

| void         | *msg_name;      | /*   | optional ‘ | address */          |
| ------------ | --------------- | ---- | ---------- | ------------------- |
| socklen_t    | msg_namelen;    | /*   | address s  | ize in bytes */     |
| struct iovec | *msg_iov;       | /*   | array of   | I/O buffers */      |
| int          | msg_iovlen;     | /*   | number of  | elements in array   |
| void         | *msg_control;   | /*   | ancillary  | data */             |
| socklen_t    | msg_controllen; | /*   | number of  | ancillary bytes */  |
| int          | msg_flags;      | /*   | flags for  | received message *, |

1；

前两个元素通常用于在网络连接上发送数据报，其中目的地址可以由每个数据报指定。接下 来的两个元素使我们可以指定一个由多个缓冲区构成的数组（散布读和聚集写），这与对readv 和writev函数（见14.6节）的说明一样。msg_flags字段包含了描述接收到的消息的标志，

[644|图16-15总结了这些标志。

两个元素处理控制信息的传送和接收。msg_control字段指向cmsghdr （控制信息头）结 构，msg_controllen字段包含控制信息的字节数。

struct cmsghdr {

socklen_t cmsg_len; int    cmsg_level;

int    cmsg_type;

/* followed by the actual



/* data byte count, including header */ /* originating protocol */

/* protocol-specific type */ control message data */

}；

为了发送文件描述符，将cmsg_len设置为cmsghdr结构的长度加一个整型的长度（描述 符的长度），cmg_level字段设置为SOL_SOCKET，cmsg_type字段设置为SCM_RIGHTS,用 以表明在传送访问权。（SCM是Socket-level Control Message的缩写，即套接字级控制消息》）访 问权仅能通过UNIX域套接字传送，描述符紧随cmsg_type字段之后存储，用CMSG_DATA宏 获得该整型量的指针。

在此定义3个宏，用于访问控制数据，一个宏用于帮助计算cmsg.len所使用的值。

♦include <sys/socket.h>

unsigned char *CMSG_DATA{struct cmsghdr *cp);

返回值：返回一个指针，指向与cmsghdr结构相关联的数据

struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *mp);

返回值：返回一个指针，指向与msghdr结构相关联的第一个cmsghdr结构： 若无这样的结垮，返回NULL

struct cmsghdr *CMSG_NXTHDR(struct msghdr *mp,

struct cmsghdr *cp);

返回值：返回一个指针，指向与msghdr结构相关联的下一个cmsghdr 结构，该msghdr结构给出了当前的cmsghdr结构：若当前 cmsghdr结构已是最后一个I返回NULL

unsigned int CMSG_LEN (unsigned int nbytes);

返回值：返回为n/ytes长的数据对象分配的长度 Single UNIX Specification 定义了前 3 个宏，但没有定义 CMSG_LEN。

CMSG_LEN定返回存储nbytes长的数据对象所需的字节数，它先将nbytes加上cmsghdr结 构的长度，然后按处理器体系结构的对齐要求进行调整，最后再向上取整。

图17-13中的程序是UNIX域套接字的send.fd函数，它通过UNIX域套接字传递文件描述 符。sendmsg调用被用来传送协议数据(包括mill字节和状态字节)以及描述符。    [645]

=SOL_SOCKET; =SCM_RIGHTS; =CONTROLLEN;



/[5](#bookmark19) [6](#bookmark20) the fd to pass [6](#bookmark20)/



| buf[l] = 0;)    | /[7](#bookmark21) | zero status means OK [7](#bookmark21)/ |
| --------------- | ----------------- | -------------------------------------- |
| buf[0] = 0;     |                   | null byte flag to recv_fd()            |
| if (sendmsg(fd, | &msg, 0)          | != 2)                                  |
| return(-l);     |                   |                                        |
| return(0};      |                   |                                        |

|646|    图17-13通过UNIX域套接字发送文件描述符

为了接收一个文件描述符（见图17-14），我们为cmsghdr结构和描述符分配了足够大的空

间，设置msg_control指向该好配到的存储区，然后调用了 recvmsg。使用CMSG_LEN定计 算所需的空间总量。

读取UNIX域套接字，直至读到null字节，它位于最后的状态字节之前，null字节之前是一 条来自发送者的出错消息。

| intcharcharstruct iovecstruct msghdr | newfd, nr, status; *ptr;buf[MAXLINE]； iov[l]；msg; |      |
| ------------------------------------ | --------------------------------------------------- | ---- |
| status                               | =-1;                                                |      |

for



iov[0].iov_base iov[0].iov_len msg.msg_iov msg.msg_iovlen msg.msg_name msg.msg_namelen



=buf;

=sizeof(buf) =iov;

=1;

=NULL；

=0；



if (cmptr == NULL && (cmptr = malloc(CONTROLLEN))



==NULL)



return(-1);

msg.msg_control = cmptr;

msg.msg_controllen = CONTROLLEN;

if ((nr = recvmsg{fd, &msg, 0)) < 0) {

err_ret("recvmsg error"); return(-1);



} else if (nr ==



0)(



err_ret("connection closed by server"); return (-1)；

\*    See if this is the final data with null & status. Null

\*    is next to last byte of buffer; status byte is last byte.

\*    Zero status means there is a file descriptor to receive.

"    |647|

for (ptr = buf; ptr < &buf[nr]? ) {

if (*ptr++ == 0) {

if (ptr != &buf[nr-1])

err_dump("message format error"); status = *ptr & OxFF;    /* prevent sign extension */

if (status == 0) {

if (msg.msg_controllen < CONTROLLEN) err_dump("status = 0 but no fd");

newfd = *(int *)CMSG_DATA(cmptr)；

} else {

newfd = -status;

nr -= 2;

}

}

if (nr > 0 && (*userfunc) (STDERR_FILENO, buf, nr) != nr) return(-1);

if {status >= 0)    /* final data has arrived */

return(newfd);    /* descriptor, or -status */

)

}

图17-14通过UNIX域套接字接收文件描述符

注意，该程序总是准备接收一个描述符（在每次调用recvmsg之前，设置msg_control 和msg_controllen）»但是仗当msg_controllen返回的是非0值时，才确宪接收到描 述符。

回忆serv_accept函数（见图17-9）确定调用者身份的步骤。如果内核能够把调用者的证 书在调用accept之后返回给调用处会更好。某些UNIX域套接字的实现提供类似的功能，但它 们的接口不同，

\* FreeBSD 8.0和Linux 3.2.0都支持通过UNIX域套接字发送证书，但它们的实现方式不同。

\> Mac OS X 10.6.8是部分从FreeBSD派生出来的，但禁止传送证书。Solaris 10不支持通过UNIX ■域套接字传送证书，然而它支持从一个通过STREAMS管道传输文件描述符的进程中获得证书，

这里我们不讨论它的细节。

在FreeBSD中，将证书作为cmsgcred结构待选。

ttdefine CMGROUP_MAX 16 struct cmsgcred {

pid_t    cmcred_pid;    Z*    sender's    process ID */

uid_t    cmcred_uid；    /*    sender’s    real UID */

uid_t    cmcred_euid;    /*    sender's    effective UID */

gid_t    cmcred_gid;    /*    sender's    real GID */

short cmcred_ngroups;    /[8](#bookmark28) [9](#bookmark29) number of groups [9](#bookmark29)/

gid_t cmcred_groups[CMGROUP_MAX];    /[9](#bookmark29) groups [9](#bookmark29)/

[648|

在传送证书时，仅需为cmsgcred结构保留存储空间。内核将填充该结构以防止应用程序伪装成 具有另一种身份。

在Linux中，将证书作为ucred结构传送。

struct ucred {

pid_t pid;    /[9](#bookmark29) sender's process ID [9](#bookmark29)/

uid_t uid;    /[9](#bookmark29) sender's user ID [9](#bookmark29)Z

gid_fc gid; /[9](#bookmark29) sender's group ID [9](#bookmark29)/

与FreeBSD不同，Linux需要在传输前初始化这个结构。内核会确保应用程序要么能够使用对应 调用者的值，要么有使用其他值的合适权限。

图17-15显示了更新过后的send.fd函数，它包含了发送进程的证书。

static struct cmaghdr



*credp; *cmp; iov[l]; msg; buf[2];



send_fd/recv_ufd 2-byte protocol [9](#bookmark29)/



msg.msg_name = NULL; rasg.msg_namelen = 0; msg.msg_flags = 0; if (fd_to_send < 0)(

msg.msg_control = NULL; msg.msg_controllen =0;

buf[1] = -fd_to_send; /* nonzero status means error */ if (buf[1] == 0)

buf[1] = 1;    /* -256, etc. would screw up protocol */

} else {

if (cmptr == NULL && (cmptr = malloc(CONTROLLENJ) == NULL) return(-1);

msg.msg_control = cmptr； msg.msg_controllen = CONTROLLEN; cmp = cmptr;

cmp->cmsg_level = SOL_SOCKET; cmp->cmsg_type = SCM_RIGHTS; cmp->cmsg_len = RIGHTSLEN;

*(int *)CMSG_DATA(cmp) = fd_to_send; /* the fd to pass */

cmp = CMSG_NXTHDR(&msg, cmp);

cmp->cmsg_level = SOL_SOCKET;

cmp->cmsg_type = SCM_CREDTYPE;

cmp->cmsg_len = CREDSLEN;

credp = (struct CREDSTRUCT *)CMSG_DATA{cmp);

\#if defined(SCM_CREDENTIALS)

credp->uid = geteuid(); credp->gid = getegid(); credp->pid = getpid();

\#endif

buf[1] =0;    /* zero status means OK */

}

buf[0] = 0;    /* null byte flag to recv_ufd() */

if (sendmsg(fd, &msg, 0) != 2)

return (-1); return(0);

图17-15通过UNIX域套接字发送证书 注意，只有在Linux上才需要初始化证书结构。

图17-16中的recv.ufd函数是recv_fd的修改版，它通过一个引用参数返回发送者的用户ID。

struct msghdr */



\#if defined(SCM.CREDS) #define CREDSTRUCT #define CR_UID ttdefine SCM_CREDTYPE



/* BSD interface */

cmsgcred

cmcred_uid

SCM_CREDS



\#elif defined(SCM^CREDENTIALS)



/* Linux interface */



ttdefine CREDSTRUCT #define CRJJID #define CREDOPT #define SCM_CREDTYPE #else



ucred

uid

SO_PASSCRED

SCM_CREDENTIALS



terror passing credentials is unsupported! tendif



/* size #define ♦define ♦define



of control RIGHTSLEN CREDSLEN CONTROLLEN



buffer to send/recv one file descriptor */ CMSG_LEN(sizeof(int))

CMSG_LEN(sizeof(struct CREDSTRUCT)) (RIGHTSLEN + CREDSLEN}



static struct cmsghdr



*cmptr = NULL;



/* malloc'ed first time */



\*    Receive a file descriptor from a server process. Also, any data

\*    received is passed to (*userfunc) (STDERR_FILENO, buf, nbytes).

\*    We have a 2-byte protocol for receiving the fd from send_fd().

*/

int

recv_ufd(int fd, uid_t *uidptr,

ssize_t (*userfunc) (int, const void *, size_t))

| struct | cmsghdr    | *cmp;         |
| ------ | ---------- | ------------- |
| struct | CREDSTRUCT | *credp;       |
| char   |            | *ptr;         |
| char   |            | buf[MAXLINE]; |
| struct | iovec      | iov[l];       |
| struct | msghdr     | msg;          |
| int    |            | nr;           |
| int    |            | newfd = -1;   |
| int    |            | status = -1;  |

\#if defined(CREDOPT)

const int    on = 1;

if (setsockopt(fd, SOL_SOCKET, CREDOPT, &onr sizeof(int)) < 0) { err_ret("setsockopt error"); return(-1);

}

\#endif

for { ; ; ) {

iov[0].iov_base = buf;

iov[0].iov_len = sizeof(buf)i

msg.msg_iov    =    iov;

msg.msg_iovlen = 1;

msg.msg_neune = NULL;

msg.msg_namelen = 0;

if (cmptr == NULL && {cmptr =

malloc(CONTROLLEN))



NULL)



return (-1) '•

msg.msg_control = cmptr;

msg.msg_controllen = CONTROLLEN; if "nr = recvmsg (fd, smsg, 0)) < 0) {

err_ret("recvmsg error");

return(-1);

} else if {nr == 0) {

err_ret("connection closed by server")； return(-1);

\*    See if this is the final data with null & status. Null

\*    is next to last byte of buffer； status byte is last byte.

\*    Zero status means there is a file descriptor to receive.

*/

for (ptr = buf; ptr < &buf [nr]，-)( if (*ptr++ == 0) {

if (ptr != &buf[nr-1])

err_dump{"message format error");

status = *ptr & OxFF; /* prevent sign extension */ if {status == 0) {

if (msg.msg_controllen != CONTROLLEN) err_dump("status = 0 but no fd");

/* process the control data */ for (cmp = CMSG_FIRSTHDR(Smsg);

crnp != NULL; cmp = CMSG_NXTHDR(Smsg, cmp)) { if {cmp->cmsg_level != SOL_SOCKET)

continue;

switch {cmp->cmsg_type} { case SCM_RIGHTS:

newfd = *(int *)CMSG_DATA(cmp); break;

case SCM_CREDTYPE:

credp = (struct CREDSTRUCT *)CMSG_DATA(cmp); *uidptr = credp->CR_UID;

}

}

} else {

newfd = -status;

}

nr —= 2;

if (nr > 0 && (*userfunc) {STDERR_FILENO, buf, nr) != nr) return(-1);

if (status >= 0)    /* final data has arrived */

return(newfd);    /* descriptor, or -status */

}

J

图17-16通过UNIX域套接字接收证书

在FreeBSD中，指定SCM_CREDS表示要传送证书。在Linux中，则使用SCM_CREDENTIALS。[652]

[1](#footnote1)

ftinclude "apue.h"

番include <sys/socket.h>

\#include <sys/un.h>

\#include <errno.h>

\#define QLEN    10

/[2](#bookmark11)

\*    Create a server endpoint of a connection.

[2](#footnote2)

   Returns fd if all OK, <0 on error.

*/

int

serv_listen(const char [2](#bookmark11)name)

\#include "apue.h”

\#include <sys/socket.h>

\#include <sys/un.h>

ftinclude <time.h>

linclude <errno.h>

30    /* client's name can't be older than this (sec) */

[3](#footnote3)

\#include "apue.h"

\#include <sys/socket.h>

\#include <sys/un.h>

ftinclude <errno.h>

\#define CLI^PATH    "/var/tmp/"

\#define CLI_PERM    S_IRWXU    /[4](#bookmark15) rwx for user only [4](#bookmark15)/

\*    Create a client endpoint and connect to a server.

[4](#footnote4)

   Returns fd if all OK, <0 on error.

*/

int

cli_conn(const char [4](#bookmark15)name)

{

int    fd, len, err, rval;

struct sockaddr_un    un, sun;

int    do_unlink = 0;

if (strlen(name) >= sizeof(un.sun_path)) { errno = ENAMETOOLONG; return(-1);

[5](#footnote5)

tinclude "apue.h"

♦include <sys/socket.h>

/[6](#bookmark20) size of control buffer to send/recv one file descriptor [6](#bookmark20)/ #define CONTROLLEN CMSG_LEN(sizeof(int)J

static struct cmsghdr [6](#bookmark20)cmptr = NULL; /[6](#bookmark20) malloc'ed first time [6](#bookmark20)/

/[6](#bookmark20)

\*    Pass a file descriptor to another process.

[6](#footnote6)

\#include "apue.h"

\#include <sys/socket.h>    /[7](#bookmark21) struct msghdr [7](#bookmark21)/ /[7](#bookmark21) size of control buffer to send/recv one file descriptor [7](#bookmark21)/

ttdefine CONTROLLEN CMSG_LEN(sizeof(int))

static struct cmsghdr    [7](#bookmark21)cmptr = NULL; /[7](#bookmark21) malloc[7](#bookmark21)ed first time [7](#bookmark21)/

\*    Receive a file descriptor from a server process. Also, any data

\*    received is passed to ([7](#bookmark21)userfunc) (STDERR_FILENO, buf, nbytes).

[7](#footnote7)

   We have a 2-byte protocol for receiving the fd from send_fd().

*/

int recv_fd(int fd, ssize_t ([7](#bookmark21)userfunc)(int, const void [7](#bookmark21), size_t))

[8](#footnote8)

\#include "apue.h"

\#Include <sys/socket.h>

\#if defined(SCM_CREDS)    /[9](#bookmark29) BSD interface [9](#bookmark29)/

tdefine CREDSTRUCT    cmsgcred

\#define SCM_CREDTYPE    SCM_CREDS

\#elif defined(SCM_CREDENTIALS>    /[9](#bookmark29) Linux interface [9](#bookmark29)/

择define CREDSTRUCT    ucred

\#define SCM_CREDTYPE    SCM_CREDENTIALS

\#else

\#error passing credentials is unsupported!

\#endif

/[9](#bookmark29) size of control buffer to send/recv one file descriptor [9](#bookmark29)/ #define RIGHTSLEN    CMSG_LEN(sizeof(int))

♦define CREDSLEN    CMSG_LEN(sizeof(struct CREDSTRUCT))

\#define CONTROLLEN (RIGHTSLEN + CREDSLEN)

*cmptr = NULL; /[9](#bookmark29) malloc'ed first time [9](#bookmark29)/

\*    Pass a file descriptor to another process.

[9](#footnote9)

   If fd<0, then -fd is sent back instead as the */

int

send_fd<int fd, int fd_to_send)

Struct CREDSTRUCT struct cmsghdr struct iovec struct msghdr char

iov[0].iov_base = buf; iov[0],iov_len = 2； msg.msg_iov    =    iov；

msg.msg_iovlen = 1;

\#include "apue.h" #include <sys/socket.h> #include <sys/un.h>


##### 17.5 open服务器进程第1版

使用文件描述符传送技术开发一个open服务器进程--个由一个进程执行以打开一个或

多个文件。该服务器进程不是将文件内容送回调用进程，而是送回一个打开文件描述符。这使该 服务器进程对任何类型的文件（如设备或套接字）而不单是普通文件都能起作用。客户进程和服 务器进程用IPC交换最小量的信息：从客户进程到服务器进程传送文件名和打开模式，而从服务 器进程到客户进程返回描述符。文件内容不需通过IPC交换。

将服务器进程设计成一个单独的可执行程序（或者是由客户进程执行的，这正是本节所说明 的：或者是由守护服务器进程执行的，将在下一节进行说明）有很多优点。

•任何客户进程都能很容易地和服务器进程联系，这类似于客户进程调用一个库函数。我 们没有将特定服务硬编码在应用程序中，而是设计了一种可供重用的设施。

•如若需要更改服务器进程，那么也只影响一个程序。相反，更新一个库函数可能需要更 新调用此库函数的所有程序（即用连接编辑器重新连接）。共享库函数可以简化这种更新 （见7.7节）„

•服务器进程可以是一个设置用户ID程序，于是使其具有客户进程没有的附加权限。注意， 库函数（或共享库函数）不能提供这种能力。

客户进程创建一个fd管道，然后调用fork和exec来调用服务器进程。客户进程使用一端 经fd管道发送请求，服务器进程使用另一端经fd管道回送响应。

定义客户进程和服务器进程间的应用程序协议如下。

（1）    客户进程通过fd管道向服务器进程发送“open <pathname> <openmode>\^n形式的请 求。<^«»«0也>是数值.以ASCII十进制数表示，是open函数的第二个参数。该请求字符串以 null字符终止。

（2）    服务器进程调用send_fd或send_err回送打开描述符或出错消息。

这是一个进程向其父进程发送打开描述符的实例。17.6节将修改此实例来使用一个守护服务 器进程，它的服务器进程将一个描述符发送给一个完全无关的进程。

首先要有一个头文件open.h （见图17-17）,它包括标准头文件，并且定义了函数原型。

\#include "apue .h'*

^include <errno.h>

\#define CL_OPEN "open"    /* client's request for server */

int    csopen（char *, int）;

[6531    图 17-17 open.h 头文件

main函数(见图17-18)是一个循环，它先从标准输入读一个路径名，然后将该文件复制到

标准输出。它调用csopen函数来联系open服务器进程，从其返回一个打开描述符。

\#include    "open.h"

\#include    <fcntl.h>

tdefine BUFFSI2E 8192

int

main(int argc, char *argv[],

int    n, fd;

char    buf[BUFFSIZE];

char    line[MAXLXNEJ;

/* read filename to cat from stdin */

while (fgets(line, MAXLINE, stdin) != NULL) {

if (line[strlen(line) - 1] == '\n')

line[strlen(line) - 1] = 0; Z* replace newline with null */

/* open the file */

if ((fd = csopen(line, O_RDONLY)) < 0)

continue; /* csopen () prints error from server */



}

exit(0);



/* and cat to stdout */

while ((n = read(fd, buf, BUFFSIZE)) > 0) if (write(STDOUT_FILENO, buf, n) != n)

err_sys("write error"); if (n < 0)

err_sys("read error"); close (fd);



图17-18 main函数

函数csopen （见图17-19）在创建了 fd管道之后，进行了服务器进程的fork和exec操作。



\#include    "open.h"

\#include    <sys/uio.h>



/* struct iovec */



/*

\*    Open the file by sending the "name" and "oflag" to the

\*    connection server and reading a file descriptor back. */

int



csopen(char *name,

pid_t

int

char

struct iovec static int



int oflag)

pid;

len；

buf[10];

iov[3];

fd[2] = { -1, -1 }



if (fd【0】< 0) {    /* fork/exec our open server first time */

if (fd_pipe(fd) < 0》{

err_ret("fd_pipe error"); return{-1);

J

if {(pid = forkO) < 0) { err_ret("fork error",; return (-1);

} else if (pid == 0) {    /* child "

close(fd[0]);

if (fd[l] != STDIN_FILENO && dup2(fd[l], STDIN_FILENO) != STDIN_FILENO)

err_sys("dup2 error to stdin"); if (fd[l] != STDOUT_FILENO &&

dup2(fd[l], STDOUT_FILENO) != STDOUT_FILENO) err_sys("dup2 error to stdout")；

if (execl("./opend", "opend", (char *)0) < 0) err_sys("execl error");

}

close(fd(l】};    /* parent */



sprintf(buf, " %d", oflag);    /* oflag to ascii */

iov[0].iov_base = CL_OPEN "    /* string concatenation */

iov[0].iov_len = strlen(CL_OPEN) + 1; iov[l].iov_base = name;

iov[1].iov_len = strlen(name);

iov[2].iov_base = buf;

iov [2] . iov_len = strlen (buf)十 1;    /* +1 for null at end of buf */

len = iov[0].iov_len + iov[1].iov_len + iov[2].iov_len; if (writev(fd[0], fiiov[0], 3) != len)(

err„ret("writev error"); return(-1);

/* read descriptor, returned errors handled by write() */ return(recv_fd(fd[0], write));

图 17-19 csopen 函数

子进程关闭fd管道的一端，父进程关闭另一端。作为服务器进程，子进程也将fd管道的一

端复制到其标淮输入和标准输出。（另一种可选择的方案是，将描述符fd[l]的ASCII表示形式 作为一个参数传送给服务器进程。）

父进程将包含路径名和打开模式的请承发送给服务器进程。最后，父进程调用reCv_fd返回描 岡述符或出错消息。如果服务器进程返回出错消息，那么父进程调用write,向标准错误输出该消息。

现在，让我们来看看open服务器进程。其程序是opend,由图17-19中的子进程执行。首先， 要有一个opend.h头文件（见图17-20〉，它包括标准头文件，并且声明了全局变量和函数原型。

♦include "apue.h"

^include <errno.h>

\#define CL_OPEN "open"



extern char errmsg门； extern int oflag; extern char *pathnarae;



/* client's request for server */

/* error message string to return to client */ /* open{) flag: 0_xxx ... */

/* of file to open() for client */

int    cli_args(int, char **);

void    handle request(char *, int, int>;

图17-20 opend.h头文件

main函数（见图17-21）经fd管道（它的标准输入）读来自客户进程的请求，然后调用函 数 handle_request«,

\#include    "opend.h"

char    errmsg[MAXLINE];

int    oflag;

char *pathname;

int

main(void) {

inc    nread;

char    buf[MAXLINE];

for ( ; ; ) {/* read arg buffer from client, process request */ if ((nread = read{STDIN_FXLENO, buf, MAXLINE)) < 0)

err_sys("read error on stream pipe"); else if (nread == 0)

break；    /* client has closed the stream pipe */

handle_request(buf, nread, STDOUT_FILENO);

)

exit(0);

图17-21服务器进程main函数第1版

图17-22中的harxUejequest函数承担了全部工作。它调用函数buf_argS将客户进程请求分 解成标准argv型的参数表，然后调用函数cli_args处理客户进程的参数。如果一切正常，则调用 open打开相应文件，接着调用Send_fd,经由fd管道(它的标准输出)将描述符回送给客户进程 如果出错则调用send_err回送一则出错消息，其中使用了前面说明的客户进程-服务器进程协议。[656]

\#    include    *'opend.h'*

\#    include    <fcnt1.h>

void

handle_request(char *buf, int nread, int fd)

int    newfd;

if (buf[nread-1] != 0) {

snprintf(errmsg, MAXLINE-1,

"request not null terminated: %*.*s\n", nread, nread, buf); send_err(fd, -1, errmsg); return;

J

if (buf_args(buf, cli_args) < 0) { Z* parse args & set options */ send_err(fd, -1, errmsg); return;

}

if ((newfd = open(pathname, oflag)) < 0) {

snprintf(errmsg, MAXLINE-1, "can't open %s: %s\n", pathname,

strerror(errno)); send_err(fd, -1, errmsg); return；

}

if (send_fd<fd, newfd) < 0)    /* send the descriptor */

err_sys("send_fd error"};

close(newfd);    /* we*re done with descriptor */

}

图 17-22 handle_request 函数第 1 版

客户进程请求是一个以null终止的字符串，它包含由空格分隔的参数。图17-23中的buf_ args函数将字符串分解成标准argv型参数表，并调用用户函数处理参数。我们使用ISO C函 数strtok将字符串分割成独立的参数。

\#include "apue.h"

\#define MAXARGC    50    /[1](#bookmark7) [2](#bookmark8) max number of arguments in buf [2](#bookmark8)/

\#define WHITE " \t\n"    /[2](#bookmark8) white space for tokenizing arguments [2](#bookmark8)/

\*    buf[] contains white-space-separated arguments. We convert it to an

\*    argv-style array of pointers, and call the user[2](#bookmark8)s function (optfunc)

\*    to process the array. We return -1 if there[2](#bookmark8)s a problem parsing buf,

\*    else we return whatever optfunc() returns. Note that user's buf []

\*    array is modified (nulls placed after each token).

*/

int

i__t buf_args (char [2](#bookmark8)buf, int ([2](#bookmark8)optfunc) tint, char [3](#bookmark9)))

[6571 {

char    [2](#bookmark8)ptr, [2](#bookmark8)argv[MAXARGC];

int    argc;

if (strtok(buf, WHITE) == MULL)    /[2](#bookmark8) an argv[0] is required ★/

return(-1);

argv[argc = 0] = buf;

while ((ptr = strtok(NOLL, WHITE)) != NULL) {

if {++argc >= MAXARGC-1)    /[2](#bookmark8) -1 for room for NULL at end [2](#bookmark8)/

return(-1); argv[argc] = ptr;

}

argv【++argc] = NULL;

/[2](#bookmark8)

\*    Since argv[] pointers point into the user's buf[],

\*    user's function can just copy the pointers, even

\*    though argv[] array will disappear on return.

*/

return(([2](#bookmark8)optfunc)(argc, argv))；

J

图 17-23 buf_args 函数

buf_args调用的服务器进程函数是cli_args (见图17-24)。它验证客户进程发送的参数 个数是否正确，然后将路径名和打开模式存储在全局变量中。

pathname = argv[l];    Z[4](#bookmark11) save ptr to pathname to open [4](#bookmark11)/

oflag = atoi(argv【2]); return(0);

图]7-24 cli_args 函数

这样也就完成了 open服务器进程，它由客户进程执行fork和exec来调用。在fork之前 创建了一个fd管道，然后客户进程和服务器进程用其进行通信。在这种安排下，每个客户进程都 有一个服务器进程。    [658]

##### 17.6 open服务器进程第2版

在上一节中，我们开发了一个叩en服务器进程，由客户进程执行fork和exec调用，它说 明了如何从子程序向父程序传送文件描述符。本节将开发一个守护进程方式的open服务器进程。 一个服务器进程处理所有客户进程的请求。由于避免了使用fork和exec，我们期望这个设计 会更有效。在客户进程和服务器进程之间仍使用UNIX域套接字连接，并用实例说明在两个无关 进程之间如何传送文件描述符。我们将使用VZ.3节引入的3个函数：serv_listen> serv_ accept和Cli_COrm。这个服务器进程还将演示一个服务器进程如何处理多个客户进程，为此 要用到14.4节中说明的select和poll菌数。

本节所述的客户进程类似于17.5节中的客户进程。实际上，文件main.c是完全相同的（见 图17-18）。我们将在open.h头文件（见图17-17〉中加入下面这行：

\#define CS_OPEN "/tmp/opend.socket" /[4](#bookmark11) server's well-known name [4](#bookmark11)/

因为在此例中调用的是cli_conn而非fork和exec，所以文件open, c与图17-19中的不同。 修改后如图17-25所示。

/[4](#bookmark11) struct iovec [4](#bookmark11)/



int oflag)

len;

buf(12]; iov[3]; csfd = -1;



iov[0]-iov_base = CL_OPEN " "; /* string concatenation */ iovIO].iov_len = strlen(CL_OPEN) + 1; iov[l].iov_base = name;

iov[l],iov_len = strlen(name);

iov[2].iov_base = buf；

iov【2] . iov_len = strlen (buf > + 1；    /* null always sent */

len = iov[0],iov_len + iov[1】.iov_len + iov[2].iov_len; if {writev(csfd, &iov[0],3) != len) {

err_ret("writev error")； return(-1);

/* read back descriptor; returned errors handled by write。 */ return(recv_fd(csfd, write));

图17-25 csopen函数第2版 客户进程与服务器进程之间使用的协议仍然相同。

接下来再看服务器进程。头文件opend.h （见图17-26）包括了标淮头文件，并且声明了全 局变量和函数原型。

♦include "apue.h"

\#include <errno.h>

释define CS_OPEN "/tmp/opend.socket"    /* well-known name */

\#define CL_OPEN "open"    /★ client's request for server */

| extern  | int            | debug;     |
| ------- | -------------- | ---------- |
| extern  | char           | errmsg【]; |
| extern  | int            | oflag;     |
| extern  | char           | ★pathname; |
| typedef | struct {    /■ |            |
| int     | fd;            | /-         |
| uid_t   | uid;           |            |

} Client;



/* nonzero if interactive (not daemon) */

/* error message string to return to client */ /* open flag: O_xxx ... */

/* of file to open for client */

one Client struct per connected client */ fd, or -1 if available */

extern Client^client;

extern int    client_size;



/* ptr to malloc'ed array */

/* 林 entries in client[] array */



int    cli_args(int, char **);

int    client^add(int, uid„t);

void    client_del(int);

void    loop(void);

void    handle request<char *, int, int, uid t);

图17-26 opend.h头文件第2版

因为此服务器进程处理所有客户进程，所以它必须保存每个客户进程连接的状态。这是用在 opend.h头文件中声明的client数组实现的。图17-27定义了 3个处理此数组的函数。

\#include



"opend.h"



♦define NALLOC    10



/* # client structs to alloc/realloc for */

static void

client_alloc(void)    /* alloc more entries in the client[] array */

int    i;

if (client == NULL)

client = malloc(NALLOC * sizeof(Client));

else

client = realloc(client, (client_size+NALLOC)*sizeof(Client)); if (client == MULL)

err_sys("can11 alloc for client array");

/* initialize the new entries */

for (i = client_size; i < client_size + NALLOC; i++)

client[i].fd = -1;    /* fd of -1 means entry available */

client_size += NALLOC;

\* Called by loop() when connection request from a new client arrives. */

int

client_add(int fd, uid_t uid)

t

int    i;

if (client == NULL}    /* first time we're called */

client_alloc(};

again:

for (i = 0; i < client_size; i++) {

if (client [i] .fd == -1) {    /* find an available entry */

client[i].fd = fd; client[i].uid = uid;

return(i);/* return index in clientt] array */

}

}

/* client array full, time to realloc for more */ client_alloc();

goto again;    /* and search again (will work this time) */

\* Called by loopO when we're done with a client. */

void

client_del《int fd)

{

int    i;

for {i = 0; i < client_size; i++)(

if (client[i].fd == fd) {    |661|

client[i].fd = -1; return;

}

}

log_quit("can't find client entry for fd %d", fd,;

图17-27处理client数组的3个函数

第一?欠调用 client_add 时，它调用 client_alloc. client_alloc 又调用 malloc 为 该数组的10个登记项分配空间。在这10个登记项全部用完后，如若再调用client_add，那么 client_allOC函数将调用realloc来分配附加空间，依靠这种动态空间分配，我们无需在编 译时将估计的数组长度值放入头文件中从而限制client数组的长度。如果出错，这些函数将调 用109_函数(见附录B)，因为我们假定服务器进程是守护进程。

通常服务器进程会作为守护进程运行，但我们想提供一个让其前台运行的选项，同时能够把 分析信息发送到标准错误输出。这应该能使服务器更容易评测和调试，特别是当用户没有权限读 取那些分析信息经常写入的日志文件时。可以使用一个命令行选项来控制服务器是否在前台运行 或者作为守护进程在后台运行。

一个系统的所有命令遵循相同的约定是非常重要的，因为这会提髙它的易用性。如果有人熟 悉某条命令的选项风格，那么若后面的命令使用了其他的风格，他就很容易犯错。

处理命令行空格就很容易发生这样的问题。有些命令需要它的选项和其参数以空格隔开，而 另一些则希望它的参数直接跟在它的选项之后。如果没有遵循一个一致的规则，用户就得记住所 有命令的语法，或者在尝试和调错中调用这些命令。

Single UNIX Specification包括了一系列的约定和规范来保证命令行语法的一致性，其中包括一些建 议，如“限制每个命令行逸项为一个单一的阿拉伯字符”以及“所有选项必须以‘-’作为开头字符'

幸运的是，getopt函数能够帮助命令开发者以一致的方式处理命令行选项。 linclude <unistd.h>

int getopt (int argc, char * const argv[], const char ’options}; extern int optind, opterr, optopt; extern char *optarg;

返回值：若所有选项被处理完，返回-1:否则，返回下一个选项字符 参数和arsy与传入main函数的一样-options参数是一个包含读命令支持的选项字符 的字符串。如果一个选项字符后面接了一个冒号，则表示该选项需要参数；否则，该选项不需要 额外参数。举例来说，如果一条命令的用法说明如下：

command 【-i] [-u username] [-z] filename 则我们可以给getopt侍送一个"iu: z"作为options字符串。

函数getopt—般用在循环体内，循环直到getopt返回-1时退出。每次迭代中，getopt 会返回下一个选项。应用程序负责筛选这些选项，判断是否有冲突，getopt仅负责解释选项并 保证一个标准的格式。

当遇至(J无效的选项时，getopt返回一个问题标记(question mark)而不是这个字符。如果选项缺 少参数，getopt也会返回一个问题标记，但如果选项字符串的第一个字符是冒号，getopt会直接返 回冒号。而特殊的“一”格式则会导致getopt停止处理选项并返回-1。这允许用户侍递以开头 但不是选项的参数。例如，如果有一个名字为“-bar”的文件’下面的命令行是无法删除这个文件的：

rm -bar

因为rm会试图把-bar解释为选项。正确的删除文件的命令应该是： rm -- -bar

getopt函数支持以下4个外部变量。

optarg如果一个选项需要参数，在处理读选项时，getopt会设置optarg指向该选项的 参数字符串。

opterr如果一个选项发生了错误，getopt会默认打印一条出错消息。庇用程序可以通过 设置opterr参数为0来禁止这个行为。

optind用来存放下一个要处理的字符串在argv数组里的下标。它从1开始，每处理一个 参数，getopt都会对其递増k

optopt如果处理选项时发生了错误，getopt会设置optopt指向导致出错的选项字符串。 open服务器进程的main函数(见图17-28〉定义全局变量，处理命令行选项，并且调用loop

函数。如果以-d选项调用服务器进程，则服务器进程将以交互方式运行而非守护进程方式。测试 服务器进程时会用到这个选项。

♦include    "opend.h"

♦include    <syslog.h>

int    debug, oflag, client_size, log_to_stderr;

char    errmsg[MAXLINE];

char *pathname;    _

Client *client = NULL;    「秘习

int

main(int argc, char *argv[])

{

int    c;

log_open("open.serv", LOG_PID, LOG_USER);

opterr = 0;    /* don't want getopt() writing to stderr */

while ((c = getopt(argc, argv, "d")) != EOF) {

switch (c) {

case 'd' :    /* debug */

debug = log_to_stderr = 1; break;

case 1f:

err_quit("unrecognized option: -%c", optopt);

}

if (debug == 0)

daemonize("opend");

loop ();



/* never returns */



图17-28服务器进程main函数第2版

loop函数是服务器进程的无限循环。我们将给出该函数的两种版本。图17-29是使用select 的一种版本。图17-30所示的程序是使用poll的另一种版本。

\#include    "opend.h"

\#include    <sys/select.h> void

loop(void)

(

int    i, n,    maxfd, maxi, listenfd, clifd, nread;

char    buf[MAXLINE];

uid_t    uid;

fd_set    rset,    allset;

FD_ZERO(&allset);

/* obtain fd to listen for client requests on */ if ((listenfd = serv_listen(CS_OPEN)) < 0)

log_sys{"serv_listen error");

FD_SET(listenfd, &allset); maxfd = listenfd;

[^1    maxi = -1;

for ( ; ; ) {

rset = allset;    /* rset gets modified each time around ★/

if ( (n = select (maxfd + 1, &rset, NULL, NULL, NULL” < 0)

log_sys("select error");

if (FD_ISSET(listenfd, &rset)) {

/* accept new client request */

if ((clifd = serv_accept(listenfd, &uid)) < 0)

log_sys(n3erv_accept error: %d", clifd); i » client_add(clifd, uid);

FD_SET(clifd, &allset); if (clifd > maxfd)

maxfd = clifd； /* max fd for select t) */ if (i > maxi)

maxi = i; /* max index in client [ ] array */ log_msg("new connection: uid %d, fd %d", uid, clifd}; continue;

}

for (i = 0; i <= maxi; i++) {    /* go through client[] array */

if ((clifd = client[i].fd) < 0)

continue;

if (FD_ISSET(clifd, &rset))(

/* read argument buffer from client */

if ((nread = read(clifd, buf, MAXLINE)) < 0) {

log_sys("read error on fd %d", clifd);

1 else if {nread == 0) {

log_msg{"closed: uid %dz fd %d", clientfi].uid, clifd);

client_del(clifd);/* client has closed cxn */

FD_CLR(clifd, fiallset); close(clifd);

} else { /[5](#bookmark17) [6](#bookmark18) process client's request [6](#bookmark18)/

handle_request{buf, nread, clifd, client[i].uid);

图17-29使用select的loop函数

此函数调用serv.listen （见图17-8）创建服务器进程与客户进程连接的端点。此函 数的其余部分是一个循环，它从select调用开始。在select返回后，可能会发生下面 两种情况。

（1）    描述符listenfd可以随时读取，这意味着一个新客户进程已调用了 Cli_COnru为了

处理这种情况，我们将调用serv_accept （见图17-9）,然后为新客户进程更新client数组以岡 及与该新客户进程相关的簿记信息。（我们要跟踪select的第一个参数的最髙描述符编号，还 要跟踪使用中的client数组的最髙下标。）

（2）    —个现有的客户进程的连接可以随时读取。这意味着该客户进程已经终止，或者该客户 进程已发送一个新请求。如果read返回0 （文件结束），则表示客户进程已终止。如果read返 回的值大于0,则表示有一个新请求需处理，可以调用request来处理。

用allset描述符集跟踪当前使用的描述符。当新客户进程连接至服务器进程时，会打开此 描述符集的相应位。当该客户进程终止时，会关闭相应位。

因为客户进程的所有描述狩都由内核自动关闭（包括与服务器进程的连接），所以我们总能 知道什么时候客户进程终止了，该终止是否是自愿的。这与XSIIPC机制不同。

使用poll函数的loop函数如图17-30所示。

| int           | i, listenfd, clifd, nread; |
| ------------- | -------------------------- |
| char          | buf[MAXLINE];              |
| uid_t         | uid;                       |
| struct pollfd | *pollfd;                   |
| int           | numfd = 1;                 |
| int           | maxfd = NALLOC;            |

|666|



if ((pollfd = malloc(NALLOC * sizeof(struct pollfd))) == NULL) err_sys C'malloc error");

for (i =0; i < NALLOC; i++) { pollfd[i].fd = -1; pollfd[i] .events = POLLIN'-pollfd[i].revents = 0;

/* obtain fd to listen for client requests on */ if {{listenfd = serv_listen(CS_OPEN)) < 0)

log_sys("serv_listen error"); client_add(listenfd, 0); "we use 【0] for listenfd */ pollfd[0].fd = listenfd;

for ( ; ; , {

if (poll(pollfd, numfd, -1) < 0) log_sys("poll error");

if (pollfd(0].revents & POLLIN) {

/* accept new client request */

if { (clifd = serv_accept {listenfd, &uid” < 0}

log_sys{"serv_accept error: %d", clifd); client_add(clifd, uid);

/* possibly increase the size of the pollfd array */ if (numfd == maxfd)

pollfd = grow_pollfd(pollfd, &maxfd); pollfd【numfd].fd = clifd; pollfd[numfd].events = POLLIN; pollfd[numfd].revents = 0; numfd++;

log_msg("new connection: uid %d, fd %d", uid, clifd);

for (i = 1; i < numfd; i++) {

if (pollfdfi].revents & POLLHUP)(

goto hungup;

} else if <pollfd[i】.revents & POLLIN) {

/* read argument buffer from client */

if ((nread = read(pollfd[i】.fd, buf, MAXLINE)) < 0) {

log_sys<"read error on fd %d", pollfd[i].fd);

} else if (nread == 0) {

hungup:



/* the client closed the connection */ log_msg("closed: uid %d, fd %d",

client[i].uid, pollfd[i].fd); client_del(pollfd[i].fd);

close(pollfd[i].fd);

if (i < (numfd-1)) 1

/* pack the array */ pollfdli】.fd = pollfd[numfd-l].fd; pollfdfi].events = pollfd[numfd-l].events; pollfd[i].revents = pollfd[numfd-l].revents; i--;    /* recheck this entry */

numfd--;

} else {    /* process client's request */

handle_request(buf, nread, pollfd[i].fd,

client[i1.uid);

}

图17-30使用poll的loop圉数

为使打开描述符的数量能与客户进程数量相当，我们动态地为pollfd结构的数字分配空间， 所使用的策略与client_alloc函数分K client数组（见图17-27）时所使用的相同。

pollfd数组中的第一个登记项（下标号为0）用于listenfd描述符。新客户进程连接的 到达由listenfd描述符中的POLLIN指示。如同前述，调用serv_accept来接受该连接。

对于一个现有的客户进程，应当处理来自poll的两个不同事件：由POLLHUP指示的客户进程 终止，由POLLIN指示的来自现有客户进程的一个新请求。即使连接的服务器端还在读取数据，客 户端也能够关闭它这端的连接。即使连接的一端己经被标记为挂起状态，服务器仍然可以读取在它 那端队列里的数据，当然，服务器在收到客户端的挂起消息时用close关闭到客户端的连接，可有 效地抛弃所有队列里的数据。剩下的请求也没必要处理，因为我们已经无法发回响应的信息。

如同此函数的select版本，调用request函数（见图17-31）处理来自客户进程的新请求。 此函数类似于其早期版本（见图17-22）。忘调用同一函数buf_args （见图17-23），buf_args 又调用cli_argS （见图17-24〉，但是，因为它是在一个守护进程中运行的，所以它在日志文件 中记录出错消息，而不是在标准错误上打印它们。

\#include    "opend.h"

\#include    <fcntl.h>

void

handle_request(char *buf, int nread, int clifd, uid_t uid) (

int    newfd;

if (buf[nread-11 != 0) {

snprintf(errmsg, MAXLINE-1,

"request from uid %d not null terminated: %*.*s\n", uid, nread, nread, buf);

send„err(clifd, -1, errmsg); return;

)

16681



log_msg("request: %s, from uid %d", buf, uid);

/* parse the arguments, set options */ if (buf_args(buf, cli_args) < 0) {

send_err(clifd, -1, errmsg}；

log_msg(errmsg);

return;

}

if ((newfd = open{pathname, oflag)) < 0) {

snprintf(errmsg, MAXLINE-1, "can1t open is: %s\n",

pathname, strerror(errno)); send_err{clifd, -1, errmsg); log_msg(errmsg);

return;

I

/* send the descriptor */ if (send_fd{clifd, newfd) < 0)

log_sys("send_fd error");

log_msg("sent fd %d over fd %d for %s", newfd, clifd, pathname); close(newfd);    /* we're done with descriptor */

}

图 17-31 request 函数

这就完成了 open服务器进程第2版，它仅使用一个守护进程就处理了所有的客户进程请求。

##### 17.7小结

本章的关键点是如何在两个进程之间传送文件描述符，以及服务器进程如何接受来自客户进 程的唯一连接。虽然所有平台都支持UNIX域套接字（见图15-1）,但是各种实现都有不同之处， 这使我们很难开发可移植的应用程序。

整章都使用了 UNIX域套接字。我们了解了如何用它们来实现一个全双工的管道以及如何利 用它们来适应14.4节的I/O多路转接函数以间接地用于XSI消息队列中。

本章给出了 open服务器进程的两个版本。一个版本由客户进程用fork和exec直接调用， 另一版本是一个守护服务器进程处理所有客户进程请求。这两个版本均采用文件描述符传送和接 收函数。

我们还展示了如何使用getopt函数来保证命令行参数处理的一致性。最终的open服务器 进程版本使用了 getopt函数、17.3节中引入的客户进程-服务器进程连接函数和14.4节中的I/O

[669]多路转接函数，

习题

17.1我们选择使用图17-3中的UNIX域数据报套接字，因为它们能够保留消息边界。描述如果 使用常规的管道实现需要哪些必要的改动。我们应当如何避免额外的两次消息复制呢？

17.2使用本章描述的文件描述符侍送函数以及8.9节中描述的父进程和子进程同步例程，编写具 有下列功能的程序。该程序调用fork,子进程打开一个现有的文件并将打开文件描述符传 送给父进程。然后，子进程调用lseek确定该文件的当前读、写位置，通知父进程。父进

程读该文件的当前偏移量，并打印它以便验证。若此文件按上述方式从子进程传递到父进 程，则父进程和子进程应共享同一个文件表项，所以当子进程每次更改该文件当前偏移量 时，这种更改应该也会影响父进程的描述符。使子进程将该文件定位至一个不同偏移量，

并再次通知父进程。

17.3图17-20和图17-21中的程序分别定义和声明了全局变量，两者的区别是什么？

17.4改写bUf_args函数（见图17-23），删除其中对argv数组长度的编译时限制。请用动态 存储分配。

17.5描述优化图17-29和图17-30中的loop函数的方法，并实现之。

17.6在serHisten函数（见图17-8）中，如果文件己经存在，我们要先对代表UNIX域套 接字的文件名解除链接。为了防止误删除不是套接字的文件，我们可以先调用stat来验证 文件类型。解释这种做法存在的两个问题。

17.7请给出两种可能的方法，使得单次调用sendmsg可以传递多个文件描述符。尝试实现你的

方法并验证你的操作系统是否支持这样的方法。    [670]

[1](#footnote1)

\#include "opend.h"

/[2](#bookmark8)

\*    This function is called by buf_args(), which is called by

\*    handle_request(). buf_args(| has broken up the client's

[2](#footnote2)

   buffer into an argv[]-style array, which we now process.

[3](#footnote3)

\#include    "open.h"

\#include    <sys/uio.h> /[4](#bookmark11)

\*    Open the file by sending the "name" and "oflag" to the

[4](#footnote4)

   connection server and reading a file descriptor back.

[5](#footnote5)

ttinclude    "opend.h"

♦include    <poll.h>

\#define NALLOC    10 /[6](#bookmark18) # pollfd structs to alloc/realloc [6](#bookmark18)/

static struct pollfd [6](#bookmark18)

grow^pollfd(struct pollfd [6](#bookmark18)pfd, int [6](#bookmark18)naxfd)

int    i;

int    oldmax    =    [6](#bookmark18)maxfd;

int    newmax    =    oldmax +    NALLOC;

if ((pfd = realloc(pfd, newmax [6](#bookmark18) sizeof(struct pollfd))) == NULL) err_sys("realloc error");

for (i = oldmax; i < newmax; i++) { pfd[i].fd = -1; pfd[i].events = POLLIN; pfd[i].revents =0;

}

[6](#footnote6)

maxfd = newmax； return(pfd);

}

void

loop(void)
