第15章

### 面向对象程序设计



<591~|



内容

面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。第7章己经介绍 了数裾抽象的知识，本草将介绍继承和动态绑定。

继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其他类 相似但不完全相的新类；二是在使用这辟彼此相似的类编写程序时，我们可以在-定程 度上忽略掉它们的区别。

H92>    在很多程序中都存在着一些相互关联但是有细微差别的概念。例如，书店中不同书籍

的定价策略可能不同：有的书籍按原价销售，有的则打折销售。有时，我们给那些购买书 籍超过一定数量的顾客打折；另一些时候，则只对前多少本销售的书籍打折，之后就调回 原价，等等。面向对象的程序设计(OOP)适用于这类应用。

沿15.1 OOP:概述

面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动 态绑定。通过使用数据抽象，我们可以将类的接口与实现分离(见第7章)；使用继承，

可以定义相似的类型并对其相似关系建模：使用动态绑定，可以在一定程度上忽略相似类 型的区别，而以统一的方式使用它们的对象。

继承

通过继承(inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部 有一个基类(base class),其他类则直接或间接地从基类继承而来，这些继承得到的类称 为派生类(derived class)。基类负责定义在层次关系中所有类共同拥有的成员，而每个派 生类定义各自特有的成员。

为了对之前提到的不同定价策略建模，我们首先定义一个名为Quote的类，并将它 作为层次关系中的基类。Quote的对象表示按原价销售的书籍。Quote派生出另一个名 为Bulk_quote的类，它表示可以打折销售的书籍。

这些类将包含下面的两个成员函数：

•    isbn(),返回书籍的ISBN编号。该操作不涉及派生类的特殊性，因此只定义在 Quote类中。

•    net_price(siZe_t),返回书籍的实际销售价格，前提是用户购买该书的数量 达到一定标准。这个操作显然是类型相关的，Quote和Bulk_quote都应该包含 该函数。

在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于 某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成 虚函数(virtual function)。因此，我们可以将Quote类编写成：

class Quote { public:

std::string isbn () const;

virtual double net_price(std::size_t n) const;

}；

派生类必须通过使用类派生列表(class derivation list)明确指出它是从哪个(哪些)基类 继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表， 其中每个基类前面可以有访问说明符：

class Bulk_quote : public Quote {    // Bulk_quote 继承了 Quote

public:

double net_price(std::size_t) const override;

}；

因为Bulk_quote在它的派生列表中使用了 public关键字，因此我们完全可以把

Bulk_quote的对象当成Quote的对象来使用。

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之 前加上virtual关键字，但是并不是非得这么做。出于15.3节(第538页)将要解释的 原因，C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具 体措施是在该函数的形参列表之后增加一个override关键字。

动态绑定

通过使用动态绑定(dynamic binding),我们能用同一段代码分别处理Quote和 Bulk_quote的对象。例如，当要购买的书籍和购买的数量都己知时，下面的函数负责打 印总6费用：

//计算并打印销售给定数量的某种书籍所得的费用 double print_total(ostream &os,

const Quote &item, size_t n)

{

//根据传入item形参的对象类型调用Quote: :net_price // 或者 Bulk_quote: : net_price double ret = item.net_price(n);

os << "ISBN: " « item, isbn ()    // 调用 Quote: : isbn

«，’ # sold: " << n « " total due: '* « ret << endl;

return ret;

}

该函数非常简单：它返回调用net_PriCe()的结果，并将该结果连同调用isbn (>的结 果一起打印出来。

关于上面的函数有两个有意思的结论：因为函数print_total的item形参是基类 Quote的一个引用，所以出于15.2.3节(第534页)将要解的原因，我们既能使用基类 Quote的对象调用该函数，也能使用派生类Bulk_quote的对象调用它:又因为print_total 是使用引用类型调用net_Price函数的，所&出于15.2.1节(第528页)将要^释的原 因，实际传入print_total的对象类型将决定到底执行net_price的哪个版本：

// basic 的类型是 Quote; bulk 的类型是 Bulk_quote

print_total (cout, basic, 20);    // 调用 Quote 的 net_price

print_total (cout, bulk, 20) ;    // 调用 Bulk一quote 6勺 net一price

第一条调用句将Quote对象传入print_total，因此当print_total调用 net_price时，执行的是Quote的版本；在第二条调用语句中，实参的类型是 Bulk_quote,因此执行的是Bulk_quote的版本(计算打折信息)。因为在上述过程中 函数运行版本由实参决定，即在运_行时选择函数的版本，所以动态绑定有时又被称为运

<59^1



行时鄉定(run-time binding)。

S在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动 态绑定。

##### 15.2定义基类和派生类

定义基类和派生类的方式在很多方面都与我们已知的定义其他类的方式类似，但是也 有一些不同之处。本节将介绍在定义有继承关系的类时可能用到的基本特性。

###### 50 15.2.1定义基类

我们首先完成Quote类的定义：

class Quote { public:

Quote () = default;    // 关于=default 请参见 7.1.4 节(第 237 页)

Quote (const std::string &book, double sales_price):

bookNo(book), price(sales_price) { } std::string isbn () const { return bookNo; }

//返回给定数量的书籍的销售总额

//派生类负责改写并使用不同的折扣计算算法

virtual double net_price(std::size_t n) const

{ return n * price; }

virtual -Quote () = default; //对析构函数进行动态绑定 private:

std: : string bookNo;    // 书籍的 ISBN 编号

protected:

double price = 0.0;    //代表普通状态下不打折的价格

}；

对于上面这个类来说，新增的部分是在net_Price函数和析构函数之前增加的virtual 关键字以及最后的protected访问说明符。我们将在15.7.1节(第552页)详细介绍虚 析构函数的知识，现在只需记住作为继承关系中根节点的类通常都会定义一个虚析构 函数。

基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如 d此：

成员函数与继承

派生类可以继承其基类的成员，然而当遇到如net_price这样与类型相关的操作时， □§5＞派生类必须对其重新定义，换句话说，派生类需要对这些操作提供自己的新定义以覆盖

(override)从基类继承而来的旧定义。

在C++语言中，基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进 行覆盖的函数：另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通 常将其定义为虚函数(virtual)。当我们使用指针或引用调用虚函数时，该调用将被动态绑 定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某 个派生类的版本，

基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑 定。任何构造函数之外的非静态函数(参见7.6节，第268页)都可以是虚函数。关键字 virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把 一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。我们将在15.3节(第 536页)介绍更多关于虚函数的知识。

成员函数如果没被声明为虚函数，则其解析过程发生在编译吋而非运行时，对于isbn 成员来说这正是我们希望看到的结果。isbn函数的执行与派生类的细节无关，不管作用 于Quote对象还是Bulk_quote对象，isbn函数的行为都一样。在我们的继承层次关 系中只有一个isbn函数，因此也就不存在调用isbn ()时到底执行哪个版本的疑问。

访问控制与继承

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类 继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有 成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员， 同时禁止其他用户访问。我们用受保护的(protected)访问运算符说明这样的成员。

我们的Quote类希望它的派生类定义各自的net_price函数，因此派生类需要访 问Quote的price成员。此时我们将price定义成受保护的。与之相反，派生类访问 bookNo成员的方式与其他用户是一样的，都是通过调用isbn函数，因此bookNo被定 义成私有的，即使是Quote派生出来的类也不能直接访问它。我们将在15.5节(第542 页)介绍更多关于受保护成员的知识。

###### 15.2.1节练习

练习15.1:什么是虚成员？

练习15.2： protected访问说明符与private有何区别？ 练习15.3:定义你自己的Quote类和print total函数。

###### 15.2.2定义派生类

派生类必须通过使用类派生列表(class derivation list)明确指出它是从哪个(哪些) 基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列 表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者 private。

派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明，因此，我们的 Bulk_quote类必须包含一个net_price成员：

class Bulk_quote : public Quote {    // Bulk_quote 继承自 Quote

public:

Bulk_quote() = default;

Bulk_quote(const std::strings, double, std::size_t, double);

// O基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override;

private:

std: : size_t min_qty = 0;    //适用折加政策的最低购买量

double discount = 0.0;    //以小数表示的折扣额

}；

我们的Bulk_quote类从它的基类Quote那里继承了 isbn函数和bookNo、price等 数据成员。外，它还定义了 net_price的新版本，同时拥有两个新增加的数据成员 min_qty和discount。这两个成员分别用于说明享受折扣所需购买的最低数量以及一 旦该&量达到之后具体的折扣信息。

我们将在15.5节(第543页)详细介绍派生列表中用到的访问说明符。现在，我们只 需知道访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。

如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们 能将公有派生类型的对象绑定到基类的引用或指针上。因为我们在派生列表中使用了

public,所以Bulk_quote的接口隐式地包含isbn函数，同时在任何需要Quote的 引用或指针的地方我们都能使用Bulk_quote的对象。

大多数类都只继承自一个类，这种形式的继承被称作“单继承”，它构成了本章的主 题。关于派生列表中含有多于一个基类的情况将在18.3节（第710页）中介绍。

派生类中的虚函数

派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个 虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这么做。我们将在 15.3节（第538页）介绍其原因，C++11新标准允许派生类显式地注明它使用某个成员函 数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数（参见 7.1.2节，第231页）的const关键字后面、或者在引用成员函数（参见13.6.3节，第483 贞）的引用限定符后面添加一个关键字override。

□9^派生类对象及派生类向基类的类型转换

-个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子 对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对 象也有多个。因此，一个Bulk_quote对象将包含四个数据元素：它从Quote继承而来 的bookNo和price数据成员，以及Bulk_quote自己定义的min_qty和discount 成员。

C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为 Bulk_quote的对象包含如图15.1所示的两部分。

Bulk_quote 对象

从Quote继承而来的 成员



Bulk_quote自定义的 成员



bookNo

price

min_qty

discount

在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的图15.1只是表 示类工作机理的概念模型，而非物理模型，

图15 J : Bulk quote对象的概念结构

因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成 基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。

| Quote item; |       | //   |
| ----------- | ----- | ---- |
| Bulk quote  | bulk; | //   |
| Quote *p =  |       | //   |
| p = &bulk;  |       | //   |
| Quote &r =  | bulk; | //   |

基类对象

派生类对象

p指向Quote对象 p指向bulk的Quote部分 r绑定到bulk的Quote部分

这种转换通常称为派生类到基类的（derived-to-base）类型转换。和其他类型转换一样，编 译器会隐式地执行派生类到基类的转换（参见4.11节，第141页）。

这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引

用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方，

![img](C++  Primer 5-134.jpg)



在派生类对象中含有与其基类对应的组成部分' 这一事实是继承的关键所在。

< 598 I



派生类构造函数

尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些 成员=和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它 的基类部分。

![img](C++  Primer 5-135.jpg)



每个类控制它自己的成员初始化过程。

派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段 (参见7.5.1节，第258页)执行初始化操作的。类似于我们初始化成员的过程，派生类构 造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个 参数的Bulk_quote构造函数如下所示：

Bulk_quote(const std::strings book, double p, std::size_t qty, double disc):

Quote(book, p), min_qty(qty), discount(disc) { }

//与之前一致

};

该函数将它的前两个参数(分别表示ISBN和价格)传递给Quote的构造函数，由Quote 的构造函数负责初始化Bulk_quote的基类部分(即bookNo成员和price成员)。当 (空的)Quote构造函数体结后，我们构建的对象的基类部分也就完成初始化了。接下 来初始化由派生类直接定义的min_qty成员和discount成员。最后运行Bulk_quote 构造函数的(空的)函数体，

除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。 如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函 数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对 象的基类部分。

首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员c

派生类使用基类的成员

派生类可以访问基类的公有成员和受保护成员：

II如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了 double Bulk_quote::net_price(size_t cnt) const {

if (cnt >= min_qty)

return cnt * (1 - discount) * price;

else

return cnt * price;

}

该函数产生_■个打折后的价格：如果给定的数量超过了 min qty,则将discount ( —

< 599 |



个小于1大于0的数)作用于price-

我们将在15.6节(第547页)进一步讨论作用域，目前只需要了解派生类的作用域嵌 套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员(例如 min_qty和discount)的方式与使用基类成员(例如price)的方式没什么不同。

关键概念：遵循基类的接N

必须明确一点：每个类负责定义各自的接口。要想与类的对象交互必须使用该类的 接口，即使这个对象是派生类的基类部分也是如此。

因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生 类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做0和使用基 类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始 化那些从基类中继承而来的成员。：

继承与静态成员

如果基类定义了一个静态成员(参见7.6节，第268页)，则在整个继承体系中只存在 该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存 在唯一的实例。

class Base { public:

static void statmem();

}；

class Derived : public Base { void f (const DerivedS);

}；

静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访 问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它：

void Derived::f(const Derived &derived_obj)

{

Base : : statmem () ;    // 正确：Base 定义了 statmem

Derived: : statmem () ;    // 正确：Derived 继承了 statmem

//正确：派生类的对象能访问基类的静态成员

derived_obj . statmem () ;    // 通过 Derived 对象访问

statmem () ;    //通过this对象访问

}

派生类的声明

派生类的声明与其他类差别不大(参见7.3.3节，第250页)，声明中包含类名但是不 包含它的派生列表：

class Bulk_quote : public Quote; //错误：派生列表不能出现在这里 class Bulk_quote;    //正确：声明派生类的正确方式

一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如 一个类、一个函数或一个变量等。派生列表以及与定义有关的其他细节必须与类的主体一 起出现。

被用作基类的类

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明：

class Quote;    //声明但未定义

//错误：Quote必须被定义

class Bulk_quote : public Quote { ...    };

这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使 用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即一个类 不能派生它本身。

一个类是基类，同时它也可以是一个派生类，

class Base { /* ..•*/ };

class DI: public Base { /*■••*/ };

class D2: public DI { /*...*/ };

在这个继承关系中，Base是DI的直接基类(direct base),同时是D2的间接基类(indirect base)。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。

每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接 基类的成员；该直接基类的成员又含有其基类的成员；依此类推直至继承链的顶端。因此, 最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

防止继承的发生

有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作岡 为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类 名后跟一■个关键字final：

class NoDerived final { /* */ }; class Base { /* */ };

// NoDerived不能作为基类



// Last不能作为基类

// 错误：NoDerived 是 final 的 //错误：Last是final的



// Last是final的；我们不能继承Last class Last final : Base { /* */ }; class Bad : NoDerived { /* */ }; class Bad2 : Last { /* */ };

<603



###### 15.2.2节练习

练习15.4:下面哪条声明语句是不正确的？请解释原因。 class Base { ... };

(a)    class Derived : public Derived { ... };

(b)    class Derived : private Base { ... };

(c)    class Derived : public Base;

练习15.5:定义你自己的Bulk_quote类。

练习15.6:将Quote和Bulk_quote的对象传给15.2.1节(第529页)练习中的 print_total函数，检查该函数是否正确。

练习15.7:定义一个类使其实现一种数量受限的折扣策略，具体策略是：当购买书籍的 数量不超过一个给定的限量时享受折扣，如果购买量一旦超过了限量，则超出的部分将 以原价销售。

15.2.3类型转换与继承

WARNING



理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关楗所在，:,

通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与 对象的类型一致（参见2.3.1节，第46贞和2.3.2节，第47页），或者对象的类型含有一 个可接受的const类型转换规则（参见4.11.2节，第144页）》存在继承关系的类是一个重 耍的例外：我们可以将基类的指针或引用绑定到派生类对象上。例如，我们可以用Quotes 指向-'个Bulk_quote对象，也可以把一个Bulk_quote对象的地址赋给一'bQuote*.

可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的 引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对 象可能是基类的对象，也可能是派生类的对象。

a和内置指针一样，智能指针类（参见12.1节，第400页）也支持派生类向基类 的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智 能指针内

静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型（static type）与该表达式表示对象的动态类型（dynamic type）区分开來。表达式的静态类型在编 译时总是已知的，它是变量声明时的类型或表达式生成的类型：动态类型则是变量或表达 式表示的内存中的对象的类型。动态类型直到运行时才可知。

L§Q?〉 例如，当 print_total 调用 net_price 时（参见 15.1 节，第 527 页）： double ret = item.net_price（n）;

我们知道item的静态类型是Quotes,它的动态类型则依赖于item绑定的实参，动态 类型直到在运行时调用该函数时才会知道。如果我们传递一个Bulk_quote对象给 print_total，则item的静态类型将与它的动态类型不-•致。如前所述，item的静态 类型是Quotes,而在此例中它的动态类型则是Bulk_quote。

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。例如， Quote类型的变量永远是一个Quote对象，我们无论如何都不能改变该变量对应的对象 的类型。

）7^基类的指针或引用的静态类型可能与其动态类型不一致，读者一定要理解其中 的原因。

不存在从基类向派生类的隐式类型转换……

之所以存在派生类向基类的类型转换是因为毎个派生类对象都包含一个基类部分，而 基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在， 也可以作为派生类对象的一部分存在=如果基类对象不是派生类对象的一部分，则它只含 有基类定义的成员，而不含有派生类定义的成员。

因为一个基类的对象可能是派生类对象的一部分.也可能不是，所以不存在从基类向 派生类的自动类型转换：

Quote base;

Bulk_quote* bulkP = &base;    //错误：不能将基类转换成派生类

Bulk_quote& bulkRef = base;    //错误：不能将基类转换成派生类

如果上述赋值是合法的，则我们有可能会使用bulkP或bulkRef访问base中本不存在 的成员。

除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对 象上，我们也不能执行从基类向派生类的转换：

Bulk_quote bulk;

Quote *itemP = &bulk;    // 正确：动态类型是 Bulk_quote

Bulk_quote *bulkP = itemP;    //错误：不能将基类转换成派生类

编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检 查指针或引用的静态类型来推断该转换是否合法。如果在基类中含有一个或多个虚函数，

我们可以使用dynamic_caSt （参见19.2.1节，第730页）请求一个类型转换，该转换 的安全检查将在运行时行。同样，如果我们己知某个基类向派生类的转换是安全的，则 我们可以使用static_caSt （参见4.11.3节，第144页）来强制覆盖掉编译器的检查工作。

……在对象之间不存在类型转换

派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之＜3oT] 间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是 这种转换的实际发生过程往往与我们期望的有所差别。

请注意，当我们初始化或赋值一个类类型的对象时，实际上是在调用某个函数。当执 行初始化时，我们调用构造函数（参见13.1.]节，第440页和13.6.2节，第473页）；而 当执行赋值操作时，我们调用赋值运算符（参见13.1.2节，第443页和13.6.2节，第474 页）。这些成员通常都包含一个参数，该参数的类型是类类型的const版本的引用。

因为这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/

移动操作传递一个派生类的对象。这些操作不是虚函数。当我们给基类的构造函数传递一 个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基 类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的 赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员。

例如，我们的书店类使用了合成版本的拷贝和赋值操作（参见13.1.1节，第440页和 13.1.2节，第444页）。关于拷贝控制与继承的知识将在15.7.2节（第552页）做更详细的 介绍，现在我们只需要知道合成版本会像其他类一样逐成员地执行拷贝或赋值操作：

Bulk_quote bulk;    // 派生类对象

Quote item （bulk） ;    // 使用 Quote : :Quote （const Quote&）构造函数

item = bulk;    // 调用 Quote : : operator= （const Quotes）

当构造item时，运行Quote的拷贝构造函数。该函数只能处理bookNo和price两个 成员，它负责拷贝bulk中Quote部分的成员，同时忽略掉bulk中Bulk_quote部分 的成员。类似的，对于将bulk赋值给item的操作来说，只有bulk中Quite部分的成 员被赋值给item。

因为在上述过程中会忽略Bulk_quote部分，所以我们可以说bulk的Bulk_quote 部分被切掉（sliced down） 了。

A 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象 中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉

###### 15.2.3节练习

练习15.8:给出静态类型和动态类型的定义。

练习15.9:在什么情况下表达式的静态类型可能与动态类型不同？请给出三个静态类型 与动态类型不同的例子。

练习15.10：回忆我们在8.1节（第279页）进行的讨论，解释第284页中将ifstream 传递给Sales data的read函数的程序是如何工作的。

关键概念：存在继承关系的类增之间的转换规则

要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：

•从派生类向基类的类型转换只对指针或引用类型有效。

•基类向派生类不存在隐式类型转换。

•和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不 可行。我们将在15.5节（第544页）详细介绍可访问性的问题。

尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或 隐式地）定义了拷贝控制成员（参见第13章）。因此，我们通常能够将一个派生类对象 拷贝、移动或赋值给一个基类对象不过需要注意的是，这种操作只处理派生类对象的 基类部分。

浥15.3虚函数

如前所述，在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执 行动态绑定（参见15.1节，第527页）。因为我们直到运行时才能知道到底调用了哪个版 本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，则 无须为该函数提供定义（参见6.1.2节，第186页）。但是我们必须为每一个虚函数都提供 定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。 对虚函数的调用可能在运行时才被解析

当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调 用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那

—个。

举个例子，考虑15.1节（第527页）的print_total函数，该函数通过其名为item 的参数来进一步调用net_price，其中item的类型是Quotes。因为item是引用而 且net_price是虚函数，所以我们到底调用net_price的哪个版本完全依赖于运行时 绑定到item的实参的实际（动态）类型：

Quote base（"0-201-82470-1", 50）;

print_total （cout, base, 10） ;    // 调用 Quote::net_price

Bulk quote derived（"0-201-82470-1", 50, 5,    .19）;

print_total （cout, derived, 10）;    // 调用 Bulk_quote: :net_price

在第一条调用语句中，item绑定到Quote类型的对象上，因此当print_total调用 net_price时，运行在Quote中定义的版本。在第二条调用语句中，item绑定到 Bulk_quote 类型的对象上，因此print_total 调用 Bulk_quote 定义的 net_price。

必须要搞清楚的一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发 生。

base = derived;    // 把 derived 的 Quote 部分拷贝给 base

base.net—price （20） ;    // 调用 Quote: :net_price

当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将 调用的版本确定下來。例如，如果我们使用base调用net_price,则应该运行 net_price的哪个版本是显而易见的。我们可以改变base表示的对象的值（即内容）， 但是¥会改变该对象的类型，因此，在编译时该调用就会被解析成Quote的net_price。

关键概念：C++的多态性:

OOP的核心思想是多态性（polymorphism）多态性这个词源自希腊语，其含义是 ‘‘多种形式”。我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型 的“多种形式”而无须在意它们的差异。引用或指针的静态类型与动态类型不同这一事 实正是C杆语言支持多态性的根本所在。

当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数 真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对 象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引 用或指针所绑定的对象的真实类型。

另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数（虚 函数或非虚函数）调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不 可能令对象的动态类型与静态类型不一致。因此.通过对象进行的函数调用将在编译时 绑定到该对象所属类中的函数版本上。

![img](C++  Primer 5-137.jpg)



当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有 在这种情况下对象的动态类型才有可能与静态类型不同，

派生类中的虚函数

当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函 数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中 它都是虚函数、

一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆 盖的基类函数完全-致。

同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当 类的虚函数返网类呕是类+身的指针或引用吋，上述规则无效。也就是说，如果D由B派＜ 606 | 生得到，则基类的虚函数可以返回B*而派生类的对应函数可以返回D*,只不过这样的返 回类型要求从D到B的类型转换是可访问的。15.5节（第544页）将介绍如何确定一个基 类的可访问性，在15.8.1节（第561页）中我们将看到这种虚函数的一个实际例子。

![img](C++  Primer 5-138.jpg)



基类中的虚函数在派生类中隐含地也是一个虚函数当派生类覆盖了某个虚函 数时，该函数在基类中的形参必须与派生类中的形参严格匹配。

final和override说明符

如我们将要在15.6节(第550页)介绍的，派生类如果定义了一个函数与基类中虚函 数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数 与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。就 实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能 覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。

要想调试并发现这样的错误显然非常困难。在C+H1新标准中我们可以使用 override关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图更加清 晰的RJ吋让编译器可以为我们发现一些错误，后者在编程实践中显得更加重要。如果我们 使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将 报错：

struct B {

| virtual void fl(int) const; |                |                 |                         |                               |
| --------------------------- | -------------- | --------------- | ----------------------- | ----------------------------- |
| virtual void                | f 2 ();        |                 |                         |                               |
| void                        | f3();          |                 |                         |                               |
| ｝；                        |                |                 |                         |                               |
| struct DI                   | :B {           |                 |                         |                               |
| void                        | fl(int)        | const override; | //                      | 正确：fl与基类中的fl匹配      |
| void                        | f2(int)        | override;       | //                      | 错误：B没有形如f2 (int)的函数 |
| void                        | f3() override; | //              | 错误：f3不是虚函数      |                               |
| void                        | f4() override; | //              | 错误：B没有名为f4的函数 |                               |

｝；

在D1中，fl的override说明符是正确的，因为基类和派生类中的fl都是const成 员，并且它们都接受一个int返回void,所以D1中的fl正确地覆盖了它从B中继承 而来的虚函数。

D1中f2的声明与B中f2的声明不匹配，显然B中定义的f2不接受任何参数而D1 的f2接受一个int，因为这两个声明不匹配，所以D1的f2不能覆盖B的f2,它是一 个新函数，仅仅是名字恰好与原来的函数一样而已。因为我们使用override所表达的 意思是我们希望能覆盖基类中的虚函数而实际上并未做到，所以编译器会报错。

因为只有虚函数才能被覆盖，所以编译器会拒绝D1的f 3。该函数不是B中的虚函数, [M＞因此它不能被覆盖=类似的，f 4的声明也会发生错误，因为B中根本就没有名为的函数。

我们还能把某个函数指定为final,如果我们己经把函数定义成final 了，则之后 任何尝试覆盖该函数的操作都将引发错误：

struct D2 : B ｛

// 从 B 继承 f2 ()和 f3 (),覆盖 fl(int)

void fl (int) const final; //不允许后续的其他类複盖fl (int)

｝；

struct D3 : D2 ｛

void f2() ;    //正确：覆盖从间接基类B继承而来的f2

void fl (int) const;    // 错误：D2 已经将 f2 声明成 final

｝；

final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置 返回类型（参见6.3.3节，第206页）之后。

虚函数与默认实参

和其他函数一样，虚函数也可以拥有默认实参（参见6.5.1节，第211页）。如果某次 函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。

换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参， 即使实际运行的是派生类中的函数版本也是如此。此吋，传入派生类函数的将是基类函数 定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。

如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致、

回避虚函数的机制

在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数 的某个特定版本。使用作用域运算符可以实现这一目的，例如下面的代码：

//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么 double undiscounted = baseP->Quote::net_price（42）;

该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是 什么。该调用将在编译时完成i析。

![img](C++  Primer 5-139.jpg)



通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回 避虚函数的机制。

什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它 覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要 做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。

A

WARNING



如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算 符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限 递归。

< 608 I



###### 15.3节练习

练习15.11:为你的Quote类体系添加一个名为debug的虚函数，令其分别显示每个 类的数据成员。

练习15.12:有必要将一个成员函数同时声明成override和final吗？为什么？ 练习15.13:给定下面的类，解释每个print函数的机理：

class base { public:

string name（）    { return basename; }

virtual void print（ostream &os） { os « basename; } private:

string basename;

}；

class derived : public base { public:

void print (ostream &os)    { print (os); os << " •’ « i; }

private:

int i;

}；

在上述代码中存在I'nj题吗？如果有，你该如何修改它？

练习15.14:给定上一题中的类以及下面这些对象，说明在运行时调用哪个函数:

base bobj; derived dobj;

(a) bobj .print ();

(d) bp2->name();



base *bpl = &bobj; base *bp2 = &dobj;

(b) dobj .print ()

(e) brl .print ();



base &brl = bobj; base &br2 = dobj;

(c) bpl->name ();

(f) br2 . print ();



##### 15.4抽象基类

假设我们希望扩展书店程序并令其支持几种不同的折扣策略。除了购买量超过一定数 量＞受折扣外，我们也可能提供另外一种策略，即购买量不超过某个限额时可以享受折扣， 但是一旦超过限额就要按原价支付。或者折扣策略还可能是购买量超过-定数量后购买的 全部书籍都享受折扣，否则全都不打折。

上面的每个策略都要求一个购买量的值和一个折扣值。我们可以定义一个新的名为 Disc_quote的类來支持不同的折扣策略，其中Disc_quote负责保存购买量的值和折

H09＞扣值。其他的表示某种特定策略的类（如Bulk_quote）将分别继承自Disc_quote, 每个派生类通过定义自己的net_price函数来现各自的折扣策略。

在定义Disc_quote类之前，首先要确定它的net_price函数完成什么工作。显 然我们的Disc_quote类与任何特定的折扣策略都无因此Disc_quote类中的 net_price函5是没有实际含义的。

我们可以在Disc_quote类中不定义新的net_price.此时，Disc_quote将继 承Quote中的net_price函数。

然而，这样的设计可能导致用户编写出-些无意义的代码。用户可能会创建一个 Disc_quote对象并为其提供购买量和折扣值，如果将该对象传给一个像print_total 这样的函数，则程序将调用Quote版本的net_price。！ii然，最终计算出的销售价格并 没有考虑我们在创建对象时提供的折扣值，因ihLb述操作毫无意义。

纯虚函数

认真思考上面描述的情形我们可以发现，关键问题并不仅仅是不知道应该如何定义 net_price,而是我们根本就不希望用户创建—Disc_quote对象。Disc_quote类 表示的是一本打折书籍的通用概念，而非某种具体的折扣略。

我们可以将net_price定义成纯虚（pure virtual）函数从而令程序实现我们的设计 意图，这样做可以清晰明了地告诉用户当前这个net_price函数是没有实际意义的。和 普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句

的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中.=0只能出现在类内部 的虚函数声明语句处：

H用于保存折扣值和购买量的类，派生类使用这些教据可以实现不同的价格策略 class Disc_quote : public Quote { public:

Disc_quote() = default;

Disc_quote(const std::strings book, double price, std::size_t qty, double disc):

Quote(book, price),

quantity(qty), discount(disc) { }

double net_price(std::size_t) const = 0; protected:

std: : size_t quantity = 0;    //折扣适用的购买量

double discount = 0.0;    //表乐折扣的小数值

}；

和我们之前定义的Bulk_quote类一样，Disc_quote也分别定义了一个默认构造函数 和一个接受四个参数G构造函数。尽管我石不能直接定义这个类的对象，但是 Disc_quote的派生类构造函数将会使用Disc_quote的构造函数来构建各个派牛.类对 象的Disc_quote部分。其中，接受四个参数的构造函数将前两个参数传递给Quote的 构造函数，然后直接初始化自己的成员discount和quantity。默认构造函数则对这 些成员进行默认初始化。

值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。 也就是说，我们不能在类的内部为一个=0的函数提供函数体。

<61Q-|



含有纯虚函数的类是抽象基类

含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类( abstract base class)。抽象 基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能(直接)创建一个抽象基 类的对象。因为Disc_quote将net_price定义成了纯虚函数，所以我们不能定义 Disc_quote的对象。我们可以定义Disc_quote的派生类的对象，前提是这些类覆盖 T net_price 函数：

// Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数

Disc_quote discounted;    // 错误：不能定义 Disc_quote 的对象

Bulk_quote bulk;    // 正确：Bulk_quote 中没有纯虚函教

Disc_quote的派生类必须给出自己的net_price定义，否则它们仍将是抽象基类。

![img](C++  Primer 5-140.jpg)



我们不能创建抽象基类的对象

派生类构造函数只初始化它的直接基类

接下来可以重新实现Bulk_quote 了，这一次我们让它继承Disc_quote而非直接 继承Quote：

//当同一书籍的销售量超过某个值时启用折扣

//折扣的值是一个小于1的正的小数值，以此来降低正常铕售价格 class Bulk_quote : public Disc_quote { public:

Bulk_quote() = default;

Bulk_quote(const std::strings book, double price, std::size_t qty, double disc):

Disc_quote(book, price, qty, disc) { }

//覆盖基类_中的函数版本以实现一种新的折扣策略 double net_price(std::size_t) const override;

}；

这个版本的Bulk_quote的直接基类是Disc_quote,间接基类是Quote。每个 Bulk_quote对象包含三个子对象：一个(空的)Bulk_quote部分、一个Disc_quote 子对象和一个Quote子对象。

如前所述，每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自 己的数据成员，它也仍然需要像原来一样提供一个接受四个参数的构造函该构造函数 将它的实参传递给Disc_quote的构造函数，随后Disc_quote的构造函数继续调用 Quote的构造函数。Quote的构造函数首先初始化bulk的bookNo和price成员，当 Quote的构造函数结束后，开始运行Disc_quote的构造函数并初始化quantity和

I 611 > discount成员，最后运行Bulk_quote的构造函数，该函数无须执行实际的初始化或 其他工作。

关键概念：盧构

在Quote的继承体系中增加Disc_quote类是重构(refactoring)的一个典型示 例。重构负责重新设计类的体系以便将操_作和/或数据从一个类移动到另一个类中。对于 面向对象的应用程序来说，重构是一种很普遍的现象，/

值得注意的是，即使我们改变了整个继承体系，那些使用了 Bulk_quote或Quote 的代码也无须进行任何改动。不过一旦类被重构(或以其他方式被i变)，就意味着我 们必须重新编译含有这些类的代码了。

###### 15.4节练习

练习15.15:定义你自己的Disc_quote和Bulk_quote。

练习15.16:改写你在15.2.2节(第533页)练习中编写的数量受限的折扣策略，令其 继承 Disc_quoteo

练习15.17:尝试定义一个DiSC quOte的对象，看看编译器给出的错误信息是什么？

##### 浥15.5访问控制与继承

每个类分别控制自己的成员初始化过程(参见15.2.2节，第531页)，与之类似，每 个类还分别控制着其成员对于派生类来说是否可访问(accessible)。

受保护的成员

如前所述，一个类使用protected关键字来声明那些它希望与派生类分享但是不想 被其他公共访问使用的成员。protected说明符可以看做是public和private中和 后的产物：

•和私有成员类ftb受保护的成员对于类的用户来说是不可访问的

•和公有成员类似，受保护的成员对于派生类的成员和友兀来说是可访W的。

此外，protected还有另夕I—条重要的性质。

•派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一 个基类对象中的受保护成员没有任何访问特权，

为了理解最后一条规则，请考虑如下的例子:

<6121



// protected 成员

// 能访问 Sneaky: :prot_mem // 不能访问 Base : :prot_mem // j 默认是 private



class Base {

protected:

int prot_mem;

}；

class Sneaky : public Base {

friend void clobber(SneakyS); friend void clobber(Base&); int j;

}；

//正确：clobber能访问Sneaky对象的private和protected成员 void clobber(Sneaky &s)    { s.j = s.prot_mem = 0; }

//错误：clobber不能访问Base的protected成员 void clobber(Base &b)    { b.prot_mem =0; }

如果派生类(及其友元)能访问基类对象的受保护成员，则上面的第二个clobber (接 受一个Bases)将是合法的。该函数不是Base的友元，但是它仍然能够改变一个Base 对象的内容。如果按照这样的思路，则我们只要定义一个形如Sneaky的新类就能非常 简单地规避掉protected提供的访问保护了。

耍想阻止以上的用法，我们就要做出如下规定，即派生类的成员和友元只能访问派生 类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限，

公有、私有和受保护继承

某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访 问说明符，二是在派生类的派生列表中的访问说明符。举个例子，考虑如下的继承关系：

class Base { public:

void pub_mem () ;    // public 成员

protected:

int prot_mem;    // protected 成员

private:

char priv_mem;    // private 成员

Instruct Pub_Derv : public Base {

//正确：派生类能访问protected成员 int f()    { return prot_mem; }

//错误：private成员对于派生类来说是不可访问的 char g()    { return priv_mem; }

Instruct Priv_Derv : private Base {

// private不影响派生类的访问权限

int f1() const { return prot_mem; }

}；

派生W问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。对 E5S>基类成员的访问权限只与基类中的访问说明符有关。Pub_Derv和Priv_Derv都能访问

受保护的成员prot_mem,同时它们都不能访问私有成员priv_mem。

派生访W说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员 的访问权限：

Pub_Derv dl; Priv_Derv d2 dl.pub_mem() d2.pub_mem()



//继承自Base的成员是public的 //继承自Base的成员是private的 //正确：pub_mem在派生类中是public的 //错误：pub_mem在派生类中是private的

Pub_Derv和Priv_Derv都继承了 pub_mem函数。如果继承是公有的，则成员将遵循 其原有的访H说明符，此时dl可以调用pub_mem。在Priv_Derv中，Base的成员是 私有的，因此类的用户不能调用pub_memo

派生说明符还可以控制继承自派生类的新类的访问权限：

struct Derived_from_Public : public Pub_Derv {

// 正碗：Base : :prot_mem 在 Pub_Derv 中仍然是 protected 的 int use_base()    { return prot_mem; }

struct Derived_from_Private : public Priv_Derv {

// 错误：Base : :prot_mem 在 Priv_Derv 中是 private 的 int use_base() { return prot_mem; }

Pub_Derv的派生类之所以能访I'。』Base的prot_mem成员是因为该成员在Pub_Derv 中vf然是受保护的。相反，Priv_Derv的派生无法执行类的访问，对于它们i说. Priv_Derv继承自Base的所有成员都是私有的。

假设我们之前还定义了一个名为PrOt_Derv的类，它采用受保护继承，则Base的 所有公有成员在新定义的类中都是受保护的。Prot_Derv的用户不能访问pub_mem，但 是Prot_Derv的成员和友元可以访问那些继承而呆的成员。

Cg派生类向基类转换的可访问性

派生类向基类的转换（参见15.2.2节，第530页）是否可访问由使用该转换的代码决 定，时派生类的派生访问说明符也会有影响。假定D继承自B，

•只有当D公有地继承B吋，用户代码才能使用派生类向基类的转换；如果D继承B 的方式是受保护的或者私有的，则用户代码不能使用该转换。

•不论D以什么方式继承B, D的成员函数和友元都能使用派生类向基类的转换；派 生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的，

rw> •如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使 用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。

zO\对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类 \^Z向基类的类型转换也是可访问的；反之则不行

X：-键概念：类的设il•与受保护的成员

不考虑继承的话.我们可以认为一个类有两种不同的用户：普通用户和类的实现者、

其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有(接口)成员； 实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访 问类的私有(实现)部分。

如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能 够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍 旧不能访问私有成员。

和其他类一样，基类应该将其接口成员声明为公有的；同时将属干其实现的部分分 成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声 明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于 后者应该声明为私有的。

友元与继承

就像友元关系不能传递一样(参见7.3.4节，第250页)，友元关系同样也不能继承。 基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问坫 类的成员：

class Base {

//添加friend声明，其他成员与之前的版本一致

friend class Pal;    // Pal在访问Base的派生类时不具有特殊性

}；

class Pal { public:

int f (Base b) { return b.prot_mem; } // 正确：Pal 是 Base 的友元 int f2 (Sneaky s) { return s.j; }    // 错误：Pal 不是 Sneaky 的友元

//对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此 int f3 (Sneaky s) { return s.prot_mem; }    // 正确：Pal 是 Base 的友元

}；

如前所述，每个类负责控制自己的成员的访问权限，因此尽管看起来有点儿奇怪，何f3 确实是正确的。Pal是Base的友元，所以Pal能够访问Base对象的成员，这种可访叫＜6151 性包括了 Base对象内嵌在其派生类对象中的情况。

当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原來 那个类来说，其友元的基类或者派生类不具有特殊的访问能力：

// D2对Base的protected和private成灵不具有特殊的访问能力 class D2 : public Pal { public:

int mem(Base b)

{ return b.prot_mem; }    //错误：友元关系不能继承

}；

不能继承友元关系；每个类负责控制各自成员的访问权限

改变个别成员的可访问性

有时我们需耍改变派生类继承的某个名字的访问级别，通过使用using声明(参见 3.1节，第74页)可以达到这一目的：

class Base { public:

std::size_t size （） const { return n; } protected:

std::size_t n;

}；

class Derived : private Base {    // 注意：private 继承

public:

//保持对象尺寸相关的成员的访问级别 using Base::size;

protected:

using Base::n;

}；

因为Derived使用了私有继承，所以继承而来的成员size和n （在默认情况下）是 Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。改 变之后，Derived的用户将可以使用size成员，而Derived的派生类将能使用n。

通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中的任何 可访问成员（例如，非私有成员）标记出来=using声明语句中名字的访问权限由该using 声明语句之前的访问说明符来决定。也就是说，如果一条using声明语句出现在类的 private部分，贝U该名字只能被类的成员和友元访问；如果using声明语句位于public 部分，则类的所有用户都能访问它：如果using声明语句位于protected部分，则该 名字对于成员、友元和派生类是可访问的，

派生类只能为那些它可以访问的名字提供using声明。

rei6＞默认的继承保护级别

在7.2节（第240页）中我们曾经介绍过使用struct和class关键字定义的类具 有不同的默认访问说明符。类似的，默认派生运算符也由定义派生类所用的关键字来决定， 默认情况下，使用class关键字定义的派生类是私有继承的；而使用struct关键字定 义的派生类是公有继承的：

class Base { /* …*/ };

struct D1 : Base { /*...*/ };    // 默认 public 继承

class D2 : Base {/*...*/};    // 默认 private 继承

人们常常有一种错觉，认为在使用struct关键字和class关键字定义的类之间还 有更深层次的差别。事实上，唯一的差别就是默认成员访问说明符及默认派生访问说明符; 除此之外，再无其他不同之处。

![img](C++  Primer 5-141.jpg)



一个私有派生的类最好盈式地将private声明出来，而不要仅仅依赖于默 认的设置.，显式声明的好处是可以令私有继承关系清晰明了，不至于产生 误会。

###### 15.5节练习

练习15.18:假设给定了第543页和第544页的类，同时已知每个对象的类型如注释所 示，判断下面的哪些赋值语句是合法的。解释那些不合法的语句为什么不被允许：

Base *p = &dl;    // dl 的类型是 Pub_Derv

p = &d2;    // d2 的类型是 Priv Derv

| P =  | &d3;  | , // | d3的类型是Prot_Derv |       |           |
| ---- | ----- | ---- | ------------------- | ----- | --------- |
| P =  | &ddl; | //   | ddl的类型是Derived_ | from  | Public    |
| P =  | &dd2; | //   | dd2的类型是Derived_ | from  | Private   |
| P =  | &dd3; | //   | dd3的类型是Derived_ | from— | Protected |

练习15.19:假设543页和544页的每个类都有如下形式的成员函数： void memfcn（Base &b）    { b = *this; }

对于每个类，分别判断上面的函数是否合法。

练习15.20：编写代码检验你对前面两题的回答是否正确。

练习15.21:从下面这些一般性抽象概念中任选一个（或者选一个你自己的），将其对应 的一组类型组织成一个继承体系：

（a）    图形文件格式（如gif、tiff、jpeg、bmp）

（b）    图形基元（如方格、圆、球、圆锥）

（c）    C++语言中的类型（如类、函数、成员函数）

练习15.22:对于你在上一题中选择的类，为其添加合适的虚函数及公有成员和受保护 的成员。

##### 15.6继承中的类作用域    ®

每个类定义自己的作用域（参见7.4节，第253页），在这个作用域内我们定义类的成＜613 员。当存在继承关系时，派生类的作用域嵌套（参见2.2.4节，第43页）在其基类的作用 域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类 作用域中寻找该名字的定义。

派生类的作用域位于基类作用域之内这一事实可能有点儿出人意料，毕竟在我们的程 序文本中派生类和基类的定义是相互分离开来的。不过也恰恰因为类作用域有这种继承嵌 套的关系，所以派生类才能像使用自己的成员一样使用基类的成员。例如，当我们编写下 面的代码时：

Bulk_quote bulk; cout « bulk.isbn（）;

名字isbn的解析将按照下述过程所示：

•因为我们是通过Bulk_quote的对象调用isbn的，所以首先在Bulk_quote中 查找，这一步没有找到名字isbn。

•因为Bulk_quote是Disc_quote的派生类，所以接下来在Disc_quote中查 找，仍然找不到。

•因为Disc_quote是Quote的派生类，所以接着查找Quote；此时找到了名字 isbn,所以我们使用的isbn最终被解析为Quote中的isbn。

在编译时进行名字查找

一个对象、引用或指针的静态类型（参见15.2.3节，第532页）决定了该对象的哪些 成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生

这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。举个例子，我们可以给 Disc_quote添加一个新成员，该成员返冋一个存有最小（或最大）数量及折扣价格的 pair （参见 11.2.3 节，第 379 页）:

class Disc_quote : public Quote {

public:

std::pair<size_t, double> discount_policy() const { return {quantity, discount}; }

//其他成员与之前的版本一致

｝；

我们只能通过Disc_quote及其派生类的对象、引用或指针使用discount_policy：

Bulk_quote bulk;

//静态类型与动态类型一致

//静态类型与动态类型不一致

// 正确：bulkP 的类型是 Bulk_quote* //错误：itemP的类型是Quote*



Bulk_quote *bulkP = &bulk; Quote *itemP = &bulk; bulkP-〉discount_policy(); itemP->discount_policy();

I 61.8〉尽管在bulk中确实含有一个名为discount_policy的成员，但是该成员对于itemP 却是不可见的。itemP的类型是Quote的指针，意味着对discount_policy的搜索将 从Quote开始。显然Quote不包含名为discount_policy的成员，所以我们无法通 过Quote的对象、引用或指针调用discount_policyo

名字冲突与继承

和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定 义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字（参见2.2.4 节，第43页）：

struct Base {

Base () : mem(0)    { }

protected:

int mem;

}；

struct Derived : Base {

| Derived(int i): mem(i)    { } | // 用 i 初始化 Derived: :mem // Base : :mem进行默认初始化 // 返回 Derived: :mem |                   |
| ----------------------------- | ------------------------------------------------------------ | ----------------- |
| int get mem()    {            | return mem; }                                                |                   |
| protected:int mem;            |                                                              | //隐藏基类中的mem |

｝；

get_mem中mem引用的解析结果是定义在Derived中的名字，下面的代码

Derived d（42）;

cout « d.get_mem （） « endl;    // 打印 42

的输出结果将是42。

![img](C++  Primer 5-142.jpg)



派生类的成员将隐藏同名的基类成员

通过作用域运算符来使用隐藏的成员

我们吋以通过作用域运算符來使用-个被隐藏的基类成员:

struct Derived : Base {

int get_base_mem（）    { return Base::mem; }

// ...

}；

作用域运算符将覆盖掉原有的查找规则，并指示编译器从Base类的作用域开始查找memo 如果使用最新的Derived版本运行上面的代码，则d. get_mem （）的输出结果将是0。

除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字

乂键概念：名卞杏找1j继承

<619~l



理解函数调用的解抵过程对于理解C++的继承至关重要，假定我们调用p->mem（）

（或者obj .mem（））,则依次执行以下4个步骤：

•首先确定p（或obj ）的静态类型。因为我扪调用的是一个成员，所以该类型必 然是类类型。

•在p （或obj ）的静态类型对应的类中查找mem。如果找不到，，则依次在直接基 类中不断查找直至到达继承链的顶端，:，如果找遍了该类及其基类仍然找不到，则编译器 将报错。

• 一旦找到了 mem,就进行常规的类型检查（参见6.1节，第183页）以确认对于 当前找到的mem,本次调用是否合法。

•假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：

—如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代 码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型,，

一反之，如果mem不是虚函数或者我们是通过对象（而非引用或指针）迸行的 调用,，则编译器将产生一个常规函数调用。;:

■-如往常，名字查找先于类型检查

如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数（参见6.4.1 节，第210页）。因此，定义派生类中的函数也不会重载其基类中的成员。和其他作用域 一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，贝IJ

派生类将在其作用域内隐藏该基类成员 基类成员也仍然会被隐藏掉：

即使派生类成员和基类成员的形参列表不-致，



//隐藏基类的memfcn



/ / 调用 Base: : memf cn

// 调用 Derived: :memfcn

/ /错误：参数列表为空的memf cn被隐藏了 / / 正确：调用 Base : : memf cn



struct Base {

int memfcn();

}；

struct Derived : Base { int memfcn(int);

}；

Derived d; Base b; b.memfcn(); d.raemfcn(10); d.memfcn(); d.Base::memfcn();

Derived中的memfcn声明隐藏了 Base中的memfcn声明。在上面的代码中前两条调 用语句容易理解，第一个通过Base对象b进行的调用执行基类的版本；类似的，第二个 通过d进行的调用执行Derived的版本；第三条调用语句有点特殊，d.memfcn()是非 法的，

I 620〉 为了解析这条调用语句，编译器首先在Derived中查找名字memfcn:因为Derived 确实定义了一个名为memfcn的成员，所以查找过程终止。一旦名字找到，编译器就不再 继续查找了。Derived中的memfcn版本需要一个int实参，而当前的调用语句无法提 供任何实参，所以该调用语句是错误的。

Cg虚函数与作用域

我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了(参见 15.3节，第537页)=假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基 类的引用或指针调用派生类的虚函数了。例如：

class Base {

public:

virtual int fen ();

}；

class DI : public Base {

public:

//隐藏基类的fen，这个fen不是虚函数 // D1 继承了 Base : : fen ()的定义

//形参列表与Base中的fen不一致 //是一个新的虚函数，在Base中不存在



//是一个非虚函救，隐藏了 D1: : fen (int) //覆盖了 Base的虚函数fen //覆盖了 D1的虚函数f2



int fen(int); virtual void f2();

}；

class D2 : public DI { public:

int fen (int); int fen (); void f2();

D1的fen函数并没有覆盖Base的虚函数fen,原因是它们的形参列表不同。实际上， D1的fen将隐藏Base的fen。此时拥有了两个名为fen的函数：一个是D1从Base 继承而来的虚函数fen;另一个是D1自己定义的接受一个int参数的非虚函数fcn»

通过基类调用隐藏的虚函数

给定上面定义的这些类后，我们来看几种使用其函数的方法:

| Base bobj; DI dlobj; | D2             | d2obj;                               |
| -------------------- | -------------- | ------------------------------------ |
| Base *bpl = &bobj, * | bp 2           | =Sdlobj, *bp3 = &d2obj;              |
| bpl->fcn ();         |                | //虚调用，将在运行时调用Base : : fen |
| bp2->fcn ();         |                | //虚调用，将在运行时调用Base: : fen  |
| bp3->fcn ();         |                | //虚调用，将在运行时调用D2: : fen    |
| DI *dlp = Sdlobj; D2 | *d2p = &d2obj; |                                      |
| bp2->f2();           |                | //错误：Base没有名为f2的成员         |
| dlp->f2 ();          |                | //虚调用，将在运行时调用D1: : f2 ()  |
| d2p-〉f2 ();         |                | //虚调用，将在运行时调用D2::f2()     |

前三条调用语句是通过基类的指针进行的，因为fen是虚函数，所以编译器产生的代码 将在运行时确定使用虚函数的哪个版本。判断的依据是该指针所绑定对象的真实类型。在 bp2的例子中，实际绑定的对象是D1类型，而D1并没有覆盖那个不接受实参的fen,

所以通过bP2进行的调用将在运行吋解析为Base定义的版本。

接下来的三条调用语句是通过不同类型的指针进行的，每个指针分别指向继承体系中 的一个类型。因为Base类中没有f2(>,所以第一条语句是非法的，即使当前的指针碰 巧指向了 一个派生类对象也无济于事。

为了完整地阐明上述问题，我们不妨再观察一些对于非虚函数fcn(int)的调用 语句：

Base *pl = &d2obj; DI *p2 = &d2obj ? D2 *p3 = &d2obj; pl->f cn (42) ;    //错误：Base中没有接受一个int的fen

p2->fcn(42);    // 静态绑定，调用 DI: : fen (int)

p3->fcn(42) ;    // 静态綁定，调用 D2: :fcn(int)

在上面的每条调用语句中，指针都指向了 D2类型的对象，但是由T我们调用的是非虚函 数，所以不会发生动态绑定，实际调用的函数版本由指针的静态类型决定。

覆盖重载的函数

和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数 的0个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需 要覆盖所有的版本，或者一个也不覆盖。

有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基 类中的每一个版本的话，显然操作将极其烦琐。

一种好的解决方案是为重载的成员提供一条using声明语句(参见15.5节，第546 页)，这样我们就无须覆盖基类中的每一个重载版本了。using声明语句指定一个名字而 不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载 实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为 继承而来的其他函数重新定义。

类内using声明的一般规则同样适用于重载函数的名字(参见15.5节，第546页)； 基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的 访问实际上是对using声明点的访问。

###### 15.6节练习

练习15.23：假设第550页的D1类需要覆盖它继承而来的fen函数，你应该如何对其 进行修改？如果你修改之后fen匹配了 Base中的定义，则该节的那些调用语句将如何 解析？

##### 15.7构造函数与拷贝控制

和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作吋发生什么 样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。如果一个类(基类或派生类) 没有定义拷贝控制操作，则编译器将为它合成-个版本。当然，这个合成的版本也可以定 义成被删除的函数。

###### 15.7.1虚析构函数

继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数（参见 15.2.1节，第528页），这样我们就能动态分配继承体系中的对象了。

如前所述,当我们delete 一个动态分配的对象的指针时将执行析构函数（参见13.1.3 节，第445页）。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型 与被删除对象的动态类型不符的情况（参见15.2.2节，第530页）。例如，如果我们delete 一个Quote*类型的指针，则该指针有可能实际指向了一个Bulk_quote类型的对象。 如果这样的话，编译器就必须清楚它应该执行的是Bulk_quote    析构函数。和其他函

数一样，我们通过在基类中将析构函数定义成虚函数以确i呆执行正确的析构函数版本：

class Quote { public:

//如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数 virtual -Quote （） = default;    // 动态绑定析构函数

}；

和其他虚函数一样，析构函数的虚属性也会被继承。因此，无论Quote的派生类使用合 成的析构函数还是定义自己的析构函数，都将是虚析构函数。只要基类的析构函数是虚函 数，就能确保当我们delete基类指针时将运行正确的析构函数版本：

Quote *itemP = new Quote;    //静态类型与动态类型一致

delete itemP;    //调用Quote的析构函数

itemP = new Bulk_quote;    //静态类型与动态类型不一致

delete itemP;    // 调用 Bulk_quote 的析构函数

WARNING



如果基类的析构函数不是虚函数，则delete —个指向派生类对象的基类指针 将产生未定义的行为。

之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷 贝和赋值操作（参见13.1.4节，第447页）。基类的析构函数并不遵循上述准则，它是一 个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时， 该析构函数为了成为虚函数而令内容为空，我们显然无法由此推断该基类还需要赋值运算 符或拷贝构造函数。

El23＞虚析构函数将阻止合成移动操作

基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的 影响：如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编 译器也不会为这个类合成移动操作（参见13.6.2节，第475页）。

###### 15.7.1节练习

练习15.24：哪种类需要虚析构函数？虚析构函数必须执行什么样的操作？

50 15.7.2合成拷贝控制与继承

基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构 函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的 成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销

毁的操作。例如，

•合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运 行Quote的&认构造函数。

•    Quote的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初 始值将price初始化为0。

•    Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始 值初始化qty和discount。

•    Disc_quote的构造函数完成后，继续执彳丁 Bulk_quote的构造函数，但是它什 么具体工作也不做。

类似的，合成的Bulk_quote拷贝构造函数使用（合成的）Disc_quote拷贝构造函数，

后者又使用（合成的）Quote拷贝构造函数。其中，Quote拷贝构造函数拷贝bookNo 和price成员；Disc_quote拷贝构造函数拷贝qty和discount成员。

值得注意的是，无论基类成员是合成的版本（如Quote继承体系的例子）还是自定 义的版本都没有太大影响。唯一的要求是相应的成员应该可访问（参见15.5节，第542 页）并且不是-个被删除的函数。

在我们的Quote继承体系中，所有类都使用合成的析构函数。其中，派生类隐式地rcTTl 使用而基类通过将其虚析构函数定义成=default而显式地使用。一如既往，合成的析构 函数体是空的，其隐式的析构部分负责销毁类的成员（参见13.1.3节，第444页）。对于 派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；

该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。

如前所述，Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动＜62£] Quote对象时实际使用的是合成的拷贝操作（参见13.6.2节，第477页）。如我们即将看 到的那样，Quote没有移动操作意味着它的派生类也没有。

派生类中删除的拷贝控制与基类的关系

就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成的默认构造 函数或者任何一个拷贝控制成员定义成被删除的函数（参见13.1.6节，第450页和13.6.2 节，第475页）。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数：

•如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除 的函数或者不可访问（参见15.5节，第543页），则派生类中对应的成员将是被删 除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值 或销毁操作。

•如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝 构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。

•和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=defaUlt请 求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中 该函数将是被删除的，原因是派生类对象的基类部分不可移动，同样，如果基类的 析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。

举个例子，对于下面的基类B来说：

class B { public:

B（）;

B(const B&) = delete;

//其他成员，不含有移动构造函数

}；

class D : public B {

//没有声明任何构造函数

};

D d;    //正确：D的合成默认构造函数使用B的默认构造函数

D d2 (d) ;    //错误：D的合成拷贝构造函教是被删除的

D d3 (std: :move (d) ) ;    //错误：隐式地使用D的被删除的拷贝构造函数

基类B含有-'个可访问的默认构造函数和一个显式删除的拷贝构造函数。因为我们定义了 拷贝构造函数，所以编译器将不会为B合成一个移动构造函数(参见13.6.2节，第475页)。 因此，我们既不能移动也不能拷贝B的对象。如果B的派牛类希望它自己的对象能被移动 和拷贝，则派生类需要自定义相应版本的构造函数。当然，在这一过程中派生类还必须考 虑如何移动或拷贝其基类部分的成员。在实际编程过程中，如果在基类中没有默汄、拷贝 或移动构造函数，则一般情况下派生类也不会定义相应的操作。

：625＞移动操作与继承

如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含 有合成的移动操作，而且在它的派生类中也没有合成的移动操作。

因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要 执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过 前提是Quote必须显式地定义这些成员。一旦Quote定义了自己的移动操作，那么它必 须同时显式地定义拷贝操作(参见13.6.2节，第476页)：

class Quote { public:

Quote () = default;    //对成员依次进行默认初始化

Quote (const Quotes) = default;    // 对成员依次拷贝

Quote (Quote&&) = default;    // 对成员依次拷贝

Quotes operator= (const Quotes) = default; // 拷贝賦值 Quotes operator= (Quote&&) = default;    // 移动賦值

virtual -Quote() = default;

//其他成员与之前的版本一致

}；

通过上面的定义，我们就能对Quote的对象逐成员地分别进行拷贝、移动、赋值和销毁 操作了。而且除非Quote的派牛.类中含有排斥移动的成员，否则它将自动获得合成的移 动操作。

###### 15.7.2节练习

练习15.25:我们为什么为DiSC_quote定义一个默认构造函数？如果去除掉该构造函 数的话会对Bulk quote的行为产生什么影响？

###### 50 15.7.3派生类的拷贝控制成员

如我们在15.2.2节(第531页)介绍过的，派生类构造函数在其初始化阶段中不但要 初始化派生类自己的成员，还负责初始化派牛类对象的基类部分。因此，派生类的拷贝和

移动构造函数在拷贝和移动自有成员的同时，也耍拷K和移动基类部分的成员。类似的，

派生类赋值运算符也必须为其基类部分的成员赋值。

和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。如 前所述，对象的成员是被隐式销毁的(参见13.1.3节，第445页)；类似的，派生类对象 的基类部分也是自动销毁的。

当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员 <626]

WARNING 在内的整个对象

定义派生类的拷贝或移动构造函数

当为派生类定义拷贝或移动构造函数时(参见13.1.1节，第440员和13.6.2节，第473 页)，我们通常使用对应的基类构造函数初始化对象的基类部分：

class Base { /*••.*/ }; class D: public Base { public:

//默认情况下，基类的默认构造函数初始化对象的基类部分 //要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中 //显式地调用该构造函数

D (const D& d) : Base (d)    // 拷贝基类成员

/* D的成员的初始值*/{/*...*/ }

D (D&& d) : Base (std: :move (d) )    // 移动基类成员

/* D的成员的初始值*/{/*...*/ }

}；

初始值Base (d)将一个D对象传递给基类构造函数。尽管从道理上来说，Base可以包含 一个参数类型为D的构造函数，但是在实际编程过程中通常不会这么做。相反，Basefd)

一般会匹配Base的拷贝构造函数。D类型的对象d将被绑定到该构造函数的Bases,形参 上。Base的拷贝构造函数负责将d的基类部分拷贝给要创建的对象。假如我们没有提供 基类的初始值的话，

// D的这个拷贝构造函数很可能是不正确的定义

II基类部分被默认初始化，而非拷贝

D (const DS d) /*成员初始值，但是没有提供基类初始值*/

{ /*

在上面的例子中，Base的默认构造函数将被用来初始化D对象的基类部分。假定D的构 造函数从d中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪：它的Base成 员被赋予了默汄值，而D成员的值则是从其他对象拷贝得来的。

A 在默认情况下，基类默认构造函数初始化派生类对象的基类部分.，如果我们想 /!\拷贝(或移动)基类部分，则必须在派生类的构造函教初始值列表中显式地使 WARMHG用基类的拷贝(或移动)构造函数,、

派生类赋值运算符

与拷贝和移动构造函数一样，派生类的赋值运算符(参见13.1.2节，第443页和13.6.2 节，第474页)也必须显式地为其基类部分赋值：

< 627 1



// Base : : operator= (const Base&)不会被自动调用

D &D::operator=(const D &rhs)

{

Base : : operator= (rhs) ; // 为基类部分赋值 //按照过去的方式为派生类的成员赋值 //酌情处理自赋值及释放已有资源等情况 return *this;

}

上面的运算符首先显式地调用基类赋值运算符，令其为派生类对象的基类部分赋值。基类 的运算符(应该可以)正确地处理自赋值的情况，如果赋值命令是正确的，则基类运算符 将释放掉其左侧运算对象的基类部分的旧值，然后利用rhs为其赋一个新值。随后，我 们继续进行其他为派生类成员赋值的工作。

值得注意的是，无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本， 派生类的对应操作都能使用它们。例如，对于Base : :operator=的调用语句将执行Base 的拷贝赋值运算符，至于该运算符是由Base显式定义的还是由编译器合成的无关紧要，

派生类析构函数

如前所述，在析构函数体执行完成后，对象的成员会被隐式销毁(参见13.1.3节，第 445页)。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同 的是，派生类析构函数只负责销毁由派生类自己分配的资源：

class D: public Base { public:

// Base::〜Base被自动调用执行

~D() { /*该处由用户定义清除派生类成员的操作*/ }

}；

对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的 析构函数，以此类推，沿着继承体系的反方向直至＜后。

在构造函数和析构函数中调用虚函数

如我们所知，派生类对象的基类部分将首先被构建。当执行基类的构造函数时，该对 象的派生类部分是未被初始化的状态。类似的，销毁派生类对象的次序正好相反，因此当 执行基类的析构函数时，派生类部分已经被销毁掉了。由此可知，当我们执行上述基类成 员的时候，该对象处？未完成的状态。

为了能够正确地处理这种未完成状态，编译器认为对象的类型在构造或析构的过程中 仿佛发生了改变一样。也就是说，当我们构建一个对象时，需要把对象的类和构造函数的

EJ28＞类看作是同一个；对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一 个的要求；对于析构函数也是同样的道理。上述的绑定不但对直接调用廉函数有效，对间 接调用也是有效的，这里的间接调用是指通过构造函数(或析构函数)调用另一个函数。

为了理解上述行为，不妨考虑当基类构造函数调用虚函数的派生类版本时会发生什么 情况。这个虚函数可能会访问派生类的成员，毕竟，如果它不需要访问派生类成员的话， 则派生类直接使用基类的虚函数版本就可以了。然而，当执行基类构造函数时，它要用到 的派生类成员尚未初始化，如果我们允许这样的访问，则程序很可能会崩溃。

![img](C++  Primer 5-144.jpg)



如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析 构函数所属类型相对应的虔函数版本

###### 15.7.3节练习

练习15.26:定义Quote和Bulk_quote的拷贝控制成员，令其与合成的版本行为一 致。为这些成员以及其他构造函数&加打印状态的语句，使得我们能够知道正在运行哪 个程序。使用这些类编写程序，预测程序将创建和销毁哪些对象。重复实验，不断比较 你的预测和实际输出结果是否相同，直到预测完全准确再结束。

###### 15.7.4继承的构造函数

在C++11新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，fcTq 这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为"继承”

的。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造 函数。类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，

则编译器将为派生类合成它们，

派生类继承基类构造函数的方式是提供一条注明了(直接)基类名的using声明语 句。举个例子，我们可以重新定义Bulk_quote类(参见15.4节，第541页)，令其继承 Disc_quote类的构造函数：

class Bulk—quote : public Disc_quote { public:

using Disc_quote: :Disc_quote; // 继承 Disc_quote 的构造函数 double net_price(std::size_t) const;

}；

通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数 时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个 与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中 生成一个形参列表完全相同的构造函数。

这些编译器生成的构造函数形如：    <629~|

derived (parms、 : base (args) { }

其中，t/en'verf是派生类的名字，Zwse是基类的名字，ptnmy是构造函数的形参列表，args 将派生类构造函数的形参传递给基类的构造函数。在我们的Bulk_quote类中，继承的 构造函数等价于：

Bulk_quote(const std::strings book, double price, std::size_t qty, double disc):

Disc_quote(book, price, qty, disc) { }

如果派生类含有自己的数据成员，则这些成员将被默认初始化(参见7.1.4节，第 238 页)。

继承的构造函数的特点

和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数 的访问级别。例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是 一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。

而且，一个using声明语句不能指定explicit或constexpr。如果基类的构造 函数是explicit (参见7.5.4节，第265页)或者constexpr (参见7.5.6节，第267

页)，则继承的构造函数也拥有相同的属性。

当一个基类构造函数含有默认实参(参见6.5.1节，第211页)时，这些实参并不会 被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含 有默认实参的形参。例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含 有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参(没有默认实参)， 另一个构造函数只接受一个形参，它对应T基类中最左侧的没有默认值的那个形参。

如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这 些构造函数。第-个例外是派生类可以继承一部分构造函数，而为其他构造函数定义自己 的版本。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函 数将不会被继承，定义在派生类中的构造函数将替换继承而来的构造函数。

第二个例外是默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被 合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有 继承的构造函数，则它也将拥有一个合成的默认构造函数。

###### 15.7.4节练习

练习15.27:重新定义你的Bulk quote类，令其继承构造函数。

##### 浥15.8容器与继承

L630>    当我们使用容器存放继承体系中的对象吋，通常必须采取间接存储的方式。因为不允

许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存 放在容器当中。

举个例子，假定我们想定义-个vector，令其保存用户准备购买的几种书籍。显然 我们不应该用vector保存Bulk_quote对象》因为我们不能将Quote对象转换 成Bulk_quote (参见15.2.3节，^534页)，所以我们将无法把Quote对象放置在该 vector 中 o

其实，我们也不应该使用vector保存Quote对象。此时，虽然我们可以把 Bulk_quote对象放置在容器中，但是这些对象再也不是Bulk_quote对象了：

vector<Quote> basket;

basket.push_back(Quote("0-201-82470-1", 50));

//正确：但是只能把对象的Quote部分拷贝给basket

basket.push_back (Bulk_quote (*'0-201-54848-8", 50, 10, .25)〉；

//调用Quote定义的版本，打印750，即15 * $50 cout « basket.back().net_price(15) << endl;

basket的元素是Quote对象，因此当我们向该vector中添加一个Bulk_quote对象 时，它的派生类部分将被忽略掉(参见15.2.3节，第535页)。

WARNING



当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容 器和存在继承关系的类型无法兼容，

在容器中放置(智能)指针而非对象

当我们希望在容器中存放具有继承关系的对象吋，我们实际上存放的通常是基类的指 针(更好的选择是智能指针(参见12.1节，第400页))。和往常一样，这些指针所指对象 的动态类型可能是基类类型，也可能是派生类类型：

vector<shared_ptr<Quote» basket;

basket.push_back (make_shared<Quote> ("0-201-82470-1*', 50)); basket.push_back(

make_shared<Bulk_quote>(',0-201-54848-8n, 50, 10,    .25));

//调用Quote定义的版本；打印562.5,即在15*&50中扣除掉折扣金额 cout << basket.back()->net_price(15) << endl;

因为basket存放着shared_ptr,所以我们必须解引用basket .back ()的返回值以 获得运行net_price的对象。我们通过在net_price的调用中使用以达到这个目的。

如我们所知，i际调用的net_price版本依&于指针所指对象的动态类型。

值得注意的是，我们将basket定义成shared_prt<Quote>,但是在第二个 push_back中传入的是一■个Bulk_quote对象的shared_ptr。正如我们可以将一个 派生奏的普通指针转换成基类指针样(参见15.2.2节，第^30页)，我们也能把一个派 生类的智能指针转换成基类的智能指针。在此例中，make_shared<Bulk_quote>返回<63?1 —个shared_ptr<Bulk_quote〉对象，当我们调用push_back时该对象被转换成 shared_ptr<Quote>o因此尽管在形式上有所差别，但实际上basket的所有元素的 类型都i相同的。

###### 15.8节练习

练习15.28:定义一个存放Quote对象的vector，将Bulk_quote对象传入其中。 计算vector中所有元素总的net_price。

练习15.29:再运行一次你的程序，这次传入Quote对象的shared_ptr。如果这次 计算出的总额与之前的程序不一致，解释为什么：如果一致，也请说g原因。

![img](C++  Primer 5-146.jpg)



###### 15.8.1 编写 Basket 类

对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编 程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以我们经常定义 一些辅助的类来处理这种复杂情况。首先，我们定义一个表示购物篮的类：

class Basket { public:

// Basket使用合成的默认构造函数和拷贝控制成员

void add_item(const std::shared_ptr<Quote> &sale)

{ items.insert(sale); }

//打印每本书的总价和购物篮中所有书的总价 double total_receipt(std::ostream&) const;

private:

//该函数用于比较shared_ptr，multiset成员会用到它 static bool compare(const std::shared_ptr<Quote> &lhs,

const std::shared_ptr<Quote> &rhs)

{ return lhs-〉isbn() < rhs->isbn(); }

// multiset保存多个报价，按照compare成员排序

std::multiset<std::shared_ptr<Quote>, decltype(compare)*> items{compare};

}；

我们的类使用一个multiset (参见11.2.1节，第377页)来存放交易信息，这样我们就 能保存同一本书的多条交易记录，而且对于一本给定的书籍，它的所有交易信息都保存在 一起(参见n.2.2节，第378页)。

multiset的元素是shared_ptr。因为shared_ptr没有定义小于运算符，所以 为了对元素排序我们必须提供自己比较运算符(参见Il.2.2节，第378页)。在此例中， 我们定义了一个名为compare的私有静态成员，该成员负责比较shared_ptr所指的对象 的isbri。我们初始化multiset,通过类内初始值调用比较函数(参见节，第246页)：

| 632〉    // multiset保存多个报价，按照compare成员排序

std::multiset<std::shared_ptr<Quote>, decltype(compare)*>

items{compare};

这个声明看起来不太容易理解，但是从左向右读的话，我们就能明白它其实是定义了一个 指向 Quote 对象的 shared_ptr 的 multiset。这个 multiset 将使用一个与 compare 成员类型相同的函数来对其的元素进行排序。multiset成员的名字是items,我们 初始化items并令其使用我们的compare函数。

定义Basket的成员

Basket类只定义两个操作。第一个成员是我们在类的内部定义的add_item成员， 该成员接受一个指向动态分配的Quote的shared_ptr,然后将这个shared_ptr放置 在multiset中。第二个成员的名字是total_receipt,它负责将购物篮的内容逐项 打印成清单，然后返回购物篮中所有物品的总价

double Basket::total_receipt(ostream &os) const

{

double sum = 0.0;    //保存实时计算出的总价格

// iter指向ISBN相同的一批元素中的第一个

// upper_bound返回一个迭代器，该迭代器指向这批元素的尾后位置 for (auto iter = items.cbegin();

iter != items.cend();

iter = items.upper_bound(*iter))    {

//我们知道在当前的Basket中至少有一个该关键字的元素 //打印该书籍对应的项目

sum += print_total(os, **iter, items.count(*iter));

}

os << "Total Sale: " << sum « endl; // 打印最终的总价格 return sum;

}

我们的for循环首先定义并初始化iter,令其指向multiset的第一个元素。条件部分 检查iter是否等于items.cendG:如果相等，表明我们已经处理完了所有购买记录， 接下来应该跳出for循环；否则，如果不相等，则继续处理下一本书籍。

比较有趣的是，for循环中的“递增”表达式。与通常的循环语句依次读取每个元素 不同，我们直接令iter指向下一个关键字，调用upper_bound函数可以令我们跳过与 当前关键字相同的所有兀素(参见11.3.5节，第390页)。对于upper_bound函数来说, 它返回的是一个迭代器，该迭代器指向所有与iter关键字相等的元i中最后■-个元素的

下一位置。因此，我们得到的迭代器或者指向集合的末尾，或者指向下一本书籍。

在for循环内部，我们通过调用print_total (参见15.1节，第527页)来打印 购物篮中每本书籍的细节：

sum += print—total(os, **iter, items.count(*iter));

print_total的实参包括一个用于写入数据的ostream、一个待处理的Quote对象和 一个计it值。当我们解引用iter后将得到一个指向准备打印的对象的Shared_ptr。为 了得到这个对象，必须解引用该shared_ptr。因此，**iter是一个Quote对象(或 者Quote的派生类的对象)。我们使用multiset的count成员(参见11.3.5节，第388 页)来统计在multiset中有多少元素的键值相同(即ISBN相同)。

如我们所知，Print_total调用了虚函数net_price,因此最终的计算结果依赖 的动态类型。print_total函数打印并返回给定书籍的总价格，我们把这个

结果添加到sum当中，最后当环结束后打印sum。

隐藏指针

Basket的用户仍然必须处理动态内存，原因是add_item需要接受一个 Shared_ptr参数。因此，用户不得不按照如下形式编写代码："

Basket bsk;

bsk. add_item (make_shared<Quote> ('*123n, 45));

bsk.add_item(make_shared<Bulk_quote>("345", 45, 3, .15));

我们的下一步是重新定义add_item，使得它接受一个Quote对象而非shared_ptr。 新版本的add_item将负责处理内存分配，这样它的用户就不必再受困于此了。们将定 义两个版本，一个拷贝它给定的对象，另一个则采取移动操作(参见13.6.3节，第481页)：

void add_item(const Quotes sale) ;    // 拷贝给定的对象

void add_item(Quote&& sale) ;    // 移动给定的对象

唯一的问题是add_item不知道要分配的类型。当add_item进行内存分配时，它将拷 贝(或移动)它的sale参数。在某处可能会有一条如下形式的new表达式：

new Quote(sale)

不幸的是，这条表达式所做的工作可能是不正确的：new为我们请求的类型分配内存，因 此这条表达式将分配一个Quote类型的对象并且拷贝sale的Quote部分。然而，sale 实际指向的可能是Bulk_quote对象，此时，该对象将被迫切掉一部分。

模拟虚拷贝

为了解决上述问题，我们给Quote类添加一个虚函数，该函数将申请一份当前对象 的拷贝。

class Quote { public:

//该虚函数返回当前对象的一份动态分配的拷贝 //这些成员使用的引用限定符参见13.6.3节(第483页) virtual Quote* clone() const & {return new Quote(*this);} virtual Quote* clone() &&

{return new Quote(std::move(*this));}

//其他成员与之前的版本一致

}；

I 634〉    class Bulk_quote : public Quote {

Bulk_quote* clone () const & {return new Bulk_quote(*this);} Bulk_quote* clone() &&

{return new Bulk_quote(std::move(*this));}

//其他成员与之前的版本一致

}；

因为我们拥有add_item的拷贝和移动版本，所以我们分别定义clone的左值和右值版 本(参见13.6.3节，g 483页)。每个clone函数分配当前类型的一个新对象，其中，const 左值引用成员将它自己拷贝给新分配的对象：右值引用成员则将自己移动到新数据中。

我们可以使用clone很容易地写出新版本的add_item：

class Basket { public:

void add_item(const Quotes sale)    // 拷贝给定的对象

{ items.insert(std::shared_ptr<Quote>(sale.clone())); }

void add_item (Quote&& sale)    // 移动给定的对象

{ items.insert(

std::shared_ptr<Quote>(std::move(sale).clone())); }

//其他成员与之前的kT本一致

}；

和add_item本身一样，clone函数也根据作用于左值还是右值而分为不同的重载版本。 在此例中，第一个add_item函数调用clone的const左值版本，第二个函数调用clone 的右值引用版本。在£值版本中，尽管sale的类型是右值引用类型，但实际上sale本 身(和任何其他变量一样)是个左值(参见13.6.1节，第471页)。因此，我们调用move 把一个右值引用绑定到sale上。

我们的clone函数也是一个虚函数，sale的动态类型(通常)决定了到底运行Quote 的函数还是Bulk_quote的函数。无论我们是拷贝还是移动数据，clone都返回一个新 分配对象的指针，该对象与clone所属的类型一致。我们把一个shared_ptr绑定到这 个对象上，然后调用insert将这个新分配的对象添加到items中。注意，因为 Shared_ptr支持派生类向基类的类型转换(参见15.2.2节，第530页)，所以我们能把 5)1316<1_9七］：<(2130七6>绑定至1』Bulk_quote*上。

###### 15.8.1节练习

练习15.30:编写你自己的Basket类，用它计算上一个练习中交易记录的总价格。

##### 15.9文本查询程序再探

接下来，我们扩展12.3节(第430页)的文本查询程序，用它作为说明继承的最后一 E^5>个例子。在上一版的程序中，我们可以查询在文件中某个指定单词的出现情况。我们将在 本节扩展该程序使其支持更多更复杂的查询操作。在后面的例子中，我们将针对下面这个

小故事展开查询：

Alice Emma has long flowing red hair.

Her Daddy says when the wind blows through her hair, it looks almost alive, like a fiery bird in flight.

A beautiful fiery bird, he tells her, magical but untamed.

••Daddy, shush, there is no such thing," she tells him, at the same time wanting him to tell her more.

Shyly, she asks, "I mean, Daddy, is there?"

我们的系统将支持如下查询形式。

•单词查询，用于得到匹配某个给定string的所有行：

Executing Query for: Daddy Daddy occurs 3 times

(line 2) Her Daddy says when the wind blows (line 7) "Daddy, shush, there is no such thing,"

(line 10) Shyly, she asks, "I mean, Daddy, is there?"

•逻辑非查询，使用-运算符得到不匹配查询条件的所有行：

Executing Query for:〜(Alice)

(Alice) occurs 9 times

(line 2) Her Daddy says when the wind blows (line 3) through her hair, it looks almost alive, (line 4) like a fiery bird in flight.

•逻辑或查询，使用I运算符返回匹配两个条件中任意一个的行：

Executing Query for: (hair | Alice)

(hair | Alice) occurs 2 times

(line 1) Alice Emma has long flowing red hair.

(line 3) through her hair, it looks almost alive,

•逻辑与查询，使用&运算符返回匹配全部两个条件的行：

Executing query for: (hair & Alice)

(hair & Alice) occurs 1 time

(line 1) Alice Emma has long flowing red hair.

此外，我们还希望能够混合使用这些运算符，比如：

fiery & bird | wind

在类似这样的例子中，我们将使用C++通用的优先级规则(参见4.1.2节，第121页)对 复杂表达式求值。因此，这条查询语句所得行应该是如下二者之一：在该行中或者fiery 和bird同时出现，或者出现了 wind：

< 636 I



Executing Query for: ((fiery & bird) | wind)

((fiery & bird) | wind) occurs 3 times (line 2) Her Daddy says when the wind blows (line 4) like a fiery bird in flight.

(line 5) A beautiful fiery bird, he tells her,

在输出内容中首先是那条查询语句，我们使用圆括号来表示查询被解释和执行的次序。与 之前实现的版本一样，接下来系统将按照查询结果中行号的升序显示结果并且每一行只显 示一次。

###### 15.9.1面向对象的解决方案

我们可能会认为使用12.3.2节(第432页)的TextQuery类来表示单词查询，然后

从该类中派生出其他查询是一种可行的方案。

然而，这样的设计实际上存在缺陷。为了理解其中的原因，我们不妨考虑逻辑非查询。 单词查询查找一个指定的单词，为了让逻辑非查询按照单词查询的方式执行，我们将不得 不定义逻辑非查询所要查找的单词。但是在一般情况下，我们无法得到这样的单词。相反， 一个逻辑非查询中含有一个结果值需要取反的查询语句（单词查询或任何其他查询）；类 似的，一个逻辑与查询和一个逻辑或查询各包含两个结果值需要合并的查询语句。

由上述观察结果可知，我们应该将几种不同的查询建模成相互独立的类，这些类共享 一个公共基类：

WordQuery

NotQuery

OrQuery

AndQuery



// Daddy // 〜Alice // hair | Alice // hair & Alice

这些类将只包含两个操作:

•    eval,接受一■个TextQuery对象并返回一个QueryResult，eval函数使用给 定的TextQuery对象查找与之匹配的行。

•    rep,返回基础查询的string表示形式，eval函数使用rep创建一个表示匹配 结果的QueryResult,输出运算符使用rep打印查询表达式。

1~637>



艽键概念：继承M组合

继承体系的设计本身是一个非常复杂的问题，已经超出了本书的范围。然而，有一 条设计准则非常重要也非常基础，每个程序员都应该熟悉它。

当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（IsA）” 关系。在设计良好的类体系当中，公有派生类的对象应该可以用在任何需要基类对象的 地方。

类型之间的另一种常见关系是“有一个（HasA）’’关系，具有这种关系的类暗含成 员的意思d

在我们的书店示例中，基类表示的是按规定价格销售的书籍的报价。Bulk_quote “是一种”报价结果，只不过它使用的价格策略不同。我们的书店类都“有一个”价格 成员和ISBN成员。

抽象基类

如我们所知，在这四种查询之间并不存在彼此的继承关系，从概念上来说它们互为兄 弟。因为所有这些类都共享同一个接口，所以我们需要定义一个抽象基类（参见15.4节， 第541页）来表示该接口。我们将所需的抽象基类命名为Query_base,以此來表示它的 角色是整个查询继承体系的根节点。

我们的Query_base类将把eval和rep定义成纯虚函数（参见15.4节，第541页）， 其他代表某种特定询类型的类必须覆盖这两个函数。我们将从Query_base直接派生 出WordQuery和NotQuery。AndQuery和OrQuery都具有系统中其他类所不具备的 一个特殊属性：它们各自包含两个运算对象。为了对这种属性建模，我们定义另外一个名 为BinaryQuery的抽象基类，该抽象基类用于表示含有两个运算对象的查询。AndQuery 和 OrQuery 继承自 BinaryQuery，而 BinaryQuery 继承自 Query base。由这些分

析我们将得到如图15.2所示的类设计结果:

图15.2: Query_base继承体系



将层次关系隐藏于接口类中

我们的程序将致力于计算查询结果，而非仅仅构建查询的体系。为了使程序能正常运 行，我们必须首先创建查询命令，最简单的办法是编写C++表达式。例如，可以编写下面 的代码来生成之前描述的复合查询：

Query q = Query("fiery") & Query("bird") | Query("wind");

如上所述，其隐含的意思是用户层代码将不会直接使用这些继承的类；相反，我们将 定义一个名为Query的接口类，由它负责隐藏整个继承体系。Query类将保存一个 Query_base指针，该指针绑定到Query_base的派生类对象上。Query类与 Query_base类提供的操作是相同的：eval用于求查询的结果，rep用于生成查询的 string版本，同时Query也会定义一个重载的输出运算符用于显示查询。

< 638 1



用户将通过Query对象的操作间接地创建并处理Query_base对象。我们定义 Query对象的三个重载运算符以及一个接受string参数的Query构造函数，这些函数 动态分配一个新的Query_base派生类的对象：

•    &运算符生成一个绑定到新的AndQuery对象上的Query对象；

•    I运算符生成一个绑定到新的OrQuery对象上的Query对象；

•"运算符生成一个绑定到新的NotQuery对象上的Query对象；

•接受string参数的Query构造函数生成一个新的WordQuery对象。

Query q = Query("fiery") & Query("bird")    | Query("wind")

图15.3：使用Query表达式创建的对象



理解这些类的工作机理

在这个应用程序中，很大一部分工作是构建代表用户查询的对象，对于读者来说认识到 这一点非常重要。例如，像上面这样的表达式将生成如图15.3所示的一系列相关对象的集合。

一旦对象树构建完成后，对某一条查询语句的求值（或生成表示形式的）过程基本上 就转换为沿着箭头方向依次对每个对象求值（或显示）的过程（由编译器为我们组织管理）。 r~639＞例如，如果我们对q（即树的根节点）调用eval函数，则该调用语句将令q所指的OrQuery

对象eval它自己。对该OrQuery求值实际上是对它的两个运算对象执行eval操作： 一^^运算对象是AndQuery,另一个是查找单词wind的WordQuery。接下来，对 AndQuery求值转化为对它的两个WordQuery求值，分别生成单词fiery和bird的 查询结果。

对于面向对象编程的新手来说，要想理解一个程序，最困难的部分往往是理解程序的 设计思路。一旦你掌握了程序的设计思路，接下来的实现也就水到渠成了。为了帮助读者 理解程序设计的过程，我们在表15.1中整理了之前那个例子用到的类，并对其进行了简要 的描述。

| 表15.1:概述：Query程序设计 |                                                              |
| -------------------------- | ------------------------------------------------------------ |
| Query程序接口类和操作      |                                                              |
| TextQuery                  | 该类读入给定的文件并构建一个查找图。这个类包含一个query操作，它接 受一个string实参，返回一个QueryResult对象；该QueryResult对象 表示string出现的行（12.3.2节，第432页） |
| QueryResult                | 该类保存一个query操作的结果（12.3.2节，第433页）             |
| Query                      | 是一个接口类，指向Query_base派生类的对象                     |
| Query q(s)                 | 将Query对象q绑定到一个存放着string s的新WordQuery对象上      |
| ql & q2                    | 返回一个Query对象，该Query绑定到一个存放ql和q2的新AndQuery对 象上 |
| ql \| q2                   | 返回一个Query对象，该Query绑定到一个存放ql和q2的新OrQuery对 象上 |
| 'qQuery程序实现类          | 返回一个Query对象，该Query绑定到一个存放q的新NotQuery对象上  |
| Query_base                 | 查询类的抽象基类                                             |
| WordQuery                  | Query_base的派生类，用于查找一个给定的单词                   |
| NotQuery                   | Query_base的派生类，查询结果是Query运算对象没有出现的行的集合 |
| Binary-Query               | Query_base派生出来的另一个抽象基类，表示有两个运算对象的查询 |
| OrQuery                    | BinaryQuery的派生类，返回它的两个运算对象分别出现的行的并集  |
| AndQuery                   | BinaryQuery的派生类，返回它的两个运算对象分别出现的行的交集  |

###### 15.9.1节练习

练习15.31:已知si、s2、s3和s4都是string,判断下面的表达式分别创建了什 么样的对象：

(a)    Query (si) | Query (s2) & ~ Query (s3);

(b)    Query (si) | (Query (s2) & ~ Query (s3));

(c)    (Query (si) & (Query (s2) )    | (Query (s3)    & Query (s4)));



###### 15.9.2 Query_base 类和 Query 类

下面我们开始程序的实现过程，首先定义Query_base类：

//这是一个抽象基类，具体的查询类型从中派生，所有成员都是private的 class Query_base {

friend class Query; protected:

using line一no = TextQuery: :line_no; // 用于 eval 函数 virtual ~Query_base() = default;

private:

// eval 回与当前Query匹酉己的QueryResult

virtual QueryResult eval(const TextQueryS) const = 0;

// rep是表示查询的一个string

virtual std::string rep() const = 0;

}；

eval和rep都是纯虚函数，因此Query_base是一个抽象基类(参见15.4节，第541 页)。因为我们不希望用户或者派生类直接@用Query_base,所以它没有public成员。 所有对Query_base的使用都需要通过Query对象，因为Query需要调用Query_base 的虚函数，所以我们将Query声明成Query_base的友元。

受保护的成员line_nO将在eval函数内部使用。类似的，析构函数也是受保护的, 因为它将(隐式地)在派生类析构函数中使用。

Query 类

Query类对外提供接口，同时隐藏了 Query_base的继承体系。每个Query对象都 含有一个指向Query_base对象的shared_ptr。因为Query是Query_base的唯一 接口，所以Query必须定义自己的eval和rep版本。

接受一个string参数的Query构造函数将创建一个新的WordQuery对象，然后 将它的shared_prt成员绑定到这个新创建的对象上。&、|和~运算符分别创建 AndQuery、OrQuery和NotQuery对象，这些运算符将返回一个绑定到新创建的对象 上的Query对象。为了支持这些运算符，Query还需要另外一个构造函数，它接受指向 Query_base的shared_ptr并且存储给定的指针。我们将这个构造函数声明为私有的， 原因是我们不希望一般的用户代码能随便定义Query_base对象。因为这个构造函数是 私有的，所以我们需要将三个运算符声明为友元。

在形成了上述设计思路后，Query类本身就比较简单了：

//这是一个管理Query_base继承体系的接口类 class Query {

//这些运其符需要访问接受shared_ptr的构造函数，而该函数是私有的 friend Query operator-(const Query &); friend Query operator|(const Query&, const QueryS); friend Query operators(const Query&, const Query&);

<64?1



public:

Query (const std: : strings) ;    // 构建一个新的 WordQuery

//接口画数：调用对应的Query_base操作 QueryResult eval(const TextQuery &t) const

{ return q->eval(t); }

std::string rep() const { return q->rep(); }

private:

Query(std::shared_ptr<Query_base> query): q(query) { } std::shared_ptr<Query_base> q;

}；

我们首先将创建Query对象的运算符声明为友元，之所以这么做是因为这些运算符需要 访问那个私有构造函数。

在Query的公有捧口部分，我们声明了接受string的构造函数，不过没有对其进 行定义。因为这个构造函数将要创建一个WordQuery对象，所以我们应该首先定义 WordQuery类，随后才能定义接受string的Query构造函数。

另外两个公有成员是Query_base的接口。其中，Query操作使用它的Query_base 指针来调用各自的Queryjoasei函数。实际调用哪个函数版本将由q所指的对类型 决定，并且直到运行时才能最终确定下来。

谷Query的输出运算符

输出运算符可以很好地解释我们的整个查询系统是如何工作的： std::ostream &

operator<<(std::ostream &os, const Query &query)

{

// Query: : rep通过它的Query_base指针对rep ()进行了虚调用 return os « query.rep();

}

当我们打印一个Query时，输出运算符调用Query类的公有rep成员。运算符函数通 过指针成员虚调用当前Query所指对象的rep成员。也就是说，当我们编写如下代码时：

Query andq = Query(soughtl) & Query(sought2); cout « andq « endl;

输出运算符将调用andq的Query: : rep，而Query: : rep通过它的Query_base指针 虚调用Query_base版本的rep函数。因为andq指向的是一个AndQuery对象，所以 本次的函数调用将运行AndQuery: : rep。

###### 15.9.2节练习

练习15.32：当一个Query类型的对象被拷贝、移动、赋值或销毁时，将分别发生什么？

练习15.33：当一个QueryjDase类型的对象被拷贝、移动、赋值或销毁时，将分别发 生什么？

###### L642> 15.9.3 派生类

对于Query_base的派生类来说，最有趣的部分是这些派生类如何表示一个真实的 查询。其中WordQuery类最直接，它的任务就是保存要查找的单词。

其他类分别操作一个或两个运算对象。NotQuery有一个运算对象，AndQuery和 ◦rQuery有两个。在这些类当中，运算对象可以是Query_base的任意一个派生类的对 象：一个 NotQuery 对象可以被用在 WordQuery、AndQuery、OrQuery 或另一个 NotQuery中。为了支持这种灵活性，运算对象必须以Query base指针的形式存储，

这样我们就能把该指针绑定到任何我们需要的具体类上。

然而，实际上我们的类并不存储Query_base指针，而是直接使用一个Query对象。 就像用户代码可以通过接口类得到简化一li，我们也可以使用接口类来简化我们自己的 类。

至此我们已经清楚了所有类的设计思路，接下来依次实现它们。

WordQuery 类

一个WordQuery查找一个给定的string,它是在给定的TextQuery对象上实际 执行查询的唯一一个操作：

class WordQuery: public Query_base {

friend class Query;    // Query 使用 WordQuery 构造函数

WordQuery(const std::string &s): query_word(s)    { }

//具体的类：WordQuery将定义所有继承而来的纯虚函数 QueryResult eval(const TextQuery &t) const

{ return t.query(query_word); } std::string rep() const { return query_word; } std: : string query_word;    // 要查找的单词

}；

和Query_base 一样，WordQuery没有公有成员。同时，Query必须作为WordQuery 的友元，这样Query才能访问WordQuery的构造函数。

每个表示具体查询的类都必须定义继承而来的纯虚函数eval和rep0我们在 WordQuery类的内部定义这两个操作：eval调用其TextQuery参数的query成员，

由query成员在文件中实际进行查找：rep返回这个WordQuery表示的string (即 query_word)。

定义了 WorciQuery类之后，我们就能定义接受string的Query构造函数了：

inline

Query::Query(const std::string &s): q(new WordQuery(s)) { }

这个构造函数分配一个WordQuery,然后令其指针成员指向新分配的对象。

NotQuery类及'运算符

'■运算符生成一个NotQuery,其中保存着一个需要对其取反的Query：

<643~|



class NotQuery: public Query_base {

friend Query operator〜(const Query &);

NotQuery(const Query &q): query(q)    { }

//具体的类：NotQuery将定义所有继承而来的绝虚函数

std::string rep() const {return    + query.rep() +

QueryResult eval(const TextQuery&) const;

Query query;

}；

inline Query operator〜(const Query Soperand)

{

return std::shared_ptr<Query_base>(new NotQuery(operand));

}

因为NotQuery的所有成员都是私有的，所以我们一开始就要把-运算符设定为友元。为

了 rep—个NotQuery,我们需要将~符号与基础的Query连接在一起。我们在输出的 结果中加上适当的括号，这样读者就可以清楚地知道查询的优先级了。

值得注意的是，在NotQuery自己的rep成员中对rep的调用最终执行的是一个虚 调用：query. rep ()是对Query类rep成员的非虚调用，接着Query: : rep将调用 q->rep ()，这是一个通过Query_base指针进行的虚调用。

•■运算符动态分配一个新的NotQuery对象，其return语句隐式地使用接受一个 shared_ptr<Query_base〉的Query构造函数。也就是说，return语句等价于：

//分配一个新的NotQuery对象

// 将所4等的 NotQuery 4旨4十榔定到一个 shared_ptr<Query_base> shared_ptr<Query_base> tmp(new NotQuery(expr));

return Query (tmp) ;    // 使用接受一个 shared_ptr 的 Query 构造函数

eval成员比较复杂，因此我们将在类的外部实现它，15.9.4节(第573页)将专门 介绍如何定义eval函数。

BinaryQuery 类

BinaryQuery类也是一个抽象基类，它保存操作两个运算对象的查询类型所需的数据：

class BinaryQuery: public Query_base { protected:

BinaryQuery(const Query &1, const Query &r, std::string s): lhs(1), rhs(r), opSym(s)    { }

//抽象类：BinaryQuery不定义eval

std: : string rep () const { return "(" + lhs. rep <) + ” •’

\+ opSym + ’’ "

\+ rhs.rep() + ")"; }

Query lhs, rhs;    //左侧和右侧运算对象

std: :string opSym;    // 运算符的名字

}；

ri44> BinaryQuery中的数据是两个运算对象及相应的运算符符号，构造函数负责接受两个运 算对象和一个运算符符号，然后将它们存储在对应的数据成员中。

要想rep —个BinaryQuery，我们需要生成一个带括号的表达式。表达式的内容依 次包括左侧运算对象、运算符以及右侧运算对象。就像我们显示NotQuery的方法一样， 对rep的调用最终是对lhs和rhs所指Query_base对象的rep函数进行虚调用。

![img](C++  Primer 5-149.jpg)



BinaryQuery不定义eval,而是继承了该纯虚函数。因此，BinaryQuery 也是一个抽象基类，我们不能劍建BinaryQuery类型的对象。

AndQuery类、OrQuery类及相应的运算符

AndQuery类和OrQuery类以及它们的运算符都非常相似：

class AndQuery: public BinaryQuery {

friend Query operators(const Query&, const Query&); AndQuery(const Query &left, const Query Sright):

BinaryQuery (left, right, ’•&’’)    { }

//具体的类：AndQuery继承了 rep并且完义了其他纯虚函数 QueryResult eval(const TextQueryS) const;

};

inline Query operators(const Query &lhs, const Query &rhs)

{

return std::shared_ptr<Query_base>(new AndQuery(lhs, rhs));

class OrQuery: public BinaryQuery {

friend Query operator| (const Query&, const Query&);

OrQuery(const Query &left, const Query &right):

BinaryQuery (left, right,    { }

QueryResult eval(const TextQuery&) const;

}；

inline Query operator| (const Query &lhs, const Query &rhs)

{

return std::shared_ptr<Query_base>(new OrQuery(lhs, rhs));

}

这两个类将各自的运算符定义成友元，并且各自定义了一个构造函数通过运算符创建 BinaryQuery基类部分。它们继承BinaryQuery的rep函数，但是覆盖了 eval函数。

和~运算符一样，&和I运算符也返回一个绑定到新分配对象上的shared_ptr。在这 些运算符中，return语句负责将shared_ptr转换成Query。

###### 15.9.3节练习

<6451



练习15.34：针对图15.3 (第565页)构建的表达式：

(a)    列举出在处理表达式的过程中执行的所有构造函数。

(b)    列举出cout«q所调用的rep。

(c)    列举出q.eval ()所调用的eval。

练习15.35：实现Query类和Query_base类，其中需要定义rep而无须定义eval。

练习15.36:在构造函数和rep成员中添加打印语句，运行你的代码以检验你对本节第 —个练习中(a)、(b)两小题的回答是否正确。

练习15.37:如果在派生类中含有shared_ptr<Query_base〉类型的成员而非Query 类型的成员，则你的类需要做出怎样的改

练习15.38：下面的声明合法吗？如果不合法，请解释原因；如果合法，请指出该声明 的含义。

BinaryQuery a = Query("fiery") & Query("bird");

AndQuery b = Query("fiery") & Query("bird");

OrQuery c = Query("fiery") & Query("bird");

###### 15.9.4 eval 函数

eval函数是我们这个查询系统的核心。每个eval函数作用于各自的运算对象，同 时遵循的内在逻辑也有所区别：OrQuery的eval操作返回两个运算对象查询结果的并 集，而AndQuery返回交集。与它们相比，NotQuery的eval函数更加复杂一些：它需 要返回运算对象没有出现的文本行。

为了支持上述eval函数的处理，我们需要使用QueryResult,在它当中定义了 12.3.2节练习(第435页)添加的成员。假设QueryResult包含begin和end成员， 它们允许我们在QueryResult保存的行号set中进行迭代；另外假设QueryResult 还包含一个名为get_file的成员，它返回一个指向待查询文件的shared_ptr。

我们的Query类使用了 12.3.2节练习(第435页)为QueryResult定义的成员。

WARNING

OrQuery::eval

一个OrQuery表示的是它的两个运算对象结果的并集，对于每个运算对象来说，我 们通过调用eval得到它的查询结果。因为这些运算对象的类型是Query,所以调用eval 也就是调用Query: :eval，而后者实际上是对潜在的Query_base对象的eval进行虚 调用。每次调用完成后，得到的结果是一个QueryResult, €表示运算对象出现的行号。 我们把这些行号组织在一个新set中：

CM6>    //返回运算对象查询结果set的并集

QueryResult

OrQuery::eval(const TextQuery& text) const

{

//通过Query成员lhs和rhs进行的虚调用

//调用eval返回每个运算对象的QueryResult

auto right = rhs.eval(text), left = lhs.eval(text);

//将左侧运算对象的行号拷贝到结果set中 auto ret_lines =

make_shared<set<line_no»(left.begin() , left.end());

//插入右側运算对象所得的行号

ret_lines->insert(right.begin() , right.end());

//返回一个新的QueryResult,它表示lhs和rhs的并集 return QueryResult(rep(), ret_lines, left.get_file());

}

我们使用接受一对迭代器的set构造函数初始化ret_lineso —个QueryResult的 begin和end成员返回行号set的迭代器，因此，创建ret_lines的过程实际上是拷 贝了 left集合的元素。接下来对ret_lines调用insert,并将right的元素插入进 来。调用结束后，ret_lines将包含在left或right中出现过的所有行号。

eval函数在最后构建并返回一个表示混合查询匹配的QueryResult。 QueryResult的构造函数(参见12.3.2节，第434页)接受三个实参：一个表示查询的 string、一个指向匹配行号set的shared_ptr和一个指向输入文件vector的 shared_ptr。我们调用rep生成所需的string,调用get_file获取指向文件的 shared_ptro因为left和right指向的是同一个文件，所以使用哪个执行get_file 函数并#重要。

AndQuery::eval

AndQuery的eval和OrQuery很类似，唯一的区别是它调用了一•个标准库算法来 求得两个查询结果中共有的行：

//返回运算对象查询结果set的交集

QueryResult

AndQuery::eval(const TextQueryS text) const

//通过Query运算对象进行的虚调用，以获得运算对象的查询结果set auto left = lhs.eval (text), right = rhs.eval(text);

//保存left和right交集的set

auto ret_lines = make_shared<set<line_no>>();

//将两个黾围的交集写入一>目的迭代器中 //本次调用的目的迭代器向ret添加元素 set_intersection(left.begin(}, left.end(),

right.begin(), right.end(),

inserter(*ret_lines, ret_lines->begin())); return QueryResult(rep(), ret_lines, left.get_file());

}

其中我们使用标准库算法set_in ter sect ion来合并两个set，关于< 647 I set_intersection在附录A.2.8 (第779页)中有详细的描述。

set_intersection算法接受五个迭代器。它使用前四个迭代器表示两个输入序列 (参见10.5.2节，第368页)，最后一个实参表示目的位置。该算法将两个输入序列中共同 出现的元素写入到目的位置中。

在上述调用中我们传入一个插入迭代器(参见10.4.1节，第357页)作为目的位置。

当set_in ter sect ion向这个迭代器写入内容时，实际上是向ret_lines插入一个新 元素。

和OrQuery的eval函数一样，AndQuery的eval函数也在最后构建并返回一个 表示混合查询匹配的QueryResult。

NotQuery::eval

NotQuery查找运算对象没有出现的文本行：

//返回运算对象的结果set中不存在的行 QueryResult

NotQuery::eval(const TextQueryS text) const {

//通过Query运算对象对eval进行虚调用 auto result = query.eval(text);

//开始时结果set为空

auto ret_lines = make_shared<set<line_no»();

//我们必鬲在运算对象出现所有行中进行迭代—

auto beg = result.begin(), end = result.end();

//对于输入文件的每一行，如果该行不在result当中，则将其添加到ret lines auto sz = result.get_file()->size(); for (size_t n = 0; n != sz; ++n)    {

//如策我们还没有处理完result的所有行

//检查当前行是否存在

if (beg == end 丨丨 *beg != n)

ret_lines->insert (n) ;    // 如果不在 result 当中，添加这一行

else if (beg != end)

++beg;    //否则继续获取result的下一行(如果有的话)

}

return QueryResult(rep(), ret_lines, result.get_file());

}

和其他eval函数一样，我们首先对当前的运算对象调用eval,所得的结果

QueryResult中包含的是运算对象出现的行号，但我们想要的是运算对象未出现的行号。 也就是说，我们需要的是存在于文件中，但是不在result中的行。

要想得到最终的结果，我们需要遍历不超过输出文件大小的所有整数，并将所有不在 result中的行号放入到ret_lines中。我们使用beg和end分别表示result的第 一个元素和最后一个元素的下1位置。因为遍历的对象是一个set,所以当遍历结束后获 得的行号将按照升序排列。

S8>    循环体负责检查当前的编号是否在result当中。如果不在，将这个数字添加到

ret_lines中；如果该数字属于result,则我们递增result的迭代器beg»

一旦处理完所有行号，就返回包含ret_lines的一个QueryResult对象；和之前 版本的eval类似，该QueryResult对象还包含rep和get_file的运行结果。

###### 15.9.4节练习

练习15.39:实现Query类和Query_base类I求图15.3 (第565页)中表达式的值 并打印相关信息，验证你的程序是否正确。

练习15.40:在OrQuery的eval函数中，如果rhs成员返回的是空集将发生什么？ 如果lhs是空集呢？如果lhs和rhs都是空集又将发生什么？

练习15.41 :重新实现你的类，这次使用指向Query_base的内置指针而非 shared_ptr。请注意，做出上述改动后你的类将不能再使房合成的拷贝控制成员。 练习15.42:从下面的几种改进中选择一种，设计并实现它：

(a)    按句子查询并打印单词，而不再是按行打印。

(b)    引入一个历史系统，用户可以按编号查阅之前的某个查询，并可以在其中增加内容或者将 其与其他查询组合。

(c)    允许用户对结果做出限制，比如从给定范围的行中挑出匹配的进行显示。

##### 小结

< 649 1



继承使得我们可以编写•些新的类，这驿新类既能共亨其基类的行为.乂能根曲;耑要 複凉或添加行为。动态绑定使得我们H了以忽略类型之间的差异，其机规足在运行时根据对 象的动态类型来选择运行函数的哪个版本。继承和动态绑定的结合使得我们能够编S其有 特定类型行为但又独立于类型的程序=

在C++语吉中，动态绑定只作用r虚函数，并钍需要通过指针或引用调用。

在派生类对象中包含有与它的每个基类对应的子对象。闲为所有派t.类对象都含有基 类部分，所以我们能将派生类的引用或指针转换为•个可访闷的基类引用或指针，

泡执行派生类的构造、拷贝、移动和赋值操作吋，首先构造、拷贝、移动和赋值其屮 的基类部分，然后才轮到派生类部分。析构函数的执行顺序则止好相反，酋先销毁派生类， 接下来执行基类子对象的析构函数。基类通常都应该定义•-•个虚析构函数，即使堪类根本 不需要析构函数也最好这么做。将基类的析构函数定义成虚函数的原因圮为了确保为我们 删除' •个基类指针，而该指针实际指向一个派生类对象时,程序也能正确运行。

派生类为它的每个基类提供一个保护级别，public基类的成迠也是派生类接口的-部分；private基类的成员是不可访问的：protected基类的成员对丁•派生类的派巾类 是可访问的，但是对于派生类的用户不可访问。

##### 术语农

抽象基类(abstract base class)含有一个

或多个纯虚函数的类，我们无法创建杣象 基类的对象。

可访问的(accessible)能被派生类对象

访问的基类成员。可访问性由派生类的派 生列表中所用的访问说明符和基类中成员 的访问级别共同决定。例如，通过公有继 承而来的一个公有成员对T•派生类的用户 來说是可访问的；而私有继承而來的公有 成员是不可访问的。

基类(base class)可供其他类继承的类。 基类的成员也将成为派生类的成员。

类派生列表(class derivation list)罗列了

所有基类，每个基类包含-个可选的访M 级别，它定义了派生类继承该基类的方式。 如果没有提供访问说明符，则当派屯类通 过关键字struct定义时继承是公有的： 而当派生类通过关键字class定义时继承 是私有的。

派生类(derived class)从其他类派生而

来的类。派生类可以覆盖其基类的虚函数， 也可以定义HlA的新成W .派生类的作用 域嵌套在基类作用域当中；派生类的成员 能直接访W苺类的成员。

派生类向基类的类型转换(derived-to-base conversion)派生类对象向基类引用或巷 派生类指针向基类指针的隐式类型转换。

直接基类(direct base class)派生类S接

继承的基类，a接基类在派生类的派生列 表中说明。直接基类本身也可以足-个派 生类。

动态绑定(dynamicbinding) 直到运行吋

才确定到底执行函数的哪个版本。fl: C++ 语言中，动态绑定的意思是在运行吋根据 引用或指针所绑定对象的实际类型来选择 执行虚函数的某•个版本。

动态类型(dynamic type)对象在运行吋

的类型。引用所引对象或者指针所指对象 的动态类型可能与该引用或指针的静态类 型不同=基类的指针或引用可以指向一个 派生类对象。在这样的情况中，静态类型 是基类的引用(或指针)，而动态类型是派 生类的引用(或指针)。

< 650 I



间接基类(indirect base class)不出现在

派生类的派生列表中的基类。直接基类以 直接或间接方式继承的类是派生类的间接 基类。

继承(inheritance)由一个已有的类(基类) 定义一个新类(派生类)的编程技术。派 生类将继承基类的成员。

面向对象编程(object-oriented programming) 利用数据抽象、继承以及动态绑定 等技术编写程序的方法。

覆盖(override)派生类中定义的虚函数 如果与基类中定义的同名虚函数有相同的 形参列表，则派生类版本将覆盖基类的版 本。

多态性(polymorphism)当用于面向对象

编程的范畴时，多态性的含义是指程序能 通过引用或指针的动态类型获取类型特定 行为的能力。

私有继承(private inheritance)在私有继

承中，基类的公有成员和受保护成员是派 生类的私有成员，

protected 访问说明符(protected access specifier) protected关键字之后定义的 成员能被派生.类的成员和友元访问。但是 这些成员只对派生类对象是可访问的，对 类的普通用户则是不可访问的。

受保护的继承(protected inheritance)在

受保护的继承中，基类的公有成员和受保 护成员是派生类的受保护成员。

公有继承(public inheritance)基类的公

有接口是派生类公有接口的组成部分。

纯虚函数(pure virtual)在类的内部声明

虚函数时，在分号之前使用了=0。一个纯 虚函数不需要(但是可以)被定义。含有 纯虚函数的类是抽象基类。如果派生类没 有对继承而来的纯虚函数定义自己的版 本，则该派生类也是抽象的。

重构(refactoring)重新设计程序以便将 一呰相关的部分搜集到一个单独的抽象 中，然后使用新的抽象替换原来的代码。 通常情况下，重构类的方式是将数据成员 和函数成员移动到继承体系的高级别节点 当中，从而避免代码冗余。

运行时绑定(run-time binding)参见“动

态绑定”.

切掉(sliced down)当我们用--个派生类 对象初始化基类对象或者为基类对象赋值 时发生的情况。对象的派生类部分将被“切 掉"，只剩下基类部分赋值给基类对象，

静态类型(statictype)对象被定义的类把 或表达式产生的类型•静态类型在编澤吋 是已知的。

虚函数(virtual function)用于定义类型特 定行为的成员函数。通过引用或指针对虚 函数的凋用直到运行时才被解析，依裾是 引用或指针所绑定对象的类型。
