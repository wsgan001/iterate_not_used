内容

7.1定义抽象数据类型.......................................................................................

7.2访问控制与封装...........................................................................................

7.3类的其他特性..............................................................................................

7.4类的作用域..................................................................................................

7.5构造函数再探..............................................................................................

7.6类的静态成员..............................................................................................

.....................................................................................................................

和吾¥..................................................................................................................

228

240

243

253

257

268

273

273



在C++语言中，我们使用类定义自己的数裾类型。通过定义新的类型來反映待解决问 题中的芥种概念，可以使我们更容易编写、调试和修改程序。

本祆是第2章关于类的话题的延续，主要关注数裾抽象的重要性。数裾抽象能帮助我 们将对象的具体实现与对象所能执行的操作分离开来。第13章将讨论如何控制对象拷贝、 移动、赋值和销毁等行为，在第14京中我们将学习如何自定义运算符。

|~254>    类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一

种依赖于接口（interface）和实现（implementation）分离的编程（以及设计）技术。类的 接口包括用户所能执行的操作：类的实现则包括类的数据成员、负责接口实现的函数体以 及定义类所需的各种私有函数。

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类 的用户只能使用接口而无法访问实现部分。

类要想实现数据抽象和封装，需要首先定义一个抽象数据类型（abstract data type）。 在抽象数据类型中，由类的设计者负责考虑类的实现过程：使用该类的程序员则只需要抽 象地思考类型做了什么，而无须了解类型的工作细节。

##### 7.1定义抽象数据类增

在第I章中使用的Sales_item类是一个抽象数据类型，我们通过它的接口（例如 1.5.1节（第17页）描述的操作）来使用一个Sales_item对象。我们不能访问Sales_item 对象的数据成员，事实上，我们甚至根本不知道&个类有哪些数据成员。

与之相反，Sales_data类（参见2.6.1节，第64页）不是一个抽象数据类型。它允 许类的用户直接访问它数据成员，并且要求由用户来编写操作。要想把Sales_data 变成抽象数据类型，我们需要定义一些操作以供类的用户使用。一旦Sales_data定义 了它自己的操作，我们就可以封装（隐藏）它的数据成员了。

姐 7.1.1 设计 Sales_data 类

我们的最终目的是令Sales_data支持与Sales_item类完全一样的操作集合。 Sales_item类有一个名为isbn的成员函数（member function）（参见1.5.2节，第20 页），且支持+、=、+=、《和》运算符。

我们将在第14章学习如何自定义运算符。现在，我们先为这些运算定义普通（命名 的）函数形式。由于14.1节（第490页）将要解释的原因，执行加法和1O的函数不作为 Sales_data的成员，相反的，我们将其定义成普通函数；执行复合赋值运算的函数是成 员函数。Sales_data类无须专门定义赋值运算，其原因将在7.1.5节（第239页）介绍。

综上所述，Sales_data的接口应该包含以下操作：

•    一个isbn成员函数，用于返回对象的ISBN编号

•    一个combine成员函数，用于将一个Sales_data对象加到另一个对象上

•    一个名为add的函数，执行两个Sales_data对象的加法

•    一个read函数，将数据从istream读入到Sales_data对象中

•    一个print函数，将Sales_data对象的值输出到ostream

□§5> 又键概念：不同的编程fft色_

程序员们常把运行其程序的人称作用户（user）。类似的，类的设计者也是为其用户 设计并实现一个类的人；显然，类的用户是程序员，而非应用程序的最终使用者。

当我们提及“用户” 一词时，不同的语境决定了不同的含义。如果我们说用户代码 或者Sales_data类的用户，指的是使用类的程序员；如果我们说书店应用程序的用

户，则意指运行该应用程序的书店经理。

![img](C++  Primer 5-57.jpg)



C++程序员们无须刻意区分应用程序的用户以及类的用户6

在一些简单的应用程序中，类的用户和类的设计者常常是同一个人。尽管如此，还 是最好把角色区分开来。当我们设计类的接口时，应该考虑如何才能使得类易于使用； 而当我们使用类时，不应该顾及类的实现机理。

要想开发一款成功的应用程序，其作者必须充分了解并实现用户的需求。同样，优 秀的类设计者也应该密切关注那些有可能使用该类的程序员的需求。作为一个设计良好 的类，既要有直观且易于使用的接口，也必须具备高效的实现过程。

使用改进的Sales_data类

在考虑如何实现我们的类之前，首先来看看应该如何使用上面这些接口函数。举个例 子，我们使用这些函数编写1.6节（第21页）书店程序的另外一个版本，其中不再使用 Sales_item对象，而是使用Sales_data对象：

//保存当前求和结果的变量 //读入第一笔交易 //保存下一条交易数据的变量 //读入剩余的交易

isbn （） ）    // 检查 isbn

//更新变量total当前的值

endl；    //输出结果

//处理下一本书



/ /输出最后一条哭易 //没有输入任何信息 //通知用户



Sales_data total;

if (read(cin, total))    {

Sales_data trans;

while(read(cin, trans)) {

if (total.isbn() == trans total.combine(trans)；

else {

print(cout, total) << total = trans;

}

}

print(cout, total) << endl;

} else {

cerr << "No data?!" << endl;

一开始我们定义了一个Sales_data对象用于保存实时的汇总信息。在if条件内部，调 用read函数将第一条交易读i到total中，这里的条件部分与之前我们使用》运算符 的效果是一样的。read函数返回它的流参数，而条件部分负责检查这个返回值（参见4.11.2 <2561 节，第144页），如果read函数失败，程序将直接跳转到else语句并输出一条错误信息。

如果检测到读入了数据，我们定义变量trans用于存放每一条交易。while语句的 条件部分同样是检查read函数的返回值，只要输入操作成功，条件就被满足，意味着我 们可以处理一条新的交易。

在while循环内部，我们分别调用total和trans的isbn成员以比较它们的ISBN 编号。如果total和trans指示的是同一本书，我们调用combine函数将trans的内 容添加到total表示的实时汇总结果中去。如果trans指示的是一本新书，我们调用 print函数将之前一本书的汇总信息输出出来。因为print返回的是它的流参数的引用， 所以我们可以把print的返回值作为《运算符的左侧运算对象。通过这种方式，我们输 出print函数的处理结果，然后转到下一行。接下来，把trans赋给total,从而为接 着处理文件中下一本书的记录做好了准备。

处理完所有输入数据后，使用while循环之后的print语句将最后一条交易的信息 输出出来。

###### 7.1.1节练习

练习7.1:使用2.6.1节练习定义的Sales_data类为1.6节（第21页）的交易处理程 序编写一个新版本。

###### 7.1.2定义改进的Sales_data类

改进之后的类的数据成员将与2.6.1节（第64页）定义的版本保持一致，它们包括： bookNo, string 类型，表示 ISBN 编号：units_sold. unsigned 类型，表示某本 书的销量；以及revenue, double类型，表示这i书的总销售收入。

如前所述，我们的类将色含两个成员函数：combine和isbn。此外，我们还将赋予 SaleS_data另一个成员函数用于返回售出书籍的平均价格，这个函数被命名为 avg_price。因为avg_price的目的并非通用，所以它应该属于类的实现的一部分， 而非口的一部分。

定义（参见6+1节，第182页）和声明（参见6.1.2节，第186页）成员函数的方式与 普通函数差不多。成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以 在类的外部。作为接口组成部分的非成员函数，例如add、read和print等，它们的定 义和声明都在类的外部。

由此可知，改进的Sales_data类应该如下所示：

struct Sales_data {

//新成员：关于Sales_data对象的操作

std::string isbn() const { return bookNo; }

Sales_data& combine(const Sales_data&); double avg_price() const;

□57>    //教据成员石2.6.1节(第64页)相比没有改变

std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;

}；

// Sales_data的非成员接口函数

Sales_data add(const Sales_data&, const Sales_data&); std::ostream Sprint(std::ostream&, const Sales_data&); std: : istream &read (std: : istream&, Sales_ciata&);

定义在类内部的函数是隐式的inline函数(参见6.5.2节，第214页),.、

定义成员函数

尽管所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在 类夕卜。对于Sales_data类来说，isbn函数定义在了类内，而combine和avg_price 定义在了类外。

我们首先介绍isbn函数，它的参数列表为空，返回值是一个string对象:

std::string isbn（） const { return bookNo; }

和其他函数一样，成员函数体也是一个块。在此例中，块只有一条return语句，用亍返 回.Sales_data对象的bookNo数据成员。关于isbn函数一件有意思的事情是：它是 如何获得bookNo成员所依赖的对象的呢？

引入this

让我们再一次观察对isbn成员函数的调用： total.isbn（）

在这里，我们使用了点运算符（参见4.6节，第133页）来访问total对象的isbn成员，

然后调用它。

7.6节（第268页）将介绍一种例外的形式，当我们调用成员函数时，实际上是在替 某个对象调用它。如果isbn指向Sales_data的成员（例如bookNo），则它隐式地指 向调用该函数的对象的成员。在上面所示的调用中.当isbn返冋bookNo时，实际上它 隐式地返回total .bookNo。

成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调 用一个成员函数时，用请求该函数的对象地址初始化this。例如，如果调用

total.isbn（）

则编译器负责把total的地址传递给isbn的隐式形参this,可以等价地认为编译器将 该调用重写成了如下的形式：

//伪代码，用于说明调用成员函数的实际执行过程    <258~|

Sales_data::isbn（&total）

其中，调用Sales_data的isbn成员时传入了 total的地址。

在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访W 运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被肴 作this的隐式引用，也就是说，当isbn使用bookNo时，它隐式地使用this指向的 成员，就像我们书写了 this->bookNo—样。

对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或 变量的行为都是非法的。我们可以在成员函数体内部使用this,因此尽管没有必要，似 我们还是能把isbn定义成如下的形式：

std::string isbn（） const { return this->bookNo; }

因为this的目的总是指向“这个”对象，所以this是一个常量指针（参见2.4.2 节，第56页），我们不允许改变this中保存的地址。

引入const成员函数

isbn函数的另一个关键之处是紧随参数列表之后的const关键字，这里，const 的作用是修改隐式this指针的类型。

默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales^data 成员函数中，this的类型是Sales_data *const。尽管this是隐式的，似它仍然;若 要遵循初始化规则，意味着（在默认ti况下）我们不能把this绑定到一个常量对象上（参 见2.4.2节，第56页）。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。

如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this 声明成const Sales_data *const.毕竟，在isbn的函数体内不会改变this所指的 对象，所以把this 置为指向常量的指针有助于提高函数的灵活性。

然而，this是隐式的井且不会出现在参数列表中，所以在哪儿将this声明成指向 常量的指针就成为我们必须面对的问题。C++语言的做法是允许把const关键字放在成员 函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量 的指针。像这样使用const的成员函数被称作常量成员函数(const member function)。

可以把isbn的函数体想象成如下的形式：

//伪代码，说明隐式的this指针是如何使用的

//下面的代码是非法的：因为我们不能显式地定义自己的this指针

//谨记此处的this是一个指向常量的指针，因为isbn是一个常量成员 std：:string Sales_data：:isbn(const Sales_data *const this)

{ return this->isbn； }

因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的lAl容。在上例 中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。

(159>    常量对象，以及常量对象的引用或指针都只能调用常量成员函数,，

类作用域和成员函数

回忆之前我们所学的知识，类本身就是一个作用域(参见2.6.1节，第64页)。类的 成员函数的定义嵌套在类的作用域之内，因此，isbn中用到的名字bookNo其实就是定 义在Sales_data内的数据成员。

值得注意的是，即使bookNo定义在isbn之后，isbn也还是能够使用bookNo。 就如我们将在7.4.1节(第254页)学习到的那样，编译器分两步处理类：首先编译成员 的声明，然后才轮到成员函数体(如果有的话)。因此，成员函数体可以随意使用类中的 其他成员而无须在意这些成员出现的次序。

在类的外部定义成员函数

像其他函数一样，当我们在类的外部定义成员函数时，成员函数的定义必须与它的声 明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致。如果成 员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同 时，类外部定义的成员的名字必须包含它所属的类名：

double Sales_data::avg_price () const { if (units_sold)

return revenue/units_sold;

else

return 0;

}

函数名Sales_data: :avg_price使用作用域运算符(参见1.2节，第7页)來说明如 下的事实:我们定义了一个名为avg_price的函数，并且该函数被声明在类Sales_data 的作用域内。一旦编译器看到这个i数名，就能理解剩余的代码是位于类的作用域_内的。 因此，当avg_price使用revenue和units_sold时，实际上它隐式地使用了

Sales_data 的成员。

定义一个返回this对象的函数

函数combine的设计初衷类似于复合赋值运算符+=，调用该函数的对象代表的是赋 值运算符左侧的运算对象，右侧运算对象则通过显式的实参被传入函数：

Sales_data& Sales_data::combine（const Sales_data &rhs）

{

units_sold += rhs .units_sold; //把rhs的成员加到this对象的成员上 revenue += rhs.revenue;

return *this;    //返回调用该函数的对象

}

当我们的交易处理程序调用如下的函数时，

< 260 I



total. combine （trans） ;    // 更新变量 total 当前的值

total的地址被绑定到隐式的this参数上，而rhs绑定到了 trans上。因此，当 combine执行下面的语句时，

units一sold += rhs . units_sold;    //把rhs的成员添加到this对象的成员中

效果等同于求total. units_sold和trans . unit_sold的和，然后把结果保存到 total.units_sold 中。

该函数一个值得关注的部分是它的返回类型和返回语句。一般来说，当我们定义的函 数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算 符把它的左侧运算对象当成左值返回（参见4.4节，第129页），因此为了与它保持一致， combine函数必须返回引用类型（参见6.3.2节，第202页）。因为此时的左侧运算对象 是一个Sales_data的对象，所以返回类型应该是Sales_data&。

如前所述，我们无须使用隐式的this指针访问函数调用者的某个具体成员，而是需 要把调用函数的对象当成一个整体来访问：

return *this;    II返回调用该函数的对象

其中，return语句解引用this指针以获得执行该函数的对象，换句话说，上面的这个 调用返回total的引用。

###### 7.1.2节练习

练习7.2:曾在2.6.2节的练习（第67页）中编写了一个Sales_data类，请向这个类 添力口 combine和isbn成员。

练习7.3:修改7.1.1节（第229页）的交易处理程序，令其使用这些成员。

练习7.4:编写一个名为Person的类，使其表示人员的姓名和住址。使用string对 象存放这些元素，接下来的练习将不断充实这个类的其他特征。

练习7.5:在你的Person类中提供一些操作使其能够返回姓名和住址。这些函数是否 应该是const的呢？解释原因。

###### 7.1.3定义类相关的佧成员函数

类的作者常常需要定义一些辅助函数，比如add、read和print等。尽管这些函数 定义的操作从概念上來说属于类的接口的组成部分，但它们实际上并不属于类本身。

我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来 r~26T> （参见6.1.2节，第168页）。如果函数在概念上属于类但是不定义在类中，则它一般应与 类声明（而非定义）在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需

要引入一个文件。

![img](C++  Primer 5-58.jpg)



一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类 在同一个头文件内

定义read和print函数

下面的read和print函数与2.6.2节（第66页）中的代码作用一样，而且代码本 身也非常相似：

//输入的交易信息包括ISBN、售出总数和售出价格

istream &read(istream &is# Sales_data &item)

{

double price = 0；

is >> item.bookNo >> item.units_sold >> price;

item.revenue = price * return is;

item. units_sold；

const Sales_data &item)

"<< item.units_sold << ""<< item.avg_price()；



}

ostream &print(ostream &os {

os << item.isbn() << ' << item.revenue <<

return os；

}

read函数从给定流中将数据读到给定的对象里，print函数则负责将给定对象的内容打 印到给定的流中。

除此之外，关于上面的函数还有两点是非常重要的。第一点，read和print分别接 受一个各自10类型的引用作为其参数，这是因为1O类属亍不能被拷贝的类型，因此我们 只能通过引用来传递它们（参见6.2.2节，第188页）。而且，因为读取和写入的操作会改 变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。

第二点，print函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格 式的控制，这样可以确保由用户代码来决定是否换行。

定义add函数

add函数接受两个Sales_data对象作为其参数，返回值是一个新的Sales_data, 用于表示前两个对象的和：

Sales_data add（const Sales_data &lhs, const Sales_data &rhs）

Sales data sum = lhs；



//把lhs的数据成员拷贝给sum



sum. combine （rhs） ;    //把rhs的数据成员加到sum当中

return sum;

}

在函数体中，我们定义了一个新的Sales_data对象并将其命名为sum。sum将用于存＜M] 放两笔交易的和，我们用lhs的副本来初始化sum。默认情况下，拷贝类的对象其实拷 贝的是对象的数据成员-在拷贝工作完成之后，sum的bookNo、units_sold和revenue 将和lhs —■致-接下来我们调用combine函数，将rhs的units_soid和revenue 添加给sum。最后，函数返回sum的副本。

###### 7.1.3节练习

练习7.6:对于函数add、read和print,定义你自己的版本。

练习7.7:使用这些新函数重写7.1.2节（第233页）&习中的交易处理程序。

练习7.8:为什么read函数将其Sales_data参数定义成普通的引用，而print将 其参数定义成常量引用？

练习7.9:对于7.1.2节（第233页）练;M中的代码，添加读取和打印Person对象的操 作。

练习7.10:在下面这条if语句中，条件部分的作用是什么？ if （read（read（cin, datal）, data2））

###### 7.1.4构造函数    ®

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来 控制其对象的初始化过祝，这些函数叫做构造函数（constructor）。构造函数的任务是初始 化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

在这一节中，我们将介绍定义构造函数的基础知识。构造函数是一个非常复杂的问题，

我们还会在7.5节（第257页）、15.7节（第551页）、18.1.3节（第689页）和第13章介 绍更多关于构造函数的知识。

构造函数的名字和类名相同。和其他函数不一样的是，构造函数没有返回类型；除此 之外类似于其他的函数，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）

函数体。类可以包含多个构造函数，和其他重载函数差不多（参见6.4节，第206页），不 同的构造函数之间必须在参数数量或参数类型上有所区别。

不同于其他成员函数，构造函数不能被声明成const的（参见7丄2节，第231页）。 当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得 其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。



合成的默认构造函数

我们的Sales_data类并没有定义任何构造函数，可是之前使用了 Sales_data对 象的程序仍然可以正确地编译和运行。举个例子，第229页的程序定义了两个对象：

Sales_data total; Sales data trans;



//保存当前求和结果的变量 //保存下一条交易数据的变量

1163>这时我们不禁要问：total和trans是如何初始化的呢？

我们没有为这些对象提供初始值，因此我们知道它们执行了默认初始化（参见2.2.1 节，第40页）。类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构 造函数（default constructor）-默认构造函数无须任何实参。

如我们所见，默认构造函数在很多方面都有其特殊性。其中之一是，如果我们的类没 有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。

编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）o对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数 据成员：

•如果存在类内的初始值（参见2.6.1节，第64页），用它来初始化成员。

•否则，默认初始化（参见2.2.1节，第40页）该成员。

因为Sales_data为units_sold和revenue提供了初始值，所以合成的默认构造函 数将使用这i值来初始化对应 成员；同时，它把bookNo默认初始化成一个空字符串。

某些类不能依赖于合成的默认构造函数

合成的默认构造函数只适合非常简单的类，比如现在定义的这个Sales_data版本。 对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：第一个原因也是最 容易理解的一个原因就是编译器只有在发现类不包含任何构造函数的情况下才会替我们 生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一 个默认的构造函数，否则类将没有默认构造函数。这条规则的依据是，如果一个类在某种 情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。

![img](C++  Primer 5-59.jpg)



只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数:，

第二个原因是对于某些类来说，合成的默认构造函数可能执行错误的操作。回忆我们 之前介绍过的，如果定义在块中的内置类型或复合类型（比如数组和指针）的对象被默认 初始化（参见2.2.1节，第40页），则它们的值将是未定义的。该准则同样适用于默认初 始化的内置类型成员。因此，含有内置类型或复合类型成员的类应该在类的内部初始化这 些成员，或者定义一个自己的默认构造函数。否则，用户在创建类的对象时就可能得到未 定义的值。

A    如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了

类内的初始值时，这个类才适合于使用合成的默认构造函数

WARNING

□«>    第三个原因是有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包

含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化 该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认 构造函数。在13.1.6节（第449页）中我们将看到还有其他一些情况也会导致编译器无法 生成一个正确的默认构造函数。

定义Sales_data的构造函数

对于我们的Sales_data类来说，我们将使用下面的参数定义4个不同的构造函数: • 一个istreamS,从中读取一条交易信息。

•—个const string&，表示ISBN编号；一个unsigned，表75售出的图书数量； 以及一个double，表示图书的售出价格。

•    一■个const strings,表示ISBN编号；编译器将赋予其他成员默认值。

•    一个空参数列表（即默认构造函数），正如刚刚介绍的，既然我们已经定义了其他 构造函数，那么也必须定义一个默认构造函数。

给类添加了这些成员之后，将得到

struct Sales_data {

//新增的％造函数 Sales_data() = default；

Sales_data(const std::string &s): bookNo(s)    { }

Sales_data(const std::string &s, unsigned n, double p):

bookNo(s), units_sold(n), revenue(p*n) { } Sales_data(std：:istream &)；

//之箭已有的其他成员

std::string isbn() const { return bookNo； }

Sales_data& combine(const Sales_data&)； double avg price() const;

std：:string bookNo； unsigned units_sold = 0; double revenue = 0.0；

};

=default的含义

我们从解释默认构造函数的含义开始：

Sales_data（） = default；

首先请明确一点：因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定 义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函 数。我们希望这个函数的作用完全等同于之前使用的合成默认构造函数。

在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上＜2651 =default来要求编译器生成构造函数。其中，=default既可以和声明一起出现在 类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果=default在类的rc^q 内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。

WARNING



上面的默认构造函数之所以对Sales_data有效，是因为我们为内置类型的 数据成员提供了初始值。如果你的编译器不支持类内初始值，那么你的默认 构造函數就应该使用构造函数初始值列表（马上就会介绍•）'来初始化类的每个 成员。

构造函数初始值列表

接下来我们介绍类中定义的另外两个构造函数:

Sales_data(const std：:string &s): bookNo(s) { }

Sales_data(const std::string &s, unsigned n, double p):

bookNo(s), units_sold(n), revenue(p*n) { }

这两个定义中出现了新的部分，即冒号以及冒号和花括号之间的代码，其中花括号定义了

(空的)函数体。我们把新出现的部分称为构造函数初始值列表(constructor initialize list)，

它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个 列表，每个名字后面紧跟括号括起来的(或者在花括号内的)成员初始值。不同成员的初 始化通过逗号分隔开来=

含有三个参数的构造函数分别使用它的前两个参数初始化成员bookNo和 units_sold> revenue的初始值则通过将售出图书总数和每本书单价相飛计算得到。

只有一个string类型参数的构造函数使用这个string对象初始化bookNo,对于 units_sold和revenue则没有显式地初始化。当某个数据成员被构造函数初始值列表 忽略时了它将以与合成默认构造函数相同的方式隐式初始化。在此例中，这样的成员使用 类内初始值初始化，因此只接受一个string参数的构造函数等价于

//与上面定义的那个构造函数效果相同

Sales_data(const std::string &s):

bookNo(s), units_sold(0)x revenue(0){ }

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在 我们就能确保为成员赋予了一个正确的值。不过.如果你的编译器不支持类内初始值，则 所有构造函数都应该显式地初始化每个内置类型的成员。

构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同._如果 你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的

成员..，

E266>    有一点需要注意，在上面的两个构造函数中函数体都是空的。这是因为这些构造函数

的唯一目的就是为数据成员赋初值，一旦没有其他任务需要执行，函数体也就为空了。

在类的外部定义构造函数

与其他几个构造函数不同，以istream为参数的构造函数需要执行一些实际的操作， 在它的函数体内，调用了 read函数以给数据成员赋以初值：

Sales_data::Sales_data(std::istream &is)

{

read (is, *this) ; // read函数的作用是从is中读取一条交易信息然后 //存入this对象中

}

构造函数没有返回类型，所以上述定义从我们指定的函数名字开始。和其他成员函数一样， 当我们在类的外部定义构造函数吋，必须指明该构造函数是哪个类的成员。因此， Sales_data: :Sales_data的含义是我们定义Sales_data类的成员，它的名字是 Sales_datao又因为该成员的名字和类名相同，所以它i一个构造函数。

这个构造函数没有构造函数初始值列表，或者讲得更准确一点，它的构造函数初始值 列表是空的。尽管构造函数初始值列表是空的，但是由于执行了构造函数体，所以对象的 成员仍然能被初始化。

没有出现在构造函数初始值列表中的成员将通过相应的类内初始值(如果存在的话) 初始化，或者执行默认初始化。对于Sales_data來说，这意味着一旦函数开始执行， 则bookNo将被初始化成空string对象，而units sold和revenue将是0。

为了更好地理解调用函数read的意义，要特别注意read的第二个参数是一个 Sales_data对象的引用。在7.1.2节（第232页）中曾经提到过，使用this来把对象 当成一+整体访问，而非直接访问对象的某个成员。因此在此例中，我们使用+this将 “this”对象作为实参传递给read函数。

###### 7.1.4节练习    ~~

练习7.11:在你的Sales_data类中添加构造函数，然后编写一段程序令其用到每个 构造函数。

练习7.12：把只接受一个istream作为参数的构造函数定义移到类的内部。

练习7.13：使用istream构造函数重写第229页的程序。

练习7.14:编写一个构造函数，令其用我们提供的类内初始值显式地初始化成员。

练习7.15：为你的Person类添加正确的构造函数。

###### 7.1.5拷贝、赋值和析构？6

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行＜260 为。对象在几种情况下会被拷贝，如我们初始化变量以及以值的方式传递或返回一个对象 等（参见6.2.1节，第187页和6.3.2节，第200页）。当我们使用了赋值运算符（参见4.4 节，第129页）时会发生对象的赋值操作。当对象不再存在时执行销毁的操作，比如一个 局部对象会在创建它的块结束时被销毁（参见6.1.1节，第184页），当vector对象（或 者数组）销毁时存储在其中的对象也会被销毁。

如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成 的版本将对对象的每个成员执行拷贝、赋值和销毁操作。例如在7.1.1节（第229贞）的 书店程序中，当编译器执行如下赋值语句时，

total = trans； //处理下一本书的信息

它的行为与下面的代码相同

// Sales_data的默认赋值操作等价于： total.bookNo = trans.bookNo; total.units_sold = trans.units_sold; total.revenue = trans.revenue;

我们将在第13章中介绍如何自定义上述操作。

某些类不能依赖于合成的版本

尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于 某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源吋，合成 的版本常常会失效。举个例子，第12章将介绍C++程序是如何分配和管现动态内存的。

而在13.1.4节（第447页）我们将会看到，管理动态内存的类通常不能依赖于上述操作的 合成版本，

不过值得注意的是，很多需要动态内存的类能（而且应该）使用vector对象或者 string对象管理必要的存储空间。使用vector或者string的类能避免分配和释放内 存带来的复杂性。

进一步讲，如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版 本能够正常工作。当我们对含有vector成员的对象执行拷贝或者赋值操作时，vector 类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁vector对象，也 就是依次销毁vector中的每一个元素。这一点与string是非常类似的。

A 在学习第13章关于如何自定义操作的知识之前，类中所有分配的资源都应该 直接以类的数据成员的形式存储

##### ® 7.2访问控制与封装

□§8>    到目前为止，我们已经为类定义了接口，但并没有任何机制强制用户使用这些接口。

我们的类还没有封装，也就是说，用户可以直达Sales_data对象的内部并且控制它的 具体实现细节。在C++语言中，我们使用访问说明符(access specifiers)加强类的封装性：

•定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的 接口。

•定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该 类的代码访问，private部分封装了(即隐藏了)类的实现细节。

再一次定义Sales_data类，其新形式如下所示： class Sales_data {

public:    //添加了访问说明符

Sales_data() = default；

Sales_data(const std：:string &s, unsigned n, double p):

bookNo(s), units_sold(n), revenue(p*n) { }

Sales_data(const std::string &s): bookNo(s) { }

Sales_data(std：:istream&)；

std：:string isbn() const { return bookNo； }

Sales_data ^combine(const Sales_data&)；

private :    //添加了访问说明符

double avg_price() const

{ return units_sold ? revenue/units_sold : 0; } std：:string bookNo； unsigned units_sold = 0; double revenue = 0.0；

};

作为接口的一部分，构造函数和部分成员函数(即isbn和combine)紧跟在public 说明符之后；而数据成员和作为实现部分的函数则跟在private说明符后面。

一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没 有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一 个访问说明符或者到达类的结尾处为止。

使用class或struct关键字

在上面的定义中我们还做了一个微妙的变化，我们使用了 class关键字而非struct 开始类的定义。这种变化仅仅是形式上有所不同，实际上我们可以使用这两个关键字中的 任何一个定义类。唯一的一点区别是，struct和class的默认访问权限不太一样。

类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义

的方式。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public 的；相反，如果我们使用class关键字，则这些成员是private的。

出于统一编程风格的考虑，当我们希望定义的类的所有成员是public的时，使用＜269] struct；反之，如果希望成员是private的，使用class。

WARNING



使用class和struct定义类唯一的区别就是默认的访问权限。

###### 7.2节练习

练习7.16：在类的定义中对于访问说明符出现的位置和次数有限定吗？如果有，是什 么？什么样的成员应该定义在public说明符之后？什么样的成员应该定义在 private说明符之后？

练习7.17:使用class和struct时有区别吗？如果有，是什么？

练习7.18:封装是何含义？它有什么用处？

练习7.19：在你的Person类中，你将把哪些成员声明成public的？哪些声明成 private的？解释你这样做的原因。

###### 7.2.1友元    姐

既然Sales_data的数据成员是private的，我们的read、print和add函数 也就无法正常编€了，这是因为尽管这几个函数是类的接口的一部分，但它们不是类的成员。

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的 友元（friend）。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开 始的函数声明语句即可：

class Sales_data {

//为Sales_data的非成员函数所做的友元声明

friend Sales_data add(const Sales_data&, const Sales_data&)；

friend std：:istream &read(std：:istream&# Sales_data&)；

friend std：：ostream Sprint(std：：ostream&, const Sales_data&)；

//其他成员及访问说明符与之前一致

public:

Sales_data() = default；

Sales_data(const std::string &s, unsigned n, double p):

bookNo(s), units_sold(n), revenue(p*n) { }

Sales_data(const std::string &s): bookNo(s) { }

Sales_data(std::istream&)；

std：:string isbn() const { return bookNo； }

Sales_data &combine(const Sales_data&)；

private:

std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;

}；

// Sales_data接口的非成员组成部分的声明    < 270 |

Sales data add(const Sales data&, const Sales data&);

std::istream &read（std::istream&, Sales_data&）;

std::ostream Sprint（std::ostream&, const Sales_data&）;

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员 也不受它所在区域访问控制级别的约束。我们将在7.3.4节（第250页）介绍更多关于友 元的知识。

![img](C++  Primer 5-61.jpg)



一般来说，最好在类定义开始或结束前的位置集中声明友元。

又-键概念：封装的益处

封装有两个重要的优点:

•确保用户代码不会无意间破坏封装对象的状态。

•被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。

一旦把数据成员定义成private的，类的作者就可以比较自由地修改数据了。当 实现部分改变时，我们只需要检查类的代码本身以确认这次改变有什幺影响；换句话说， 只要类的接口不变，用户代码就无须改变、如果数据是public的，则所有使用了原来 数据成员的代码都可能失效，这时我们必须定位并重写所有依救于老版本实现的代码， 之后才能重新使用该程序。

把数据成员的访问权限设成private还有另外一个好处，这么做能防止由于用户 的原因造成数据被破坏。如果我们发现有程序缺陷破坏了对象的状态，则可以在有限的 范围内定位缺陷：因为只有实现部分的代码可能产生这样的错误。因此，将查错限制在 有限范围内将能极大地降低维护代码及修正程序错误的难度。

![img](C++  Primer 5-62.jpg)



尽管当类的定义发生改变时无须更改用户代码，但是使用了该类的源文件必须 重新编译。

eg友元的声明

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望 类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次 声明。

为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中 （类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立 的声明（除了类内部的友元声明之^）。

许多编译器并未强制限定友元函数必须在使用之前在类的外部声明，

□ZE>    一些编译器允许在尚无友元函数的初始声明的情况下就调用它。不过即使你的编译器

支持这种行为，最好还是提供一个独立的函数声明。这样即使你更换了一个有这种强制要 求的编译器，也不必改变代码。

###### 7.2.1节练习

练习7.20:友元在什么时候有用？请分别列举出使用友元的利弊。

练习7.21：修改你的Sales_data类使其隐藏实现的细节。你之前编写的关于 Sales_data操作的程序应该€续使用，借助类的新定义重新编译该程序，确保其工作正常。 练习7.22：修改你的Person类使其隐藏实现的细节。

##### 7.3炎的其他特性

虽然Sales_data类非常简单，但是通过它我们已经了解C++语言中关于类的许多 语法要点。在本节中，我们将继续介绍Sales_data没有体现出来的一些类的特性。这 些特性包括：类型成员、类的成员的类内初始€、可变数据成员、内联成员函数、从成员 函数返0*this、关于如何定义并使用类类型及友元类的更多知识。

###### 7.3.1类成员再探

为了展示这些新的特性，我们需要定义一对相互关联的类，它们分别是Screen和 Window_mgr0

定义一个类型成员

Screen表示显示器中的一个窗口。每个Screen包含一个用于保存Screen内容的 string成员和三个string: : size_type类型的成员，它们分别表示光标的位置以及 屏幕的高和宽，

除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的 类型名字和其他成员一样存在访问限制，可以是public或者private中的一种：

class Screen { public:

typedef std：:string：:size_type pos； private:

pos cursor = 0;

pos height = 0, width = 0;

std：:string contents；

}；

我们在Screen的public部分定义了 pos,这样用户就可以使用这个名字。Screen的＜ 272 1 用户不应该知道Screen使用了一个string对象来存放它的数据，因此通过把pos定 义成public成员可以隐藏Screen实现的细节。

关于pos的声明有两点需要注意。首先，我们使用了 typedef （参见2.5.1节，第 60页），也可以等价地使用类型别名（参见2.5.1节，第60页）：

class Screen { public:

//使用类型别名等价地声明一个类型名字 using pos = std：:string：:size_type；

//其他成员与之前的版本一致

};

其次，用来定义类型的成员必须先定义后使用，这-点与普通成员有所区别，具体原因将

在7.4.1节（第254页）解释。因此，类型成员通常出现在类开始的地方。

Screen类的成员函数

要使我们的类更加实用，还需要添加一个构造函数令用户能够定义屏幕的尺寸和内 容，以及其他两个成员，分别负责移动光标和读取给定位置的字符：

class Screen {

public:

typedef std：:string：:size_type pos；

Screen （） = default； //因为Screen有另一个构造函数，

//所以本函数是必需的 // cursor被其类内初始值初始化为0

Screen(pos ht, pos wd, char c): contents(ht * wd, c) { } char get() const

height(ht), width(wd),



}

const；



//读取光标处的字符 //隐式内联 //显式内联 //能在之后被设为内联



{ return contents[cursor]； inline char get(pos ht, pos wd) Screen amove(pos r, pos c)；

private:

pos cursor = 0；

pos height = 0, width = 0;

std：:string contents；

};

因为我们已经提供了一个构造函数，所以编译器将不会自动生成默认的构造函数。如果我 们的类需要默认构造函数，必须显式地把它声明出来。在此例中，我们使用=（1以扣1亡告 诉编译器为我们合成默认的构造函数（参见7+1+4节，第237页）。

需要指出的是，第二个构造函数（接受三个参数）为cursor成员隐式地使用了类内 初始值（参见7.1.4节，第238页）。如果类中不存在cursor的类内初始值，我们就需要 像其他成员一样显式地初始化cursor 了。

HZ3＞令成员作为内联函数

在类中，常有一些规模较小的函数适合于被声明成内联函数。如我们之前所见的，定 义在类内部的成员函数是自动inline的（参见6.5.2节，第213页）。因此，Screen的 构造函数和返回光标所指字符的get函数默认是inline函数。

我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也 能在类的外部用inline关键字修饰函数的定义：

| inline                                  | //可以在函数的定义处指定inline |
| --------------------------------------- | ------------------------------ |
| Screen &Screen：:move(pos r, pos c) r   |                                |
| 1pos row = r * width；                  | //计算行的位置                 |
| cursor = row + c；                      | //在行内将光标移动到指定的列   |
| return *this；                          | //以左值的形式返回对象         |
| }char Screen：:get(pos r, pos c) constr | //在类的内部声明成inline       |
| {pos row = r * width；                  | //计算行的位置                 |
| return contents[row + c]；              | //返回给定列的字符             |

}

虽然我们无须在声明和定义的地方同时说明inline,但这么做其实是合法的。不过，最 好只在类外部定义的地方说明inline,这样可以使类更容易理解。

![img](C++  Primer 5-63.jpg)



和我们在头文件中定义inline函数的原因一样(参见6.5.2节，第214页)， inline成员函数也应该与相应的类定义在同一个头文件中

重载成员函数

和非成员函数一样，成员函数也可以被重载(参见6.4节，第206页)，只要函数之间 在参数的数量和/或类型上有所区别就行。成员函数的函数匹配过程(参见6.4节，第208 页)同样与非成员函数非常类似。

举个例子，我们的Screen类定义了两个版本的get函数。一个版本返回光标当前 位置的字符；另一个版本返回由行号和列号确定的位置的字符。编译器根据实参的数量来 决定运行哪个版本的函数：

Screen myscreen;

char ch = myscreen. get () ；    // 调用 Screen :: get ()

ch = myscreen.get (0,0) ；    // 调用 Screen: :get (pos, pos)

可变数据成员

有时(但并不频繁)会发生这样一种情况，我们希望能修改类的某个数据成员，即 使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这

—*点。

一个可变数据成员(mutable data member)永远不会是const，即使它是const对＜ 274 | 象的成员。因此，一个const成员函数可以改变一个可变成员的值。举个例子，我们将 给Screen添加一个名为access_ctr的可变成员，通过它我们可以追踪每个Screen 的成员函数被调用了多少次：

class Screen { public:

void some_member() const; private:

mutable size_t access_ctr；    //即使在一个const对象内也能被修改

//其他成员与之前的版本一it

} •

void Screen：:some_member() const

{

++access_ctr ；    //保存一个计数值，用于记录成员函数被调用的次数

//该成员S要完成的其他工作

}

尽管some_member是一个const成员函数，它仍然能够改变access_ctr的值。该成 员是个可'£成员，因此任何成员函数，包括const函数在内都能改变它值。

类数据成员的初始值

在定义好Screen类之后，我们将继续定义一个窗口管理类并用它表示显示器上的一 组Screen。这个类将包含一个Screen类型的vector,每个元素表示一个特定的 Screen.默认情况下，我们希望Window_mgr类开始时总是拥有一个默认初始化的

岡Screen。在C++11新标准中，最好的方式就是把这个默认值声明成一个类内初始值（参 11 见2.6.1节，第64页）：

class Window_mgr { private:

// 这个 Window_mgr 追踪的 Screen

//默认情况下，一Window_mgr包^■个标准尺寸的空白Screen std::vector<Screen> screens{Screen（24, 80, ' '）};

}；

当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。在此例中， 我们使用一个单独的元素值对vector成员执行了列表初始化（参见3.3.1节，第87页）， 这个Screen的值被传递给vector<Screen>的构造函数，从而创建了一个单元素的 vector对象。具体地说，Screen的构造函数接受两个尺寸参数和一个字符值，创建了 一个给定大小的空白屏幕对象。

如我们之前所知的，类内初始值必须使用=的初始化形式（初始化Screen的数据成 员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。

当我们提供一个类内初始值时，必须以符号=或者花括号表乐

1~275>



###### 7.3.1节练习

练习7.23:编写你自己的Screen类。

练习7.24:给你的Screen类添加三个构造函数：一个默认构造函数；另一个构造函数 接受宽和高的值，然后将contents初始化成给定数量的空白；第三个构造函数接受 宽和高的值以及一个字符，该字符作为初始化之后屏幕的内容。

练习7.25: Screen能安全地依赖于拷贝和赋值操作的默认版本吗？如果能，为什么？ 如果不能，为什么？

练习7.26:将Sales data: :avg price定义成内联函数。

啦7.3.2返回*this的成员函数

接下来我们继续添加一些函数，它们负责设置光标所在位置的字符或者其他任一给定 位置的字符：

class Screen {

public:

Screen &set(char)；

Screen &set(pos, pos, char); //其他成员和之前的版本一致

}；

inline Screen SScreen::set(char c)

contents[cursor] return *this;



//设置当前光标所在位置的新值 //将this对象作为左值返回

}

inline Screen SScreen::set(pos r, pos col, char ch)

{

contents [r*width + col] = ch; //设置给定位置的新值 return *this;    //将this对象作为左值返回

}

和move操作一样，我们的set成员的返回值是调用set的对象的引用(参见7.1.2节， 第232页)。返回引用的函数是左值的(参见6.3.2节，第202页)，意味着这些函数返回 的是对象本身而非对象的副本。如果我们把一系列这样的操作连接在一条表达式中的话：

//把光标移动到一个指定的位置，然后设置该位置的字符值 myScreen.move(4,0) .set (z #z);

这些操作将在同一个对象上执行。在上面的表达式中，我们首先移动myScreen内的光 标，然后设置myScreen的contents成员。也就是说，上述语句等价于

myScreen.move(4,0); myScreen.set('#');

如果我们令move和set返回Screen而非Screens,则上述语句的行为将大不相同。 在此例中等价于：

// 如果 move 返回 Screen 而非 Screen&

<2761



Screen temp = myScreen.move (4,0) ；    // 对返回值进行拷贝

temp. set ('#') ;    // 不会改变 myScreen 的 contents

假如当初我们定义的返回类型不是引用，则move的返回值将是*this的副本(参见6.3.2 节，第201页)，因此调用set只能改变临时副本，而不能改变myScreen的值。

从const成员函数返回*this

接下来，我们继续添加一个名为diplay的操作，它负责打印Screen的内容。我们 希望这个函数能和move以及set出现在同一■序列中，因此类似于movb和set, diplay 函数也应该返回执行它的对象的引用。

从逻辑上来说，显示一个Screen并不需要改变它的内容，因此我们令diplay为一 个const成员，此时，this将是一个指向const的指针而*1;1115是const对象。由 此推断，display的返回类型应该是const Sales_data&。然而，如果真的令diplay 返回一个const的引用，则我们将不能把display嵌入到一组动作的序列中去：

Screen myScreen;

//如果display返回常量引用，则调用set将引发错误 myScreen.display(cout) .set (z z);

即使myScreen是个非常量对象，对set的调用也无法通过编译。问题在于display 的const版本返回的是常量引用，而我们显然无权set —个常量对象。

![img](C++  Primer 5-64.jpg)



一个const成员函数如果以引用的形式返回*this，那么它的返回类里将是 常量引用。

基于const的重载

通过区分成员函数是否是const的，我们可以对其进行重载，其原因与我们之前根 据指针参数是否指向const (参见6.4节，第208页)而重载函数的原因差不多。具体说

来，因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调 用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本， 但显然此时非常量版本是一个更好的匹配。

在下面的这个例子中，我们将定义一个名为do_display的私有成员，由它负责打 印Screen的实际工作。所有的display操作都将调用这个函数，然后返回执行操作的 对象，

class Screen { public:

//根据对象是否是const重载了 display函数 Screen Scdisplay (std: : ostream &os)

(Z277>



{ do_display(os)； return *this； } const Screen Scdisplay (std ： ： ostream &os) const

{ do_display(os)； return *this； }

private:

//该函数负责显示Screen的内容

void do_display(std：：ostream &os) const {os << contents；}

//其他成与之前的版本一致

};

和我们之前所学的一样，当一个成员调用另外一个成员时，this指针在其中隐式地传递。 因此，当display调用do_display时，它的this指针隐式地传递给do_display。 而当display的非常量版本调用do_display时，它的this指针将隐式地从指向非常 量的指针转换成指向常量的指针(参见4.11.2节，第144页)。

当do_diSplay完成后，display函数各自返回解引用this所得的对象。在非常 量版本中，this指向一个非常量对象，因此display返回一个普通的(非常量)引用； 而const成员则返回一个常量引用。

当我们在某个对象上调用display时，该对象是否是const决定了应该调用 display的哪个版本：

Screen myScreen(5,3〉； const Screen blank(5, 3);

myScreen. set (z .display (cout) ；    // 调用非常量版本

blank.display(cout) ；    // 调用常量版本

建议：对于公共代码使用私有功能函数

有些读者可能会奇怪为什么我们要费力定义一个单独的do_display函数。毕竟， 对do_display的调用并不比do_display函数内部所做的操作简单多少。为什么还 要这f做呢？实际上我们是出于以>原因的：

•一个基本的愿望是避免在多处使用同样的代码。

•我们预期随着类的规模发展，display函数有可能变得更加复杂，此时，把相 应的操作写在一处而非两处的作用就比较明显了。

•我们很可能在开发过程中给do_display函数添加某些调试信息，而这些信息 将在代码的最终产品版本中去显然，只在do_disPlay—处添加或删除这 些信息要更容易一些。

•这个额外的函数调用不会增加任何开销。因为我们在类内部定义了 do_display, 所以它隐式地被声明成内联函数。这样的话，调用do_display就不会带来任 何额外的运行时开销。

在实践中，设计良好的C++代码常常包含大量类似于do_display的小函数，通过调 用这些函数，可以完成一组其他函数的“实际”工作。

###### 7.3.2节练习

练习7.27:给你自己的Screen类添加move、set和display函数，通过执行下面 的代码检验你的类M否正确。

Screen myScreen(5, 5, r Xr );

myScreen.move(4,0).set(z #z) .display(cout);

cout « "\n";

myScreen.display(cout); cout << "\n";

练习7.28：如果move、set和display函数的返回类型不是Screens而是Screen, 则在上一个练习中将会发生什么情况？

练习7.29:修改你的Screen类，令move、set和display函数返回Screen并检 查程序的运行结果，在上一个练习中你的推测正确吗？

练习7.30:通过this指针使用成员的做法虽然合法，但是有点多余。讨论显式地使用 指针访问成员的优缺点。

###### 7.3.3类类型

每个类定义了唯一的类型。对于两个类来说，即使它们的成员完全一样，这两个类也 是两个不同的类型。例如：

<278~|



struct First { int memi； int getMem()；

}；

struct Second { int memi; int getMem()；

} '•

First objl;

Second obj2 = objl;    // 错误：obj 1 和 obj2 的类型不同

![img](C++  Primer 5-65.jpg)



即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类来说，它 的成员和其他任何类(或者任何其他作用域)的成员都不是一回事儿。

我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类 名跟在关键字class或struct后面：

Sales_data iteml ；    //默认初始化Sales_data类型的对象

class Sales_data iteml ；    // 一条等价的声明

上面这两种使用类类型的方式是等价的，其中第二种方式从C语言继承而来，并且在C++ 语言中也是合法的。

类的声明

就像可以把函数的声明和定义分离开来一样（参见6.1.2节，第186页），我们也能仅 仅声明类而暂时不定义它：

class Screen;    II Screen 类的声明

I 279＞这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并 且指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不 完全类型（incomplete type）,也就是说，此时我们已知Screen是一个类类型，但是不清 楚它到底包含哪些成员。

不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也 可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。

对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。 否则，编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义， 然后才能用引用或者指针访问其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到 底有哪些成员。

在7.6节（第268页）中我们将描述一种例外的情况：直到类被定义之后数据成员才 能被声明成这种类类型。换句话说，我们必须首先完成类的定义，然后编译器才能知道存 储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以一个类的成员 类型不能是该类自己，然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未 定义），因此类允许包含指向它自身类型的引用或指针：

class Link_screen {

Screen window；

Link_screen *next；

Link_screen *prev；

};

###### 7.3.3节练习

练习7.31:定义一对类X和Y,其中X包含一个指向Y的指针，而Y包含一个类型为 X的对象。

###### 7.3.4友元再探

我们的Sales_data类把三个普通的非成员函数定义成了友元（参见7.2.1节，第241 页）。类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数 定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。

类之间的友元关系

举个友元类的例子，我们的Window_mgr类（参见7.3.1节，第245页）的某些成员 可能需要访问它管理的Screen类的内&数据。例如，假设我们需要为Window_mgr添 加一个名为clear的成员，它负责把一个指定的Screen的内容都设为空白。为了完成 这一任务，clear需要访问Screen的私有成员；而要想令这种访问合法，Screen需要

把Window_mgr指定成它的友元： class Screen {

// Window_mgr的成员可以访问Screen类的私有部分 friend class Window_mgr;

// Screen类的剩余部分

}；

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有 成员。通过上面的声明，Window_mgr被指定为Screen的友元，因此我们可以将 Window_mgr的clear成员写成如下的形式：

class Window_mgr { public:

//窗口中每个屏幕的编号

using Screenlndex = std：:vector<Screen>：:size_type；

//按照编号将指定的Screen重置为空白 void clear(Screenlndex);

private:

std：:vector<Screen> screens{Screen(24, 80, • 1 )};

};

void Window_mgr::clear(Screenlndex i)

{

// s是一个Screen的引用，指向我们想清空的那个屏幕 Screen &s = screens[i]；

//将那个选定的Screen重置为空白

s.contents = string(s.height * s.width,'')；

}

一开始，首先把s定义成screens vector中第i个位置上的Screen的引用，随后利 用Screen的height和width成员计算出一个新的string对象，并令其含有若干个 空白字符，最后我们把这个含有很多空白的字符串赋给contents成员。

如果clear不是Screen的友元，上面的代码将无法通过编译，因为此时clear将 不能访问 Screen 的 height、width 和 contents 成员。而当 Screen 将 Window_mgr 指定为其友元之后，Screen的所有成员对于Window_mgr就都变成可见的了。

必须要注意的一点是，友元关系不存在传递性。也就是说，如果Window_mgr有它 自己的友元，则这些友元并不能理所当然地具有访问Screen的特权。

每个类负责控制自己的友元类或友元函数。    iff'

令成员函数作为友元

除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。 当把一个成员函数声明成元时，我们必须明确指出该成员函数属于哪个类：

class Screen {

// Window_mgr : : clear必须在Screen类之前被声明 friend void Window_mgr::clear(Screenlndex);

// Screen类的剩余部分

}；

要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼 此依赖关系。在这个例子中，我们必须按照如下方式设计程序：

•首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear 使用Screen的成员之前必须先声明Screen。

•接下来定义Screen，包括对于clear的友元声明。

•最后定义clear，此时它才可以使用Screen的成员。

函数重载和友元

尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重 载函数声明成它的友元，它需要对这组函数中的每一个分别声明：

II重载的storeOn函数

extern std：：ostream& storeOn(std：：ostream &z Screen &)； extern BitMapfic storeOn(BitMap &, Screen &)； class Screen {

// storeOn的ostream版本能访问Screen对象的私有部分 friend std：：ostream& storeOn(std：：ostream Screen &)；

// ...

\>;

Screen类把接受ostream&的storeOn函数声明成它的友元，但是接受BitMap&作为 参数的版本仍然不能访问Screen。

(g    友元声明和作用域

类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一 个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一 定真的声明在当前作用域中(参见7.2.1节，第241页)。

甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函 数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是 被声明过的：

struct X {

| friend void f () { /*友元函数可以定义在类的内部*/ } |                                 |
| --------------------------------------------------- | ------------------------------- |
| X() { f()； }void g 0; void h()；                   | //错误：f还没有被声明           |
| };                                                  |                                 |
| void X：：g() { return f()； }                      | //错误：f还没有被声明           |
| void f()；                                          | //声明那个定义在X中的函数       |
| void X：:h() { return f()； }                       | //正确：现在f的声明在作用域中了 |

关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的 声明。

![img](C++  Primer 5-66.jpg)



请注意，有的编译器并不强制执行上述关于友元的限定规则(参见7.2.1节， 第241页)。

.w.    -    .广'    .■ - *    *    『.

###### 7.3.4节练习

练习7.32:定义你自己的Screen和Window_mgr，其中clear是Window_mgr的 成员，是Screen的友元。

##### 7.4类的作用域

每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对^6 象、引用或者指针使用成员访问运算符(参见4.6节，第133页)来访问。对于类类型成员 则使用作用域运算符访问。不论哪种情况，跟在运算符之后的名字都必须是对应类的成员：

Screen： :pos ht = 24, wd = 80;    // 使用 Screen 定义的 pos 类型

Screen scr(ht, wd,'');

Screen *p = &scr；

char c = scr.get () ；    // 访问 scr 对象的 get 成员

c = p->get () ；    //访问p所指对象的get成员



作用域和定义在类外部的成员

一个类就是一个作用域的事实能够很好地解释为什么当我们在类的外部定义成员函 数时必须同时提供类名和函数名(参见7.1.2节，第230页)。在类的外部，成员的名字被 隐藏起来了。

一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数 列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了。

例如，我们回顾一下Window_mgr类的clear成员(参见7.3.4节，第251页)，该 函数的参数用到了 Window_mgr类定义的一种类型：

void Window_mgr：:clear(Screenlndex i)

{

Screen &s = screens[i]；

s.contents = string(s.height * s.width,'')；

}

因为编译器在处理参数列表之前已经明确了我们当前正位于WindOw_mgr类的作用域中，

所以不必再专门说明Screenlndex是Window_mgr类定义的。出于同样的原因，编译<283 I 器也能知道函数体中用到的screens也是在Window_mgr类中定义的。

另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部 时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类 的成员。例如，我们可能向Window_mgr类添加一个新的名为addScreen的函数，它 负责向显不器添加一个新的屏幕。这个成员的返回类型将是Screenlndex.用户可以通 过它定位到指定的Screen：

class Window_mgr { public:

//向窗口添加一个Screen,返回它的编号

Screenlndex addScreen(const Screen&)；

//其他成员与之前的版本一致

}；

//首先处理返回类型，之后我们才进入Window mgr的作用域

Window_mgr::ScreenIndex

Window_mgr::addScreen(const Screen &s)

{

screens.push_back(s); return screens.size() - 1;

}

因为返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的。 在这种情况下，要想使用Screenlndex作为返回类型，我们必须明确指定哪个类定义 了它。

7.4节练习

练习7.33：如果我们给Screen添加一个如下所示的size成员将发生什么情况？如果 出现了问题，请尝试修改它。

pos Screen::size() const {

return height * width;

7.4.1名字查找与类的作用域

在目前为止，我们编写的程序中，名字查找(name lookup)(寻找与所用名字最匹配 的声明的过程)的过程比较直截了当：

•首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。

•如果没找到，继续查找外层作用域。

•如果最终没有找到匹配的声明，则程序报错。

对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区 别.不过在当前的这个例子中体现得不太明显。类的定义分两步处理：

•首先，编译成员的声明。

•直到类全部可见后才编译函数体。

![img](C++  Primer 5-67.jpg)



编译器处理完类中的全部声明后才会处理成员函數的定义。

按照这种两阶段的方式处理类可以简化类代码的组织方式。因为成员函数体直到整个 类可见后才会被处理，所以它能使用类中定义的任何名字。相反，如果函数的定义和成员 的声明被同时处理，那么我们将不得不在成员函数中只使用那些已经出现的名字。

用于类成员声明的名字查找

这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返 回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用 了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。例如：

typedef double Money; string bal; class Account { public:

Money balance()    { return bal; }

private:

Money bal;

// ...

}；

当编译器看到balance函数的声明语句时，它将在Account类的范围内寻找对Money 的声明。编译器只考虑Account中在使用Money前出现的声明，因为没找到匹配的成员， 所以编译器会接着到Account的外层作用域中查找，在这个例子中，编译器会找到Money 的typedef语句，该类型被用作balance函数的返回类型以及数据成员bal的类型。 另一方面，balance函数体在整个类可见后才被处理，因此，该函数的return语句返 回名为bal的成员，而非外层作用域的string对象。

类型名要特殊处理

一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作 用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一 <M] 种类型，则类不能在之后重新定义该名字：

typedef double Money; class Account { public:

Money balance () { return bal ； }    // 使用外层作用域的 Money

private:

typedef double Money ；    // 错吴：不食巨重新定义 Money

Money bal;

"...

};

需耍特别注意的是，即使Account中定义的Money类型与外层作用域一致，上述代码仍 然是错误的。

尽管重新定义类型名字是一种错误的行为，但是编译器并不为此负责。一些编译器仍 将顺利通过这样的代码，而忽略代码有错的事实。

![img](C++  Primer 5-68.jpg)



类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都 出现在类名的定义之后。

成员定义中的普通块作用域的名字查找

成员函数中使用的名字按照如下方式解析：

•首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的 声明才被考虑。

•如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。 •如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。

一般来说，不建议使用其他成员的名字作为某个成员函数的参数。不过为了更好地解 释名字的解析过程，我们不妨在dummy_f cn函数中暂时违反一下这个约定：

//注意：这段代码仅为了说明而用，不是一段很好的代码 //通常情况下不建议为参数和成员使用同样的名字

int height；    //定义了一个名字，稍后将在Screen中使用

class Screen { public:

typedef std::string::size_type pos; void dummy_fcn(pos height) {

cursor = width * height;    // 哪个 height?是那个参数

}

| 286〉    private :

pos cursor = 0;

pos height = 0, width = 0;

}；

当编译器处理dummy_fcn中的乘法表达式时，它首先在函数作用域内查找表达式中用到 的名字。函数的参数位于函数作用域内，因此dummy_fCn函数体内用到的名字height 指的是参数声明。

在此例中，height参数隐藏了同名的成员。如果想绕开上面的查找规则，应该将代 码变为：

//不建议的写法：成员函数中的名字不应该隐藏同名的成员 void Screen::dummy_fcn(pos height) {

cursor = width * this->height；    // 成员 height

//另外一种表示该成员的方式

cursor = width * Screen： :height；    // 成员 height

}

![img](C++  Primer 5-69.jpg)



尽管类的成员被隐藏了，但我们仍然可以通过加上类的名字或显式地使用 this指针来强制访问成员。

其实最好的确保我们使用height成员的方法是给参数起个其他名字：

//建议的写法：不要把成员名字作为参数或其他局部变量使用 void Screen::dummy_fcn(pos ht) {

cursor = width * height；    // 成员 height

}

在此例中，当编译器查找名字height时，显然在dummy_fcn函数内部是找不到的。编 译器接着会在Screen内查找匹配的声明，即使height的声明出现在dummy_fcn使用 它之后，编译器也能正确地解析函数使用的是名为height的成员。

类作用域之后，在外围的作用域中查找

如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查 找。在我们的例子中，名字height定义在外层作用域中，且位于Screen的定义之前。 然而，外层作用域中的对象被名为height的成员隐藏掉了。因此，如果我们需要的是外 层作用域中的名字，可以显式地通过作用域运算符来进行请求：

//不建议的写法：不要隐藏外层作用域中可能被用到的名字 void Screen：:dumray_fcn(pos height) {

cursor = width * : :height;    // 哪个 height?是那个全局的

}

![img](C++  Primer 5-70.jpg)



尽管外层的对象被隐藏掉了，但我们仍然可以用作用域运算符访问它。

在文件中名字的出现处对其进行解析

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中 的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。例如：

int height；    //定义了一个名字，稍后将在Screen中使用

class Screen { public:

typedef std：:string：:size_type pos； void setHeight(pos)；

pos height = 0;    //隐藏了外层作用域中的height

}；

Screen::pos verify(Screen：:pos)； void Screen::setHeight(pos var) {

// var：参数 // height:类的成员 // verify：全局函数 height = verify(var)；

}

请注意，全局函数verify的声明在Screen类的定义之前是不可见的。然而.名字查找 的第三步包括了成员函数出现之前的全局作用域。在此例中，verify的声明位于 setHeight的定义之前，因此可以被正常使用。

##### 7.4.1节练习_

练习7.34：如果我们把第256页Screen类的pos的typedef放在类的最后一行会 发生什么情况？

练习7.35：解释下面代码的含义，说明其中的Type和initVal分别使用了哪个定 义。如果代码存在错误，尝试修改它。

typedef string Type;

Type initVal(); class Exercise { public:

typedef double Type;

Type setVal(Type);

Type initVal(); private:

int val;

}；

Type Exercise::setVal(Type parm) { val = parm + initVal(); return val;

}

##### 7.5构造函数再探    < 288 I

对于任何C++的类来说，构造函数都是其中重要的组成部分。我们已经在7.1.4节(第 235页)中介绍了构造函数的基础知识，本节将继续介绍构造函数的一些其他功能，并对

之前已经介绍的内容进行一些更深入的讨论。

###### 7.5.1构造函数初始值列表

当我们定义变量时习惯于立即对其进行初始化，而非先定义、再赋值：

string foo = "Hello World!";    // 定义并初始化

string bar；    //默认初始化成空string对象

bar = "Hello World!";    // 为 bar 赋一个新值

就对象的数据成员而言，初始化和赋值也有类似的区别。如果没有在构造函数的初始值列 表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。例如：

// Sales_data构造函数的一种写法，虽然合法但比较草率：没有使用构造函数初始值

Sales_data：:Sales_data(const string &s,

unsigned cnt, double price)

{

bookNo = s； units_sold = cnt; revenue = cnt * price；

}

这段代码和我们在237页的原始定义效果是相同的：当构造函数完成后，数据成员的值相 同。区别是原来的版本初始化了它的数据成员，而这个版本是对数据成员执行了赋值操作。 这一区别到底会有什么深层次的影响完全依赖于数据成员的类型。

构造函数的初始值有时必不可少

有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是 const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定 义默认构造函数时，也必须将这个成员初始化。例如：

class ConstRef { public:

ConstRef(int ii)； private:

int i；

const int ci; int &ri；

};

和其他常量对象或者引用一样，成员ci和ri都必须被初始化。因此，如果我们没有为 它们提供构造函数初始值的话将引发错误：

//错误：ci和ri必须被初始化

ConstRef::ConstRef(int ii)

{ //賦值：

i = ii;    // 正确

ci = ii；    //错误：不能给const赋值

ri = i；    //错误：ri没被初始化

}

随着构造函数体一开始执行，初始化就完成了。我们初始化const或者引用类型的数据 成员的唯一机会就是通过构造函数初始值，因此该构造函数的正确形式应该是：

//正确：星式地初始化引用和const成员

ConstRef：:ConstRef(int ii): i (ii), ci(ii), ri(i)    { }

![img](C++  Primer 5-71.jpg)



如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们 必须通过构造函数初始值列表为这些成员提供初值•.

建议：使川构造函数初始值

在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员， 后者则先初始化再赋值。

除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造 函数初始值的习惯，这样能避免某些意想不到的编译错误，特别是遇到有的类含有需要 构造函数初始值的成员时。•

成员初始化的顺序

显然，在构造函数初始值中每个成员只能出现一次。否则，给同一个成员赋两个不同 的初始值有什么意义呢？

不过让人稍感意外的是，构造函数初始值列表只说明用于初始化成员的值，而不限定 初始化的具体执行顺序。

成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后 第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化 顺序。

一般来说，初始化的顺序没什么特别要求。不过如果一个成员是用另一个成员来初始 化的，那么这两个成员的初始化顺序就很关键了。

举个例子，考虑下面这个类：

< 290 I



class X { int i ； int j ；

public:

//未定义的：i在j之前被初始化 X(int val): j(val), i(j) { }

};

在此例中，从构造函数初始值的形式上来看仿佛是先用val初始化了 j,然后再用j初始 化i。实际上，i先被初始化，因此这个初始值的效果是试图使用未定义的值j初始化i!

有的编译器具备一项比较友好的功能，即当构造函数初始值列表中的数据成员顺序与 这些成员声明的顺序不符吋会生成一条警告信息。

Best 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的 话，尽量避免使用某些成员初始化其他成员。

如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对

象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。例如，X的构造函数 如果写成如下的形式效果会更好：

X (int val) : i(val), j(val) { }

在这个版本中，i和j初始化的顺序就没什么影响了。

默认实参和构造函数

Sales_data默认构造函数的行为与只接受一个string实参的构造函数差不多。 唯一的区别是接受string实参的构造函数使用这个实参初始化bookNo,而默认构造函 数(隐式地)使用string的默认构造函数初始化bookNo。我们可以把它们重写成一个 使用默认实参(参见6.5.1节，第211页)的构造函数：

class Sales_data { public:

//定义默认构造函数，令其与只接受一个string实参的构造函数功能相同 Sales_data(std：:string s = ""): bookNo(s) { }

//其亟构造函数与之前一致

Sales_data(std：：string s# unsigned cnt, double rev):

bookNo(s), units_sold(cnt)# revenue(rev*cnt) { }

Sales_data(std：:istream &is) { read(is, *this)； }

//其反成员与之前的版本一致

};

在上面这段程序中，类的接口与第237页的代码是一样的。当没有给定实参，或者给定了 一个string实参时，两个版本的类创建了相同的对象。因为我们不提供实参也能调用上 述的构造函数，所以该构造函数实际上为我们的类提供了默认构造函数。

1~291>



如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构

造函数i?' rt'

值得注意的是，我们不应该为Sales_data接受三个实参的构造函数提供默认值。 因为如果用户为售出书籍的数量提供了一个非零的值，则我们就会期望用户同时提供这些 书籍的售出价格。

###### 7.5.1节练习

练习7.36:下面的初始值是错误的，请找出问题所在并尝试修改它。 struct X {

X (int i, int j): base(i), rem(base % j)    { }

int rem, base;

}；

练习7.37:使用本节提供的sales_data类，确定初始化下面的变量时分别使用了哪 个构造函数，然后罗列出每个对象有数据成员的值。

Sales一data first_item(cin);

int main()    {

Sales_data next;

Sales_data last("9-999-99999-9");

}

练习7.38：有些情况下我们希望提供cin作为接受istream&参数的构造函数的默认 实参，请声明这样的构造函数。

练习7.39:如果接受string的构造函数和接受istreamS的构造函数都使用默认实 参，这种行为合法吗？如果不，为什么？

练习7.40：从下面的抽象概念中选择一个(或者你自己指定一个)，思考这样的类需要 哪些数据成员，提供一组合理的构造函数并阐明这样做的原因。

(a) Book    (b) Date    (c) Employee

(d) Vehicle    (e) Object    (f) Tree

###### 7.5.2委托构造函数

C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数rcTTl (delegating constructor)。一个委托构造函数使用它所属类的其他构造函数执行它自己的初    1，

始化过程，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数。

和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。＜292： 在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初 始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函 数匹配。

举个例子，我们使用委托构造函数重写SaleS_data类，重写后的形式如下所示:

class Sales_data { public:

//非委托构造函数使用对应的实参初始化成员

Sales_data(std：：string sz unsigned cnt, double price):

bookNo(s), units_sold(cnt), revenue(cnt*price) { }

//其余构造函数全都委托给另一+构造函数 Sales_data(): Sales_data("", 0, 0) {}

Sales_data(std：:string s): Sales_data(s, 0,0) {}

Sales_data(std：:istream &is): Sales_data()

{ read(isz *this)； }

//其他成员与之前的版本一致

};

在这个Sales_data类中，除了一个构造函数外其他的都委托了它们的工作。第一个构 造函数接受三个实参，使用这些实参初始化数据成员，然后结束工作。我们定义默认构造 函数令其使用三参数的构造函数完成初始化过程，它也无须执行其他任务，这一点从空的 构造函数体能看得出来。接受一个string的构造函数同样委托给了三参数的版本。

接受istreams的构造函数也是委托构造函数，它委托给了默认构造函数，默认构造 函数又接着委托给三参数构造函数。当这些受委托的构造函数执行完后，接着执行 istream&构造函数体的内容。它的构造函数体调用read函数读取给定的istream。

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体 被依次执行。在Sales_data类中，受委托的构造函数体恰好是空的。假如函数体包含 有代码的话，将先执行些代码，然后控制权才会交还给委托者的函数体。

###### 7.5.2节练习

练习7.41:使用委托构造函数重新编写你的SaleS_data类，给每个构造函数体添加

-条语句，令其一旦执行就打印一条信息。用各种可能的方式分别创建Sales_data 对象，认真研究每次输出的信息直到你确实理解了委托构造函数的执行顺序=

练习7.42:对于你在练习7.40 （参见7.5.1节，第261页）中编写的类，确定哪些构造 函数可以使用委托。如果可以的话，编写委托构造函数。如果不可以，从抽象概念列表 中重新选择一个你认为可以使用委托构造函数的，为挑选出的这个概念编写类定义。

^6 7.5.3默认构造函数的作用

ri93>    当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下

发生：

•当我们在块作用域内不使用任何初始值定义一个非静态变量（参见2.2.1节，第39 页）或者数组时（参见3.5.1节，第101页）。

•当一个类本身含有类类型的成员且使用合成的默认构造函数时（参见7+1+4节，第 235 页）。

•当类类型的成员没有在构造函数初始值列表中显式地初始化时（参见7.1.4节，第 237 页）。

值初始化在以下情况下发生：

•在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时（参见3.5.1 节，第101页）。

•当我们不使用初始值定义一个局部静态变量时（参见6.1.1节，第185页）。

•当我们通过书写形如T（）的表达式显式地请求值初始化时，其中T是类型名

（vector的一个构造函数只接受一个实参用于说明vector大小（参见3.3.1节， 第88页），它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。

类必须包含一个默认构造函数以便在上述情况下使用，其中的大多数情况非常容易判断。

不那么明显的一种情况是类的某些数据成员缺少默认构造函数：

class NoDefault { public:

NoDefault（const std::string&）；

//还有其他成贯，但是没有其他构造函数了

};

| struct A {         | //默认情况下my_mem是public的（参见7.2节，第240页） |                                                        |
| ------------------ | -------------------------------------------------- | ------------------------------------------------------ |
| };A a；            | NoDefault                                          | my_mem；                                               |
|                    | //错误：不能为A合成构造函数                        |                                                        |
| struct B {B() {}   | //错误：b member没有初始值                         |                                                        |
| }；                | NoDefault                                          | b_member；                                             |
| Best 卩 rottifefes | 在实际中，                                         | 如果定义了其他构造函数，那么最好也提供一个默认构造函数 |

使用默认构造函数

下面的obj的声明可以正常编译通过：

Sales_data obj () ;    //正确：定义了一个函教而非对象

if (obj . isbn () == Primer_5th_ed.isbn () )    // 错误：obj 是一个画数

但当我们试图使用obj时，编译器将报错，提示我们不能对函数使用成员访问运算符。 问题在于，尽管我们想声明-个默认初始化的对象，Obj实际的含义却是一个不接受任何 参数的函数并且其返回值是sales_data类型的对象。

如果想定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后 的空的括号对：

//正确：obj是个默认初始化的对象 Sales_data obj;

zjX

WARNING



对于C+4■的新手程序员来说有一种常犯的错误，它们试图以如下的形式声明一 个用默认构造函数初始化的对象：

Sales_data obj () ;    //错误：声明了一个函数而非对象

Sales_data obj2;    //正碗：obj2是一个对象而非函数

###### 7.5.3节练习

练习7.43：假定有一个名为NoDefault的类，它有一个接受int的构造函数，但是 没有默认构造函数。定义类C, C有一个NoDefault类型的成员，定义C的默认构造 函数。

练习7.44:下面这条声明合法吗？如果不，为什么？ vector<NoDefault> vec(10);

练习7.45:如果在上一个练习中定义的vector的元素类型是C,则声明合法吗？为什 么？

练习7.46:下面哪些论断是不正确的？为什么？

(a)    —个类必须至少提供一个构造函数。

(b)    默认构造函数是参数列表为空的构造函数。

(c)    如果对于类来说不存在有意义的默认值，则类不应该提供默认构造函数。

(d)    如果类没有定义默认构造函数，则编译器将为其生成一个并把每个数据成员初始化 成相应类型的默认值。

###### 7.5.4隐式的类类型转换

4.11节(第141页)曾经介绍过C#语言在内置类型之间定义了几种自动转换规则。 同样的，我们也能为类定义隐式转换规则。如果构造函数只接受一个实参，则它实际上定 义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数 (converting constructor)»我们将在14.9节(第514页)介绍如何定义将一种类类型转换为 另一种类类型的转换规则。

<2941



<295~1



![img](C++  Primer 5-73.jpg)



能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型 隐式转换的规则。

在Sales_data类中，接受string的构造函数和接受istream的构造函数分别 定义了从这两类型向Sales_data隐式转换的规则。也就是说，在需要使用 Sales_data的地方，我们可以使用string或者istream作为替代：

string null_book = '*9-999-99999-9";

//构造一个临时的Sales_data对象

// 该对象的 units_sold 和 revenue 等于 0，bookNo 等于 null_book item.combine(null_book);

在这里我们用一个string实参调用了 Sales_data的combine成员。该调用是合法 的，编译器用给定的string自动创建了一个Sales_data对象。新生成的这个(临吋) Sales_data对象被传递给combine。因为combine的参数是一个常量引用，所以我 们可以I合该参数传递一个临吋量。

只允许一步类类型转换

在4.11.2节(第143页)中我们指出，编译器只会自动地执行一步类型转换。例如， 因为下面的代码隐式地使用了两种转换规则，所以它是错误的：

//错误：需要用户定义的两种转换：

// (1)把 “9-999-99999-9” 转换成 string

// (2)再把这个(临时的)string转换成Sales_data item.combine("9-999-99999-9")；

如果我们想完成上述调用，可以显式地把字符串转换成string或者Sales_data 对象：

//正确：显式地转换成string,隐式地转换成Sales_data item.combine(string("9-999-99999-9"));

//正确：隐式地转换成string,显式地转换成Sales_data item.combine(Sales_data{"9-999-99999-9"));

类类型转换不是总有效

是否需要从string到Sales_data的转换依赖于我们对用户使用该转换的看法。 在此例中，这种转换可能是对的。null_book中的string可能表示了一个不存在的 ISBN编号。

另一个是从istream到Sales_data的转换：

//使用istream构造函数创建一个函数传递给combine item.combine(cin);

这段代码隐式地把cin转换成Sales_data,这个转换执行了接受一个istream的 Sales_data构造函数。该构造函数通过读取标准输入创建了一个(临时的)SaleS_data 对象，&后将得到的对象传递给combine,

□%>    Sales_data对象是个临时量(参见2.4.1节，第54页)，一旦combine完成我们

就不能再访问它了。实际上，我们构建了一个对象，先将它的值加到item中，随后将其 丢弃。

抑制构造函数定义的隐式转换

在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以 阻止：

class Sales_data { public:

Sales_data() = default；

Sales_data(const std::string &s, unsigned n, double p):

bookNo(s), units_sold(n), revenue(p*n)    { }

explicit Sales_data(const std::string &s): bookNo(s)    { }

explicit Sales一data(std::istreams);

//其他成员与之前_的版本一致

}；

此时，没有任何构造函数能用于隐式地创建Sales_data对象，之前的两种用法都无法 通过编译：

item, combine (null_book) ；    // 错误：string 构造函数是 explicit 的

item, combine (cin) ；    // 错误：istream 构造函数是 explicit 的

关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用 于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造 函数吋使用explicit关键字，在类外部定义时不应重复：

//错误：explicit关键字只允许出现在类内的构造函教声明处 explicit Sales_data：:Sales_data(istream& is)

{

read(is r *this)；

}

explicit构造函数只能用于直接初始化

发生隐式转换的一种情况是当我们执行拷贝形式的初始化时(使用=)(参见3.2+1节, 第76页)。此时，我们只能使用直接初始化而不能使用explicit构造函数：

Sales_data iteml (null_book) ；    // 正确：直接初始化

//错误：不能将explicit构造函数用于拷贝形式的初始化过程 Sales_data item2 = null_book；

![img](C++  Primer 5-74.jpg)



当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式 使用(参见3.2.1节，第76页I而且，编译器将不会在自动转换过程中使用 该构造函数

为转换显式地使用构造函数

尽管編译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这 样的构造函数显式地强制进行转换：

//正确：实参是一个显式构造的Sales_data对象 item.combine(Sales_data(null_book))；

//正确：static_cast可以使用explicit的构造函数 item, combine (static_cast<Sales_data> (cin))；

在第一个调用中，我们直接使用Sales_data的构造函数，该调用通过接受string的

构造函数创建了一个临吋的Sales_data对象。在第二个调用中，我们使用 static_cast (参见4.11.3节，第145页)执行了显式的而非隐式的转换。其中， static_cast使用istream构造函数创建了一个临时的Sales_data对象。

标准库中含有显式构造函数的类

我们用过的一些标准库中的类含有单参数的构造函数：

•接受一个单参数的const char*的string构造函数(参见3.2.1节，第76页) 不是explicit的。

•接受一个容量参数的vector构造函数(参见3.3.1节，第87页)是explicit的。

###### 7.5.4节练习

练习7.47:说明接受一个string参数的Sales_data构造函数是否应该是explicit 的，并解释这样做的优缺点。

练习7.48:假定Sales_data的构造函数不是explicit的，则下述定义将执行什么 样的操作？

string null_isbn(9-999-99999-9**);

Sales_data iteml(null_isbn);

Sales_data item2("9-999-99999-9");

如果Sales_data的构造函数是explicit的，又会发生什么呢？

练习7.49：对于combine函数的三种不同声明，当我们调用i . combine (s)时分别 发生什么情况？其中i是一个Sales_data，而s是一个string对象。

(a)    Sales_data Scombine(Sales_data);

(b)    Sales_data &combine(Sales_data&);

(c)    Sales_data &combine(const Sales_data&) const;

练习7.50：确定在你的Person类中是否有一些构造函数应该是explicit的。

练习7.51: vector将其单参数的构造函数定义成explicit的，而string则不是， 你觉得原因何在？

###### 緣7.5.5聚合类

聚合类(aggregate class)使得用户可以直接访问其成员，并且具有特殊的初始化语法 形式。当一个类满足如下条件时，我们说它是聚合的：

•所有成员都是public的。

•没有定义任何构造函数。

•没有类内初始值(参见2.6.1节，第64页)。

•没有基类，也没有virtual函数，关于这部分知识我们将在第15章详细介绍。

例如，下面的类是一个聚合类：

struct Data { int ival； string s；

}；

我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员：

// vail.ival =0; vall.s = string（"Anna"）

Data vail = { 0, "Anna" }；

初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然 后是第二个，以此类推。下面的例子是错误的：

//错误：不能使用"Anna"初始化ival,也不能使用1024初始化s Data val2 = { "Anna" , 1024 }；

与初始化数组元素的规则（参见3.5.1节，第101页）一样，如果初始值列表中的元素个 数少于类的成员数量，则靠后的成员被值初始化（参见3.5.1节，第101页）。初始值列表 的元素个数绝对不能超过类的成员数量。

值得注意的是，显式地初始化类的对象的成员存在三个明显的缺点：

•要求类的所有成员都是public的。

•将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为 用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过 程冗长乏味且容易出错。

•添加或删除一个成员之后，所有的初始化语句都需要更新。

###### 7.5.5节练习

< 299 I



练习7.52:使用2.6.1节（第64页）的Sales_data类，解释下面的初始化过程。如 果存在问题，尝试修改它。

Sales data item = {"978-0590353403", 25, 15.99};

###### 7.5.6字面值常量类

在6.5.2节（第214页）中我们提到过constexpr函数的参数和返回值必须是字面 值类型。除了算术类型、引用和指针外，某些类也是字面值类型。和其他类不同，字面值 类型的类可能含有constexpr函数成员。这样的成员必须符合constexpr函数的所有 要求，它们是隐式const的（参见7.1.2节，第231页）。

数据成员都是字面值类型的聚合类（参见7.5.5节，第266页）是字面值常量类。如 果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：

•数据成员都必须是字面值类型。

•类必须至少含有一个constexpr构造函数。

•如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达 式（参见2.4.4节，第58页）；或者如果成员属于某种类类型，则初始值必须使用 成员自己的constexpr构造函数。

•类必须使用析构函数的默认定义，该成员负责销毁类的对象（参见7.1.5节，第239 页）。

constexpr构造函数

尽管构造函数不能是const的（参见7.1+4节，第235页），但是字面值常量类的构 造函数可以是constexpr （参见6.5.2节，第213页）函数。事实上，一个字面值常量类 必须至少提供一个constexpr构造函数。

constexpr构造函数可以声明成=default (参见，7.1.4节，第237災)的形式C或 者是删除函数的形式，我们将在13.1.6节(第449页)介绍相关知识)。否则，constexpr )构造函数就必须既符合构造函数的要求(意味着不能包含返回语句)，又符合constexpr 函数的要求(意味着它能拥有的唯一可执行语句就是返回语句(参见6.5.2节，第214页))。 综合这两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字

constexpr就可以声明一个constexpr构造函数了：

class Debug { public:

constexpr Debug(bool b = true) : hw(b), io(b), other(b)    {    }

constexpr Debug(bool h, bool i, bool o):

hw(h), io(i), other(o)    { }

| constexpr bool any() | { return hw  | II   | io \|\| other; }     |
| -------------------- | ------------ | ---- | -------------------- |
| void set io (bool b) | { io = b; }  |      |                      |
| void set_hw(bool b)  | { hw = b; }  |      |                      |
| void set other(bool  | b) { hw = b; | }    |                      |
| private:             |              |      |                      |
| bool hw;             |              | //   | 硬件错误，而非10错误 |
| bool io;             |              | //   | 10错误               |
| bool other;          |              | //   | 其他错误             |

}；

constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数， 或者是一条常量表达式。

constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返 回类型：

constexpr Debug io_sub(false, true, false)； if (io_sub.any())

//调试10 // 等价于 if (true)

<< endl；

//无调试

// 等价于 if (false)



cerr << "print appropriate error messages constexpr Debug prod(false)； if (prod.any())

cerr << "print an error message" << endl；

###### 7.5.6节练习

练习7.53:定义你自己的Debug。

练习7.54: Debug中以set_开头的成员应该被声明成constexpr吗？如果不，为什 么？

练习7.55: 7.5.5节(第266页)的Data类是字面值常量类吗？请解释原因。

##### 7.6类的静态成鉍

有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。 例如，-个银行账户类可能需要一个数据成员来表示当前的基准利率。在此例中，我们希 望利率与类关联，而非与类的每个对象关联。从实现效率的角度来看，没必要每个对象都 存储利率信息。而且更加重要的是，一旦利率浮动，我们希望所有的对象都能使用新值。

声明静态成员

我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员 一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引 用、指针、类类型等。

<3QE



举个例子，我们定义一个类，用它表示银行的账户记录：

class Account { public:

void calculate()    { amount += amount * interestRate； }

static double rate() { return interestRate； } static void rate(double)；

private:

std：:string owner； double amount； static double interestRate； static double initRate()；

};

类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此， 每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate 对象而且它被所有Account对象共享。

类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结 果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this 指针。这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效=

使用类的静态成员

我们使用作用域运算符直接访问静态成员：

double r；

r = Account: : rate () ；    //使用作用域运算符访问静态成员

虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针來访 问静态成员：

Account acl；

Account *ac2 = &acl；

//调用静态成员函数rate的等价形式

r = acl. rate () ；    //通过Account的对象或引用

r = ac2->rate () ；    //通过指向Account对象的指针

成员函数不用通过作用域运算符就能直接使用静态成员：

class Account { public:

void calculate()    { amount += amount * interestRate; }

private:

static double interestRate;

//其他成员与之前的版本一致

}；

EM＞定义静态成员

和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函 数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部 的声明语句：

void Account::rate(double newRate)

{

interestRate = newRate；

}

![img](C++  Primer 5-75.jpg)



和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的 类名。static关键字则只出现在类内部的声明语句中

因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定 义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部 初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员，和其他对象一样， 一个静态数据成员只能定义一次。

类似于全局变量(参见6.1.1节，第184页)，静态数据成员定义在任何函数之外。因 此一旦它被定义，就将一直存在于程序的整个生命周期中。

我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象 的类型名，然后是类名、作用域运算符以及成员自己的名字：

//定义并初始化一个静态成员

double Account::interestRate = initRate()；

这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类 型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此, 我们可以直接使用initRate函数。注意，虽然initRate是私有的，我们也能用它初 始化interestRate。和其他成员的定义-•样，interestRate的定义也可以访I'nj类的 私有成员。

/Q ,要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联 函数的定义放在同一个文件中

静态成员的类内初始化

通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提 供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的

I 303〉constexpr (参见7.5.6节，第267页)。初始值必须是常量表达式，因为这些成员本身 就是常量表达式，所以它们能用在所有适合于常量表达式的地方。例如，我们可以用一个 初始化了的静态数据成员指定数组成员的维度：

class Account { public:

static double rate() { return interestRate； } static void rate(double)；

private:

static constexpr int period = 30;    // period 是常量表达式

double daily_tbl[period]；

｝；

如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的 const或constexpr static不需要分别定义。相反，如果我们将它用于值不能替换的 场景中，则该成员必须有一条定义语句。

例如，如果period的唯一用途就是定义daily_tbl的维度，则不需要在Account 外面专门定义period。此时，如果我们忽略了这条义，那么对程序非常微小的改动也 可能造成编译错误，因为程序找不到该成员的定义语句。举个例子，当需要把 Account: : period传递给一个接受const int &的函数时，必须定义period。

如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了：

// 一个不带初始值的静态成员的定义

constexpr int Account： :period；    //初始值在类的定义内提供

Best

Proctiftfc?



即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外 部定义一下该成员

静态成员能用于某些场景，而普通成员不能

如我们所见，静态成员独立于任何对象。因此，在某些非静态数据成员可能非法的场 合，静态成员却可以正常地使用。举个例子，静态数据成员可以是不完全类型（参见7.3.3 节，第249页）。特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据 成员则受到限制，只能声明成它所属类的指针或引用：

private:



class Bar { public:

// ...

| static Bar meml； | //正确 |
| ----------------- | ------ |
| Bar *mem2；       | //正确 |
| Bar mem3；        | //错误 |

静态成员可以是不完全类型 指针成员可以是不完全类型 数据成员必须是完全类型

静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参（参见6.5.1 <3^1 节，第211页）：

class Screen {

public:

// bkground表示一个在类中稍后定义的静态成员 Screens： clear (char = bkground)；

private:

static const char bkground；

};

非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是 无法真正提供一个对象以便从巾获取成员的值，最终将引发错误。

###### 7.6节练习

练习7.56:什么是类的静态成员？它有何优点？静态成员与普通成员有何区别？ 练习7.57：编写你自己的Account类。

练习7.58:下面的静态数据成员的声明和定义有错误吗？请解释原因。

// example.h class Example { public:

static double rate = 6.5; static const int vecSize = 20; static vector<double> vec(vecSize);

}；

// example.C #include "example.h" double Example::rate; vector<double> Example::vec;

小结    <3051

类是C++语言中最基本的特性。类允许我们为自己的应用定义新类型，从而使得程序 更加简洁.1!易于修改。

类有两项基本能力：一是数据抽象，即定义数裾成员和函数成员的能力；二是封装，

即保护类的成员不被随意访问的能力。通过将类的实现细节设为private,我们就能完 成类的封装。类可以将其他类或者函数没为友元，这样它们就能访问类的非公有成员了。

类可以定义一种特殊的成员函数：构造函数，其作用是控制初始化对象的方式。构造 函数可以重载，构造函数应该使用构造函数初始值列表来初始化所有数裾成员。

类还能定义可变或者静态成员。+—个可变成员永远都不会是const,即使在const 成员函数内也能修改它的值：一个静态成员可以是函数也町以是数据，静态成负存在于所 有对象之外。

##### 术语表

抽象数据类型(abstract data type)封装

(隐藏)了实现细节的数据结构=

访问说明符(access specifier)包括关键

字public和private。用于定义成员对 类的用户可见还是只对类的友元和成员可 见。在类中说明符可以出现多次，每个说 明符的有效范围从它自身开始，到下一个 说明符为止，

聚合类(aggregate class)只含有公有成

员的类，并且没有类内初始值或者构造函 数=聚合类的成员可以用花括号括起來的 初始值列表进行初始化。

类(class) C++提供的句定义数据类型的 机制。类可以包含数据、函数和类型成员。 一个类定义一种新的类型和一个新的作用 域。

类的声明(classdeclaration)首先_是关键

字class (或者struct)，随后是类名以 及分号。如果类已经声明而尚未定义，则 它是一个不完全类型。

class关键字(class keyword)用于定义

类的关键字，默认情况下成员是private 的。

类的作用域(classscope)每个类定义一

个作用域。类作用域比其他作用域更加复

杂，类中定义的成员函数S至有可能使用 定义语句之后的名字。

常量成员函数(001^(7160^6「1：1111沈011)---

个成员函数，在其中不能修改对象的普通 (即既不是static也不是mutable)数 裾成员。const成员的this指针是指向 常量的指针，通过区分函数是否是const 可以进行重载。

构造函数(constructor)用丁•初始化对象

的•一种特殊的成员函数-构造函数应该给 每个数据成员都赋-个合适的初始值。

构造函数初始值列表(constructor initializer

list)说明一•个类的数裾成员的初始值，在 构造函数体执行之前首先用初始值列表中 的值初始化数据成员。未经初始值列表初 始化的成员将被默认初始化，

转换构造函数(converting constructor)可

以用y个实参调用的非显式构造函数。这 样的函数隐式地将参数类型转换成类类 型。

数据抽象(data abstraction)着S关注类< 306 I

型接口的一种编程技术。数裾抽象令程序 员可以忽略类型的实现细节，只关注类型 执行的操作即数据抽象是面向对象编 程和泛型编程的基础。



默认构造函数(default constructor)当没

有提供仃何实参时使用的构造函数

委托构造函数(delegating constructor) _姿

托构造函数的初始值列表只有•个入口， 柑定类的另-个构造函数执行初始化操 作。

圭寸装(encapsulation)分离类的实现与接

U,从而隐藏了类的实现细W。在C++语 ,i 'l1 •迪过把实现部分设为private完成 封装的任务。

显式构造函数(explicit constructor)川'以

用-•个单独的实参调用但是不能用r隐式 转换的构造函数。通过在构造函数的声明 ■Z前加1: explicit关键'以将其j:;i' 明成W式构造函数。

前向声明(forward declaration)对崗朱定

义的名字的声明，通常川T表¥位丁类定 义之前的类声明。参见“不完伞类型”.

友元(friend)类向外部提供其非公好成员 访问权限的-种机制.友元的访W杈限与 成记函数拃，友儿可以是类，也吋以足 函数。

实现(implementation)类的成员(通常-是 私有的)，定义了不希蜇为使用类类型的代 W所川的数裾及任何操作。

不完全类型(incomplete type) i_i经声明

衍足尚未足义的类型。不完全类型不能用 T定义变K成者类的成员，但是用不完全 类型定义指针或者引用是合法的。

接口 (interface)类型提供的(公有)操 作。通常情况接口不包含数据成员。

■成员函数(member function)类的函数成

员.普通的成员函数通过隐忒的this指 针4类的对象绑定在-_起：静态成K函数 不15对象绑定在-起也没有this指针。

成员函数町以重载,此时隐式的this指 针参1j'函数匹配的过程。

可变数据成员(mutable data member)这

种成员永远不是const,即使它属于 const对象。在const涵数内可以修改可 变数裾成员。

名字查找(name lookup)根据名字的使

川、/找匹配的声明的过程。

私有成员(private member) 定义在

private访M说明符之后的成员，只能被 类的友元或者类的其他成员访问.数裾成 员以及仅供类本身使用而不作为接口的功 能函数…般没为private。

公有成员(public member) 定义iV_

public访问说明符之后的成员，可以被 类的所有川户访问。通常情况F,只有实 现类的接I-」的函数'被设为pub 1 i c。

struct关键字(struct keyword) 用尸定义

类的关键字，默认情况下成员趙public 的。

合成默认构造函数(synthesized default constructor)対于没有显式地定义任何构 造凼数的类，编译器为其创建(合成)的 默认构造函数。该构造函数检杏类的数裾 成员，如果提供了类内初始值，就用它执 行初始化操作：否则就对数据成员执行默 认初始化。

this指针(this pointer)是•■个隐式的值，

怍为额外的实参传递给类的毎个非静态成 员函数。this指针指向代农函数调用者的 对象。

=default -种语法形位T•类内部默汄 构造函数A明语句的参数列表之后，要求 编译器生成构造函数，而不管类是否已经 有了 M:他构造函数。
