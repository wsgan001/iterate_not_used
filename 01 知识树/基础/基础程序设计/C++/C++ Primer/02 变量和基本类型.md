### 第I部分 C++基础

内容

任何常用的编程语言都具备•组公共的语法特征，不同语言仅在特征的细节上有所区 别。要想学习并掌握一种编程语言，理解其语法特征的实现细节是第一步。最基本的特征 包括：

•整型、字符型等内置类型

•变量，用來为对象命名

•表达式和语句，用于操纵上述数据类型的具体值

• if或while等控制结构，这些结构允许我们有选择地执行一些语句或者重复地执 行一些语句

•函数，用于定义可供随时调用的计算单元

大多数编程语言通过两种方式来进一步补充其基本特征：一是赋予程序员自定义数裾 类型的权利，从而实现对语言的扩展：二是将一些有用的功能封装成库函数提供给程序员。

与大多数编程语言一样，C++的对象类型决定了能对该对象进行的操作，一条表达式 是否合法依赖于其中参与运算的对象的类型。一些语言，如Smalltalk和Python等，在程 序运行时检査数据类型；与之相反，C++是一种静态数据类型语言，它的类型检查发生在 编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。

C++提供了一组内置数据类型、相应的运算符以及为数不多的几种程序流控制语句， 这些元素共向构成了 CM•语言的基本形态。以这些元素为基础，我们可以编写出规模庞火、 结构复杂、用T•解决实际M题的软件系统。仅就C++的基本形态來说，它是一种简单的编 程语言，其强大的能力显示于它对程序员自定义数据结构的支持。这种支持作用巨大，显 而易见的一个事实是，C++语言的缔造者无须洞悉所有程序员的要求，而稈序员恰好可以 通过自主定义新的数据结构來使语言满足他们各自的需求。

C++中最重要的语法特征应该就是类了，通过它，程序员可以定义自己的数据类型。 为了与C++的内置类型区别开来，它们通常被称为“类类型(class type)\在一呰编程语 言中，程序员自定义的新类型仅能包含数据成员；另外一些语言，比如C++,则允许新类 型中既包含数据成员，也包含函数成员。C++语言主要的一个设计目标就是让程序员自定 义的数据类型像内置类型一样好用。基于此，标准C++库实现了丰富的类和函数。

本书第I部分的主题是学习C++语言的基础知识，这也是掌握C++语言的第一步。第 2章详述内置类型，并初步介绍了自定义数据类型的方法。第3章介绍了两种最基本的数 据类型：字符串和向量。C++和许多编程语言所共有的•一种底层数据结构——数组也在本 章有所提及，接下來，第4~6章依次介绍了表达式、语句和函数。作为第I部分的最后 ---章，第7章描述了如何构建我们自己的类，完成这一任务需要综合运用之前各章所介绍 的知识。

#### 第2章



### 变量和基本类型

内容

....................................................................................................................69

数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。

C++语言支持广泛的数据类型，它定义了几种基本内置类型（如字符、整型、浮点数 等），同时也为程序员提供了自定义数据类型的机制。基于此，C++标准库定义了一残更加 复杂的数据类型，比如可变长字符串和向量等。本章将主要讲述内置类型，并带领大家初 步了解C++语言是如何支持更复杂数据类型的。

□C>    数据类型决定了程序中数据和操作的意义。如下所示的语句是一个简单示例：

i = i + j;

其含义依赖于i和j的数据类型。如果i和j都是整型数，那么这条语句执行的就是最 普通的加法运算。然而，如果i和j是Sales_item类型的数据（参见1.5.1节，第17 页），则上述语句把这两个对象的成分相加。

##### 2.1基本内置类敬

C++定义了一套包枯算术类型（arithmetic type）和空类型（void）在内的基本数据类 型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用 于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返冋类型。

###### $6 2.1.1算术类型

算术类型分为两类：整型（integral type,包括字符和布尔类型在内）和浮点型。

算术类型的尺寸（也就是该类型数据所占的比特数）在不同机器上有所差别。表2.1 列出了 C++标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。某一类 型所占的比特数不同，它所能表示的数据范围也不一样。

| 表2.1: C++：算术类型 |                |              |
| -------------------- | -------------- | ------------ |
| 类型                 | 含义           | 最小尺寸     |
| bool                 | 布尔类型       | 未定义       |
| char                 | 字符           | 8位          |
| wchar t              | 宽字符         | 16位         |
| char16 t             | Unicode 字符   | 16位         |
| char32 t             | Unicode 字符   | 32位         |
| short                | 短整型         | 16位         |
| int                  | 整型           | 16位         |
| long                 | 长整型         | 32位         |
| long long            | 长整型         | 64位         |
| float                | 单精度浮点数   | 6位有效数字  |
| double               | 双精度浮点数   | 10位有效数字 |
| long double          | 扩展精度浮点数 | 10位有效数字 |

布尔类型（bool）的取值是真（true）或者假（false）。

C++提供了几种字符类型，其中多数支持国际化。基本的字符类型是char, 一个char 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char 的大小和一个机器字节一样。

I 33〉    其他字符类型用于扩展字符集，如wchar_t、charl6_t、char32_t。wchar_t

类型用于确保可以存放机器最大扩展字符集+的任意一个¥符，类型charl6_tln char32_t则为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）。

除字符和布尔类型之外，其他整型用于表示（可能）不同尺寸的整数。C杆语言规定 一个int至少和一个short —样大，一个long至少和一个int —样大，一个long long

至少和一个long—样大。其中，数据类型long long是在C++11中新定义的。    1 CiT 1

内a类增的机器实现

计算机以比特序列存储数据，每个比特非0即1，例如：

00011011011100010110010000111011 ...

大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字 节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。在C++语言 中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成， 字则由32或64比特构成，也就是4或8字节。

大多数计算机将内存中的每个字节与一个数字（被称为“地址（address ）”）关联起 来，在一个字节为8比特、字为32比特的机器上，我们可能看到一个字的内存区域如 下所示：

| 736424 | 0    | 0    | 1    | 1 1  | 0    | 1    | 1    |      |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 736425 | 0    | 0    | 0    | 1    | 1    | 0    | 1    | 1    |
| 736426 | 0    | 1    | 1    | 1    | 0    | 0    | 0    | 1    |
| 736427 | 0    | 1    | 1    | 0    | 0    | 1    | 0    | 0    |

其中，左侧是字节的地址，右侧是字节中8比特的具体内容„

我们能够使用某个地址来表示从这个地址开始的大小不同的比特串，例如，我们可 能会说地址736424的那个字或者地址736427的那个字节。为了赋予内存中某个地址明 确的含义，必须首先知道存储在该地址的数据的类型,，类型决定了数据所占的比特数以 及该如何解释这些比特的内容。

如果位置736424处的对象类型是float,并且该机器中float以32比特存储， 那么我们就能知道这个对象的内容占满了整个字。这个float数的实际值依赖于该机 器是如何存储浮点数的。或者如果位置736424处的对象类型是unsigned char,并且 该机器使用ISO-Latin-1字符集，则该位置处的字节表示一个分号。

浮点型可表示单精度、双精度和扩展精度值，C++标准指定了一个浮点数有效位数的 最小值，然而大多数编译器都实现了更高的精度。通常，float以1个字（32比特）来 表示，double以2个字（64比特）来表示，long double以3或4个字（96或128 比特）来表示。一般来说，类型float和double分别有7和16个有效位；类型long double则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。 CK3 带符号类型和无符号类型

除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号 的（unsigned）两种。带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于 等于0的值。

类型int、short、long和long long都是带符号的，通过在这些类型名前添加 unsigned就可以得到无符号类型，例如unsigned long.类型unsigned int可以 缩写为unsigned。

与其他整型不H，字符型被分为了二种：char、signed char和unsigned char。

特别需要注意的是：类型char和类型signed char并不一样。尽管字符型有三种，但 是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两 种形式中的一种，具体是哪种由编译器决定。

无符号类型中所有比特都用来存储值，例如，8比特的unsigned char可以表示0 至255区间内的值。

C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的 量应该平衡。因此，8比特的signed char理论上应该可以表示-127至127区间内的 值，大多数现代计算机将实际的表示范围定为-128至127。

建议：如何选择类观

和C语言一样，C++的设计准则之一也是尽可能地接近硬件。C++的算术类型必须 满足各种硬件特质，所以它们常常显得繁杂而令人不知所措。事实上，：大多数程序员能 够（也应该）对数据类型的使用做出限定从而简化选择的过程=以下是选择类型的一些 经验准则：

•当明确知晓数值不可能为负时，选用无符号类型。

•使用int执行整数运算。在实际应用中，short常常显得太小而long—般和int 有一样的尺寸。如果你的数值超过了 int的表示范围，选用long long。

•在算术表达式中不要使用char或bool,只有在存放字符或布尔值时才使用它 们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的， 所以如果使用c h a r进行运算特别容易出问题。如果你需要使用一个不大的整数， 那么明确指定它的类型是signed char或者unsigned char。

•执行浮点数运算选用double,这是因为float通常精度不够而且双精度浮点 数和单精度浮点数的计算代价相差无几。事实上，对于某些机器來说，双精度运 算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的， 况且它带来的运行时消耗也不容忽视&

###### 2.1.1节练习

练习2.1:类型int、long、long long和short的区别是什么？无符号类型和带符 号类型的区别是什么？ float和double的区别是什么？

练习2.2:计算按揭贷款时，对于利率、本金和付款分别应选择何种数据类型？说明你 的理由。

###### 檢2.1.2类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支 持，就是将对象从一种给定的类型转换（convert）为另一种相关类型。

当在程序的某处我们使用了 一种类型而其实对象应该取另一种类型时，程序会自动进 行类型转换，在4.11节（第141页）中我们将对类型转换做更详细的介绍。此处，有必要 说明当给某种类型的对象强行赋了另一种类型的值时，到底会发生什么。

当我们像下面这样把一种算术类型的值赋给另外一种类型时：

// b为真



bool b = 42;

int i = b; // i = 3.14; // double pi = i; // unsigned char c = -1; // signed char c2 = 256; //



i的值为1

i的值为3

pi的值为3.0

假设char占8比特，c的值为255 假设char占8比特，c2的值是未定义的



类型所能表示的值的范围决定了转换的过程:

•当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false, 否则结果为true。

•当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为 true则结果为1。

•当我们把一个浮点数赋给整数类型时，进行了近似处理，结果值将仅保留浮点数中 小数点之前的部分。

•当我们把一个整数值赋给浮点类型时，小数部分记为0»如果该整数所占的空间超 过了浮点类型的容量，精度可能有损失。

•当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表 示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至 255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256 取模后所得的余数=因此，把-1赋给8比特大小的unsigned char所得的结果 是 255。

•当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的(undefined)o 此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。

建议：避免无法预知和依賴于实现环境的行为

无法预知的行为源于编译器无须(有时是不能)检测的错误。即使代码编译通过了， 如果程序执行了一条未定义的表达式，仍有可能产生错误。

不幸的是，在某些情况和/或某些编译器下,含有无法预知行为的程序也能正确执行。 但是我们却无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通过的代 码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对另一组输 入就一定有效_。

程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个 确定不变的已知值，那么这样的程序就称作不可移植的(nonportable)。当程序移植到别 的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误 可不是一件轻松愉快的工作。

当在程序的某处使用了一种算术类型的值而其实所需的是另一种类型的值时，编译器 同样会执行上述的类型转换。例如，如果我们使用了一个非布尔值作为条件(参见1.4.1 节，第10页)，那么它会被自动地转换成布尔值，这一做法和把非布尔值赋给布尔变量时 的操作完全一样：

int i = 42;

if (i)    //if条件的值将为true

i = 0;

如果i的值为0,则条件的值为false; i的所有其他取值(非0)都将使条件为true-

以此类推，如果我们把一个布尔值用在算术表达式里，则它的取值非0即1，所以一 般不宜在算术表达式里使用布尔值。

eg含有无符号类型的表达式

尽管我们不会故意给无符号对象赋一个负值，却可能（特别容易）写出这么做的代码。 例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号 数。把int转换成无符号数的过程和把int直接赋给无符号变量一样：

unsigned u = 10; int i = -42;

std: :cout << i + i << std: :endl; // 输出-84

std: :cout « u + i « std: :endl; // 如果 int 占 32 位，输出 4294967264

在第一个输出表达式里，两个（负）整数相加并得到了期望的结果。在第二个输出表达式 里，相加前首先把整数-42转换成无符号数。把负数转换成无符号数类似于直接给无符号 数赋一个负值，结果等于这个负数加上无符号数的模。

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不 能是一个负值：

| 37 〉 unsigned ul = 42, u2 = 10;

std: : cout « ul - u2 « std: :endl; // 正确：输出 32

std: :cout << u2 - ul << std::endl; //正确：不过，结果是取模后的值

无符号数不会小于0这一事实同样关系到循环的写法。例如，在1.4.1节的练习（第11页） 中需要写一个循环，通过控制变量递减的方式把从10到0的数字降序输出。这个循环可 能类似于下面的形式：

for （int i = 10; i >= 0; --i）

std::cout « i « std::endl;

可能你会觉得反正也不打算输出负数，可以用无符号数来重写这个循环。然而，这个不经 意的改变却意味着死循环：

//错误：变量u永远也不会小于0,循环条件一直成立 for （unsigned u = 10; u >= 0;——u）

std::cout « u « std::endl;

来看看当u等于0时发生了什么，这次迭代输出0,然后继续执行for语句里的表达式。 表达式一11从11当中减去1,得到的结果-1并不满足无符号数的要求，此时像所有表示范 围之外的其他数字一样，-1被自动地转换成一个合法的无符号数。假设int类型占32 位，则当u等于0时，--U的结果将会是4294967295。

一种解决的办法是，用while语句来代替for语句，因为前者让我们能够在输出变 量之前（而非之后）先减去1:

unsigned u = 11; //确定要输出的最大数，从比它大1的数开始 while （u > 0）{

—u;    / /先减1，这样最后一■次迭代时就会输出0

std::cout << u « std::endl;

}

改写后的循环先执行对循环控制变量减1的操作，这样最后一次迭代时，进入循环的U值 为1。此时将其减1,则这次迭代输出的数就是0:下一次再检验循环条件吋，u的值等

于0而无法再进入循环。因为我们要先做减1的操作，所以初始化u的值应该比要输出 的最大值大1。这里，u初始化为11，输出的最大数是10。

提示：切勿混用带符号类概和无符唼类彻

如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异 常结杲，这是因为带符号数会自动地转换成无符号数。例如，在一个形如a*b的式子 中，如果a = -1, b = 1,而且a和b都是int,则表达式的值显然为-1。然而，如 果a是int,而b是unsigned,则结果须视在当前机器上int所占位数而定在我 们的环境里，结果是4294967295。

###### 2.1.2节练习

<38~|



练习2.3:读程序写结果。

| unsigned u | =           | 10,  | u2 = 42; |              |         |
| ---------- | ----------- | ---- | -------- | ------------ | ------- |
| std:       | :cout       | «    | u2       | -u « std     | ::endl; |
| std:       | :cout       | «    | u _      | u2 « std     | ::endl; |
| intstd:    | i = 10:cout | t«   | i2 =i2   | 42;-i« std:: | endl;   |
| std:       | :cout       | «    | i -      | i2<< std:    | :endl;  |
| std:       | ::cout      | «    | i -      | u« std::     | endl;   |
| std:       | ::cout      | «    | u -      | i« std::     | endl;   |

练习2.4:编写程序检查你的估计是否正确，如果不正确，请仔细研读本节直到弄明白 问题所在。

###### 2.1.3字面值常量

一个形如42的值被称作字面值常量（literal）,这样的值一望而知。每个字面值常量 都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

整型和浮点型字面值

我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整 数代表八进制数，以Ox或0X开头的代表十六进制数。例如，我们能用下面的任意一种 形式来表示数值20:

20 /*十进制*/    024 /*八进制*/    0x14 /*十六进制*/

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数， 八进制和十六进制字面值既可能是带符号的也可能是无符号的。十进制字面值的类型是 int、long和long long中尺寸最小的那个（例如，三者当中最小是int）,当然前提 是这种类型要能容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的 int、unsigned int、long、unsigned long、long long 和 unsigned long long 中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。 类型short没有对应的字面值。在表2.2 （第37页）中，我们将以后缀代表相应的字面 值类型。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负

数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的 作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识：

3.14159    3.14159E0    0.    OeO    .001

L39＞默认的，浮点型字面值是一个double,我们可以使用表2.2 （第37页）中的后缀来表示 其他浮点型。

字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则 构成字符串型字面值。

'a'    II字符字面值

"Hello World! "    //字符串字面值

字符串字面值的类型实际上是由常量字符构成的数组（array）,该类型将在3.5.4节（第 109页）介绍。编译器在每个字符串的结尾处添加一个空字符（AO1）,因此，字符串字 面值的实际长度要比它的内容多1=例如，字面值'A'表示的就是单独的字符A,而字符 串”A”则代表了一个字符的数组，该数组包含两个字符：一个是字母A、另一个是空字符。

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一 个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的 方式：

II分多行书写的字符串字面值

std::cout « "a really, really long string literal "that spans two lines" « std::endl;

转义序列

有两类字符程序员不能直接使用：一类是不可打印（nonprintable）的字符，如退格或 其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单 引号、双引号、问号、反斜线）=在这些情况下需要用到转义序列（escape sequence）,转 义序列均以反斜线作为开始，C++语言规定的转义序列包括：

| 换行符     | \n   | 横向制表符 | \t   | 报警（响铃）符 | \a   |
| ---------- | ---- | ---------- | ---- | -------------- | ---- |
| 纵向制表符 | \v   | 退格符     | \b   | 双引号         | V    |
| 反斜线     | \\   | 问号       | \?   | 单引号         |      |
| 回车符     | \r   | 进纸符     | \f   |                |      |

在程序中，上述转义序列被当作一个字符使用：

std: :cout « r \nr;    // 转到新一行

std::cout «    //输出一个制表符，输出"Hi!",转到新一行

我们也可以使用泛化的转义序列，其形式是\*后紧跟1个或多个十六进制数字，或者\后 紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。假设使用的 是Latin-1字符集，以下是一些示例：

\7 （响铃） \12 （换行符）    \40（空格）

\0 （空字符）\115 （字符M）    \x4d （字符M）

S＞我们可以像使用普通字符那样使用C++语言定义的转义序列：

std: : cout « "Hi \x4dO\115!\n";    //输出 Hi MOM!,转到新一行

std::cout «    << '\n';    //输出 M，转到新一行

注意，如果反斜线\后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列。 例如，”\1234”表示2个字符，即八进制数123对应的字符以及字符4。相反，\x要用 到后面跟着的所有数字，例如，•’\xl234”表示一个16位的字符，该字符由这4个十六 进制数所对应的比特唯一确定。因为大多数机器的char型数据占8位，所以上面这个例 子可能会报错=一般来说，超过8位的十六进制字符都是与表2.2中某个前缀作为开头的 扩展字符集一起使用的。

指定字面值的类型

通过添加如表2.2中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默 认类型。

L,a,

u8，'hi!n

42ULL

1E-3F

3.14159L



//宽字符型字面值，类型是wchar_t

// utf-8字符串字面值（utf-8用8位编码一个Unicode字符） //无符号整型字面值，类型是unsigned long long //单精度浮点型字面值，类型是float

//扩展精度浮点型字面值，类型是long double

Best    当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母1和数

字1太容易混淆了。夂

表2.2:指定字面值的类型

字符和字符串字面值

| 前缀     | 含义                           | 类型         |             |
| -------- | ------------------------------ | ------------ | ----------- |
| u        | Unicode 16 字符                |              | charl6_t    |
| U        | Unicode 32 字符                |              | char32 t    |
| L        | 宽字符                         |              | wchar t     |
| u8       | UTF-8 （仅用于字符串字面常量） | char         |             |
|          | 整型字面值                     | 浮点型字面值 |             |
| 后缀     | 最小匹配类型                   | 后缀         | 类型        |
| u or U   | unsigned                       | f或F         | float       |
| 1 orL    | long                           | 1或L         | long double |
| 11 or LL | long long                      |              |             |

对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。如果后 缀中有U,则该字面值属于无符号类型，也就是说，以U为后缀的十进制数、八进制数或 十六进制数都将从 unsigned int、unsigned long 和 unsigned long long 中选择 能匹配的空间最小的一个作为其数据类型。如果后缀中有L,则字面值的类型至少是long; 如果后缀中有LL，则字面值的类型将是long long和unsigned long long中的一种。 显然我们可以将U与L或LL合在一起使用。例如，以UL为后缀的字面值的数据类型将 根据具体数值情况或者取unsigned long，或者取unsigned long long。

on



布尔字面值和指针字面值

true和false是布尔类型的字面值：

bool test =



false;



nullptr是指针字面值，2.3.2节(第47页)将有更多关丁•指针和指针字面值的介绍。

###### 2.1.3节练习

练习2.5:指出下述字面值的数据类型并说明每一组内几种字面值的区别：

\1/

abed



'a', L'a', "a", L"a"

10, lOu, 10L, lOuL, 012, OxC

3.14, 3.14f, 3.14L

10, lOu, 10., 10e-2

练习2.6:下面两组定义是否有区别，如果有，请叙述之：

int month = 9, day = 7; int month = 09, day = 07;

练习2.7:下述字面值表示何种含义？它们各自的数据类型是什么？

(a)    "Who goes with F\145rgus?\012n

(b)    3.14elL    (c) 1024f    (d) 3.14L

练习2.8:请利用转义序列编写一段程序，要求先输出2M,然后转到新一行。修改程序 使其先输出2,然后输出制表符，再输出M,最后转到新一行。

##### 2.2变量

变量提供一个具名的、可供程序操作的存储空间。C#中的每个变量都有其数据类型， 数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变 量能参与的运算。对C++程序员来说，“变量(variable)”和“对象(object)” 一般可以互 换使用。

^6 2.2.1变量定义

变量定义的基本形式是：首先是类型说明符(type specifier),随后紧跟由一个或多个 变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。列表中毎个变量名的类型 都由类型说明符指定，定义时还可以为一个或多个变量赋初值：

int sum = 0, value, // sum、value 和 units_sold 都是 int units_sold = 0;    // sum 和 units_sold 初值为 0

Sales_item item;    // item 的类型是 Sales_item (参见 1.5.1 节，第 17 页)

// string是一种库类型，表示一个可变长的字符序列

std: : string book ("0-201-78345-X") ; //book 通过一个 string 字面值初始化

book的定义用到了库类型std: : string，像iostream (参见1.2节，第6页) 一样，string也是在命名空间std中定义的，我们将在第3章中对string类型做更详 细的介绍。眼下，只需了解string是一种表示可变长字符序列的数据类型就可以了。C++ 库提供了几种初始化string对象的方法，其中一种是把字面值拷贝给string对象(参 见2.1.3节，第36页)，因此在上例中，book被初始化为0-201-78345-X。

术语：何为对象?

C++程序员们在很多场合都会使用对象(object)这个名词。通常情况下，对象是指 一块能存储数据并具有某种类型的内存空间。

一些人仅在与类有关的场景下才使用“对象”这个词。另一些人则已把命名的对象 和未命名的对象区分开来，他们把命名了的对象叫做变量还有一些人把对象和值区分 开来，其中对象指能被程序修改的数据，而值(value)指只读的数据。

本书遵循大多数人的习惯用法，即认为对象是具有某种数据类型的内存空间我们 在使用对象这个词时，并不严格区分是类还是内置类型，也不区分是否命名或是否只读。

初始值

当对象在创建时获得了一个特定的值，我们说这个对象被初始化(initialized) 了。用 于初始化变量的值可以是任意复杂的表达式。当一次定义了两个或多个变量时，对象的名 字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量值去初 始化后定义的其他变量。

//正确：price先被定义并赋值，随后被用于初始化discount double price = 109.99, discount = price * 0.16;

//正确：调用函教applyDiscount，然后用函数的返回值初始化salePrice double salePrice = applyDiscount(price, discount);

在C++语言中，初始化是一个异常复杂的问题，我们也将反复讨论这个问题。很多柷 序员对于用等号=来初始化变量的方式倍感困惑，这种方式容易让人认为初始化玷赋值的 一种。事实上在C++语言中，初始化和赋值是两个完全不同的操作。然而在很多编稈语j 中二者的区别几乎可以忽略不计，即使在C++语言中有时这种区别也无关紧要，所以人们 特别容易把二者混为一谈。需耍强调的是，这个概念至关重耍，我们也将在后面不||: •次＜^J 提及这一点。

/]\ 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含 ^SninG义是把对象的当前值擦除，而以一个新值来替代

列表初始化

C++语言定义了初始化的好几种不同形式，这也是初始化问题复杂性的-个体现。例 如，要想定义一个名为units_sold的int变量并初始化为0,以下的4条语句都可以 做到这一点：

int units_sold =0; int units_sold = {0}; int units_sold{0}; int units_sold(0);

作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，而在此之前，

这种初始化的形式仅在某些受限的场合下才能使用。出于3.3.1节(第88迈)将耍介绍的 原因，这种初始化的形式被称为列表初始化(list initialization)。现在，无论是初始化对象 还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。

当用于内置类型的变量时，这种初始化形式有--个重要特点：如果我们使用列农初始 化且初始值存在丢失信息的风险，则编译器将报错：

long double Id = 3.1415926536;

int a{Id}, b = {Id};    //错误：转换未执行，因为存在丢失信息的危险

int c（ld） , d = Id;    //正确：转换执行，且确实丢失了部分值

使用long double的值初始化int变量吋可能丢失数据，所以编译器拒绝了 a和b的初 始化请求。其中，至少Id的小数部分会丢失掉，而且int也可能存不下Id的整数部分。

刚刚所介绍的看起来无关紧要，毕竟我们不会故意用long double的值去初始化 int变量。然而，像第16章介绍的一样，这种初始化有可能在不经意间发生。我们将在 3.2.1节（第76页）和3.3.1节（第88页）对列表初始化做更多介绍。

默认初始化

如果定义变量时没有指定初值，则变量被默认初始化（default initialized）,此时变量 被赋予了 "默认值”，默认值到底是什么由变量类型决定，同时定义变量的位置也会对此 有影响。

nr>    如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数

体之外的变量被初始化为0。然而如6.1.1节（第185页）所示，一种例外情况是，定义 在函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型 变量的值是未定义的（参见2.1.2节，第33页），如果试图拷贝或以其他形式访问此类值 将引发错误。

每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类 自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。

绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。 例如，以刚刚所见为例，string类规定如果没有指定初值则生成一个空串：

std: : string empty; // empty非显式地初始化为一个空串 Sales_item item;    //被默认初始化的Sales_item对象

一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确 的初始化操作，将引发错误。

![img](C++  Primer 5-15.jpg)



定义于函数体内的内置类型的对象如果没有初始化，则其值未定义类的对象 如果没有显式地初始化，则其值由类确定：

###### 2.2.1节练习

练习2.9:解释下列定义的含义。对于非法的定义，请说明错在何处并将其改正。

(a) std: :cin » int input_value;    (b) int i = { 3.14 };

(c)double salary = wage = 9999.99; (d) int i = 3.14;

练习2.10：下列变量的初值分别是什么？

std::string global_str; int global_int; int main()

{

int local_int;

std::string local_str;

}

提示：未初始化变量引发运行吋故障

未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程行 为并且很难调试。尽管大多数编译器都能对一部分使用未初始化变量的行为提出警告， 但严格来说，编译器并未被要求检查此类错误。

使用未初始化的变量将带来无法预计的后果。有时我们足够幸运，一访问此类对象 程序就崩溃并报错，此时只要找到崩溃的位置就很容易发现变量没被初始化的问题。另 外一些时候，程序会一直执行完并产生错误的结果。更糟糕的情况是，程序结果时对时 错、无法把握。而且，往无关的位置添加代码还会导致我们误以为程序对了，其实结果 仍旧有错。/

^建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确 保初始化后程序安全，那么这么做不失为一种简单可靠的方法。

###### 2.2.2突量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译(separate compilation)机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

如果将程序分为多个文件，则需要有在文件间共享代码的方法。例如，一个文件的代 码可能需要使用另一个文件中定义的变量-一个实际的例子是std: : cout和std: : cin,

它们定义于标准库，却能被我们写的程序使用。

为了支持分离式编译，C++语言将声明和定义区分开来。声明(declaration)使得名字 为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义 (definition)负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义 还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字extern,而且不要显式 地初始化变量：

extern int i; II声明i而非定义i int j;    //声明并定义j

任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋 一个初始值，但是这么做也就抵消了 extern的作用。extern语句如果包含初始值就不 再是声明，而变成定义了：

extern double pi = 3.1416; // 定义 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

![img](C++  Primer 5-16.jpg)



变量能且只能被定义一次，但是可以被多次声明。

声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中 使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在 一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

关于C++语言对分离式编译的支持我们将在2.6.3节(第67页)和6.1.3节(第186 <50

页)中做更详细的介绍。

| 2.2.2节练习                                                  |      |
| ------------------------------------------------------------ | ---- |
| 练习2.11:指出下面的语句是声明还是定义：(a)    extern int ix = 1024;(b)    int iy;(c)    extern int iz; | •    |

K键概念：静态类哦

C++是一种静态类型(statically typed )语言，其含义是在编译阶段检查类型。其中， 检查类型的过程称为类型检查(type checking k

我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负 责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报 错并且不会生成可执行文件。

程序越复杂，静态类型检查越有助于发现问题然而，前提是编译器必须知道每一 个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型:，

###### 2.2.3标识符

C++的标识符(identifier)由字母、数字和下画线组成，其巾必须以字母或下画线开 头。标识符的长度没有限制，但是对大小写字母敏感：

//定义4个不同的int变量

int somename, someName, SomeName, SOMENAME;

如表2.3和表2.4所示，C++语言保留了一些名字供语言本身使用，这些名字不能被用 作标识符。

同吋，C科也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下 画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线 开头。

变量命名规范

变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性：

标识符要能体现实际含义。

•变量名一般用小写字母，如index,不要使用Index或INDEX。

•用户自定义的类名一般以大写字母开头，如Sales_item。

•如果标识符由多个单词组成，则单词间应有明显区分，如Student_lOan或 studentLoan,不要使用 studentloano

对于命名规范来说，若能坚持，必将有效..

表2.3: C++关键字

| alignas    | continue     | friend    | register         | true     |
| ---------- | ------------ | --------- | ---------------- | -------- |
| alignof    | decltype     | goto      | reinterpret_cast | try      |
| asm        | default      | if        | return           | typedef  |
| auto       | delete       | inline    | short            | typeid   |
| bool       | do           | int       | signed           | typename |
| break      | double       | long      | sizeof           | union    |
| case       | dynamic cast | mutable   | static           | unsigned |
| catch      | else         | namespace | static_assert    | using    |
| char       | enum         | new       | static cast      | virtual  |
| charl6 t   | explicit     | noexcept  | struct           | void     |
| char32 t   | export       | nullptr   | switch           | volatile |
| class      | extern       | operator  | template         | wchar_t  |
| const      | false        | private   | this             | while    |
| constexpr  | float        | protected | thread local     |          |
| const cast | for          | public    | throw            |          |

|        |        | 表 2.4: | C++操作符替代名 |       |        |
| ------ | ------ | ------- | --------------- | ----- | ------ |
| and    | bitand | compl   | not_eq          | or_eq | xor eq |
| and eq | bitor  | not     | or              | xor   |        |

###### 2.2.3节练习

练习2.12：请指出下面的名字中哪些是非法的？

(a) int double = 3.14;    (b) int

(c) int catch-22;    (d) int l_or_2 = 1;

(e) double Double = 3.14;

###### 2.2.4名字的件:用域

不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、 类型等。然而，同一个名字如果出现在程序的不同位置，也可能指向的是不同实体。

<48~|



作用域(scope)是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作 用域都以花括号分隔。

同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明 语句，以声明语句所在的作用域末端为结束，

一个典型的示例来自T 1.4.2节(第11页)的程序：

^include <iostream> int main()

{

int sum = 0;

// sum用于存放从1到10所有数的和 for (int val = 1; val <= 10; ++val)

sum += val; // 等价于 sum = sum + val

std: :cout « "Sum of 1 to 10 inclusive is •’

« sum << std::endl;

return 0;

}

这段程序定义了 3个名字：main、sum和val,同时使用了命名空间名字std,该空间 提供了 2个名字cout和cin供程序使用。

名字main定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥 有全局作用域(global scope)。一旦声明之后，全局作用域内的名字在整个程序的范围内 都可使用。名字sum定义于main函数所限定的作用域之内，从声明sum开始直到main 函数结束为止都可以访问它，但是出了 main函数所在的块就无法访问了，因此说变量sum 拥有块作用域(block scope)。名字val定义于for语句内，在for语句之内可以访问 val,但是在main函数的其他部分就不能访问它了。

建议：当你第•次使用变量吋再定义它

一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，因为这样做有 助于更容易地找到变量的定义。更重要的是，当变量的定义与它第一次被使用的地方很 近时，我们也会赋给它一个比较合理的初始值

嵌套的作用域

作用域能彼此包含，被包含(或者说被嵌套)的作用域称为内层作用域(innerscope), 包含着别的作用域的作用域称为外层作用域(outer scope)o

作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时， 允许在内层作用域中重新定义外层作用域已有的名字：

| 49 〉    #include <iostream>

//该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量 int reused = 42; II reused拥有全局作用域

int main()

{

int unique = 0; // unique 拥有块作用域

//输出#1:使用全局变量reused;输出42 0

std: : cout << reused « *' " << unique « std: : endl;

int reused =0; //新建局部变量reused，覆盖了全局变量reused

//输出#2:使用局部变量reused;输出0 0

std::cout « reused << " " « unique « std::endl;

//输出#3:显式地访问全局变量reused;输出42 0

std: : cout « :: reused « ” ’’ << unique << std: : endl;

return 0;

}

输出#1出现在局部变量reused定义之前，因此这条语句使用全局作用域中定义的名字 reused,输出42 0。输出#2发生在局部变量reused定义之后，此时局部变量reused 正在作用域内(in scope),因此第二条输出语句使用的是局部变量reused而非全局变量， 输出0 0。输出#3使用作用域操作符(参见1.2节，第7页)来覆盖默认的作用域规则， 因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出 请求获取作用域操作符右侧名字对应的变量。结果是，第三条输出语句使用全局变量 reused,输出 42 0。

![img](C++  Primer 5-17.jpg)



如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量


###### 2.2.4节练习

练习2.13：下面程序中j的值是多少？

int i = 42; int main()

int i = 100; int j = i;

练习2.14：下面的程序合法吗？如果合法，它将输出什么？

int i = 100, sum = 0;

for (int i = 0; i != 10; ++i)

sum += i;

std::cout << i << " " « sum « std::endl;

##### 2.3复合类喂

复合类型(compound type)是指基于其他类型定义的类型。C++语言有几种复合类型， 本章将介绍其中的两种：引用和指针。

与我们已经掌握的变量声明相比，定义复合类型的变量要复杂很多。2.2节(第38页) 提到，一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。其实更通 用的描述是，一条声明语句由一个基本数据类型(base type)和紧随其后的一个声明符 (declarator)列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关 的某种类型，

目前为止，我们所接触的声明语句中，声明符其实就是变量名，此时变量的类型也就 是声明的基本数据类型。其实还可能有更复杂的声明符，它基于基本数据类型得到更复杂 的类型，并把它指定给变量。

2.3.1 引用

C++11中新增了一种引用：所谓的"右值引用(rvalue reference)”，我们将在

13.6.1节(第471页)做更详细的介绍、这种引用主要用于内置类：严格来说，

当我们使用术语“引用(reference)’’时，指的其实是“左值引用(lvalue reference。

引用(reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。 通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：

int ival = 1024;

int SrefVal = ival;    // refVal 指向 ival (是 ival 的另一个名字)

int &refVal2;    //报错：引用必须被初始化

-般在初始化变量时，初始值会被拷贝到新建的对象中=然而定义引用时，程序把引用和 它的初始值绑定(bind)在一起，而不是将初始值拷51给引用。一旦初始化完成，引用将 和它的初始值对象一直绑定在一起=因为无法令引用重新绑定到另外一个对象，因此引用 必须初始化。

引用即别名

![img](C++  Primer 5-18.jpg)



引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：

refVal = 2;    //把2賦给refVal指向的对象，此处即是赋给了 ival

int ii = refVal; // 与 ii = ival 执行结果^羊

EH＞为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与 引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初 始值：

//正确：refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上 int &refVal3 = refVal;

//利用与refVal绑定的对象的值初始化变量i

int i = refVal; //正确：i被初始化为ival的值

因为引用本身不是一个对象，所以不能定义引用的引用。

引用的定义

允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头： int i = 1024, i2 = 2048; // i 和 i2 都是 int

int &r = i, r2 = i2;    // r是一个引用，与i绑定在一起，r2是int

int i3 = 1024, &ri = i3; // i3 是 int, ri 是一个引用，与 i3 绑定在一起 int &r3 = i3, &r4 = i2;    // r3 和 r4 都是引用

除了 2.4.1节(第55页)和15.2.3节(第534页)将要介绍的两种例外情况，其他所 有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与 字面值或某个表达式的计算结果绑定在一起，相关原因将在2.4.1节详述：

int &refVal4 = 10;    //错误：引用类型的初始值必须是一个对象

double dval = 3.14;

int &refVal5 = dval;    //错误：此处引用类型的初始值必须是:Lnt型对象

###### 2.3.1节练习

练习2.15:下面的哪个定义是不合法的？为什么？

(a) int ival = 1.01;    (b) int &rvall = 1.01;

(c) int &rval2 = ival;    (d) int &rval3;

练习2.16：考查下面的所有赋值然后冋答：哪些赋值是不合法的？为什么？哪些赋值是 合法的？它们执行了什么样的操作？

int i = 0, &rl = i;    double d = 0, &r2 = d;

(a)r2 = 3.14159;    (b) r2 = rl;

(c) i = r2;    (d) rl = d;

练习2.17：执行下面的代码段将输出什么结果？

int i, &ri = i; i = 5; ri = 10;

std::cout << i « " " << ri << std::endl;

###### 2.3.2 指针    50

指针（pointer）是“指向（point to）”另外一种类型的复合类型。与引用类似，指针 也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一,指针本身 就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不 同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的 指针如果没有被初始化，也将拥有一个不确定的值，

WARNING



指^十通常难以理解，即使是有经验的程序员也常常因为调试指针引发的错误而 被备受折麼.、

定义指针类型的方法将声明符写成*d的形式，其中d是变量名。如果在一条语句中 定义了几个指针变量，每个变量前面都必须有符号*:

int *ipl, *ip2;    // ipl和ip2都是指向int型对象的指针

double dp, *dp2;    // dp2是指向double型对象的指针，dp是double型对象

获取对象的地址

指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）: int ival = 42;

int *p = &ival; // p存放变量ival的地址，或者说p是指向变量ival的指针

第二条语句把p定义为一个指向int的指针，随后初始化P令其指向名为ival的int 对象。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

除了 2.4.2节（第56页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所 有指针的类型都要和它所指向的对象严格匹配：

| double dval; double *pd = &dval; double *pd2 = pd; | //正确 //正确 |
| -------------------------------------------------- | ------------- |
| int *pi = pd;                                      | //错误        |
| pi = &dval;                                        | //错误        |



初始值是double型对象的地址

初始值是指向double对象的指针

指针pi的类型和pd的类型不匹配

试图把double型对象的地址赋给int型指针

因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以者必须匹 配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

指针值

指针的值（即地址）应属下列4种状态之一: 1.指向一个对象。

2 .指向紧邻对象所占空间的下一个位置。

3-空指针，意味着指针没有指向任何对象。

4.无效指针，也就是上述情况之外的其他值。

试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误， ES3>这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序

员必须清楚任意给定的指针是否有效。

尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没 有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样 做了，后果也无法预计。

利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象： int ival = 42;

int *p = &ival; // p存放着变量ival的地址，或者说p是指向变量ival的指针 cout « *p;    //由符号*得到指针p所指的对象，输出42

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所 指的对象赋值：

*p = 0;    //由符号*得到指针p所指的对象，即可经由p为变量ival賦值

cout « *p;    // 输出 0

如上述程序所示，为+p赋值实际上是为p所指的对象赋值。

![img](C++  Primer 5-20.jpg)



解引用操作仅适用于那些确实指向了某个对象的有效指针

又键概念：某拽符'4■打多艰穴义

像&和*这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符 号的上下文决定了符号的意义：

| int  | i =  | 42;  |      |                  |
| ---- | ---- | ---- | ---- | ---------------- |
| int  | &r = | :i;  | //   | &紧随类型名出现  |
| int  | *p； |      | //   | *紧随类型名出现  |
| P =  | &i ; |      | //   | &出现在表达式中  |
| *P = | =i； |      | //   | *出现在表达式中  |
| int  | &r2  | =*p; | //   | &是声明的一■部分 |



因此是声明的一部分，r是一个引用 因此是声明的一部分，p是一个指针 是一个取地址符

是一个解引用符 *是一个解引用符



在声明语句中，&和*用于组成复合类型；在表达式中，它们的角色又转变成运算符。在 不同场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它 当作不同的符号来看待。

空指针

空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查 它是否为空。以下列出几个生成空指针的方法：

I 54 >    int *pl = nullptr;    // 等价于 int *pl = 0;

int *p2 = 0;    //直接将p2初始化为字面常量0

// 需要首先#include cstdlib

int *p3 = NULL;    // 等价于 int *p3 = 0;

fgjT］得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚 刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成（参见2.1.2节，

第32页）任意其他的指针类型。另一种办法就如对P2的定义一样，也可以通过将指针初 始化为字面值0来生成空指针。

过去的程序还会用到一个名为NULL的预处理变量（preprocessor variable）来给指针 赋值，这个变量在头文件cstdlib中定义，它的值就是0。

2.6.3节（第68页）将稍微介绍一点关于预处理器的知识，现在只要知道预处理器是 运行于编译过程之前的一段程序就可以了。预处理变量不属于命名空间std,它由预处理 器负责管理，因此我们可以直接使用预处理变量而无须在前面加上std::.

当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用NULL初始 化指针和用0初始化指针是一样的，在新标准下，现在的C++程序最好使用nullptr, 同时尽量避免使用NULL。

把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。 int zero = 0;

pi = zero;    //错误：不能把int变量直接赋给指针

迸议：初始化所有指针

使用未经初始化的指针是引发运行时错误的一大原因。

和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的、通常这一 行为将造成程序崩溃，而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。_

在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的 当前内容将被看作-■个地址值。访问该指针，相当于去访问一个本不存在的位置上的本 不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作 了某个地址，我们就很难分清它到底是合法的还是非法的了。

因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义 指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0, 这样程序就能检测并知道它没有指向任何具体的对象了。

赋值和指针

指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不 同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定＜55~| 到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

指针和它存放的地址之间就没有这种限制了。和其他任何变量（只要不是引用）一样，

给指针赋值就是令它存放一个新的地址，从而指向一个新的对象：

int i = 42; int *pi = 0; int *pi2 = &i; int *pi3;



pi3 = pi2; pi2 = 0;



// pi被初始化，但没有指向任何对象

// pi2被初始化，存有i的地址

//如果pi3定义于块内，则pi3的值是无法确定的

// pi3和pi2指向同一个对象i //现在pi2不指向任何对象了

有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的 值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时, // pi的值被改变，现在pi指向了 ival

pi = &ival;



意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写 出如下语句，

*pi = 0;    II ival的值被改变，指针pi并没有改变

则*pi （也就是指针pi指向的那个对象）发生改变=

其他指针操作

只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件（参 见2.1.2节，第32页）遵循的规则类似，如果指针的值是0,条件取false:

int ival = 1024; int *pi = 0; int *pi2 = &ival; if (pi)

// ... if (pi2)

// ...



II pi合法，是一个空指针

II pi2是一个合法的指针，存放着ival的地址 // pi的值是0，因此条件的值是false

// pi2指向ival，因此它的值不是0,条件的值是true

任何非0指针对应的条件值都是true。

对于两个类型相同的合法指针，可以用相等操作符（==）或不相等操作符（!=）来比 较它们，比较的结果是布尔类型=如果两个指针存放的地址值相同，则它们相等；反之它 们不相等。这里两个指针存放的地址值相同（两个指针相等）有三种可能：它们都为空、 都指向同一个对象，或者都指向了同一个对象的下一地址。需要注意的是，一个指针指向 某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同 的情况，即指针相等。

因为上述操作要用到指针的值，所以不论是作为条件出现还是参与比较运算，都必须 使用合法指针，使用非法指针作为条件或进行比较都会引发不可预计的后果。

3.5.3节（第105页）将介绍更多关于指针的操作。

rsT> void* 指针

void*是一种特殊的指针类型，可用于存放任意对象的地址，一个void*指针存放着 一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象 并不了解：

double obj = 3.14, *pd = &obj;

II正确：void*能存放任意类型对象的地址

void *pv = &obj ;    // obj可以是任意类型的对象

pv = pd;    // pv可以存放任意类4!的指针

利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或 者赋给另外一个void*指针。不能直接操作void*指针所指的对象，因为我们并不知道 这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

概括说来，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间 中所存的对象，关于这点将在19.1.1节（第726页）有更详细的介绍，4.11.3节（第144 页）将讲述获取void*指针所存地址的方法。

2.3.2节练习_

练习2.18：编写代码分别更改指针的值以及指针所指对象的值。

练习2.19：说明指针和引用的主要区别。

练习2.20:请叙述下面这段代码的作用。

int i = 42; int *pl = &i;

*pl = *pl * *pl;

练习2.21:请解释下述定义。在这些定义中有非法的吗？如果有，为什么？ int i = 0;

(a) double* dp = &i;    (b) int *ip = i; (c) int *p = &i;

练习2.22:假设P是一个int型指针，请说明下述代码的含义。

if (p)    // ...

if (*p)    // ...

练习2.23:给定指针p,你能知道它是否指向了一个合法的对象吗？如果能，叙述判断 的思路；如果不能，也请说明原因。

练习2.24：在下面这段代码中为什么p合法而1P非法？

int i = 42;    void *p = &i;    long *lp = &i;

2.3.3理解复合类型的声明    ®

如前所述，变量的定义包括一个基本数据类型(base type)和一组声明符。在同一条<57H 定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一 条定义语句可能定义出不同类型的变量：

// i是一个int型的数，p是一个int型指针，r是一个int型引用 i = 1024, *p = &i, &r = i;

int

WARNING



很多程序员容易迷惑于基本数据类型和类型修饰符的关系，其实后者不过是声 明符的一部分罢了。

定义多个变量    <§

经常有一种观点会误以为，在定义语句中，类型修饰符(*或&)作用于本次定义的全 部变量。造成这种错误看法的原因有很多，其中之一是我们可以把空格写在类型修饰符和 变量名中间：

int* p;    //合法但是容易产生误导

我们说这种写法可能产生误导是因为int*放在一起好像是这条语句中所有变量共同的类 型一样。其实恰恰相反，基本数据类型是int而非int*。*仅仅是修饰了 p而已，对该 声明语句中的其他变量，它并不产生任何作用：

int* pi, p2;    // pi 是指向 int 的指针，p2 是 int

涉及指针或引用的声明，一般有两种写法。第一种把修饰符和变量标识符写在一起：

int *pl, *p2; // pi和p2都是指向int的指针

这种形式着重强调变量具有的复合类型。第二种把修饰符和类型名写在一起，并且每条语 句只定义一个变量：

int* pi;    //pi是指向int的指针

int* p2;    // p2是指向int的指针

这种形式着重强调本次声明定义了一种复合类型。

![img](C++  Primer 5-22.jpg)



上述两种定义指针或引用的不同方法没有孰对孰错之分，关键是选择并坚持其 中的一种写法，不要总是变来变去。

本书采用第一种写法，将* （或是&）与变量名连在一起。

指向指针的指针

一般来说，声明符中修饰符的个数并没有限制。当有多个修饰符连写在一起时，按照 □£＞其逻辑关系详加解释即可。以指针为例，指针是内存中的对象，像其他对象一样也有自己

的地址，因此允许把指针的地址再存放到另一个指针当中。

通过*的个数可以区分指针的级别。也就是说，**表示指向指针的指针，***表示指 向指针的指针的指针，以此类推：

int ival = 1024;

int *pi = &ival; //pi 指向一个 int 型的数 int **ppi = &pi; // ppi才旨向一个int型的才旨4十

此处pi是指向int型数的指针，而ppi是指向int型指针的指针，下图描述了它们之 间的关系。

ppi pi    ival

——4 —1——4    1024

解引用int型指针会得到一个int型的数，同样，解引用指向指针的指针会得到一 个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用：

cout << «

«

«

«



"The value of ival\n"

"direct value: " « ival « "\n" "indirect value: " « *pi << ”\n" "doubly indirect value: " << **ppi endl;

该程序使用三种不同的方式输出了变量ival的值：第一种直接输出；第二种通过int型 指针pi输出；第三种两次解引用ppi,取得ival的值。

指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对 指针的引用：

int i = 42; int *p; int *&r = p;



=&i; r = 0;



// p是一个int型指针 // r是一个对指针p的引用

r引用了 一个指针，因此给r賦值&i就是令p指向i 解引用r得到i，也就是p指向的对象，将i的值改为0

要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符 号(此例中是&r的符号S)对变量的类型有最直接的影响，因此r是一个引用。声明符的 其余部分用以确定r引用的类型是什么，此例中的符号★说明r引用的是一个指针。最后, 声明的基本数据类型部分指出r引用的是一个int指针。

![img](C++  Primer 5-23.jpg)



面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它 的真实含义。

###### 2.3.3节结;习

<593



练习2.25：说明下列变量的类型和值。

(a) int* ip, i, &r = i; (b) int i, *ip = 0; (c) int* ip, ip2;

###### 2.4 const限定符

有时我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲 区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。 另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关 键字const对变量的类型加以限定：

const int bufSize = 512;    // 输入缓冲区大小

这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误：

bufSize = 512;    //错误：试图向const对象写值

因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。一如既往， 初始值可以是任意复杂的表达式：

const int i = get_size () ;    //正确：运行时初始化

const int j = 42;    //正确：编译时初始化

const int k;    //错误：k是一个未经初始化的常量

初始化和const

正如之前反复提到的，对象的类型决定了其上的操作。与非const类型所能参与的 操作相比，const类型的对象能完成其中大部分，但也不是所有的操作都适合。主要的限 制就是只能在const类型的对象上执行不改变其内容的操作。例如，const int和普通 的int—样都能参与算术运算，也都能转换成一个布尔值，等等。

在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外 一个对象，则它们是不是const都无关紧要：

int i = 42/

const int ci = i;    //正确：i的值被拷贝给了 ci

int j = ci;    //正确：ci的值被拷贝给了 j

尽管ci是整型常量，但无论如何ci中的值还是一个整型数。ci的常量特征仅仅在执行 改变ci的操作时才会发挥作用。当用ci去初始化j时，根本无须在意ci是不是一个常 量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关 系了。

Ejo>默认状态下，const对象仅在文件内有效

当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样： const int bufSize = 512; // 输入缓冲区大小

编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到 代码中所有用到bufSize的地方，然后用512替换。

为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个 用了 const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每 一个用到变量的文件中都有对它的定义(参见2.2.2节，第41页)。为了支持这一用法， 同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当 多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必 要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反， 我们想让这类const对象像其他(非常量)对象一样工作，也就是说，只在一个文件中 定义const，而在其他多个文件中声明并使用它。

解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样 只需定义一次就可以了：

// file_l.cc定义并初始化了一个常量，该常量能被其他文件访问 extern const int bufSize = fcn ();

// file_l.h 头文件

extern const int bufSize; // 与 file_l. cc 中定义的 bufSize 是同一个

如上述程序所示，file_l.cc定义并初始化了 bufSize。因为这条语句包含了初始值， 所以它(显然)是一次£义=然而，因为bufSize是一个常量，必须用extern加以限 定使其被其他文件使用。

file_l .h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本 文件所独i，它的定义将在别处出现。

i

![img](C++  Primer 5-24.jpg)



如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern 关键字。

###### 2.4节练习

练习2.26：下面哪些句子是合法的？如果有不合法的句子，请说明为什么？

(a) const int buf;    (b) int cnt = 0;

(c) const int sz = cnt;    (d)++cnt; ++sz;

啦2.4.1 const的引用

CK>    可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量

的引用(reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它所绑 定的对象：

const int ci = 1024;

const int &r 1 = ci; //正确：引用及其对应的对象都是常量

rl = 42;    //错误：rl是对常量的引用

int &r2 = ci;    II错谡：试图让一个非常量引用指向一个常量对象

因为不允许直接为ci赋值，当然也就不能通过引用去改变ci，因此，对r2的初始化是 错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确的。

术语：常fl引川足对const的引用

C#程序员们经常把词组"对const的引用”筒称为“常量引用”，这一简称还是挺 靠谱的，不过前提是你得时刻记得这就是个简称而已。

严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身 恒定不变。事实上，由于C#语言并不允许随意改变引用所绑定的对象，所以从这层意 义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与 的操作，却无论如何都不会影响到引用和对象的绑定关系本身。

初始化和对const的引用

2.3.1节（第46页）提到，引用的类型必须与其所引用对象的类型一致，但是有两个 例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表 达式的结果能转换成（参见2.1.2节，第32页）引用的类型即可。尤其，允许为一个常量 引用绑定非常量的对象、字面值，甚至是个一般表达式：

int i = 42;-

| const     | int  | &rl  | =i；     | //   |
| --------- | ---- | ---- | -------- | ---- |
| const     | int  | &r2  | =42;     | //   |
| const     | int  | &r3  | =rl * 2; | //   |
| int &r4 = | rl   | 2;   | //       |      |



允许将const int&绑定到一个普通int对象上

正确：rl是一个常量引用

正确：r3是一个常量引用

错误：是一个普通的非常量引用

要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外•种 类型上时到底发生了什么：

double dval = 3.14; const int &ri = dval;

此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精 度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下 形式：

const int temp = dval; //由双精度浮点数生成一个临时的整型常量 const int &ri = temp; //让ri绑定这个临时量

<62~|



在这种情况下，ri绑定了一个临时量（temporary）对象。所谓临时量对象就是当编译器 需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常 常把临时量对象简称为临时量。

接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的 后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意， 此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval,就肯定想通过 ri改变dval的值，否则干什么要给ri赋值呢？如此看来，既然大家基本上不会想着把 引用綁定到临时量上，C++语言也就把这种行为归为非法。

对const的引用可能引用一个并非const的对象

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不 是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

int i = 42;

int &rl = i;    //引用ri辨定对象i

const int &r2 = i;    // r2也绑定对象i，但是不允许通过r2修改i的值

rl = 0;    // rl并非常量，i的值修改为0

r2 = 0;    //错误：r2是一个常量引用

is2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此, i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像rl 一样绑定到 i的其他引用来修改。

###### 沿2.4.2指针和const

与引用一样，也可以令指针指向常量或非常量。类似于常量引用（参见2.4.1节，第 54页），指向常量的指针（pointer to const）不能用于改变其所指对象的值。要想存放常量 对象的地址，只能使用指向常量的指针：

const double pi = 3.14; double *ptr = &pi; const double *cptr = &pi; *cptr = 42;



// pi是个常量，它的值不能改变 //错误：ptr是一个普通指针 //正确：cptr可以指向一个双精度常量 //错误：不能给*cptr赋值

2.3.2节（第47页）提到，指针的类型必须与其所指对象的类型一致，但是有两个例 夕卜。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：

double dval = 3.14;    // dval是一个双精度浮点数，它的值可以改变

cptr = &dval;    //正确：但是不能通过cptr改变dval的值

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指 向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过 其他途径改变。

![img](C++  Primer 5-25.jpg)



试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是” 罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。

const指针

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常 量指针（constpointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针 中的那个地址）就不能再改变了。把*放在const关键字之前用以说明指针是一个常量， 这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：

int errNumb = 0;

int *const curErr = SerrNumb; // curErr 将一直指向 errNumb const double pi = 3.14159;

const double *const pip = &pi; // pip是一个指向常量对象的常量指针

如同2.3.3节（第52页）所讲的，要想弄清楚这些声明的含义最行之有效的办法是从右向 左阅读。此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对 象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*,意思是curErr

是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个 int对象。与之相似，我们也能推断出，pip是一个常量指针，它指向的对象是一个双精 度浮点型常量。

指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全 依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的 对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一4'一般的 非常量整数，那么就完全可以用curErr去修改errNumb的值：

*pip = 2.72;    //错误：pip是一个指向常量的指针

//如果curErr所指的对象(也就是errNumb )的值不为0

if (*curErr) {

errorHandler();

\* curErr = 0;    //正确：把curErr所指的对象的值重置

###### 2.4.2节练习

练习2.27:下面的哪些初始化是合法的？请说明原因。

(a) int i = -1, &r = 0;    (b)    int *const p2 = &i2;

(c) const int i = -1, &r = 0;    (d)    const int * const p3 = &i2;

(e) const int *pl = &i2;    (f)    const int &const r2;

(g) const int i2 = i, &r = i;

练习2.28:说明下面的这些定义是什么意思，挑出其中不合法的。

(a) int i, *const cp;    (b) int *pl, *const p2;

(c) const int ic, &r = ic; (d) const int * const p3;

(e) const int *p;

练习2.29:假设己有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说 明原因。

(a) i = ic;

Il I- -I 1 3 C p p .1 b)(d)(o



![img](C++  Primer 5-26.jpg)



(c) pi = &ic;

& r



(e)p2 = Pl；

###### 2.4.3 顶层 const    粗

如前所述，指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不 是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const (top-level const)表示指针本身是个常量，而用名词底层const (low-level const)表示指 针所指的对象是一个常量。

更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，

如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。

比较特殊的是，指针类型既可以是顶层const也可以是底层const,这一点和其他类型 相比区别明显：

int i = 0;

int *const pi = &i; const int ci = 42; const int *p2 = &ci;



//不能改变pi的值， //不能改变ci的值， //允许改变p2的值，



这是一个项层const 这是一个顶层const 这是一个底层const



const int *const p3 = p2; // 靠右的 const 是顶层 const，靠左的是底层 const const int &r = ci;    //用于声明弓1用的const都是底层const

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶 层const不受什么影响：

i = ci;    //正确：拷贝ci的值，ci是一个顶层const，对此操作无影响

p2 = p3;    //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响

执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么 影响。

另一方面，底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出 的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般

来说，非常量可以转换成常量，反之则不行:

| l~65?> | int *p =  | P3;       | //错误 |
| ------ | --------- | --------- | ------ |
|        | p2 = p3;  |           | //正确 |
|        | p2 = &i;  |           | //正确 |
|        | int &r =  | ci;       | //错误 |
|        | const int | :&r2 = i; | //正确 |



p3包含底层const的定义，而p没有 p2和p3都是底层const int*能转换成 const int*

普通的int&不能绑定到int常量上 const int&可以绑定到一个普通int上



p3既是顶层const也是底层const,拷贝p3时可以不在乎它是一个顶层const,但是 必须清楚它指向的对象得是一个常量。因此，不能用P3去初始化p,因为p指向的是一 个普通的（非常量）整数。另一方面，p3的值可以赋给p2,是因为这两个指针都是底层 const,尽管p3同时也是一个常量指针（顶层const）,仅就这次赋值而言不会有什么 影响。

###### 2.4.3节练习

练习2.30:对于下面的这些语句，请说明对象被声明成了顶层const还是底层const?

const int v2 = 0;    int vl = v2;

int *pl = &vl, &rl = vl;

const int *p2 = &v2, *const p3 = &i, &r2 = v2;

练习2.31:假设已有上一个练习中所做的那些声明，则下面的哪些语句是合法的？请说 明顶层const和底层const在每个例子中有何体现。 rl = v2;

pi = p2; p2 = pi； pi = p3; p2 = p3;

###### 緣2.4.4 constexpr和常量表达式

常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的 表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表 达式。后面将会提到，C++语言中有几种情况下是要用到常量表达式的。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：

const int max_files = 20;    // max_files 是常量表达式

const int limit = max_files + 1;    // limit 是常量表达式

int staff size = 27;    // staff size 不是常量表达式

const int sz = get_size（）;    // sz 不是常量表达式

尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而 非const fnt,所以它不属于常量表达式。另一方面，尽管sz本身是一个常量，但它 的具体值直到运行时才能获取到，所以也不是常量表达式。

constexpr 变量

在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。 当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实 际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种 情况下，对象的定义和使用根本就是两回事儿。

C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的 值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量' 表达式初始化：

| constexpr int mf = 20;    // |      |                 |      |
| ---------------------------- | ---- | --------------- | ---- |
| constexpr                    | int  | limit = mf + 1; | //   |
| constexpr                    | int  | sz = size ();   | //// |



20是常量表达式

mf + 1是常量表达式

只有当size是一个constexpr函数时 才是一条正确的声明语句



尽管不能使用普通函数作为constexpr变量的初始值，但是正如6.5.2节（第214页） 将要介绍的，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使 得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。

Best



一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr 类型

字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必 须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字 面值类型”（literal type）。

到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义 类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成 constexpr。其他一些字面值类型将在7.5.6节（第267页）和19.3节（第736页）介绍。

尽管指针和引用都能定义成constexpr,但它们的初始值却受到严格限制。一个 constexpr指针的初始值必须是nullptr或者0,或者是存储于某个固定地址中的对象。

6.1 + 1节（第184页）将要提到，函数体内定义的变量一般来说并非存放在固定地址中， 因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地 址固定不变，能用来初始化constexpr指针。同样是在6.1 + 1节（第185页）中还将提 到，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变 量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指 针也能指向这样的变量。

指针和 constexpr

必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅

对指针有效，与指针所指的对象无关，

const int *p = nullptr;    // p是一个指向整型常量的指针

constexpr int *q = nullptr; // q是一个指向整数的常量指针

p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在 于constexpr把它所定义的对象置为了顶层const (参见2.4.3节，第57页)。

与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量

constexpr int *np = nullptr; int j = 0;

constexpr int i = 42;

// i和j都必须定义在函数体之外 constexpr const int *p = &i; constexpr int *pl = &j;



// np是一个指向整数的常量指针，其值为空



// i的类型是整型常量



// p是常量指针，指向整型常量i // pi是常量指针，指向整数j



###### 2.4.4节练习

练习2.32:下面的代码是否合法？如果非法，请设法将其修改正确。 int null =0, *p = null;

##### 2.5处理类型

随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两个方面。 一是一些类型难于“拼写”，它们的名字既难记又容易写错，还无法明确体现其真实目的 和含义。二是有时候根本搞不清到底需要的类型是什么，程序员不得不回过头去从程序的 上下文中寻求帮助。

###### 2.5.1类型别名

类型别名(type alias)是一个名字，它是某种类型的同义词。使用类型别名有很多好 处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使 用该类型的真实目的。

有两种方法可用于定义类型别名。传统的方法是使用关键字typedef： typedef double wages; //wages 是 double 的同义词

typedef wages base, *p; //base 是 double 的同义词，p 是 double*的同义词

其中，关键字typedef作为声明语句中的基本数据类型(参见2.3节，第45页)的一部 分出现。含有typedef的声明语句定义的不再是变量而是类型别名。和以前的声明语句

® 一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。

新标准规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名： using SI = Sales_item; // SI 是 Sales_item 的同义词

这种方法用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号 左侧的名字规定成等号右侧类型的别名。

类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名: wages hourly, weekly;    // 等价于 double hourly、weekly;

SI item;    // 等价于 Sales_item item

指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想 不到的后果。例如下面的声明语句用到了类型pstring,它实际上是类型char*的别名：

typedef char *pstring;

const pstring cstr = 0;    // cstr 是指向 char 的常量指针

const pstring *ps;    // ps是一个指针，它的对象是指向char的常量指针

上述两条声明语句的基本数据类型都是const pstring,和过去一样，const是对给定 类型的修饰。pstring实际上是指向char的指针，因此，const pstring就是指向 char的常量指针，而非指向常量字符的指针。

遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它 本来的样子，以理解该语句的含义：

const char *cstr = 0;    // 是对 const pstring cstr 的错误理解

再强调一遍：这种理解是错误的。声明语句中用到pstring时，其基本数据类型是指针。

可是用char*重写了声明语句后，数据类型就变成了 char, *成为了声明符的一部分。

这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者 声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。



###### 2.5.2 auto类型说明符

编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达 式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，

C++11新标准引入了 auto类型说明符，用它就能让编译器替我们去分析表达式所属的类 型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通＜691 过初始值来推算变量的类型，显然，auto定义的变量必须有初始值：

//由vail和val2相加的结果可以推断出item的类型

auto item = vail + val2; // item 初始化为 vail 和 val2 相加的结果

此处编译器将根据vail和val2相加的结果来推断item的类型。如果vail和val2 是类Sales_item （参见1.5节，第17页）的对象，则item的类型就是Sales_item: 如果这两个变量的类型是double,贝G item的类型就是double,以此类推。

使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据 类型，所以该语句中所有变量的初始基本数据类型都必须一样：

auto i = ◦, *p = &i;    //正确：i是整数、p是整型指针

auto sz = 0, pi = 3.14;    // 错误：sz 和 pi 的类型不一致

复合类型、常量和auto

编译器推断出來的auto类型有时候和初始值的类型并不完全一样，编译器会适当地 改变结果类型使其更符合初始化规则。

首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初 始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto 的类型：

int i = 0, &r = i;

auto a = r;    // a是一个整教（r是i的别名，而i是一个整数）

其次，auto—般会忽略掉顶层const （参见2.4.3节，第57页），同时底层const则会 保留下来，比如当初始值是一个指向常量的指针时，

const int ci = i, &cr = ci;

auto b = ci; // b是一个整数（ci的顶层const特性被忽略掉了）

auto c = cr; // c是一个整数（cr是ci的别名，ci本身是一个顶层const ）

auto d = &i;    //d是一个整型指针（整数的地址就是指向整数的指针）

auto e = &ci; // e是一个指向整数常量的指针（对常量对象取地址是一种底层const ）

如果希望推断出的auto类型是一个顶层const,需要明确指出：

const auto f = ci;    // ci 的推演类型是 int, f 是 const int

还可以将引用的类型设为auto,此时原来的初始化规则仍然适用：

auto &g = ci;    // g是一个整型常量引用，绑定到ci

auto &h = 42;    //错误：不能为非常量引用绑定字面值

const auto &j = 42;    //正确：可以为常量引用绑定字面值

S＞设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果 我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。

要在一条语句中定义多个变量，切记，符号&和*只从属于某个声明符，而非基本数据 类型的一部分，因此初始值必须是同一种类型：

auto k = ci, &1 = i;    / / k是整数，1是整型引用

auto &m = ci, *p = &ci; // m是对整型常量的引用，p是指向整型常量的指针 //错误：i的类型是int而&ci的类型是const int auto &n = i, *p2 = &ci;

###### 2.5.2节练习

练习2.33:利用本节定义的变量，判断下列语句的运行结果。

a = 42; b = 42; c = 42; d = 42; e = 42; g = 42;

练习2.34:基于上一个练习中的变量和语句编写一段程序，输出赋值前后变量的内容, 你刚才的推断正确吗？如果不对，请反复研读本节的示例直到你明白错在何处为止。 练习2.35:判断下列定义推断出的类型是什么，然后编写程序进行验证。 const int i = 42;

auto j = i; const auto &k = i; auto *p = &i; const auto j2 = i, &k2 = i;

啦2.5.3 decltype类型指示符

有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，似是不想用 岡该表达式的值初始化变量，为了满足这一要求，c++n新标准引入了第二种类型说明符 decltype,它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式

并得到它的类型，却不实际计算表达式的值：

decltype(f()) sum



x;



// sum的类型就是函数f的返回类型



编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型，换 句话说，编译器为sum指定的类型是什么呢？就是假如f被调用的话将会返回的那个类 型。

decltype处理顶层const和引用的方式与auto有些许不同=如果decltype使 用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)：＜!□

const int ci = 0, &cj = ci;

decltype (ci) x = 0;    // x 的类型是 const int

decltype (cj) y = x;    // y 的类型是 const int&, y 绑定到变量 x

decltype (cj ) z;    //错误：z是一个引用，必须初始化

因为cj是一个引用，decltype (cj)的结果就是引用类型，因此作为引用的z必须被初 始化=

需要指出的是，引用从來都作为其所指对象的同义词出现，只有用在decltype处 是一个例外。

decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的 类型。如4.1.1节(第120页)将要介绍的，有些表达式将向decltype返回一个引用类 型。一般來说当这种情况发生吋，意味着该表达式的结果对象能作为一条赋值语句的左值：

// decltype的结果可以是引用类型 int i = 42, *p = &i, &r = i;

decltype (r + 0) b; //正确：加法的结果是int，因此b是一个(未初始化的)int decltype (*p) c;    //错误：c是int&,必须初始化

因为r是一个引用，因此decltype (r)的结果是引用类型。如果想让结果类型是r所指 的类型，可以把r作为表达式的一部分，如r+0,显然这个表达式的结果将是一个具体值 而非一个引用。

另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。正如 我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因 此，decltype (*p＞的结果类型就是int&，而非int。

decltype和auto的另一处重要区别是，decltype的结果类型与表达式形式密切@ 相关。有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上 了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一•个不加 括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译 器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这 样的decltype就会得到引用类型：

// decltype的表达式如果是加上了括号的变量，结果将是引用 decltype ( (i) ) d;    // 错误：d 是 intS.，必须初始化

decltype (i) e;    //正确：e是一个(未初始化的)int

/a 切记：decltype ( (variable))(注意是双层括号)的结果永远是引用，而 / ! \ decltype (variaWe)结果只有当variaide本身就是一个引用时才是

WARNING 引用。

![img](C++  Primer 5-28.jpg)



###### 2.5.3节练习

练习2.36:关于下面的代码，请指出每一个变量的类型以及程序结束时它们各自的值。

int a = 3, b = 4; decltype(a) c = a; decltype((b)) d = a;

++c;

++d;

练习2.37：赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是 说，如果i是int,则表达式i=x的类型是int&。根据这一特点，请指出下面的代码 中每一个变量的类型和值。

int a = 3, b = 4; decltype(a) c = a; decltype(a = b) d = a;

练习2.38：说明由decltype指定类型和由auto指定类型有何区别。请举出一个例 子，decltype指定的类型与auto指定的类型一样；再举一个例子，decltype指定 的类型与auto指定的类型不一样。

##### 6 2.6自定义数椐结构

从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策 略和方法。举一个例子，我们的Sales_item类把书本的ISBN编号、售出量及销售收 入等数据组织在了一起，并且提供诸如isbn函数、＞＞、＜＜、+、+=等运算在内的一系列 操作，Sales_item类就是一个数据结构。

C++语言允许用户以类的形式自定义数据类型，而库类型string、istream、 ostream等也都是以类的形式定义的，就像第1章的Sales_item类型一样。C++语言 对类的支持甚多，事实上本书的第III部分和第IV部分都将大篇幅地介绍与类有关的知识。 尽管Sales_item类非常简单，但是要想给出它的完整定义可在第14章介绍自定义运算 符之后。

齡 2.6.1定义Sales_data类型

尽管我们还写不出完整的Sales_item类，但是可以尝试着把那些数据元素组织到 一起形成一个简单点儿的类。初步的法是用户能直接访问其中的数据元素，也能实现一 些基本的操作。

既然我们筹划的这个数据结构不带有任何运算功能，不妨把它命名为Sales_data 以示与Sales_item的区别。Sales_data初步定义如下：

| 73 ＞    struct Sales_data {

std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;

}；

我们的类以关键字struct开始，紧跟着类名和类体(其中类体部分可以为空)。类体由

花括号包围形成了一个新的作用域（参见2.2.4节，第43页）。类内部定义的名字必须唯 一，但是可以与类外部定义的名字重复。

类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名 以示对该类型对象的定义，所以分号必不可少，

struct Sales_data { /* ... */ } accum, trans, *salesptr;

//与上一条语等价，但可能更好一些 struct Sales_data { /* ... */ };

Sales_data accum, trans, *salesptr;

分号表示声明符（通常为空）的结束。一般来说，最好不要把对象的定义和类的定义放在 一起。这么做无异于把两种不同实体的定义混在了一条语句里，一会儿定义类，一会儿又 定义变量，显然这是一种不被建议的行为。

/l\很多新手程序员经常忘了在类定义的最后加上分号.

WARNING

类数据成员

类体定义类的成员，我们的类只有数据成员（data member）o类的数据成员定义了类 的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不 会影响其他Sales_data的对象。

定义数据成员的方法和定义普通变量一样：首先说明一个基本类型，随后紧跟一个或 多个声明符。我们的类有3个数据成员：一个名为bookNo的string成员、一•个名为 units_sold的unsigned成员和一个名为revenue的double成员。每个 Sales_data的对象都将包括这3个数据成员。

C++11新标准规定，可以为数据成员提供一个类内初始值（in-class initializer）。创建丨c:,j 对象时，类PJ初始值将用于初始化数据成员。没有初始值的成员将被默认初始化（参见2.2.1 节，第40页）。因此当定义Sales_data的对象时，units_sold和revenue都将初 始化为0, bookNo将初始化为空字符串。

对类内初始值的限制与之前（参见2.2.1节，第39页）介绍的类似：或者放在花括号 里，或者放在等号右边，记住不能使用圆括号。

7.2节（第240页）将要介绍，用户可以使用C++语言提供的另外一个关键字class 来定义自己的数据结构，到时也将说明现在我们使用struct的原因。在第7章学习与 class有关的知识之前，建议读者继续使用struct定义自己的数据类型。

###### 2.6.1节练习

<~74~]



练习2.39：编译下面的程序观察其运行结果，注意，如果忘记写类定义体后面的分号会 发生什么情况？记录下相关信息，以后可能会有用。

struct Foo { /*此处为空*/ } //注意：没有分号 int main（）

{

return 0;

}

练习2.40:根据自己的理解写出Sales data类，最好与书中的例子有所区别。

###### 啦 2.6.2 使用 Sales_data 类

和Sales_item类不同的是，我们自定义的Sales_data类没有提供任何操作， Sales_clata    的使用者如果想执行什么操作就必须自己动手实现。例如，我们将参照

1.5.2节（第20页）的例子写一段程序实现求两次交易相加结果的功能。程序的输入是下 面这两条交易记录：

0-201-78345-X 3 20.00

0-201-78345-X 2 25.00

每笔交易记录着图书的ISBN编号、售出数量和售出单价。

添加两个Sales_data对象

因为Sales_data类没有提供任何操作，所以我们必须自己编码实现输入、输出和 相加的功能。假设已知Sales_data类定义于Sales_data. h文件内，2.6.3节（第67 页）将详细介绍定义头文件的法。

因为程序比较长，所以接下来分成几部分介绍。总的来说，程序的结构如下：

\#include ciostream〉

\#include <string>

\#include "Sales—data.h" int main（）

{

Sales_data datal, data2;

//读入datal和data2的代码

//检查datal和data2的ISBN是否相同的代码

//如果相同，求datal和data2的总和

}

和原来的程序一样，先把所需的头文件包含进来并且定义变量用于接受输入。和 Sales_item类不同的是，新程序还包含了 string头文件，因为我们的代码中将用到 string类型的成员愛量bookNoo

Sales_data对象读入数据

第3章和第10章将详细介绍string类型的细节，在此之前，我们先了解一点儿关 于string的知识以便定义和使用我们的ISBN成员。string类型其实就是字符的序列， 它的操作有>>、<<和==等，功能分别是读入字符串、写出字符串和比较字符串。这样我 们就能书写代码读入第一笔交易了：

double price = 0; //书的单价，用于计算销售收入

//读入第1笔交易：ISBN、销售数量、单价

std::cin » datal.bookNo » datal.units_sold » price;

//计算销售收入

datal.revenue = datal.units_sold * price;

交易信息记录的是书售出的单价，而数据结构存储的是一次交易的销售收入，因此需要将 单价读入到double变量price,然后再计算销售收入revenue。输入语句

std::cin >> datal.bookNo » datal.units_sold >> price;

使用点操作符（参见1.5.2节，第20页）读入对象datal的bookNo成员和units_sold成员。

最JrT一■条语句把datal. units sold和price的乘积赋值给datal的revenue成员。

接下来程序重复上述过程读入对象data2的数据：

//读入第2笔交易

std::cin » data2.bookNo » data2.units_sold » price; data2.revenue = data2.units_sold * price;

输出两个Sales_data对象的和

剩下的工作就是检查两笔交易涉及的工sbn编号是否相同了。如果相同输出它们的和，

否则输出一条报错信息：

if （datai.bookNo == data2.bookNo） {

unsigned totalCnt = datal.units_sold + data2.units_sold; double totalRevenue = datal.revenue + data2.revenue;

//输出：ISBN、总销售量、总销售额、平均价格

std::cout « datal.bookNo « ” " « totalCnt « " " « totalRevenue « "";

if （totalCnt != 0）

std::cout << totalRevenue/totalCnt « std::endl; else

std::cout « "（no sales）" « std::endl; return 0;    //标示成功

} else {    //两笔交易的工SBN不一^羊

std::cerr << "Data must refer to the same ISBN"

<< std::endl;

return -1;    //标示失败

}

在第-个if语句中比较了 datal和data2的bookNo成员是否相同。如果相同则执行<76 I 第一个if语句花括号内的操作，首先计算unitS_Sold的和并赋给变量totalCnt,然 后计算revenue的和并赋给变量totalRevenue,输出这些值。接下来检查是否确实售 出了书籍，如果是，计算并输出每本书的平均价格；如果售量为零，输出一条相应的信息。

###### 2.6.2节练习

练习2.41:使用你自己的Sales_data类重写1.5.1节（第20页）、1.5.2节（第21页） 和1.6节（第22页）的练习。眼下先把Sales_data类的定义和main函数放在同一 个文件里。

###### 2.6.3编写自己的头文件

尽管如19.7节（第754页）所讲可以在函数体内定义类，但是这样的类毕竟受到了一 些限制。所以，类一般都不定义在函数体内。当在函数体外部定义类时，在各个指定的源 文件中可能只有一处该类的定义。而且，如果要在不同文件中使用同一个类，类的定义就 必须保持一致。

为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的 名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。又如， 我们应该把Sales_data类定义在名为Sales_data.h的头文件中。

头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量（参 见2.4节，第54页）等。头文件也经常用到其他头文件的功能。例如，我们的SaleS_data 类包含有一个string成员，所以Sales_data.h必须包含string.h头文件。同时， 使用Sales_data类的程序为了能操作bookNo成员需要再一次包含string.h头文件。

这样，事实上使用Sales_data类的程序就先后两次包含了 string.h头文件：一次是 直接包含的，另有一次是i着包含SaleS_data.h被隐式地包含进来的。有必要在书写 头文件时做适当处理，使其遇到多次包含情况也能安全和正常地工作。

![img](C++  Primer 5-29.jpg)



头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明

预处理器概述

确保头文件多次包含仍能安全工作的常用技术赶预处理器(preprocessor),它由C++ [JL＞语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所 写的程序。之前已经用到了一项预处理功能itinclude,当预处理器看标记

时就会用指定的头文件的内容代替#include。

C++程序还会用到的一项预处理功能是头文件保护符(header guard),头文件保护符 依赖于预处理变量(参见2.3.2节，第48页X预处理变量有两种状态：已定义和未定义。 #define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处 理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未 定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。

使用这些功能就能有效地防止重复包含的发生：

\#ifndef SA1ES_DATA_H ♦define SALES一DATA一H #include <string> struct Sales_data {

std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;

}；

\#endif

第一次包含Sales_data.h时，#ifndef的检查结果为真，预处理器将顺序执行后面的 操作直至遇到#endif为止。此时，预处理变量SALES_DATA_H的值将变为已定义，而 且Sales_data.h也会被拷贝到我们的程序中来。后面如果再一次包含Sales_data.h，

的检查结果将为假，编译器将忽略#ifndef之间的部分。

/!\预处理变量无视C++语言中关于作用域的规则.

WARNING

整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类 的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲 突，一般把预处理变量的名字全部大写。

头文件即使(目前还〉没有被包含在任何其他头文件中，也应该设置保护符：

Beet

■Proa^    头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的

程序到底需不需要。

###### 2.6.3节练习

练习2.42:根据你自己的理解重写一个Sales_data.h头文件，并以此为基础重做 2.6.2节(第67页)的练习。

小结    <WI

类型是C++编程的基础。

类型规定了其对象的存储要求和所能执行的操作，C+ +语言提供了一套基础内置类 型，如int和char等，这些类型与实现它们的机器硬件密切相关。类型分为非常量和常 量，一个常量对象必须初始化，而且一旦初始化其值就不能再改变=此外，还可以定义复 合类型，如指针和引用等。复合类型的定义以其他类型为基础。

C++语言允许用户以类的形式自定义类型。C++库通过类提供了~套高级抽象类型，

如输入输出和string等。

##### 术语表

地址(address)是一个数字，根据它可以 找到内存中的一个字节。

别名声明(alias declaration)为另外一种

类型定义--个同义词：使用“名字=类型” 的格式将名字作为该类型的同义词。

算术类型(arithmetic type)布尔值、字

符、整数、浮点数等内置类型。

数组(array)是一种数据结构，存放着一 组未命名的对象，可以通过索弓I来访问这 些对象。3.5节将详细介绍数组的知识，

auto是一个类型说明符，通过变量的初始 值来推断变量的类型。

基本类型(basetype)是类型说明符，可

用const修饰，在声明语句中位于声明符 之前。基本类型提供了最常见的数据类型， 以此为基础构建声明符。

綁定(bind)令某个名字与给定的实体关 联在一起，使用该名字也就是使用该实体。 例如，引用就是将某个名字与某个对象绑 定在一起。

字节(byte)内存中可寻址的最小单元， 大多数机器的字节占8位。

类成员(class member)类的组成部分。

复合类型(compound type)是一种类型，

它的定义以其他类型为基础。

const是一种类型修饰符，用于说明永不改 变的对象。const对象一旦定义就无法再 为。由类本身负责执行的类对象的初始化 行为。+局作用域的内置类型对象初始化 为0:局部作用域的对象未被初始化即拥 冇未定义的值。

赋新值，所以必须初始化。

常量指针(const pointer)是一种指针，它

的值永不改变。

常量引用(const reference)是一种习惯

叫法，含义是指向常量的引用。

常量表达式(const expression)能在编译

时计算并获取结果的表达式。

constexpr是一种函数，用于代表一条常量 表达式。6.5.2节(第214页)将介绍 constexpr 函数-

转换(conversion) —种类型的值转变成

另外一种类型值的过程。C+ +语言支持内 置类型之间的转换。

数据成员(data member)组成对象的数

据元素，类的每个对象都有类的数据成员 的一份拷贝。数据成员可以在类内部声明 的同时初始化。

声明(declaration)声称存在一个变量、<79 I

函数或是别处定义的类型。名字必须在定 义或声明之后才能使用，

声明符(declarator)是声明的一部分，包

括被定义的名字和类型修饰符，其中类型 修饰符可以有也可以没有。

decltype是一个类型说明符，从变量或表 达式推断得到类型。    .

默认初始化(defaultinitialization)当对象

未被显式地赋予初始值时执行的初始化行



定义(definition)为某一特定类型的变ft 中清存储空间，可以选择初始化该变量。

名字必须在定义或声明之后才能使用，

转义序列(escape sequence)字符特别

是那些不可打印？■•符的詩代形式=转义以 反斜线开头，后闹紧跟 '个字符，或者不 多丁• 3个八进制数字，或者字母x加上1 个h六进制数。

全局作用域(global scope)位丁•其他所有

作用域之外的作用域。

头文件保护符(header guard)使用预处

理变S以防止头文件被某个文件重复包 含。

标识符(identifier)组成名字的字符序列， 标识符对人小写敏感，

类内初始值(in-class initializer)在声明类

的数裾成员时M时提供的初始值，必须置 丁'等U•右侧或花括号内。

在作用域内(in scope)名字在当前作用域 内可见。

被初始化(initialized)变量在定义的同吋

被赋予初始值，变量-•般都应该被初始化。

内层作用域(inner scope)嵌套在其他作 引用(reference) H对¥的力G名’ 用域2•内的作用域。    对常量的引用(reference to const) jv -



整型(integral type)参见算术翁型.。

列表初始化(listinitialization)利用花括号

把一个或多个初始值放在-起的初始化形 式。

字面值(literal)是一个不能改变的值，如 数字、字符、字符串等。单引吁内的是字 符字叫值，双引号内的是字符申字面值。

局部作用域(local scope)是块作用域的

\>J惯叫法。

底层 const (low-level const) 一个不属 T

顶®的const,类型如果由底足常量定义， 则不能被忽略。

成员(member)类的组成部分。

不可打印字符(nonprintable character)

不具有町见形式的字符,如拘制符、退格、 换行符等。

空指针(null pointer)值为0的指针，窄

指针合法佴是不指向任何对象。

nullptr是表示窄指针的•字曲值常S。

对象(object)是内存的-块区域，具有某 种类甩，变量是命名了的对象。

外层作用域(outer scope)嵌登着别的作

用域的作用域，

指针(pointer)是•个对象，存放着某个 对象的地址，或省•某个对象存储区域之后 的卜'••-•地址，或者0.

指向常量的指针(pointer to const)-足

个指针，存放着某个常曼对象的地址。指 向常S:的指针不能用來改变它所指对象的 值。

预处理器(preprocessor)在C++編泽过

程中执行的-段程序。

预处理变量(preprocessor variable)由预

处理器管理的变在程序编译之前，预 处理器负责将程序中的顶处现变量锊换成 它的寊.实值。

个引用，不能用来改变它所绑定对象的值。 对常量的引用可以绑定常羅:对象，或者非 常S对象，或者表达式的结果，

作用域(scope)足样伴的•_部分，在其中 某鸣名字有意义。C++有儿级作用域：

全局(global)-乾字定义在所有其他作

用域之外。

类(class)-名字定义在类内部。

命名空间(namespace)-名字定义在

命名空间内部。

块(block)-名字定义在块内部。

名字从声叫位置开始d［至A叫语句所在的 作IH域未端为il:都是"T川的。

分离式编译(separate compilation)把程

序分割为多个中独文件的能力。

带符号类型(signed )保ft il数、货数或0 的整型。

字符串(string)    •种痄类喂.彻河变

氏字符序列。

struct足-个又键川Tiii义类。

临时值(.temporary)编汴器农达乂

結果时创建的尤朽对象。为浓农达式创建 f -个临时值，则此临时俏将，勝在ft 到包穴相:该表达式的域人的茨达式计算完 成为ll:-

顶层 const (top-level const)记 '-个

const,舰进某对象的值不能改变。

类型别名(type alias)圯个名坫W

外个炎堦的|nj义吋.通过关键7-typedef i?父別农记义.

类型捡查(type checking ) Jv ■个过fM, 编4器检~ ftU i＜使川K给定炎哦对象的方 AU该类嘈的定义圮沂•致，

类型说明符＜ type specifier)炎咿的名'/•,

typedef为來类兜记义•个別名。关键宇 tvpedef作Wj|1月的卷木龙HI!现时，P 明屮定义的名卞就圮类型名。

未定义(undefined)即C++H+没甸叫确 规定的怙况。不论足古有意A之,未定义 行力都"f能引发难以追踪的运行时错误、 安令问题和可移桢仲问题。

未初始化(uninitialized)变％己记义什U＜ 波赋f初始值。-般來说.试阄访l'"j未初 始化变W的值将•_； I发未定义行为

无符号类型(unsigned)保存人0

的整喂。

变量(variable)命名的对象或引)4h C++ iS ,7趄求CE耍先声明后使川。

void* nJ以指向任意非常鼠的指针类嘲，不 能执彳r解引用操作，

void类型足-种有特殊用处的类哦，既尤 操作也无值。不能定义一个void类甩的 变％。

字(word)在指定机器上进汀幣数运算的 自然中位。•般來说，字的空M址够存放 地址,32位机器k的字通常占裾4个'O.

&运算符(& operator)取地址运算符。

*运算符(* operator)解引用达灯符，解 ，制-个指tl•将返冋该指针所指的对象, 为解引用的结果赋值也就足为指针所指的 対象赋值。

\#define足-条顶处理指令，ffl r定义个 顶处押变!4 „

\#endif &条预处嬋指令,用P结!|i -个 #ifdef 或#ifndef K域。

\#ifdef足-条预处现指令，WJ r•判断给定的 变S足否Li经定义，

\#ifndef    -条顶处押指令,用P判断给记

的变畢:足否尚未定义，
