## 第 16 章 协程

如果 Python 书籍有一定的指导作用，那么(协程就是)文档最匮乏、最鲜为人知的

Python 特性，因此表面上看是最无用的特性。

——David Beazley Python 图书作者

字典为动词“to yield”给出了两个释义：产出和让步。对于Python生成器中的yield来 说，这两个含义都成立。 yield item 这行代码会产出一个值，提供给 next(...) 的调 用方；此外，还会作出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个 值时再调用next()。调用方会从生成器中拉取值。

从句法上看，协程与生成器类似，都是定义体中包含 yield 关键字的函数。可是，在协 程中，yield通常出现在表达式的右边(例如，datum = yield)，可以产出值，也可 以不产出一如果yield关键字后面没有表达式，那么生成器产出None。协程可能会从 调用方接收数据，不过调用方把数据提供给协程使用的是 .send(datum) 方法，而不是 next(...) 函数。通常，调用方会把值推送给协程。

yield 关键字甚至还可以不接收或传出数据。不管数据如何流动， yield 都是一种流程控 制工具，使用它可以实现协作式多任务：协程可以把控制器让步给中心调度程序，从而激 活其他的协程。

从根本上把 yield 视作控制流程的方式，这样就好理解协程了。

本书前面介绍的生成器函数作用不大，但是进行一系列功能改进之后，得到了 Python 协 程。了解 Python 协程的进化过程有助于理解各个阶段改进的功能和复杂度。

本章首先要简单介绍生成器如何变成协程，然后再进入核心内容。本章涵盖以下话题：

•生成器作为协程使用时的行为和状态 •使用装饰器自动预激协程

•调用方如何使用生成器对象的.close()和.throw(...)方法控制协程

•协程终止时如何返回值

• yield from新句法的用途和语义

•使用案例——使用协程管理仿真系统中的并发活动

### 16.1 生成器如何进化成协程

协程的底层架构在“PEP 342—Coroutines via Enhanced

Generators” ([https://www+python+org/dev/peps/pep-0342/](https://www.python.org/dev/peps/pep-0342/))中定义，并在 Python 2.5 (2006

年)实现了。自此之后， yield 关键字可以在表达式中使用，而且生成器 API 中增加了 .send(value) 方法。生成器的调用方可以使用 .send(...) 方法发送数据，发送的数据 会成为生成器函数中 yield 表达式的值。因此，生成器可以作为协程使用。协程是指一 个过程，这个过程与调用方协作，产出由调用方提供的值。

除了 .send(...) 方法， PEP 342 还添加了 .throw(...) 和 .close() 方法：前者的作 用是让调用方抛出异常，在生成器中处理；后者的作用是终止生成器。下一节和 16.5 节 会说明这些方法。

协程最近的演进来自 Python 3+3 (2012 年)实现的“PEP380—Syntax for Delegating to a Subgenerator” (<https://www.python.org/dev/peps/pep-0380/>) 。 PEP 380 对生成器函数的句法

做了两处改动，以便更好地作为协程使用。

•现在，生成器可以返回一个值；以前，如果在生成器中给return语句提供值，会抛 出 SyntaxError 异常。

•新引入了 yield from句法，使用它可以把复杂的生成器重构成小型的嵌套生成器， 省去了之前把生成器的工作委托给子生成器所需的大量样板代码。

这两个最新的改动分别在 16.6 节和 16.7 节讨论。

按照本书的惯例，我们先从基本概念和示例入手，然后再深入越来越难以理解的特性。

### 16.2 用作协程的生成器的基本行为

示例 16-1 展示了协程的行为。

示例 16-1 可能是协程最简单的使用演示

\>>> def simple_coroutine():    # O

...    print('->    coroutine    started')

…    x = yield    # ©

...    print('->    coroutine    received:', x)

\>>> my_coro = simple_coroutine()

\>>> my_coro # ©

<generator object simple_coroutine at 0x100c2be10>

\>>> next(my_coro) # ©

-> coroutine started >>> my_coro.send(42) # ❺

-> coroutine received: 42

Traceback (most recent call last): # ©

StopIteration

❶ 协程使用生成器函数定义：定义体中有 yield 关键字。

❷ yield 在表达式中使用；如果协程只需从客户那里接收数据，那么产出的值是 None ——这个值是隐式指定的，因为 yield 关键字右边没有表达式。

❸ 与创建生成器的方式一样，调用函数得到生成器对象。

❹ 首先要调用 next(...) 函数，因为生成器还没启动，没在 yield 语句处暂停，所以一

开始无法发送数据。

❺ 调用这个方法后，协程定义体中的 yield 表达式会计算出 42；现在，协程会恢复，一 直运行到下一个 yield 表达式，或者终止。

❻ 这里，控制权流动到协程定义体的末尾，导致生成器像往常一样抛出 StopIteration 异常。

协程可以身处四个状态中的一个。当前状态可以使用

inspect.getgeneratorstate(...) 函数确定，该函数会返回下述字符串中的一个。

'GEN_CREATED'

等待开始执行。

'GEN_RUNNING'

解释器正在执行。

1只有在多线程应用中才能看至这个状态。此外，生成器对象在自己身上调用 getgeneratorstate 函数也行，不过这 样做没什么用。

'GEN_SUSPENDED'

在 yield 表达式处暂停。

'GEN_CLOSED'

执行结束。

因为 send 方法的参数会成为暂停的 yield 表达式的值，所以，仅当协程处于暂停状态时

才能调用send方法，例如my_coro.send(42)。不过，如果协程还没激活(即，状态是 'GEN_CREATED')，情况就不同了。因此，始终要调用next(my_coro)激活协程——也 可以调用my_coro.send(None)，效果一样。

如果创建协程对象后立即把 None 之外的值发给它，会出现下述错误：

\>>> my_coro = simple_coroutine()

\>>> my_coro.send(1729)

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

TypeError: can't send non-None value to a just-started generator

注意错误消息，它表述得相当清楚。

最先调用next(my_coro)函数这一步通常称为“预激” (prime)协程(即，让协程向前执 行至第一个 yield 表达式，准备好作为活跃的协程使用)。 下面举个产出多个值的例子，以便更好地理解协程的行为，如示例 16-2 所示。

示例 16-2 产出两个值的协程

\>>> def simple_coro2(a):

... print('-> Started: a =', a)

...    b = yield a

...    print('-> Received: b =', b)

... c = yield a + b

... print('-> Received: c =', c)

\>>> my_coro2 = simple_coro2(14)

\>>> from inspect import getgeneratorstate >>> getgeneratorstate(my_coro2) O

'GEN_CREATED'

\>>> next(my_coro2) ©

-> Started: a = 14

14

\>>> getgeneratorstate(my_coro2) ©

'GEN_SUSPENDED'

\>>> my_coro2.send(28) ©

-> Received: b = 28

42

\>>> my_coro2.send(99)❺

-> Received: c = 99

Traceback (most recent call last): File "<stdin>", line 1, in <module>

StopIteration

\>>> getgeneratorstate(my_coro2) ©

'GEN CLOSED'

❶ inspect.getgeneratorstate 函数指明，处于 GEN_CREATED 状态(即协程未启

动)。

❷ 向前执行协程到第一个 yield 表达式，打印 -> Started: a = 14 消息，然后产出 a 的值，并且暂停，等待为 b 赋值。

❸ getgeneratorstate 函数指明，处于 GEN_SUSPENDED 状态(即协程在 yield 表达式 处暂停)。

❹ 把数字 28 发给暂停的协程；计算 yield 表达式，得到 28，然后把那个数绑定给 b。 打印 -> Received: b = 28 消息，产出 a + b 的值(42)，然后协程暂停，等待为 c 赋值。

❺ 把数字 99 发给暂停的协程；计算 yield 表达式，得到 99，然后把那个数绑定给 c。 打印 -> Received: c = 99 消息，然后协程终止，导致生成器对象抛出

StopIteration 异常。

❻ getgeneratorstate 函数指明，处于 GEN_CLOSED 状态(即协程执行结束)。

关键的一点是，协程在 yield 关键字所在的位置暂停执行。前面说过，在赋值语句中， =

右边的代码在赋值之前执行。因此，对于 b = yield a 这行代码来说，等到客户端代码 再激活协程时才会设定 b 的值。这种行为要花点时间才能习惯，不过一定要理解，这样

才能弄懂异步编程中 yield 的作用(后文探讨)。

simple_coro2 协程的执行过程分为 3 个阶段，如图 16-1 所示。

(1)    调用next(my_coro2)，打印第一个消息，然后执行yield a，产出数字14。

(2)    调用my_coro2.send(28)，把28赋值给b，打印第二个消息，然后执行yield a +

b，产出数字42。

(3)    调用my_coro2.send(99)，把99赋值给c，打印第三个消息，协程终止。

\>» ny_coro2 = sinple_coro2(14)

def sinple_coro2(a):    »> next(ny_coro2)

p「int(’-> Started: a =', a)    O ■> Started: a = 14

~b = | yield a_14

print(1-> Received: b =’， b)    >» ny_coro2.send(28)

c 二 yield a + b    0    -> Received: b = 28

print(,-> Received: c =*, c) |_42

»> ny_coro2. send(99)

@    -> Received: c = 99

Traceback (most recent call last):

File "<stdin>,', line 1, in <module>

St叩Iteration

图 16-1：执行 simple_coro2 协程的 3 个阶段(注意，各个阶段都在 yield 表达式中 结束，而且下一个阶段都从那一行代码开始，然后再把 yield 表达式的值赋给变量)

下面来看一个稍微复杂的协程示例。

### 16.3 示例：使用协程计算移动平均值

第 7 章讨论闭包时，我们分析了如何使用对象计算移动平均值：示例 7-8 定义的是一个简 单的类；示例 7-14 定义的是一个高阶函数，用于生成一个闭包，在多次调用之间跟踪 total 和 count 变量的值。示例 16-3 展示如何使用协程实现相同的功能。 2

2这个示例的灵感来自Jacob Holm在Python-ideas邮件列表中发布的一个代码片段，他发布的消息题为“Yield-From:

Finalization guarantees” ( [https://mail.python. org/pipermai\]/python-ideas/2009-Apri]/003841+html](https://mail.python.org/pipermail/python-ideas/2009-April/003841.html))。在那个消息的后续回复中， 那段代码有几个变体。Holm 在 003912 号消息([https://mail.python.org/pipermai\]/python-ideas/2009-April/003912+html](https://mail.python.org/pipermail/python-ideas/2009-April/003912.html))中进

一步说明了自己的想法。

#### 示例16-3 coroaverager0+py：定义一个计算移动平均值的协程

def averager(): total = 0.0 count = 0 average = None while True:

term = yield average & total += term count += 1

average = total/count

这个无限循环表明，只要调用方不断把值发给这个协程，它就会一直接收值，然后生 成结果。仅当调用方在协程上调用 .close() 方法，或者没有对协程的引用而被垃圾回收 程序回收时，这个协程才会终止。

#### &这里的yield表达式用于暂停执行协程，把结果发给调用方；还用于接收调用方后面 发给协程的值，恢复无限循环。

使用协程的好处是， total 和 count 声明为局部变量即可，无需使用实例属性或闭包在 多次调用之间保持上下文。示例 16-4 是使用 averager 协程的 doctest。

#### 示例16-4 coroaverager0+py:示例16-3中定义的移动平均值协程的doctest

\>>> coro_avg = averager() O >>> next(coro_avg) ©

\>>> coro_avg.send(10) ©

10.0

\>>> coro_avg.send(30)

20.0

\>>> coro_avg.send(5)

15.0

#### ❶ 创建协程对象。

#### ❷ 调用 next 函数，预激协程。

❸ 计算移动平均值：多次调用 .send(...) 方法，产出当前的平均值。

在上述 doctest 中(示例 16-4)，调用 next(coro_avg) 函数后，协程会向前执行到

yield表达式，产出average变量的初始值-None，因此不会出现在控制台中。此

时，协程在 yield 表达式处暂停，等到调用方发送值。 coro_avg.send(10) 那一行发送 一个值，激活协程，把发送的值赋给term，并更新total、count和average三个变量 的值，然后开始 while 循环的下一次迭代，产出 average 变量的值，等待下一次为 term 变量赋值。

细心的读者可能迫切地想知道如何终止执行averager实例(如coro_avg)，因为定义 体中有个无限循环。 16+5 节会讨论这个话题。

讨论如何终止协程之前，我们要先谈谈如何启动协程。使用协程之前必须预激，可是这一

步容易忘记。为了避免忘记，可以在协程上使用一个特殊的装饰器。接下来介绍这样一个

装饰器。

### 16.4 预激协程的装饰器

如果不预激，那么协程没什么用。调用 my_coro.send(x) 之前，记住一定要调用

next(my_coro)。为了简化协程的用法，有时会使用一个预激装饰器。示例16-5中的 coroutine 装饰器是一例。 3

3网上有多个类似的装饰器。这个改自ActiveState中的一个诀窍——“Pipeline made of

coroutines” ( [http://code. active state. com/rec ipes/578265-pipeline-made-of-c oroutines/](http://code.activestate.com/recipes/578265-pipeline-made-of-coroutines/))，作者是 Chaobin Tang，而他是受至 lj 了 David Beazley 的启发。

#### 示例16-5 coroutil.py：预激协程的装饰器

from functools import wraps def coroutine(func):

"""装饰器：向前执行到第一个'yield'表达式，预激'func'"""

@wraps(func)

def primer(*args,**kwargs): O gen = func(*args,**kwargs) © next(gen) ©

return gen © return primer

#### ❶ 把被装饰的生成器函数替换成这里的 primer 函数；调用 primer 函数时，返回预激后

的生成器。

#### ❷ 调用被装饰的函数，获取生成器对象。

#### ❸ 预激生成器。

#### ❹ 返回生成器。

示例 16-6 展示 @coroutine 装饰器的用法。请与示例 16-3 对比。

#### 示例16-6 coroaveragerl.py：使用示例16-5中定义的@coroutine装饰器定义并测

试计算移动平均值的协程

用于计算移动平均值的协程

\>>> coro_avg = averager() O

\>>> from inspect import getgeneratorstate

\>>> getgeneratorstate(coro_avg) ©

'GEN_SUSPENDED'

\>>> coro_avg.send(10) ©

10.0

\>>> coro_avg.send(30)

20.0

\>>> coro_avg.send(5)

15.0

from coroutil import coroutine ©

@coroutine def averager total = count =

:0

❺ (0



![img](08414584Python-76.png)



average = None while True:

term = yield average total += term count += 1

average = total/count



❶ 调用 averager() 函数创建一个生成器对象，在 coroutine 装饰器的 primer 函数中

已经预激了这个生成器。

❷ getgeneratorstate 函数指明，处于 GEN_SUSPENDED 状态，因此这个协程已经准备

好，可以接收值了。

❸可以立即开始把值发给coro_avg-这正是coroutine装饰器的目的。

❹ 导入 coroutine 装饰器。

❺ 把装饰器应用到 averager 函数上。

❻ 函数的定义体与示例 16-3 完全一样。

很多框架都提供了处理协程的特殊装饰器，不过不是所有装饰器都用于预激协程，有些会

提供其他服务，例如勾入事件循环。比如说，异步网络库 Tornado 提供了 tornado.gen 装饰器( <http://tornado.readthedocs.org/en/latest/gen.html>) 。

使用 yield from 句法(参见 16.7 节)调用协程时，会自动预激，因此与示例 16-5 中的 @coroutine 等装饰器不兼容。 Python 3.4 标准库里的 asyncio.coroutine 装饰器(第 18 章介绍)不会预激协程，因此能兼容 yield from 句法。

接下来探讨协程的重要特性——用于终止协程，以及在协程中抛出异常的方法。

### 16.5 终止协程和异常处理

协程中未处理的异常会向上冒泡，传给 next 函数或 send 方法的调用方(即触发协程的 对象)。示例 16-7 举例说明如何使用示例 16-6 中由装饰器定义的 averager 协程。

示例 16-7 未处理的异常会导致协程终止

\>>> from coroaverager1 import averager >>> coro_avg = averager()

\>>> coro_avg.send(40) # O 40.0

\>>> coro_avg.send(50)

45.0

\>>> coro_avg.send('spam') # ©

Traceback (most recent call last):

TypeError: unsupported operand type(s) for +=: 'float' and 'str'

\>>> coro_avg.send(60) # ©

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

StopIteration

❶ 使用 @coroutine 装饰器装饰的 averager 协程，可以立即开始发送值。

❷ 发送的值不是数字，导致协程内部有异常抛出。

❸ 由于在协程内没有处理异常，协程会终止。如果试图重新激活协程，会抛出

StopIteration 异常。

出错的原因是，发送给协程的 'spam' 值不能加到 total 变量上。

示例 16-7 暗示了终止协程的一种方式：发送某个哨符值，让协程退出。内置的 None 和 Ellipsis 等常量经常用作哨符值。 Ellipsis 的优点是，数据流中不太常有这个值。我 还见过有人把 StopIteration 类(类本身，而不是实例，也不抛出)作为哨符值；也就

是说，是像这样使用的： my_coro.send(StopIteration)。

从 Python 2.5 开始，客户代码可以在生成器对象上调用两个方法，显式地把异常发给协 程。

这两个方法是 throw 和 close。

generator.throw(exc_type[, exc_value[, traceback]])

致使生成器在暂停的 yield 表达式处抛出指定的异常。如果生成器处理了抛出的异 常，代码会向前执行到下一个 yield 表达式，而产出的值会成为调用 generator.throw

方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上

下文中。

generator.close()

致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。如果生成器没有处

理这个异常，或者抛出了 StopIteration 异常(通常是指运行到结尾)，调用方不会报

错。如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出

RuntimeError 异常。生成器抛出的其他异常会向上冒泡，传给调用方。

生成器对象方法的官方文档深藏在Python语言参考手册中，参 见“6.2.9.1. Generator-iterator

[methods”](https://docs.python.org/3/reference/expressions.html%23generator-iterator-methods)[(https://docs.python.org/3/reference/expressions.html#generator-iterator-](https://docs.python.org/3/reference/expressions.html%23generator-iterator-methods)

methods)。

下面举例说明如何使用 close 和 throw 方法控制协程。示例 16-8 列出的是接下来的例子 使用的 demo_exc_handling 函数。

示例16-8 coro_exc_demo.py:学习在协程中处理异常的测试代码

class DemoException(Exception):

"""为这次演示定义的异常类型。 """

def demo_exc_handling():

print('-> coroutine started')

while True: try:

x = yield

except DemoException: O

print('*** DemoException handled. Continuing...')

else: ©

print('-> coroutine received: {!r}'.format(x)) raise RuntimeError('This line should never run.')

❶ 特别处理 DemoException 异常。

❷ 如果没有异常，那么显示接收到的值。

❸ 这一行永远不会执行。

示例 16-8 中的最后一行代码不会执行，因为只有未处理的异常才会中止那个无限循环

而一旦出现未处理的异常，协程会立即终止。

demo_exc_handling 函数的常规用法如示例 16-9 所示。

示例16-9激活和关闭demo_exc_handling，没有异常

\>>> exc_coro.send(22)

-> coroutine received: 22

\>>> exc_coro.close()

\>>> from inspect import getgeneratorstate >>> getgeneratorstate(exc_coro)

'GEN CLOSED'

#### 如果把 DemoException 异常传入 demo_exc_handling 协程，它会处理，然后继续运 行，如示例 16-10 所示。

示例 16-10 把 DemoException 异常传入 demo_exc_handling 不会导致协程中止

\>>> exc_coro = demo_exc_handling()

\>>> next(exc_coro)

-> coroutine started >>> exc_coro.send(11)

-> coroutine received: 11

\>>> exc_coro.throw(DemoException)

*** DemoException handled. Continuing... >>> getgeneratorstate(exc_coro)

'GEN SUSPENDED'

#### 但是，如果传入协程的异常没有处理，协程会停止，即状态变成’GEN_CLOSED'。示例 16-11 演示了这种情况。

#### 示例 16-11 如果无法处理传入的异常，协程会终止

\>>> exc_coro = demo_exc_handling() >>> next(exc_coro)

-> coroutine started >>> exc_coro.send(11)

-> coroutine received: 11

\>>> exc_coro.throw(ZeroDivisionError)

Traceback (most recent call last):

ZeroDivisionError

\>>> getgeneratorstate(exc_coro)

'GEN CLOSED'

如果不管协程如何结束都想做些清理工作，要把协程定义体中相关的代码放入 try/finally 块中，如示例 16-12。

#### 示例16-12 coro_finally_demo+py：使用try/finally块在协程终止时执行操作

class DemoException(Exception):

"""为这次演示定义的异常类型。

def demo_finally():

print('-> coroutine started') try:

while True: try:

except DemoException:

print('*** DemoException handled. Continuing...') else:

print('-> coroutine received: {!r}'.format(x))

finally:

print('-> coroutine ending')

#### Python 3.3 引入 yield from 结构的主要原因之一与把异常传入嵌套的协程有关。另一个 原因是让协程更方便地返回值。请继续往下读，了解详情。

### 16.6 让协程返回值

示例 16-13 是 averager 协程的不同版本，这一版会返回结果。为了说明如何返回值，每 次激活协程时不会产出移动平均值。这么做是为了强调某些协程不会产出值，而是在最后 返回一个值(通常是某种累计值)。

示例16-13中的averager协程返回的结果是一个namedtuple，两个字段分别是项数 (count)和平均值(average)。我本可以只返回平均值，但是返回一个元组可以获得

累积数据的另一个重要信息——项数。

示例16-13 coroaverager2.py:定义一个求平均值的协程，让它返回一个结果

from collections import namedtuple

Result = namedtuple('Result', 'count average')

def averager(): total = 0.0 count = 0 average = None while True:

term = yield if term is None:

break O total += term count += 1

average = total/count return Result(count, average) ©

O 为了返回值，协程必须正常终止；因此，这一版 averager 中有个条件判断，以便退

出累计循环。

©返回一个namedtuple，包含count和average两个字段。在Python 3.3之前，如果

生成器返回值，解释器会报句法错误。

下面在控制台中说明如何使用新版averager，如示例16-14所示。

示例 16-14 coroaverager2.py:说明 averager 行为的 doctest

\>>> coro_avg = averager()

\>>> next(coro_avg)

\>>> coro_avg.send(10) O >>> coro_avg.send(30)

\>>> coro_avg.send(6.5)

\>>> coro_avg.send(None) ©

Traceback (most recent call last): StopIteration: Result(count=3, average=15.5)

❶ 这一版不产出值。

❷ 发送 None 会终止循环，导致协程结束，返回结果。一如既往，生成器对象会抛出

StopIteration 异常。异常对象的 value 属性保存着返回的值。

注意， return 表达式的值会偷偷传给调用方，赋值给 StopIteration 异常的一个属 性。这样做有点不合常理，但是能保留生成器对象的常规行为——耗尽时抛出

StopIteration 异常。

示例 16-15 展示如何获取协程返回的值。

示例 16-15 捕获 StopIteration 异常，获取 averager 返回的值

\>>> coro_avg = averager()

\>>> next(coro_avg)

\>>> coro_avg.send(10)

\>>> coro_avg.send(30)

\>>> coro_avg.send(6.5)

\>>> try:

...    coro_avg.send(None)

... except StopIteration as exc:

...    result = exc.value

\>>> result

Result(count=3, average=15.5)

获取协程的返回值虽然要绕个圈子，但这是 PEP 380 定义的方式，当我们意识到这一点之

后就说得通了： yield from结构会在内部自动捕获StopIteration异常。这种处理方 式与 for 循环处理 StopIteration 异常的方式一样：循环机制使用用户易于理解的方式 处理异常。对 yield from 结构来说，解释器不仅会捕获 StopIteration 异常，还会把 value 属性的值变成 yield from 表达式的值。可惜，我们无法在控制台中使用交互的方 式测试这种行为，因为在函数外部使用yield from (以及yield)会导致句法出错。4

4iPython有个扩展-ipython-yf (<https://github.com/tecki/ipython-yf>)，安装这个扩展后可以在iPython捜制台中直接执行

yield from。这个扩展用于测试异步代码，可以结合asyncio模块使用。这个扩展己径提交为Python 3+5的补丁，但 是没有被接受。参见 Python 缺陷追踪系统中的 22412 号工单： Towards an asyncio-enabled command

line(<http://bugs.python.org/issue22412>)。

下一节会举例说明如何使用 yield from 结构按照 PEP 380 定义的方式获取 averager 协 程返回的值。下面讨论 yield from 结构。

### 16.7 使用 yield from

首先要知道， yield from 是全新的语言结构。它的作用比 yield 多很多，因此人们认为 继续使用那个关键字多少会引起误解。在其他语言中，类似的结构使用 await 关键字， 这个名称好多了，因为它传达了至关重要的一点：在生成器 gen 中使用 yield from subgen() 时， subgen 会获得控制权，把产出的值传给 gen 的调用方，即调用方可以直

接控制subgen。与此同时，gen会阻塞，等待subgen终止。5

I 5写作本书时，有个PEP正在讨论中，提议增加await和async关键字：PEP 492—Coroutines with async and await

syntax(<https://www.python.org/dev/peps/pep-0492/>)。

第 14 章说过， yield from 可用于简化 for 循环中的 yield 表达式。例如：

\>>> def gen():

...    for c in 'AB':

...    yield c

...    for i in range(1, 3):

...    yield i

\>>> list(gen())

['A', 'B', 1, 2]

#### 可以改写为：

| >>>  | def gen():   |             |
| ---- | ------------ | ----------- |
|      | yield from   | 'AB'        |
|      | yield from   | range(1, 3) |
| >>>  | list(gen())  |             |
| ['A' | , 'B', 1, 2] |             |

#### 1示4.。106 节首次提到 yield from 时举了一个例子，演示这个结构的用法，如示例 16-16 所 示。

6示例16-16仅供教学使用。itertools模块提供了优化版chain函数，使用C语言编写

示例 16-16 使用 yield from 链接可迭代的对象

\>>> def chain(*iterables): ... for it in iterables: ...    yield from it

\>>> s = 'ABC'

\>>> t = tuple(range(3))

\>>> list(chain(s, t))

['A', 'B', 'C', 0, 1, 2]

#### 在Beazley与Jones的《Python Cookbook (第3版)中文版》一书中，“4.14扁平化处理嵌 套型的序列”一节有个稍微复杂(不过更有用)的 yield from 示例(源码在 GitHub 中， <https://github.com/dabeaz/python->

[cookbook/blob/master/src/4/how_to_flatten_a_nested_sequence/example.py](https://github.com/dabeaz/python-cookbook/blob/master/src/4/how_to_flatten_a_nested_sequence/example.py)) 。

yield from x表达式对x对象所做的第一件事是，调用iter(x)，从中获取迭代器。因 此， x 可以是任何可迭代的对象。

可是，如果 yield from 结构唯一的作用是替代产出值的嵌套 for 循环，这个结构很有 可能不会添加到 Python 语言中。 yield from 结构的本质作用无法通过简单的可迭代对象 说明，而要发散思维，使用嵌套的生成器。因此，引入 yield from 结构的 PEP 380 才起 了“Syntaxfor Delegating to a Subgenerator” (“把职责委托给子生成器的句法”)这个标题。

yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起

来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中

添加大量处理异常的样板代码。有了这个结构，协程可以通过以前不可能的方式委托职

责。

若想使用 yield from 结构，就要大幅改动代码。为了说明需要改动的部分， PEP 380 使 用了一些专门的术语。

委派生成器

包含 yield from <iterable> 表达式的生成器函数。

子生成器

从 yield from 表达式中 <iterable> 部分获取的生成器。这就是 PEP 380 的标题 (“Syntax for Delegating to a Subgenerator”)中所说的“子生成器”(subgenerator)。

调用方

PEP 380 使用“调用方”这个术语指代调用委派生成器的客户端代码。在不同的语境 中，我会使用“客户端”代替“调用方”，以此与委派生成器(也是调用方，因为它调用了子 生成器)区分开。

PEP 380经常使用“迭代器”这个词指代子生成器。这样会让人误解，因为委派 生成器也是迭代器。因此，我选择使用“子生成器”这个术语，与 PEP 380 的标题

“Syntax for Delegating to a Subgenerator”)保持一致。然而，子生成器可能是简单的 迭代器，只实现了 __next__ 方法；但是， yield from 也能处理这种子生成器。不 过，引入 yield from 结构的目的是为了支持实现了 __next__、send、close 和

throw 方法的生成器。

示例 16-17 能更好地说明 yield from 结构的用法。图 16-2 把该示例中各个相关的部分

标识出来了。 7

图 16-2：委派生成器在 yield from 表达式处暂停时，调用方可以直接把数据发给子 生成器，子生成器再把产出的值发给调用方。子生成器返回之后，解释器会抛出 StopIteration 异常，并把返回值附加到异常对象上，此时委派生成器会恢复

coroaverager3.py 脚本从一个字典中读取虚构的七年级男女学生的体重和身高。例如， 'boys;m' 键对应于 9 个男学生的身高（单位是米）， 'girls;kg' 键对应于 10 个女学生 的体重（单位是千克）。这个脚本把各组数据传给前面定义的 averager 协程，然后生成 一个报告，如下所示：

$ python3 coroaverager3.py

9 boys averaging 40.42kg

9 boys averaging 1.39m

10 girls averaging 42.04kg 10 girls averaging 1.43m

示例 16-17 中列出的代码显然不是解决这个问题最简单的方案，但是通过实例说明了

yield from结构的用法。这个示例的灵感来自“What's New in Python 3.3”一文 （[https://docs+python.org/3/whatsnew/3+3+html#pep-380](https://docs.python.org/3/whatsnew/3.3.html%23pep-380)）给出的例子。

示例16-17 coroaverager3+py：使用yield from计算平均值并输出统计报告

from collections import namedtuple

Result = namedtuple('Result', 'count average')

\# 子生成器

def averager(): O total = 0.0 count = 0 average = None while True:

term = yield if term is None: &

break

total += term count += 1

average = total/count

return Result(count, average) ©

\# 委派生成器

def grouper(results, key):❺ while True: ©

results[key] = yield from averager() O

\# 客户端代码，即调用方

def main(data): © results = {}

for key, values in data.items():

group = grouper(results, key) © next(group) ©

for value in values:

group.send(value) ®

group.send(None) # 重要！ ®

\# print(results) # 如果要调试，去掉注释 report(results)

\# 输出报告

def report(results):

for key, result in sorted(results.items()): group, unit = key.split(';') print('{:2} {:5} averaging {:.2f}{}'.format(

result.count, group, result.average, unit))

data = {

'girls;kg':

[40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],

'girls;m':

[1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43], 'boys;kg':

[39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],

'boys;m':

[1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],

}

if __name__ == '__main__': main(data)

#### ❶ 与示例 16-13 中的 averager 协程一样。这里作为子生成器使用。

❷ main 函数中的客户代码发送的各个值绑定到这里的 term 变量上。

❸ 至关重要的终止条件。如果不这么做，使用 yield from 调用这个协程的生成器会永

远阻塞。

❹ 返回的 Result 会成为 grouper 函数中 yield from 表达式的值。

❺ grouper 是委派生成器。

❻ 这个循环每次迭代时会新建一个 averager 实例；每个实例都是作为协程使用的生成 器对象。

❼ grouper 发送的每个值都会经由 yield from 处理，通过管道传给 averager 实 例。 grouper 会在 yield from 表达式处暂停，等待 averager 实例处理客户端发来的 值。 averager 实例运行完毕后，返回的值绑定到 results[key] 上。 while 循环会不断 创建 averager 实例，处理更多的值。

❽ main 函数是客户端代码，用 PEP 380 定义的术语来说，是“调用方”。这是驱动一切的 函数。

❾ group 是调用 grouper 函数得到的生成器对象，传给 grouper 函数的第一个参数是 results，用于收集结果；第二个参数是某个键。group作为协程使用。

❿ 预激 group 协程。

G把各个    给grouper。传入的值最终到达averager函数中term = yield那

一行； grouper 永远不知道传入的值是什么。

©把None传入grouper，导致当前的averager实例终止，也让grouper继续运行， 再创建一个 averager 实例，处理下一组值。

示例 16-17 中最后一个标号前面有个注释——“重要！”，强调这行代码

(group.send(None))至关重要：终止当前的averager实例，开始执行下一个。如果 注释掉那一行，这个脚本不会输出任何报告。此时，把 main 函数靠近末尾的 print(results) 那行的注释去掉，你会发现， results 字典是空的。

研究为何没有收集到数据，能检验自己有没有理解yield from结构的运作方 式。本书的代码仓库中有 coroaverager3.py 脚本的代码 [(](https://github.com/fluentpython/example-code/blob/master/16-coroutine/coroaverager3.py)[https://github.com/fluentpython/example-code/blob/master/16-](https://github.com/fluentpython/example-code/blob/master/16-coroutine/coroaverager3.py)coroutine/coroaverager3.py)。原因说明如下。

下面简要说明示例 16-17 的运作方式，还会说明把 main 函数中调用 group.send(None) 那一行代码(带有“重要！”注释的那一行)去掉会发生什么事。

•外层for循环每次迭代会新建一个grouper实例，赋值给group变量；group是委

派生成器。

•调用next(group)，预激委派生成器grouper，此时进入while True循环，调用 子生成器 averager 后，在 yield from 表达式处暂停。

•内层for循环调用group.send(value)，直接把值传给子生成器averager。同 时，当前的grouper实例(group)在yield from表达式处暂停。

•内层循环结束后，group实例依旧在yield from表达式处暂停，因此，grouper 函数定义体中为 results[key] 赋值的语句还没有执行。

•如果外层for循环的末尾没有group.send(None)，那么averager子生成器永远

不会终止，委派生成器 group 永远不会再次激活，因此永远不会为 results[key] 赋值。

•外层for循环重新迭代时会新建一个grouper实例，然后绑定到group变量上。前 一个 grouper 实例(以及它创建的尚未终止的 averager 子生成器实例)被垃圾回

收程序回收。

这个试验想表明的关键一点是，如果子生成器不终止，委派生成器会在 yield from 表达式处永远暂停。如果是这样，程序不会向前执行，因为 yield from (与yield 一样)把控制权转交给客户代码(即，委派生成器的调用方)了。

显然，肯定有任务无法完成。

示例 16-17 展示了 yield from 结构最简单的用法，只有一个委派生成器和一个子生成 器。因为委派生成器相当于管道，所以可以把任意数量个委派生成器连接在一起：一个委 派生成器使用 yield from 调用一个子生成器，而那个子生成器本身也是委派生成器，使 用 yield from 调用另一个子生成器，以此类推。最终，这个链条要以一个只使用 yield 表达式的简单生成器结束；不过，也能以任何可迭代的对象结束，如示例 16-16 所示。

任何 yield from 链条都必须由客户驱动，在最外层委派生成器上调用 next(...) 函数 或 .send(...) 方法。可以隐式调用，例如使用 for 循环。

下面综述 PEP 380 对 yield from 结构的正式说明。

### 16.8 yield from 的意义

制定 PEP 380 时，有人质疑作者 Greg Ewing 提议的语义过于复杂了。他的回应之一 是： “对人类来说，几乎所有最重要的信息都在靠近顶部的某个段落里。 ”他还引述了 PEP 380 草稿中的一段话，当时那段话是这样的：

“把迭代器当作生成器使用，相当于把子生成器的定义体内联在 yield from 表达式

中。此外，子生成器可以执行 return 语句，返回一个值，而返回的值会成为 yield from 表达式的值。 ”8

I 8摘自 Python-Dev 邮件列表中的一个消息：“PEP 380 (yield from a subgenerator) comments” (发布于 2009 年 3 月 21 日，[https://mai!python+org/pipermail/python-dev/2009-March/087385+html](https://mail.python.org/pipermail/python-dev/2009-March/087385.html))。

PEP 380 中己经没有这段宽慰人心的话，因为没有涵盖所有极端情况。不过，一开始可以 这样粗略地说。

批准后的 PEP 380 在“Proposal”一节([https://www+python+org/dev/peps/pep-0380/#proposal](https://www.python.org/dev/peps/pep-0380/%23proposal)

分六点说明了 yield from 的行为。这里，我几乎原封不动地引述，不过把有歧义的“迭

代器”一词都换成了“子生成器”，还做了进一步说明。示例 16-17 阐明了下述四点。

•子生成器产出的值都直接传给委派生成器的调用方(即客户端代码)。

•使用send()方法发给委派生成器的值都直接传给子生成器。如果发送的值是 None，那么会调用子生成器的__next__()方法。如果发送的值不是None，那么会 调用子生成器的 send() 方法。如果调用的方法抛出 StopIteration 异常，那么委 派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。

•生成器退出时，生成器(或子生成器)中的return expr表达式会触发 StopIteration(expr) 异常抛出。

• yield from表达式的值是子生成器终止时传给StopIteration异常的第一个参

数。

yield from 结构的另外两个特性与异常和终止有关。

•传入委派生成器的异常，除了 GeneratorExit之外都传给子生成器的throw()方 法。如果调用 throw() 方法时抛出 StopIteration 异常，委派生成器恢复运 行。 StopIteration 之外的异常会向上冒泡，传给委派生成器。

•如果把GeneratorExit异常传入委派生成器，或者在委派生成器上调用close()方 法，那么在子生成器上调用 close() 方法，如果它有的话。如果调用 close() 方法 导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出

GeneratorExit 异常。

yield from 的具体语义很难理解，尤其是处理异常的那两点。 Greg Ewing 做得很好，在

PEP 380 中使用英语阐述了 yield from 的语义。

Ewing 还使用伪代码(使用 Python 句法)演示了 yield from 的行为。我个人认为值得花 时间研究 PEP 380 中的伪代码。不过，那段伪代码长达 40 行，看一遍很难理解。 若想研究那段伪代码，最好将其简化，只涵盖 yield from 最基本且最常见的用法。

假设 yield from 出现在委派生成器中。客户端代码驱动着委派生成器，而委派生成器驱 动着子生成器。那么，为了简化涉及到的逻辑，我们假设客户端没有在委派生成器上调用 .throw(...) 或 .close() 方法。此外，我们还假设子生成器不会抛出异常，而是一直 运行到终止，让解释器抛出 StopIteration 异常。

示例 16-17 中的脚本就做了这些简化逻辑的假设。其实，在真实的代码中，委派生成器应 该运行到结束。下面来看一下在这个简化的美满世界中， yield from 是如何运作的。 请看示例 16-18，那里列出的代码是委派生成器的定义体中下面这一行代码的扩充：

RESULT = yield from EXPR

自己试着理解示例 16-18 中的逻辑。

示例 16-18 简化的伪代码，等效于委派生成器中的 RESULT = yield from EXPR 语句(这里针对的是最简单的情况：不支持 .throw(...) 和 .close() 方法，而且

只处理 StopIteration 异常)

_i = iter(EXPR) O try:

_y = next(_i) © except StopIteration as _e:

_r = _e.value © else:

while 1:    ©

_s = yield _y ❺ try:

_y = _i.send(_s) © except StopIteration as _e: O

_r = _e.value break

RESULT = _r ©

❶EXPR可以是任何可迭代的对象，因为获取迭代器_i (这是子生成器)使用的是 iter() 函数。

❷ 预激子生成器；结果保存在 _y 中，作为产出的第一个值。

❸如果抛出StopIteration异常，获取异常对象的value属性，赋值给_r-这是最

简单情况下的返回值(RESULT)。

❹ 运行这个循环时，委派生成器会阻塞，只作为调用方和子生成器之间的通道。

❺ 产出子生成器当前产出的元素；等待调用方发送 _s 中保存的值。注意，这个代码清单 中只有这一个 yield 表达式。

❻ 尝试让子生成器向前执行，转发调用方发送的 _s。

❼如果子生成器抛出StopIteration异常，获取value属性的值，赋值给_r，然后退

出循环，让委派生成器恢复运行。

❽返回的结果^日5。匕丁)是_r，即整个yield from表达式的值。

在这段简化的伪代码中，我保留了 PEP 380 中那段伪代码使用的变量名称。这些变量是： _i (迭代器)

子生成器 _y (产出的值)

子生成器产出的值 _r (结果)

最终的结果(即子生成器运行结束后 yield from 表达式的值)

_s (发送的值)

调用方发给委派生成器的值，这个值会转发给子生成器 _e (异常)

异常对象(在这段简化的伪代码中始终是 StopIteration 实例)

除了没有处理 .throw(...) 和 .close() 方法之外，这段简化的伪代码还在子生成器上 调用 .send(...) 方法，以此达到客户调用 next() 函数或 .send(...) 方法的目的。首 次阅读时不要担心这些细微的差别。前面说过，即使 yield from 结构只做示例 16-18 中 展示的事情，示例 16-17 也依旧能正常运行。

但是，现实情况要复杂一些，因为要处理客户对 .throw(...) 和 .close() 方法的调 用，而这两个方法执行的操作必须传入子生成器。此外，子生成器可能只是纯粹的迭代 器，不支持 .throw(...) 和 .close() 方法，因此 yield from 结构的逻辑必须处理这 种情况。如果子生成器实现了这两个方法，而在子生成器内部，这两个方法都会触发异常 抛出，这种情况也必须由 yield from 机制处理。调用方可能会无缘无故地让子生成器自 己抛出异常，实现 yield from 结构时也必须处理这种情况。最后，为了优化，如果调用 方调用 next(...) 函数或 .send(None) 方法，都要转交职责，在子生成器上调用 next(...) 函数；仅当调用方发送的值不是 None 时，才使用子生成器的 .send(...) 方 法。

#### 为了方便对比，下面列出 PEP 380 中扩充 yield from 表达式的完整伪代码，而且加上了

带标号的注解。示例 16-19 中的代码是一字不差复制过来的，只有标注是我自己加的。

再次说明，示例 16-19 中的代码是委派生成器的定义体中下面这一个语句的扩充：

RESULT = yield from EXPR

#### 示例 16-19 伪代码，等效于委派生成器中的 RESULT = yield from EXPR 语句

_i = iter(EXPR) O try:

_y = next(_i) © except StopIteration as _e:

_r = _e.value © else:

while 1: © try:

_s = yield _y © except GeneratorExit as _e:    ©

try:

_m = _i.close except AttributeError:

pass

else:

_m() raise _e

except BaseException as _e: O _x = sys.exc_info() try:

_m = _i.throw except AttributeError:

raise _e else:❻

try:

_y = _m(*_x)

except StopIteration as _e: _r = _e.value break

else: 0 try: ©

if _s is None:    ®

_y = next(_i)

else:

_y = _i.send(_s) except StopIteration as _e:    ®

_r = _e.value

break

RESULT = _r ©

#### ❶EXPR可以是任何可迭代的对象，因为获取迭代器_i (这是子生成器)使用的是 iter() 函数。

❷ 预激子生成器；结果保存在 _y 中，作为产出的第一个值。

❸如果抛出StopIteration异常，获取异常对象的value属性，赋值给_r-这是最

简单情况下的返回值（RESULT）。

❹ 运行这个循环时，委派生成器会阻塞，只作为调用方和子生成器之间的通道。

❺ 产出子生成器当前产出的元素；等待调用方发送 _s 中保存的值。这个代码清单中只有 这一个 yield 表达式。

❻ 这一部分用于关闭委派生成器和子生成器。因为子生成器可以是任何可迭代的对象， 所以可能没有 close 方法。

❼ 这一部分处理调用方通过 .throw（...） 方法传入的异常。同样，子生成器可以是迭代 器，从而没有 throw 方法可调用——这种情况会导致委派生成器抛出异常。

❽ 如果子生成器有 throw 方法，调用它并传入调用方发来的异常。子生成器可能会处理 传入的异常（然后继续循环）；可能抛出 StopIteration 异常（从中获取结果，赋值给 _r，循环结束）；还可能不处理，而是抛出相同的或不同的异常，向上冒泡，传给委派 生成器。

❾ 如果产出值时没有异常 ……

❿ 尝试让子生成器向前执行……

©如果调用方最后发送的值是None，在子生成器上调用next函数，否则调用send方 法。

©如果子生成器抛出StopIteration异常，获取value属性的值，赋值给_r，然后退

出循环，让委派生成器恢复运行。

®返回的结果^日5。匕丁）是_r，即整个yield from表达式的值。

这段 yield from 伪代码的大多数逻辑通过六个 try/except 块实现，而且嵌套了四层， 因此有点难以阅读。此外，用到的其他流程控制关键字有一个while、一个if和一个 yield。找到while循环、yield表达式以及next（...）函数和.send（...）方法调 用，这些代码有助于对 yield from 结构的运作方式有个整体的了解。

就在示例16-19所列伪代码的顶部，有行代码（标号❷）揭示了一个重要的细节：要预激 子生成器。 9 这表明，用于自动预激的装饰器（如 16.4 节定义的那个）与 yield from 结 构不兼容。

I[9](https://mail.python.org/pipermail/python-ideas/2009-April/003954.html)[Nick Coghlan 于 2009 年 4 月 5 日在 Python-ideas 邮件列表中发布的一个消息（https://mailpython.org/pipermail/python-](https://mail.python.org/pipermail/python-ideas/2009-April/003954.html)ideas/2009-April/003954.html）中质疑，yield from结构隐式预激是不是好主意。

[在本节开头引用的那个消息中（](https://mail.python.org/pipermail/python-dev/2009-March/087385.html)[https://mail.python.org/pipermail/python-dev/2009-](https://mail.python.org/pipermail/python-dev/2009-March/087385.html)March/087385.html），关于扩充 yield from 结构的伪代码，Greg Ewing 说：

我不是让你通过扩充的伪代码学习这个结构，那段伪代码是为了让语言专家弄明白细

节。

仔细研究扩充的伪代码可能没什么用——这与你的学习方式有关。显然，分析真正使用

yield from 结构的代码要比深入研究实现这一结构的伪代码更有好处。不过，我见过的 yield from 示例几乎都使用 asyncio 模块做异步编程，因此要有有效的事件循环才能 运行。第 18 章会多次用到 yield from 结构。 16.11 节中有几个链接，指向使用 yield from 结构的一些有趣代码，而且无需事件循环。

下面分析一个使用协程的经典案例：仿真编程。这个案例没有展示 yield from 结构的用

法，但是揭示了如何使用协程在单个线程中管理并发活动。

### 16.9 使用案例：使用协程做离散事件仿真

协程能自然地表述很多算法，例如仿真、游戏、异步I/O，以及其他事件驱动型编程

形式或协作式多任务。 10

——Guido van Rossum 和 Phillip J. Eby PEP 342—Coroutines via Enhanced Generators

| 10PEP 342 (<https://www.python.org/dev/peps/pep-0342/>)中“Motivation”一节开头的第一句话。

本节我会说明如何只使用协程和标准库中的对象实现一个特别简单的仿真系统。在计算机 科学领域，仿真是协程的经典应用。第一门面向对象的语言 Simula 引入了协程这个概

念，目的就是为了支持仿真。

下述仿真示例不是为了做学术研究。协程是asyncio包的基础构建。通过仿

真系统能说明如何使用协程代替线程实现并发的活动，而且对理解第 18 章讨论的

asyncio 包有极大的帮助。

分析示例之前，先简单介绍一下仿真。

16.9.1 离散事件仿真简介

离散事件仿真(Discrete Event Simulation，DES)是一种把系统建模成一系列事件的仿真

类型。在离散事件仿真中，仿真“钟”向前推进的量不是固定的，而是直接推进到下一个事

件模型的模拟时间。假如我们抽象模拟出租车的运营过程，其中一个事件是乘客上车，下

一个事件则是乘客下车。不管乘客坐了 5 分钟还是 50 分钟，一旦乘客下车，仿真钟就会 更新，指向此次运营的结束时间。使用离散事件仿真可以在不到一秒钟的时间内模拟一年

的出租车运营过程。这与连续仿真不同，连续仿真的仿真钟以固定的量(通常很小)不断

向前推进。

显然，回合制游戏就是离散事件仿真的例子：游戏的状态只在玩家操作时变化，而且一旦

玩家决定下一步怎么走了，仿真钟就会冻结。而实时游戏则是连续仿真，仿真钟一直在运

行，游戏的状态在一秒钟之内更新很多次，因此反应慢的玩家特别吃亏。

这两种仿真类型都能使用多线程或在单个线程中使用面向事件的编程技术(例如事件循环

驱动的回调或协程)实现。可以说，为了实现连续仿真，在多个线程中处理实时并行的操

作更自然。而协程恰好为实现离散事件仿真提供了合理的抽象。 SimPy[1](#bookmark6) 是一个实现离散 事件仿真的 Python 包，通过一个协程表示离散事件仿真系统中的各个进程。

在仿真领域，进程这个术语指代模型中某个实体的活动，与操作系统中的进程 无关。仿真系统中的一个进程可以使用操作系统中的一个进程实现，但是通常会使用 一个线程或一个协程实现。

如果对仿真感兴趣，值得研究一下SimPy。不过，在这一节我会说明如何只使用标准库提

供的功能实现一个特别简单的离散事件仿真系统。我的目的是增进你对使用协程管理并发

操作的感性认知。若想理解下一节所讲的内容，要仔细研究，不过这一付出能得到很大回

报，让我们洞悉 asyncio、Twisted 和 Tornado 等库是如何在单个线程中管理多个并发活 动的。

16.9.2 出租车队运营仿真

仿真程序 taxi_sim+py 会创建几辆出租车，每辆车会拉几个乘客，然后回家。出租车首先

驶离车库，四处徘徊，寻找乘客；拉到乘客后，行程开始；乘客下车后，继续四处徘徊。

四处徘徊和行程所用的时间使用指数分布生成。为了让显示的信息更加整洁，时间使用取 整的分钟数，不过这个仿真程序也能使用浮点数表示耗时。 [2](#bookmark8) 每辆出租车每次的状态变

化都是一个事件。图 16-3 是运行这个程序的输出示例。

$ python3 taxi_sln.py -s 3

taxi: 0 Event(time=0, proc=0, action:1leave garage')

taxi: 0 Event(tine=2, proc=0, action='pick up passenger') taxi: 1    Event(tine=5, proc=i, action='leave garage')

taxi: 1    Event(tlne=8, proc=i, action='pick up passenger')

taxi: 2    Event(time=10, proc=2, action:'leave garage')

taxi:    2    Event(tine=15,    proc=2,    action='pick    up passenger')

taxi:    2    Event(time=17,    proc=2,    action='drop    off passenger')

taxi: 0 Event(tine=18, proc=0, actlon='drop off passenger') taxi:    2    Event(tirne=18,    proc=2,    action='pick    up passenger')

taxi:    2    Event(tine=25,    proc=2,    action='drop    off passenger')

taxi: 1 Event(tine=27, proc=l, action='drop off passenger') taxi: 2    Event(tlne=27, proc=2, actlon='pick up passenger')

taxi: 0 Event(tine=28, proc=0, action='pick up passenger') taxi: 2    Event(tine=40, proc=2, action=*clrop off passenger')

taxi: 2    Event(time=44, proc=2, action='pick up passenger')

taxi: 1    Event(tlne=55, proc=i, action='pick up passenger')

taxi: 1    Event(tine=59, proc=l, action='drop off passenger')

taxi: 0 Event(tine=65, proc=0, actlon='drop off passenger') taxi: 1 Event(tine=65, proc=l, action='pick up passenger') taxi: 2    Event(tlne=65, proc=2, action='drop off passenger')

taxi: 2    Event(tine=72, proc=2, action='pick up passenger')

taxi: 0 Event(tlne=76, proc=0, action='going hone') taxi: 1    Event(tine=80, proc=l, action='drop off passenger')

taxi: 1    Event(tlne=88, proc=l, action='pick up passenger')

taxi:    2    Event(tine=95,    proc=2,    action='drop    off passenger')

taxi:    2    Event(tine=97,    proc=2,    action='pick    up passenger')

taxi:    2    Event(tine=98,    proc=2,    action='drop    off passenger')

taxi: 1 Event(tine=106, proc=l, actlon='drop off passenger') taxi: 2    Event(time=109, proc=2, action='going home')

taxi: 1 Event(tine=li0, proc=l, actlon='going hone1) *** end of events ***

![img](08414584Python-78.jpg)



图 16-3：运行 taxi_sim.py 创建 3 辆出租车的输出示例。 -s 3 参数设置随机数生成器 的种子，这样在调试和演示时可以重复运行程序，输出相同的结果。不同颜色的箭头 表示不同出租车的行程 13

| 13图16-3的彩色图片可从本书页面(<http://www.ituring.com.cn/book/1564>)的“随书下载”部分获取。-编者注

图 16-3 中最值得注意的一件事是，3 辆出租车的行程是交叉进行的。那些箭头是我加上

的，为的是让你看清各辆出租车的行程：箭头从乘客上车时开始，到乘客下车后结束。有

了箭头，能直观地看出如何使用协程管理并发的活动。

图 16-3 中还有几件事值得注意。

•出租车每隔5分钟从车库中出发。

•    0号出租车2分钟后拉到乘客（time=2），1号出租车3分钟后拉到乘客

（time=8） ，2号出租车5分钟后拉到乘客（time=15）。

•    0号出租车拉了两个乘客（紫色箭头）：第一个乘客从time=2时上车，到time=18 时下车；第二个乘客从 time=28 时上车，到 time=65 时下车——这是此次仿真中最 长的行程。

•    1号出租车拉了四个乘客（绿色箭头），在time=110时回家。

•    2号出租车拉了六个乘客（红色箭头），在time=109时回家。这辆车最后一次行程 从 time=97 时开始，只持续了一分钟。 14

•    1号出租车的第一次行程从time=8时开始，在这个过程中2号出租车离开了车库

（time=10），而且完成了两次行程（那两个短的红色箭头）。

•在此次运行示例中，所有排定的事件都在默认的仿真时间内（180分钟）完成；最后 一次事件发生在 time=110 时。

14乘客是我，我发现忘了带钱包。

仿真结束时可能还有未完成的事件。如果是这种情况，最后一条消息会是下面这样：

*** end of simulation time: 3 events pending ***

taxi_sim.py 脚本的完整代码在示例 A-6 中，本章只会列出与协程相关的部分。真正重要的

函数只有两个：taxi_process （—个协程），以及执行仿真主循环的Simulator.run

方法。

示例 16-20 是 taxi_process 函数的代码。这个协程用到了别处定义的两个对 象： compute_delay 函数，返回单位为分钟的时间间隔； Event 类，一个 namedtuple，定义方式如下：

Event = collections.namedtuple('Event', 'time proc action')

在 Event 实例中， time 字段是事件发生时的仿真时间， proc 字段是出租车进程实例的 编号， action 字段是描述活动的字符串。

下面逐行分析示例 16-20 中的 taxi_process 函数。

示例 16-20 taxi_sim.py： taxi_process 协程，实现各辆出租车的活动

for i in range(trips):    ©

time = yield Event(time, ident, 'pick up passenger') © time = yield Event(time, ident, 'drop off passenger')❺

yield Event(time, ident, 'going home') ©

\#出租车进程结束©

❶ 每辆出租车调用一次 taxi_process 函数，创建一个生成器对象，表示各辆出租车的 运营过程。 ident 是出租车的编号（如上述运行示例中的 0、1、2）；trips 是出租车回

家之前的行程数量；start_time是出租车离开车库的时间。

❷产出的第一个Event是'leave garage'。执行到这一行时，协程会暂停，让仿真主

循环着手处理排定的下一个事件。需要重新激活这个进程时，主循环会发送（使用 send

方法）当前的仿真时间，赋值给 time。

❸ 每次行程都会执行一遍这个代码块。

❹ 产出一个 Event 实例，表示拉到乘客了。协程在这里暂停。需要重新激活这个协程 时，主循环会发送（使用 send 方法）当前的时间。

❺ 产出一个 Event 实例，表示乘客下车了。协程在这里暂停，等待主循环发送时间，然

后重新激活。

❻ 指定的行程数量完成后， for 循环结束，最后产出 'going home' 事件。此时，协程

最后一次暂停。仿真主循环发送时间后，协程重新激活；不过，这里没有把产出的值赋值

给变量，因为用不到了。

❼ 协程执行到最后时，生成器对象抛出 StopIteration 异常。

你可以在Python控制台中调用taxi_process函数，自己“驾驶”（drive） —辆出租车

15，如示例 16-21 所示。

15描述协程的操作时经常使用“drive”这个动词，例如：客户代码把值发给协程，驱动协程。在示例16-21中，客户代码 是你在控制台中输入的代码。（drive —词有不同的含义，因此在不同的语境中有不同的译法，例如这个脚注所在的那

句话中译为“驾驶”。 ——译者注）

示例 16-21 驱动 taxi_process 协程

\>>> from taxi_sim import taxi_process

\>>> taxi = taxi_process(ident=13, trips=2, start_time=0) O >>> next(taxi) ©

Event(time=0, proc=13, action='leave garage')

\>>> taxi.send(_.time + 7) ©

Event(time=7, proc=13, action='pick up passenger') ©

\>>> taxi.send(_.time + 23) ❺

Event(time=30, proc=13, action='drop off passenger')

\>>> taxi.send(_.time + 5) ©

Event(time=35, proc=13, action='pick up passenger')

\>>> taxi.send(_.time + 48) ©

Event(time=83, proc=13, action='drop off passenger')

\>>> taxi.send(_.time + 1)

Event(time=84, proc=13, action='going home')❻

\>>> taxi.send(_.time + 10) 0 Traceback (most recent call last):

File "<stdin>", line 1, in <module>

StopIteration

❶创建一个生成器对象，表示一辆出租车。这辆出租车的编号是13 (ident=13)，从 t=0 时开始工作，有两次行程。

❷ 预激协程；产出第一个事件。

❸ 现在可以发送当前时间。在控制台中， _ 变量绑定的是前一个结果；这里我在时间上 加 7，意思是这辆出租车 7 分钟后找到第一个乘客。

❹ 这个事件由 for 循环在第一个行程的开头产出。

❺ 发送 _.time + 23，表示第一个乘客的行程持续了 23 分钟。

❻ 然后，这辆出租车会徘徊 5 分钟。

❼ 最后一次行程持续 48 分钟。

❽ 两次行程完成后， for 循环结束，产出 'going home' 事件。

❾ 如果尝试再把值发给协程，会执行到协程的末尾。协程返回后，解释器会抛出

StopIteration 异常。

注意，在示例 16-21 中，我使用控制台模拟仿真主循环。我从 taxi 协程产出的 Event 实 例中获取 .time 属性，随意与一个数相加，然后调用 taxi.send 方法发送两数之和，重 新激活协程。在这个仿真系统中，各个出租车协程由 Simulator.run 方法中的主循环驱 动。仿真“钟”保存在 sim_time 变量中，每次产出事件时都会更新仿真钟。

为了实例化 Simulator 类， taxi_sim.py 脚本的 main 函数构建了一个 taxis 字典，如下 所示：

| taxis | = {i: taxi_process(i, | (i + 1) * 2, i * DEPARTURE_INTERVAL) |
| ----- | --------------------- | ------------------------------------ |
|       | for i in range(num    | taxis)}                              |
| sim = | Simulator(taxis)      |                                      |

DEPARTURE_INTERVAL 的值是 5；如果 num_taxis 的值与前面的运行示例一样也是 3， 这三行代码的作用与下述代码一样：

taxis =    {0:    taxi_process(ident=0,    trips=2,    start_time=0),

1:    taxi_process(ident=1,    trips=4,    start_time=5),

2:    taxi_process(ident=2,    trips=6,    start_time=10)}

sim = Simulator(taxis)

因此， taxis 字典的值是三个参数不同的生成器对象。例如， 1 号出租车从 start_time=5 时开始，寻找四个乘客。构建 Simulator 实例只需这个字典参数。

Simulator.__init__ 方法如示例 16-22 所示。 Simulator 类的主要数据结构如下。

self.events

PriorityQueue 对象，保存 Event 实例。元素可以放进（使用 put 方 法）PriorityQueue对象中，然后按item[0]（即Event对象的time属性）依序取出

（使用 get 方法）。

self.procs

一个字典，把出租车的编号映射到仿真过程中激活的进程（表示出租车的生成器对 象）。这个属性会绑定前面所示的 taxis 字典副本。

示例 16-22 taxi _sim.py：S i m u l a to r 类的初始化方法

class Simulator:

def __init__(self, procs_map):

self.events = queue.PriorityQueue() O self.procs = dict(procs_map) ©

❶ 保存排定事件的 PriorityQueue 对象，按时间正向排序。

❷ 获取的 procs_map 参数是一个字典（或其他映射），可是又从中构建一个字典，创建 本地副本，因为在仿真过程中，出租车回家后会从 self.procs 属性中移除，而我们不想 修改用户传入的对象。

优先队列是离散事件仿真系统的基础构件：创建事件的顺序不定，放入这种队列之后，可

以按照各个事件排定的时间顺序取出。例如，可能会把下面两个事件放入优先队列：

Event(time=14, proc=0, action='pick up passenger') Event(time=11, proc=1, action='pick up passenger')

这两个事件的意思是，0号出租车14分钟后拉到第一个乘客，而1号出租车（time=10 时出发）1分钟后（time=11）拉到乘客。如果这两个事件在队列中，主循环从优先队列 中获取的第一个事件将是 Event（time=11, proc=1, action='pick up passenger'）。

下面分析这个仿真系统的主算法-Simulator.run方法。在main函数中，实例化

Simulator 类之后立即就调用了这个方法，如下所示：

sim = Simulator(taxis) sim.run(end_time)

Simulator 类带有注解的代码清单在示例 16-23 中，下面先概述 Simulator.run 方法实 现的算法。

(1)    迭代表示各辆出租车的进程。

a.    在各辆出租车上调用 next() 函数，预激协程。这样会产出各辆出租车的第一个事

件。

b.    把各个事件放入 Simulator 类的 self.events 属性(队列)中。

(2)    满足 sim_time < end_time 条件时，运行仿真系统的主循环。

a.    检查 self.events 属性是否为空；如果为空，跳出循环。

b.    从 self.events 中获取当前事件(current_event)，即 PriorityQueue 对象

中时间值最小的 Event 对象。

c.    显示获取的 Event 对象。

d.    获取current_event的time属性，更新仿真时间。

e.    把时间发给current_event的proc属性标识的协程，产出下一个事件 (next_event)。

f.    把 next_event 添加到 self.events 队列中，排定 next_event。

Simulator 类完整的代码如示例 16-23 所示。

示例16-23 taxi_sim.py： Simulator，一个简单的离散事件仿真类；关注的重点是 run 方法

class Simulator:

def __init__(self, procs_map):

self.events = queue.PriorityQueue()

self.procs = dict(procs_map)

def run(self, end_time): O

"""排定并显示事件，直到时间结束 """

\# 排定各辆出租车的第一个事件

for _, proc in sorted(self.procs.items()):    ©

first_event = next(proc) © self.events.put(first_event) ©

\# 这个仿真系统的主循环

sim_time = 0    ❺

while sim_time < end_time: © if self.events.empty(): O

print('*** end of events ***') break

sim_time, proc_id, previous_action = current_event o print('taxi:', proc_id, proc_id * '    ', current_event) ©

active_proc = self.procs[proc_id] ®

next_time = sim_time + compute_duration(previous_action) ® try:

next_event = active_proc.send(next_time)❽ except StopIteration:

del self.procs[proc_id] © else:

self.events.put(next_event) ©

else: ©

msg = '*** end of simulation time: {} events pending ***' print(msg.format(self.events.qsize()))

©否则，把next_event放入队列中。

©如果循环由于仿真时间到了而退出，显示待完成的事件数量(有时可能碰巧是零)。

注意，示例 16-23 中的 Simulator.run 方法有两处用到了第 15 章介绍的 else 块，而且 都不在 if 语句中。

•主while循环有一个else语句，报告仿真系统由于到达结束时间而结束，而不是由 于没有事件要处理而结束。

•靠近主while循环底部那个try语句把next_time发给当前的出租车进程，尝试获 取下一个事件(next_event)，如果成功，执行else块，把next_event放入 self.events 队列中。

我觉得，如果没有这两个 else 块， Simulator.run 方法的代码会有点难以阅读。

这个示例的要旨是说明如何在一个主循环中处理事件，以及如何通过发送数据驱动协程。

这是 asyncio 包底层的基本思想，我们在第 18 章会学习这个包。

### 16.10 本章小结

Guido van Rossum 写道，生成器有三种不同的代码编写风格：

有传统的“拉取式”(迭代器)、“推送式”(例如计算平均值那个示例)，还有“任务 式”(读过 Dave Beazley 写的协程教程了吗……)。 17

[17](https://mail.python.org/pipermail/python-ideas/2009-April/003884.html)[摘自对 Python-ideas 邮件列表中 “Yield-From: F inalization guarantee s”消息的回复(https://mail. python. org/pipermail/python-](https://mail.python.org/pipermail/python-ideas/2009-April/003884.html)ideas/2009-April/003884.html)。Guido 所说的 David Beazley 写的教程是“A Curious Course on Coroutines and Concurrency”(<http://www.dabeaz.com/coroutines/>)。

第 14 章专门介绍了迭代器，本章则介绍了“推送式”协程，还介绍了特别简单的“任务

式”——仿真示例中的出租车进程。第 18 章会在并发编程中使用这两种技术实现异步任 务。

计算移动平均值的示例展示了协程的常见用途：累加器，处理接收到的值。我们知道，可

以在协程上应用装饰器，预激协程；在某些情况下，这么做更方便。不过要记住，预激装

饰器与协程的某些用法不兼容。尤其是yield from subgenerator()，这个结构假定 subgenerator 没有预激，然后自动预激。

每次调用 send 方法时，作为累加器使用的协程可以获取部分结果，不过能返回值的协程 更有用。这个特性在 PEP 380 中定义，于 Python 3.3 引入。我们知道，现在生成器中的

return the_result 语句会抛出 StopIteration(the_result) 异常，这样调用方可以 从异常的value属性中获取the_result。这样获取协程的结果还是很麻烦，不过PEP 380 引入的 yield from 句法能自动处理。

探讨 yield from 结构时，我们首先从使用简单的迭代器的示例入手，然后又举了一个例 子，重点说明 yield from 结构的三个主要组件：委派生成器(在定义体中使用 yield from)， yield from 激活的子生成器，以及通过委派生成器中 yield from 表达式架设

起来的通道把值发给子生成器，从而驱动整个过程的客户代码。最后，那一节参照 PEP 380 中使用的英语和类似 Python 的伪代码分析了 yield from 结构的正式定义。

本章最后举了一个离散事件仿真示例，说明如何使用生成器代替线程和回调，实现并发。

那个出租车仿真系统虽然简单，但是首次一窥了事件驱动型框架(如 Tornado 和

asyncio)的运作方式：在单个线程中使用一个主循环驱动协程执行并发活动。使用协程

做面向事件编程时，协程会不断把控制权让步给主循环，激活并向前运行其他协程，从而

执行各个并发活动。这是一种协作式多任务：协程显式自主地把控制权让步给中央调度程

序。而多线程实现的是抢占式多任务。调度程序可以在任何时刻暂停线程(即使在执行一

个语句的过程中)，把控制权让给其他线程。

最后要说明一点，本章对协程的定义是宽泛的、不正式的，即：通过客户调用 .send(...) 方法发送数据或使用 yield from 结构驱动的生成器函数。写作本书

时， “PEP 342— Coroutines via Enhanced Generators”( [https://www.python.org/dev/peps/pep-0342/](https://www.python.org/dev/peps/pep-0342/)%e5%92%8c%e7%8e%b0%e6%9c%89%e7%9a%84%e5%a4%a7%e5%a4%9a%e6%95%b0)[)和现有的大多数](https://www.python.org/dev/peps/pep-0342/)%e5%92%8c%e7%8e%b0%e6%9c%89%e7%9a%84%e5%a4%a7%e5%a4%9a%e6%95%b0)[ Python 书籍都使用这个宽泛的定义。第 18 章介绍的 asyncio 库](https://www.python.org/dev/peps/pep-0342/)

建构在协程之上，不过采用的协程定义更为严格：在 asyncio 库中，协程(通常)使用

@asyncio.coroutine 装饰器装饰，而且始终使用 yield from 结构驱动，而不通过直 接在协程上调用 .send(...) 方法驱动。当然，在 asyncio 库的底层，协程使用 next(...) 函数和 .send(...) 方法驱动，不过在用户代码中只使用 yield from 结构

驱动协程运行。

### 16.11 延伸阅读

David Beazley是Python生成器和协程的终极权威。他与Brian Jones合著的《Python Cookbook (第3版)中文版》一书中有很多使用协程编写的诀窍。Beazley在PyCon期间 开设的课程兼有深度和广度，因此享有盛名。首先是PyCon US 2008期间的“Generator Tricks for Systems Programmers”课程(<http://www.dabeaz.com/generators/>)，在 PyCon US 2009 期间又开设了 声名远播的“A Curious Course on Coroutines and Concurrency”课程

(<http://www.dabeaz.com/coroutines/>，三个部分的全部视频链接很难找到：第一部 分，http://pyvideo.org/video/213；第二部分，http://pyvideo.org/video/215;第三部 分， <http://pyvideo.org/video/214>) 。他最新的课程在蒙特利尔 PyCon 2014 期间开设，题 为“Generators: The Final Frontier” (<http://www.dabeaz.com/finalgenerator/>)。在这个课程 中，他举了更多并发的例子，因此与本书第 18 章的话题联系更大。他根本不担心学员的 大脑会爆炸，因此在“The Final Frontier”课程的最后一部分用协程代替了经典的访问者模 式，用于计算算术表达式。

使用协程能以多种新方式组织代码，不过与递归和多态(动态调度)一样，要花点时间才

能习惯。James Powell 写了一篇文章，题为“Greedy algorithm with

coroutines” (<http://seriously.dontusethiscode.com/2013/05/01/greedy-coroutine.html>) 。他在这 篇文章中使用协程重写了经典的算法。你可能还想浏览 ActiveState Code 诀窍数据库

<https://code.activestate.com/recipes/>)中标记为协程的流行诀窍

(<https://code.activestate.com/recipes/tags/coroutine/>) 。

Paul Sokolovsky 为 Damien George 开发的超级精简的 MicroPython(<http://micropython.org/>， 针对微控制器)解释器实现了 yield from 结构。在研究这个特性的过程中，他制作了非 常详细的示意图([https://dl+dropboxusercontent+com/u/44884329/yield-from+pdf](https://dl.dropboxusercontent.com/u/44884329/yield-from.pdf))，解说 yield from 结构的工作原理，并在 python-tulip 邮件列表中分享。 Sokolovsky 很友好，允 许我把那个 PDF 文件复制到本书的网站中，那个文件的固定链接是

<http://flupy.org/resources/yield-from.pdf>。

写作本书时，只有asyncio库本身和使用这个库的代码大量使用yield from。我花了

很多时间，想找到不依赖 asyncio 库的 yield from 示例。 Greg Ewing(PEP 380 的作 者，为CPython实现了 yield from)发表了一些yield from的使用示例

(<http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/yield_from.html>[) ： BinaryTree 类、一个简单的 XM](http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/yield_from.html)L 解析器和一个任务调度程序。

Brett Slatkin写的《Effective Python：编写高质量Python代码的59个有敛方法》一书中的 第 40 条短小精辟，题为“考虑用协程来并发地运行多个函数”(网上有免费的英文版样 [章， ](http://www.effectivepython.com/2015/03/10/consider-coroutines-to-run-many-functions-concurrently/)[http://www.effectivepython.com/2015/03/10/consider-coroutines-to-run-many-functions-](http://www.effectivepython.com/2015/03/10/consider-coroutines-to-run-many-functions-concurrently/)concurrently/)。这一节中使用yield from驱动生成器的示例是我见过最棒的：那个示 例实现了 John Conway 发明的“生命游

戏” (<https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life>) ，使用协程管理游戏运行过 程中各个细胞的状态。该书的随书代码在一个 GitHub 仓库中

(<https://github.com/bslatkin/effectivepython>) 。我重构了那个“生命游戏”示例——把 Slatkin

书中的函数和类与测试代码分开(原来的代

码： <https://github.com/bslatkin/effectivepython/blob/master/example_code/item_40.py>) 。我还 编写了 doctest 形式的测试，因此不用运行脚本就能看到各个协程和类的输出。重构后的

示例发布在 GitHub Gist 网站上([https://gist+github+com/ramalho/da5590bc38c973408839](https://gist.github.com/ramalho/da5590bc38c973408839))。

还有几个有趣的示例没用 asyncio 库，只用了 yield from：Peter Otten 在 Python Tutor 邮件列表中发布的消息， “Comparing two CSV files using

Python” ([https://mail+python+org/pipermail/tutor/2015-February/104200+html](https://mail.python.org/pipermail/tutor/2015-February/104200.html)) ；Ian Ward 以 iPython Notebook 形式发布的“Iterables, Iterators, and Generators”教程

(http://nbviewer+ipython+org/github/wardi/iterables-iterators-generators/blob/master/Iterables,%20Iterators,%20Generators+ipynb) ，实现的是剪刀石头布

游戏。

Guido van Rossum 在 python-tulip Google Group 中发表了 一篇内容很长的消息，题为“The [difference between ](https://groups.google.com/forum/%23!msg/python-tulip/bmphRrryuFk/aB45sEJUomYJ)[yield and yield-from” (https://groups+google+com/forum/#!msg/python-](https://groups.google.com/forum/%23!msg/python-tulip/bmphRrryuFk/aB45sEJUomYJ)tulip/bmphRrryuFk/aB45sEJUomYJ)，值得一读。2009 年 3 月 21 日，Nick Coghlan 在 Python-Dev 邮件列表中发布了带有大量注释的 yield from 扩充实现

([https://mail+python+org/pipermail/python-dev/2009-March/087382+html](https://mail.python.org/pipermail/python-dev/2009-March/087382.html)) 。在那篇消息中， 他写道：

不管人们是否觉得使用 yield from 结构的代码难以理解，也不管人们能否领会协作 式多线程相关的概念， yield from 结构底层的精巧处理能实现真正的嵌套生成器。

Yury Selivanov 撰写的“PEP 492—Coroutines with async and await

syntax” ([https://www+python+org/dev/peps/pep-0492/](https://www.python.org/dev/peps/pep-0492/))提议为 Python 增加两个关键

字：async和await。async与其他现有的关键字结合使用，用于定义新的语言结构。例 如， async def 用于定义协程， async for 用于使用异步迭代器(实现 __aiter__ 和 __anext__ 方法，这是协程版的 __iter__ 和 __next__ 方法)迭代可迭代的异步对象。 为了避免与即将引入的 async 关键字冲突， asyncio.async() 函数将在 Python 3+4+4 中 重命名为 asyncio.ensure_future()。 await 关键字的作用与 yield from 结构类似， 不过只能在以async def定义的协程(禁止使用yield和yield from)中使用。PEP 492 使用新句法把发展成类似协程对象的生成器与全新的原生协程对象明确地区分开了。 得益于 async 和 await 关键字，以及几个特殊的新方法， Python 语言将对原生的协程对 象提供更好的支持。协程已经做好准备，会成为 Python 未来特别重要的特性，因此 Python 语言应该更好地集成协程。

使用离散事件仿真系统做试验是熟悉协作式多任务的好方法。维基百科中的“Discrete event simulation”一文([https://en+wikipedia+org/wiki/Discrete_event_simulation](https://en.wikipedia.org/wiki/Discrete_event_simulation))是不错的入 门资料。18Ashish Gupta 写的短篇教程“Writing a Discrete Event Simulation: Ten Easy Lessons” ([http://www+cs+northwestern+edu/~agupta/_projects/networking/QueueSimulation/mm1+h](http://www.cs.northwestern.edu/~agupta/_projects/networking/QueueSimulation/mm1.html)

说明了如何自己动手(不使用特别的库)编写离散事件仿真系统。那篇教程中的代码使用 Java编写，因此是基于类的，而且没使用协程，不过可以轻松地移植到Python。除了代码 之外，那篇简短的教程还介绍了离散事件仿真的术语和组件。把 Gupta 教程中的示例转换 成 Python 类，然后再转换成利用协程的类，是个很好的练习。

18如今，即使终身教授也同意，维基百科几乎是学习任何计算机科学知识的入门首选。对其他知识而言虽然不是如 此，但是在计算机科学这方面，维基百科特别棒。

如果想使用现成的Python协程库，可以使用SimPy。这个库的在线文档

(<https://simpy.readthedocs.org/en/latest/>)中说道:

SimPy 是使用标准的 Python 开发的基于进程的离散事件仿真框架，事件调度程序基于

Python 的生成器实现，因此还可用于异步网络或实现多智能体系统（即可模拟，也可

真正通信）。

协程不是特别新的Python特性，但是得到异步编程框架支持（Tornado最先支持）之前， 只在较窄的应用领域内使用。 Python 3.3 引入的 yield from 结构和 Python 3.4 添加的 asyncio 包可能会提升协程（和 Python 3.4 本身）的使用量。但写作本书时， Python 3.4 发布还不到一年，因此观看 David Beazley 的课程，阅读涉及这个话题的经典实例时，不 会有太多内容深入探讨 Python 协程编程。不过，这只是暂时的。

杂谈

raise from lambda

对编程语言来说，关键字的作用是建立控制流程和表达式计算的基本规则。

语言的关键字像是棋盘游戏中的棋子。对国际象棋来说，关键字是會、徵、置、J。、 和；对围棋来说，关键字是*。

国际象棋的棋手实现计划时，有六种类型的棋子可用；而围棋的棋手看起来只有一种

类型的棋子可用。可是，在围棋的玩法中，相邻的棋子能构成更大更稳定的棋子，形

状各异，不受束缚。围棋棋子的某些排列是不可摧毁的。围棋的表现力比国际象棋

强。围棋的开局走法有 361 种，大约有 1e+170 个合规的位置；而国际象棋的开局走 法有 20 种，有 1e+50 个位置。

如果为国际象棋添加一个新棋子，将带来颠覆性的改变；为编程语言添加一个新的关

键字也是如此。因此，语言的设计者谨慎考虑引入新关键字是合理的。

表16-1：不同编程语言中的关键字数量

| 关键字数量 | 语言         | 备注                                                      |
| ---------- | ------------ | --------------------------------------------------------- |
| 5          | Smalltalk-80 | 以句法极简而著称                                          |
| 25         | Go           | 编程语言，而不是围棋*                                     |
| 32         | C            | 指ANSI C。C99有37个关键字，C11有44个                      |
| 33         | Python       | Python 2.7 有 31 个关键字， Python 1.5 有 28 个           |
| 41         | Ruby         | 关键字可以作为标识符使用（例如，class也是一个方法的名称） |

|      |            |                                                              |
| ---- | ---------- | ------------------------------------------------------------ |
| 49   | Java       | 与C语言一样，基本类型的名称(char、float等)是保留字           |
| 60   | JavaScript | 包含Java 1+0的所有关键字，很多都没用([http://mzlla/1JIr8fM](http://mzl.la/1JIr8fM)) |
| 65   | PHP        | PHP 5+3之后引入了七个关键字，如goto、trait和yield            |
| 85   | C++        | 据 cppreference+com 网站给出的信息[(](http://en.cppreference.com/w/cpp/keyword)[http://en+cppreference+com/w/cpp/keyword](http://en.cppreference.com/w/cpp/keyword))， C++11 在现有的 75 个关键字的基础上添加了 10 个 |
| 555  | COBOL      | 这不是我捏造的。参见 IBM ILE COBOL 手册[(](http://publib.boulder.ibm.com/iseries/v5r2/ic2924/books/x091317316.htm)[http://publib+boulder+ibm+com/iseries/v5r2/ic2924/books/x091317316+htm](http://publib.boulder.ibm.com/iseries/v5r2/ic2924/books/x091317316.htm)) |
| TO   | Scheme     | 任何人都能定义新关键字                                       |

*围棋的英文是Go,因此作者备注这里说的是Go语言。——译者注

Python 3 添加了 nonlocal 关键字，把 None、True 和 False 提升为关键字，废弃了 print和exec。在语言的发展过程中，弃用关键字十分罕见。表16-1列出了几门语 言，按照关键字的数量排序。

Scheme 继承了 Lisp 的宏，允许任何人创建特殊的形式，为语言添加新的控制结构和 计算规则。用户定义的这种标识符叫作“句法关键字”。 Scheme R5RS 标准声称， “这 门语言没有保留的标识符”(标准的第 45

页， [http://www+schemers+org/Documents/Standards/R5RS/r5rs+pdf](http://www.schemers.org/Documents/Standards/R5RS/r5rs.pdf)) ，但是 MIT/GNU [Scheme ](http://www.gnu.org/software/mitscheme/documentation/mit-scheme-ref/Special-Form-Syntax.html%23Special-Form-Syntax)[(http://www+gnu+org/software/mitscheme/documentation/mit-scheme-ref/Special-](http://www.gnu.org/software/mitscheme/documentation/mit-scheme-ref/Special-Form-Syntax.html%23Special-Form-Syntax)Form-Syntax+html#Special-Form-Syntax)这种特殊的实现预定义了 34个句法关键字， 例如if、lambda和define-syntax (用于创建新关键字的关键字)。18 Python 像国际象棋，而 Scheme 像围棋。

现在，回到 Python 句法。我觉得 Guido 对关键字的态度过于保守了。关键字的数量 应该少，添加新关键字可能会破坏大量代码，但是在循环中使用 else 揭示了一个递 归问题：在更适合使用新关键字的地方重用现有的关键字。在 for、 while 和 try 的上下文中，应该使用 then 关键字，而不该妄用 else。

在这个问题上，最严重的一点是重用def。现在，这个关键字用于定义函数、生成器 和协程，而这些对象之间的差异很大，不应该使用相同的句法声明。 19

引入 yield from 句法尤其让人失望。再次声明，我觉得真的应该为 Python 使用者 提供新的关键字。更糟的是，这开启了新的趋势：把现有的关键字串起来，创建新的 句法，而不添加描述性的合理关键字。恐怕有一天我们要苦苦思索 raise from lambda 是什么意思。

突发新闻

完成本书的技术审校之后，Yury Selivanov提交的“PEP 492 — Coroutines with async and await syntax” ([https://www+python+org/dev/peps/pep-0492/](https://www.python.org/dev/peps/pep-0492/))好像要被接受了，将在 Python 3.5 中实现。[3](#bookmark13)Guido van Rossum 和 Victor Stinner 都支持这个 PEP，前者是 Python 语言的创造者，后者是 asyncio 库的主要维护者，而 asyncio 库将是新句法 的主要使用案例。回应 Selivanov 在 Python-ideas 邮件列表中发布的消息

[https://mail+python+org/pipermail/python-ideas/2015-April/033007+html](https://mail.python.org/pipermail/python-ideas/2015-April/033007.html))时，Guido 甚 至暗示，为了实现这个PEP[4](#bookmark14)，可能会延迟发布Python 3.5 (<https://mail.python.org/pipermail/pythonideas/2015-April/033050.html>) 。 当然，这会平息前一节所述的大部分抱怨。

19“The Value Of Syntax?”一文([http://lambda-the-ultimate+org/node/4295](http://lambda-the-ultimate.org/node/4295))对可扩展的句法和编程语言的可用性做了有趣的 探讨。Lambda the Ultimate 讨论组([http://lambda-the-ultimate+org/](http://lambda-the-ultimate.org/))是编程语言极客的度假胜地。

[1](#footnote1)

参见 SimPy 的官方文档(<https://simpy.readthedocs.org/en/latest/>)。不要和著名的 SymPy ([http://www. sympy.org](http://www.sympy.org) )混淆

了。 SymPy 是一个符号数学库，与 DES 无关。

[2](#footnote2)

我不是运营出租车队的行家，因此别太在意显示的时间。离散事件仿真经常使用指数分布。你会看到一些非常短的

行程，你就假设那是一个雨天，一些乘客坐出租车只走了一个街区。在理想的城市中，即使下雨也有出租车。

[3](#footnote3)

JavaScript、Python和其他语言都有这样的问题。推荐阅读Bob Nystrom写的“What Color Is Your Function?”一文

[4](#footnote4)

(<http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/>)。
