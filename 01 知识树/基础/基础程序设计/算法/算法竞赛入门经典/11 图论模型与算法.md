第11章 图论模型与算法

学习目标

叵掌握无根树的常用存储法和转化为有根树的方法 E掌握由表达式构造表达式树的算法 叵掌握Kruskal算法及其正确性证明，并用并查集实现 叵掌握基于优先队列的Dijkstra算法实现 E掌握基于FIFO队列的Bellman-Ford算法实现 E掌握Floyd算法和传递闭包的求法

叵理解最大流问题的概念、流量的3个条件、残量网络的概念和求法 E理解增广路定理与最小割最大流定理的证明方法，会实现Edmonds-Karp算法 叵理解最小费用最大流问题的概念，以及平行边和反向弧可能造成的问题 E会实现基于Bellman-Ford的最小费用路算法

叵学会用网络流算法求解二分图最大基数匹配和最大权完美匹配 叵学会最小费用循环流的消圈算法

本章介绍一些常见的图论模型和算法，包括最小生成树、单源最短路、每对结点的最短

路、最大流、最小费用最大流等。限于篇幅，很多算法都没有给出完整的正确性证明（很容

易在其他参考资料中找到相关内容），但给出了简单、易懂的完整代码，方便读者参考。

###### 11.1再谈树

在第6章中,我们第一次接触到二叉树；后来,又接触到了其他树状结构,如解答树、

BFS树。本节将继续讨论“树”这一话题。

有n个顶点的树具有以下3个特点：连通、不含圈、恰好包含n-1条边。有意思的是，具

备上述3个特点中的任意两个,就可以推导出第3个,有兴趣的读者不妨试着证明一下。

11.1.1无根树转有根树

输入一个n个结点的无根树的各条边，并指 定一个根结点,要求把该树转化为有根树,输出 各个结点的父结点编号。n<106 ,如图11-1所 示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-232.jpg)



【分析】

树是一种特殊的图，因此很容易想到用邻接矩阵表示。可惜，n个结点的图对应的邻接

矩阵要占用n2个元素的空间，开不下。怎么办呢？用vector数组即可。由于n个结点的树只 有n-1条边，vector数组实际占用的空间与n成正比。

vector<int> G[maxn];

void read_tree() { int u, v; scanf("%d", &n); for(int i = 0; i < n-1; i++) {

scanf("%d%d", &u, &v);

G[u].push_back(v);

G[v].push_back(u);

转化过程如下：

for(int i = 0; i < d; i++) {

int v = G[u] [i];    //结点u的第i个相邻点v

if(v != fa) dfs(v, p[v] = u);    //把v的父结点设为u ,然后递归转化以v为根的子树

}

}

主程序中设置p[root] = -1 （表示根结点的父结点不存在），然后调用dfs（root，-1）即可。 初学者最容易犯的错误之一就是忘记判断v是否和其父结点相等。如果忽略，将引起无限递

归。

11.1.2 表达式树

二叉树是表达式处理的常用工具。例 如，＜3+办*（0办^//可以表示成如图11-2所示的二 叉树。

其中，每个非叶结点表示一个运算符，左子

树是第一个运算数对应的表达式，而右子树则是

第二个运算数对应的表达式。如何给一个表达式

建立表达式树呢？方法有很多，这里只介绍一

种：找到“最后计算”的运算符（它是整棵表达式

树的根），然后递归处理。下面是程序：

const int maxn = 1000;

int lch[maxn], rch[maxn]; char op [maxn] ;

int nc = 0;    //结点数

图/1/1每-2个表结达点式的树左右子结点编号和字符



int build_tree(char* s, int x, int y) { int i, c1=-1, c2=-1, p=0;

int u;

if(y-x == 1){    // 仅一个字符，建立单独结点

u = ++nc;

lch[u] = rch[u] =

0; op[u]



= s[x];



return u;

for(i = x; i < y; i++) {

switch(s[i]) {

case '(': p++; break; case ')': p--; break;

case '+': case '-': if(!p) c1=i; break; case '*': case '/': if(!p) c2=i; break;

}

}

if(c1 < 0) c1 = c2;    // 找不到括号外的加减号,就用乘除号

if(c1 < 0) return build_tree(s, x+1, y-1);    / / 整个表达式被一对括号括起来

u = ++nc;

lch[u] = build_tree(s, x, c1); rch[u] = build_tree(s, c1+1, y); op[u] = s[c1];

return u;

}

注意上述代码是如何寻找“最后一个运算符”的。代码里用了一个变量^ ,只有当^=0时才 考虑这个运算符。为什么呢？因为括号里的运算符一定不是最后计算的,应当忽略。例如, ^+幻*'中虽然有一个加号，但却是在括号里的，实际上比它优先级高的乘号才是最后计算 的。由于加减和乘除号都是左结合的，最后一个运算符才是最后计算的，所以用两个变量C1 和c2分别记录“最右”出现的加减号和乘除号。

再接下来的代码就不难理解了：如果括号外有加减号,它们肯定最后计算；但如果没有 加减号，就需要考虑乘除号(if(c1<0) c1 = c2 );如果全都没有，说明整个表达式外面被一 对括号括起来，把它去掉后递归调用。这样，就找到了最后计算的运算符s[c1],它的左子树 是区间[x, c1],右子树是区间[c1+1，y]。

提示11-1：建立表达式树的一种方法是每次找到最后计算的运算符,然后递归建树。

“最后计算”的运算符是在括号外的、优先级最低的运算符。如果有多个,根据结合性来选

择：左结合的(如加、减、乘、除)选最右边；右结合的(如乘方)选最左边。根据规定,

优先级相同的运算符的结合性总是相同。

例题11-1 公共表达式消除( Common Subexpression Elimination, ACM/ICPC NWERC 2009, UVa12219)

可以用表达式树来表示—个表达式。在本题中，运算符均为二元的，且运算符和运算数 均用1〜4个小写字母表示。例如，aO^aMb^aMO^b^aMb^aMOXf))可以表示为图 11-3 (a)中形式。

用消除公共表达式的方法可以减少表达式树上的结点，得到一个图，如图11-3 ( b )所 示。左图有21个点，而右图只有7个点。其表示方法为aQ^a^Xbpff^^))，其中各个结点 按照出现顺序编号为1，2，3，…，即编号k表示目前为止写下的第&个结点。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-234.jpg)



(b)



图11-3 公共表达式消除

输入—个长度不超过50000的表达式，输出—个等价的，结点最少的图

分析】

算法的第—步是构造表达式树。接下来应该怎么做呢？是否可以用两两比较的方法去掉

重复？比较两棵树的时间复杂度为0（«）（因为要递归比较二者的所有后代），再加上二重循 环枚举两棵子树，总时间复杂度高达0（«3）,无法承受。此处不仅需要更快地比较两棵树， 还需要更快地查找一棵树是否存在过。

借用第5章“集合栈计算机”的思路，用一个

map把子树映射成编号1，2,…。这样一来，子树 就可以用根的名字（字符串）和左右子结点编号 表示。如图11-4所示，用（a，0，0）表示根的名字为 a ,且左右子结点均为空（0表示不存在）的子 树，即叶子a。可以看到，下面所有叶子a的编号 都是4。再例如，（b，3,6）就是根的名字为b ,左右 两个子树的编号分别为3，6。可以看到，这样的 子树编号均为5。

这样，每次判断一棵子树是否出现过只需要 在map中查找，总时间复杂度为□（«log«）。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-236.jpg)



###### 11.2最小生成树

前面提到过，在无向图中，连通且不含圈的图称为树(Tree )。给定无向图G=(F^), 连接G中所有点，且边集是冗的子集的树称为G的生成树(Spanning Tree ),而权值最小的生 成树称为最小生成树(Minimal Spanning Tree , MST )。构造MST的算法有很多，最常见的 有两个：Kruskal算法和Prim算法。限于篇幅，这里只介绍Kruskal算法，它易于编写，而且效 率很高。

11.2.1 Kruskal 算法

Kruskal算法的第一步是给所有边按照从小到大的顺序排列。这一步可以直接使用库函数 qsort或者sort。接下来从小到大依次考查每条边(w, v)。

情况1 : w和v在同一个连通分量中，那么加入(w, v)后会形成环，因此不能选择。

情况2 :如果w和v在不同的连通分量，那么加入(w, v)—定是最优的。为什么呢？下面用 反证法——如果不加这条边能得到一个最优解7,则T+(w, v)—定有且只有一个环，而且环中 至少有一条边(W, v')的权值大于或等于(w,v)的权值。删除该边后，得到的新树r=7+(w, v)-(w', v')不会比7更差。因此，加入(w, v)不会比不加入差。

下面是伪代码：

把所有边排序，记第i小的边为e[i] ( 1<=i<m )

初始化MST为空

初始化连通分量，让每个点自成一个独立的连通分量

for(int i = 0; i < m; i++)

if(e[i] .u和e[i] .v不在同一^个连通分量){

把边e [幻加入MST

合并e[i] .u和e[i] .v所在的连通分量

}

在上面的伪代码中，最关键的地方在于“连通分量的查询与合并”：需要知道任意两个点

是否在同一个连通分量中，还需要合并两个连通分量。

最容易想到的方法是“暴力”——每次“合并”时只在MST中加入一条边(如果使用邻接矩

阵，只需G[e[i].u][e[i].v]=1 )，而“查询”时直接在MST中进行图遍历(DFS和BFS都可以判断 连通性)。遗憾的是，这个方法不仅复杂(需要写DFS或者BFS )，而且效率不高。

并查集。有—种简洁高效的方法可用来处理这个问题：使用并查集( Union-Find Set)。可以把每个连通分量看成一个集合，该集合包含了连通分量中的所有点。这些点两 两连通，而具体的连通方式无关紧要，就好比集合中的元素没有先后顺序之分，只有“属 于”和“不属于”的区别。在图中，每个点恰好属于—个连通分量，对应到集合表示中，每个 元素恰好属于—个集合。换句话说，图的所有连通分量可以用若干个不相交集合来表示。

并查集的精妙之处在于用树来表示集合。例如，若包含点1， 2， 3， 4， 5， 6的图有3个 连通分量｛1,3｝、｛2,5,6｝、｛4｝，则需要用3棵树来表示。这3棵树的具体形态无关紧要，只要 有—棵树包含1、3两个点，—棵树包含2、5、6这3个点，还有—棵树只包含4这—个点即 可。规定每棵树的根结点是这棵树所对应的集合的代表元( representative ) 。

如果把x的父结点保存在卩^]中(如果X殳有父结点，则p[x]等于X)，则不难写出“查找结 点X所在树的根结点”的递归程序：int find(int X) ｛ p[x] == X ? X : find(p[x]); ｝，通俗地讲就是： 如果p[x]等于x，说明X本身就是树根，因此返回X ;否则返回x的父结点p[X]所在树的树根。

问题来了：在特殊情况下，这棵树可能是一条长长的链。设链的最后一个结点为x，则 每次执行find(x)都会遍历整条链，效率十分低下。看上去是个很棘手的问题，其实改进方法 很简单。既然每棵树表示的只是—个集合，因此树的形态是无关紧要的，并不需要在“查 找”操作之后保持树的形态不变，只要顺便把遍历过的结点都改成树根的子结点，下次查找 就会快很多了，如图11-5所示。

图11-5 并查集中的路径压缩

这样，Kruskal算法的完整代码便不难给出了。假设第i条边的两个端点序号和权值分别

保存在u[i] , v[i]和w[i]中，而排序后第i小的边的序号保存在r[i]中（这叫做间接排序。排序 的关键字是对象的“代号”，而不是对象本身）。

int cmp(const int i, const int j) { return w[i]<w[j]; }    / /间接排序函数

int find (int x) { return p[x] == x ? x : p[x] = find (p[x] ) ; }// 并查集的 find int Kruskal() {

| int ans | = 0;       |             |                 |                     |                 |
| ------- | ---------- | ----------- | --------------- | ------------------- | --------------- |
| for(int | i = 0; i < | n;          | i++) p[i]       | = i;                | //初始化并查集  |
| for(int | i = 0; i < | m;          | i++) r[i]       | = i;                | // 初始化边序号 |
| sort(r, | r+m, cmp); | // 给边排序 |                 |                     |                 |
| for(int | i = 0; i < | m;          | i++)    {       |                     |                 |
| int     | e = r[i];  | int         | x = find(u[e]); | int y = find(v[e]); |                 |

// 找出当前边两个端点所在集合编号

if（x != y） { ans += w[e]; p[x] = y; }    / /如果在不同集合，合并

}

return ans;

}

注意，x和y分别是第e条边的两个端点所在连通分量的代表元。合并x和y所在集合可以 简单地写成p[x]=y ,即直接把x作为y的子结点，则两个树就合并成一棵树了。注意不能写成 P[u[e]]=p[v[e]],因为u[e]和v[e]不一定是树根。并查集的效率非常高，在平摊意义下，find函 数的时间复杂度几乎可以看成是常数（而union显然是常数时间）。

11.2.2 竞赛题目选解

例题 11-2 苗条的生成树(Slim Span, ACM/ICPC Japan 2007, UVa1395 )

给出一个《 （ ^<100 ）结点的图，求苗条度（最大边减最小边的值）尽量小的生成树。

【分析】

首先把边按权值从小到大排序。对于一个连续的边集区间[£，列，如果这些边使得〃个点 全部连通，则一定存在一个苗条度不超过呵列-呵£]的生成树（其中呵/]表示排序后第i条边 的权值）。

从小到大枚举Z ,对于每个£ ,从小到大枚举及，同时用并查集将新进入［£,列的边两端的 点合并成一个集合，与Kruskal算法一样。当所有点连通时停止枚举及，换下一个£ (并且 把及重置为£ )继续枚举。

例题 11-3 买还是建(Buy or Build, ACM/ICPC SWERC 2005, UVa1151 )

平面上有《个点(1<^<1000 ),你的任务是让所有《个点连通。为此，你可以新建一些 边，费用等于两个端点的欧几里德距离。另外还有g ( 0<^<8 )个“套餐”可以购买，如果你购 买了第/个套餐，该套餐中的所有结点将变得相互连通。第/个套餐的花费为Cz。如图11-6所 示，一共有3个套餐：

它的最优解是购买套餐1和套餐2，然后手动连接两条边，如图11-7所示。

O

图11-6 3个套餐 分析】



O

O



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-240.jpg)



图11-7 购买套餐1、2并连接边



最容易想到的算法是：先枚举购买哪些套餐，把套餐中包含的边的权值设为0，然后求 最小生成树。由于枚举量为0(2^1 ,给边排序的时间复杂度为O(«2log«),而排序之后每次

Kruskal算法的时间复杂度为0(«2),因此总时间复杂度为O(2^2+«2log«),对于题目的规模来 说太大了。

只需一个小小的优化即可降低时间复杂度：先求一次原图（不购买任何套餐）的最小生 成树，得到《-1条边，然后每次枚举完套餐后只考虑套餐中的边和这《-1条边，则枚举套餐之 后再求最小生成树时，图上的边已经寥寥无几。

为什么可以这样呢？首先回顾一下，在Kruskal算法中，哪些边不会进入最小生成树。答 案是：两端已经属于同一个连通分量的边。买了套餐以后，相当于一些边的权变为0，而对 于不在套餐中的每条边e，排序在e之前的边一个都没少，反而可能多了一些权值为0的边， 所以在原图Kruskal时被“扔掉”的边，在后面的Kruska冲也一样会被扔掉。

本题还有一个地方需要说明：因为Kruskal在连通分量包含《个点时会终止，所以对于随 机数据，即使用原始的“暴力算法”，也能很快出解。如果你是命题者，可以这样出一个数 据：有一个点很远，而其他《-1个点相互比较近。这样，相距较近的《-1个点之间的C（«-1，2）条 边会排序在前面，每次Kruskal都会先考虑完所有这些边。而考虑这些边时是无法让远点和近 点连通的。

###### 11.3 最短路问题

最短路问题并不陌生：在第9章中，曾介绍过无权和带权DAG上的最短路和最长路，二 者的算法几乎是一样的（只是初始化不同，并且状态转移时把min和max互换）。但如果图中 可以有环，情况就不同了。

11.3.1 Dijkstra 算法

Dijkstra算法适用于边权为正的情况。下面直接给出Dijkstra算法的伪代码，它可用于计 算正权图上的单源最短路（Single-Source Shortest Paths , SSSP ）,即从单个源点出发，到所 有结点的最短路。该算法同时适用于有向图和无向图。

清除所有点的标号

设d[0]=0 ,其他d[幻=INF

循环。次{

在所有未标号结点中，选出d值最小的结点x

给结点x标记

对于从x出发的所有边（x,y），更新d [y] = min{d[y], d[x]+w（x,y）}

}

下面是伪代码对应的程序。假设起点是结点0 ,它到结点i的路径长度为d[i]。未标号结 点的v[i]=0 ,已标号结点的v[i]=1。为了简单起见，用w[x][y]==INF表示边（x，y）不存在。

| memset(v, | 0,   | sizeof(v));                                        |
| --------- | ---- | -------------------------------------------------- |
| for(int i | =    | 0; i < n; i++) d[i] =    (i==0 ? 0 : INF);         |
| for(int i | =    | 0; i < n; i++)    {                                |
| int x, m  |      | INF;                                               |
| for(int   | y    | = 0; y < n; y++) if(!v[y] && d[y]<=m) m = d[x=y];  |
| v[x] = 1  | ;    |                                                    |
| for(int   | y    | = 0; y < n; y++) d[y] = min(d[y], d[x] + w[x][y]); |

}

除了求出最短路的长度外，使用Dijkstra算法也能很方便地打印出结点0到所有结点的最 短路本身，原理和动态规划中的方案打印一样——从终点出发，不断顺着d[i]+w[i][j]==d[j] 的边（i，j）从结点j“退回”到结点i ,直到回到起点。另外，仍然可以用空间换时间，在更新d数

组时维护“父亲指针”。具体来说，需要把d[y] = min(d[y], d[x]+w[x][y])改成：

if(d[y] > d[x] + w[x][y]) {

d[y] = d[x] + w[x][y]; fa[y] = x;

这称为边(x,y)上的松弛操作(relaxation )。不难看出，上面程序的时间复杂度为0(n2) 一循环体一共执行了n次，而在每次循环中，“求最小d值”和“更新其他d值”均是0⑻的。 由于最短路算法实在太重要了，下面花一些篇幅把它优化到0(rnlogn),并给出一份简单高效

的完整代码。

等一等，为什么说是“优化到”呢？在最坏情况下，m和n2是同阶的，rnlogn岂不是比n2要

大？这话没错，但在很多情况下，图中的边并没有那么多，mlogn比n2小得多。m远小于n2的 图称为稀疏图(Sparse Graph ),而m相对较大的图称为稠密图(Dense Graph )。

和前面一样，稀疏图适合使用vector数组保存。除此之外，还有一种流行的表示法—— 邻接表(Adjacency List )。在这种表示法中，每个结点/都有一个链表，里面保存着从/出发 的所有边。对于无向图来说，每条边会在邻接表中出现两次。和前面一样，这里继续用数组 实现链表：首先给每条边编号，然后用first[u]保存结点w的第一条边的编号，next[e]表示编号 为e的边的“下一条边”的编号。下面的函数读入有向图的边列表，并建立邻接表：

int n, m;

int first[maxn];

int u[maxm], v[maxm], w[maxm], next[maxm];

void read_graph() { scanf("%d%d", &n, &m);

for(int i = 0; i < n; i++) first[i] = -1; // 初始化表头 for(int e = 0; e < m; e++) {

scanf("%d%d%d", &u[e], &v[e], &w[e]);

next[e] = first[u[e]];    //插入链表

first[u[e]] = e;

上述代码的巧妙之处是插入到链表的首部而非尾部，这样就避免了对链表的遍历。不过

需要注意的是，同一个起点的各条边在邻接表中的顺序和读入顺序正好相反。读者如果还记

得哈希表，应该会发现这里的链表和哈希表中的链表实现很相似。

尽管邻接表很流行，但在概念上vector数组更为简单，所以接下来仍然给出基于vector数 组的代码。虽然在最短路问题中，每条边只有“边权”这一个属性，但后面的最大流以及最小 费用流中还会出现“容量”、“流量”以及“费用”等属性。所以在这里使用一个称为Edge的结构 体，这会让这里的代码与后面的代码在风格上更统一。

struct Edge { int from, to, dist;

Edge(int u, int v, int d):from(u),to(v),dist(d) {}

};

为了使用方便，此处把算法中用到的数据结构封装到一个结构体中：

struct Dijkstra { int n, m;

vector<Edge> edges; vector<int> G[maxn]; bool done[maxn];

int d[maxn]; int p[maxn];

void init(int n) { this->n = n; for(int i = 0; i < edges.clear();

}

void AddEdge(int



//是否已永久标号

//s到各个点的距离

//最短路中的上一条弧



n; i++) G[i].clear();



from,



int to, int dist) {



edges.push_back(Edge(from, to, dist)); m = edges.size(); G[from].push_back(m-1);



void dijkstra(int s) {

};

不难看出，在vector数组中保存的只是边的编号。有了编号之后可以从edges数组中查到 边的具体信息。有了这样的数据结构，“遍历从出发的所有边b，y）,更新4V]”就可以写 成“for（int i = 0; i < G[u].size（）; i++）执行边edges[G[u][i]]上的松弛操作”。尽管在最坏情况下， 这个循环仍然会循环《-1次，但从整体上来看，每条边恰好被检查过一次（想一想，为什 么），因此松弛操作执行的次数恰好是rn。这样，只需集中精力优化“找出未标号结点中的最 小d值”即可。

在Dijkstra算法中，d[i]越小，应该越先出队，因此需要使用自定义比较器。在STL中， 可以用greater<lnt〉表示“大于”运算符，因此可以用 priority_queue<int， vector<int>， greater<int> >q来声明一个小整数先出队的优先队列。然而，除了需要最小的d值之外，还要找到这个最 小值对应的结点编号，所以需要把d值和编号“捆綁”成一个整体放到优先队列中，使得取出 最小d值的同时也会取出对应的结点编号。

STL中的pair便是专门把两个类型捆綁到一起的。为了方便起见，用typedef pair<int，int> pii 自定义一^个pii类型，则priority_queue<pii，vector<pii>，greater<pii> > q就定义了 一^个由二元 组构成的优先队列。pair定义了它自己的排序规则——先比较第一维，相等时才比较第二 维，因此需要按（d[i]，i）而不是（i，d[i]）的方式组合。这样的方法理论上和实际上都没有问题， 很多用户并不习惯。为了保持简单，这里不使用pair ,而是显式定义一个结构体作为优先队 列中的元素类型,例如：

struct HeapNode { int d, u;

bool operator < （const HeapNode& rhs） const {

return d > rhs.d;

};

然后主算法就可以写出来了：

void dijkstra(int s) {

priority_queue<HeapNode> Q;

for(int i = 0; i < n; i++) d[i] = INF; d[s] = 0;

memset(done, 0, sizeof(done)); Q.push((HeapNode){0, s});

while(!Q.empty()) {

HeapNode x = Q.top(); Q.pop(); int u = x.u; if(done[u]) continue; done[u] = true;

for(int i = 0; i < G[u].size(); i++) { Edge& e = edges[G[u][i]]; if(d[e.to] > d[u] + e.dist) {

d[e.to] = d[u] + e.dist; p[e.to] = G[u][i];

Q.push((HeapNode){d[e.to], e.to});

}

}

}

}

在松弛成功后，需要修改结点e.to的优先级，但STL中的优先队列不提供“修改优先级”的 操作。因此，只能将新元素重新插入优先队列。这样做并不会影响结果的正确性，因为d值 小的结点自然会先出队。为了防止结点的重复扩展，如果发现新取出来的结点曾经被取出来 过(done[u])，应该直接把它扔掉。避免重复的另一个方法是把if(done[u])改成if(x.d    !=

d[u])，可以省掉一个done数组。

再补充一点：即使是稠密图，使用priority_queue实现的Dijkstra算法也常常比基于邻接矩 阵的Dijkstra算法的运算速度快。理由很简单，执行push操作的前提是d[e.to] > d[u] + e.dist， 如果这个式子常常不成立，则push操作会很少。

11.3.2 Bellman-Ford 算法

当负权存在时，连最短路都不一定存在了。尽管如此，还是有办法在最短路存在的情况

下把它求出来。在介绍算法之前，请读者确认这样一个事实：如果最短路存在，一定存在一

个不含环的最短路。

理由如下：在边权可正可负的图中，环有零环、正环和负环3种。如果包含零环或正

环，去掉以后路径不会变长；如果包含负环，则意味着最短路不存在(想一想，为什么)。

既然不含环，最短路最多只经过(起点不算)n-1个结点，可以通过n-1“轮”松弛操作得 到，像这样(起点仍然是0)：

for(int i = 0; i < n; i++) d[i] = INF;

d[0] = 0;

for(int k = 0; k < n-1; k++) //迭代n-1次

for(int i = 0; i < m; i++) // 检查每条边 {

int x = u[i], y = v[i];

if(d[x] < INF) d[y] = min(d[y], d[x]+w[i]); // 松弛

上述算法称为Bellman-Ford算法，不难看出它的时间复杂度为0(nm)。在实践中，常常用 FIFO队列来代替上面的循环检查，像这样：

bool bellman_ford(int s) { queue<int> Q;

memset(inq, 0, sizeof(inq)); memset(cnt, 0, sizeof(cnt)); for(int i = 0; i < n; i++) d[i] = INF;

d[s] = 0; inq[s] = true;

Q.push(s);

while(!Q.empty()) {

int u = Q.front(); Q.pop(); inq[u] = false;

for(int i = 0; i < G[u].size(); i++) {

Edge& e = edges[G[u][i]];

if(d[u] < INF && d[e.to] > d[u] + e.dist) { d[e.to] = d[u] + e.dist; p[e.to] = G[u][i];

if(!inq[e.to]) { Q.push(e.to); inq[e.to] = true; if(++cnt[e.to] > n) re

return true;

有没有注意到上面的代码和前面的Dijkstra算法很像？ 一方面，优先队列替换为了普通 的FIFO队列，而另一方面，一个结点可以多次进入队列。可以证明，采取FIFO队列的 Bellman-Ford算法在最坏情况下需要0（醐）时间，不过在实践中，往往只需要很短的时间就能 求出最短路。上面的代码还有一个功能：在发现负圈时及时退出。注意，这只说明s可以到 达一个负圈，并不代表s到每个点的最短路都不存在。另外，如果图中有其他负圈但是s无法 到达这个负圈，则上面的算法也无法找到。解决方法留给读者思考（提示：加一个结点）。

11.3.3 Floyd 算法

如果需要求出每两点之间的最短路，不必调（边权均为正）或者Bellman-ford （ 有负权）。有一个更简单的方法可以实现——Floyd-Warshall算法（请记住下面的代 码！）：

for（int k = 0; k < n; k++） for（int i = 0; i < n; i++）

for（int j = 0; j < n; j++） d[i][j] = min（d[i][j], d[i][k] + d[k][j]）;

在调用它之前只需做一些简单的初始化：d[i][i]=0，其他d值为“正无穷”INF。注意这里 有一个潜在的问题：如果INF定义太大（如2000000000 ），加法d[i][k] + d[k][j]可能会溢出！ 但如果INF太小，可能会使得长度为INF的边真的变成最短路的一部分。谨慎起见，最好估计 —下实际最短路长度的上限，并把INF设置成“只比它大一点点”的值。例如，最多有1000条

边，若每条边长度不超过1000 ,可以把INF设成1000001。

如果坚持认为不应该允许INF和其他值相加，更不应该得到一个大于INF的数，请把上述 代码改成：

for(int k = 0; k < n; k++) for(int i = 0; i < n; i++)

for(int j = 0; j < n; j++)

if(d[i][j] < INF && d[k][j] < INF)

d[i][j] = min(d[i][j], d[i][k] + d[k][j]);

在有向图中，有时不必关心路径的长度，而只关心每两点间是否有通路，则可以用1和0 分别表示“连通”和“不连通”。这样，除了预处理需做少许调整外，主算法中只需把“d[i][j]= min{d[i][j], d[i][k] + d[k][j]}”改成“d[i][j] = d剛]|| (d[i][k] && d[k][j])”。这样的结果称为有向 图的传递闭包( Transitive Closure)。

11.3.4 竞赛题目选讲

例题 11-4 电话圈(Calling Circles, ACM/ICPC World Finals 1996, UVa247 )

如果两个人相互打电话(直接或间接)，则说他们在同一个电话圈里。例如，a打给 b , b打给c , c打给d , d打给a ,则这4个人在同一个圈里；如果e打给f但f不打给e ,则不能推 出e和f在同一个电话圈里。输入n ( n<25 )个人的m次电话，找出所有电话圈。人名只包含字 母，不超过25个字符，且不重复。

【分析】

首先用floyd求出传递闭包，即g[i][j]表示i是否直接或者间接给j打过电话，则当且仅当 g[i]Lj]=gLj][i]=1时二者处于一个电话圈。构造一个新图，在“在一个电话圈里”的两个人之间 连一条边，然后依次输出各个连通分量的所有人即可。

例题 11-5 噪音恐惧症(Audiophobia, UVa10048 )

输入一个C个点S条边(C<100 , 5<1000 )的无向带权图，边权表示该路径上的噪声值。 当噪声值太大时，耳膜可能会受到伤害，所以当你从某点去往另一个点时，总是希望路上经 过的最大噪声值最小。输入一些询问，每次询问两个点，输出这两点间最大噪声值最小的路

图11-8 路径与噪声值



径。例如，在图11-8中，A到G的最大噪声值为80 ,是所有其 大噪声值为90）。

【分析】

本题的做法十分简单：直接用floyd算法，但 是要把加法改成min , min改成max。为什么可以 这样做呢？不管是floyd算法还是dijkstra算法，都 是基于这样一个事实：对于任意一条至少包含两 条边的路径i->j ,—定存在一个中间点女，使得i->j的总长度等于i->&与h>j的长度之和。对于不

同的点^ , i->&和&->j的长度之和可能不同，最后还需要取一个最小值才是i->j的最短路径< 把刚才的推理中“之和”与“取最小值”换成“取最小值”和“取最大值”,推理仍然适用。

例题 11-6 这不是bug ,而是特性(It's not a Bug, it's a Feature!, UVa 658 )

补丁在修正bug时，有时也会引入新的bug。假定有《 （ n<20 ）个潜在bug*rn （ m<100 ）

个补丁，每个补丁用两个长度为n的字符串表示，其中字符串的每个位置表示一个bug。第一 个串表示打补丁之前的状态（“-”表示该bug必须不存在，“+”表示必须存在，0表示无所 谓）,第二个串表示打补丁之后的状态（ “-”表示不存在,“+”表示存在,0表示不变）。每 个补丁都有一个执行时间，你的任务是用最少的时间把一个所有bug都存在的软件通过打补 丁的方式变得没有bug。一个补丁可以打多次。

【分析】

在任意时刻，每个bug可能存在也可能不存在，所以可以用一个n位二进制串表示当前软 件的“状态”。打完补丁之后，bug状态会发生改变，对应“状态转移”。是不是很像动态规 划？可惜动态规划是行不通的,因为状态经过多次转移之后可能会回到以前的状态,即状态 图并不是DAG。如果直接用记忆化搜索，会出现无限递归。

正确的方法是把状态看成结点,状态转移看成边,转化成图论中的最短路径问题,然后 使用Dijkstra或Bellman-Ford算法求解。不过这道题和普通的最短路径问题不一样：结点很

多，多达2n个，而且很多状态根本遇不到（即不管怎么打补丁，也不可能打成那个状态）， 所以没有必要像前面那样先把图储存好。

还记得第7章中介绍的“隐式图搜索”吗？这里也可以用相同的方法：当需要得到某个结 点m出发的所有边时，不是去读G[u]，而是直接枚举所有rn个补丁，看看是否能打得上。不管 是Dijsktra算法还是Bellman-Ford算法，这个方法都适用。本题很经典，强烈建议读者编程实 现。

###### 11.4 网络流初步

网络流是—个适用范围相当广的模型，相关的算法也非常多。尽管如此，网络流中的概

念、思想和基本算法并不难理解。

11.4.1 最大流问题

如图11-9所示，假设需要把一些物品从结点5 (称为源点)运送到结点Z (称为汇点)，

可以从其他结点中转。图11-9 ( a )中各条有向边的权表示最多能有多少个物品从这条边的 起点直接运送到终点。例如，最多可以有9个物品从结点v3运送到v2。

图11-9 ( b )展示了一种可能的方案，其中每条边中的第一个数字表示实际运送的物品 数目，而第二个数字就是题目中的上限。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-243.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-244.jpg)



这样的问题称为最大流问题(Maximum-Flow Problem)。对于一条边(u,v)，它的物品上 限称为容量(capacity )，记为c(w，v)(对于不存在的边(w，v)，c(u,v)=0 );实际运送的物品称 为流量(flow )，记为f＞，v)。注意，“把3个物品从“运送到v，又把5个物品从v运送到W”没什 么意义，因为它等价于把两个物品从v运送到W。这样，就可以规定f＞，v)和Av)最多只有一 个正数(可以均为0 )，并且f＞，v)=-f(v)。这样规定就好比“把3个物品从权运送到v”等价 于“把-3个物品从v运送到W”一样。

最大流问题的目标是把最多的物品从5运送到Z，而其他结点都只是中转，因此对于除了 结点5和Z外的任意结点w，三    =:(这些/中有些是负数)。从5运送出来的物品数目等

(w,v)e£

于到达Z的物品数目，而这正是此处最大化的目标。

提示11-2 :在最大流问题中，容量c和流量f满足3个性质：容量限制 (f(u,v)<c(u,v))、斜对称性(f(u,v)=-f(v,u))和流量平衡(对于除了结点s和t外的任意结

点U , X MiU-i1 )。冋题的目标是最大化'X U X即从S点流出

(w，v)e£    (j,v)e£    ("，，)e£

的净流量(它也等于流入t点的净流量)。

11.4.2 增广路算法

介绍完最大流问题后，下面介绍求解最大流问题的算法。算法思想很简单，从零流(所

有边的流量均为0)开始不断增加流量，保持每次增加流量后都满足容量限制、斜对称性和

流量平衡3个条件。

计算出图11-10 ( a )中的每条边上容量与流量之差(称为残余容量，简称残量)，得到 图11-10 ( b )中的残量网络(residual network )。同理，由图11-10 ( c )可以得到图11-10(d)。注意残量网络中的边数可能达到原图中边数的两倍，如原图中c=16 ,戶11的边在 残量网络中对应正反两条边，残量分别为16-11=5和0-(-11)=11。

S



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-246.jpg)



(b)



a)

(c)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-248.jpg)



(d)



该算法基于这样一个事实：残量网络中任何一条从5到Z的有向道路都对应一条原图中的

增广路(augmenting path)-只要求出该道路中所有残量的最小值^ ,把对应的所有边上的

流量增加即可，这个过程称为增广(augmenting )。不难验证，如果增广前的流量满足3个 条件，增广后仍然满足。显然，只要残量网络中存在增广路，流量就可以增大。可以证明它 的逆命题也成立：如果残量网络中不存在增广路，则当前流就是最大流。这就是著名的增广 路定理。

提示11-3 :当且仅当残量网络中不存在s-t有向道路(增广路)时，此时的流是 从s到t的最大流。

“找任意路径”最简单的办法无疑是用DFS ,但很容易找出让它很慢的例子。一个稍微好 一些的方法是使用BFS ,它足以应对数据不刁钻的网络流题目。这就是Edmonds-Karp算法。 下面是完整的代码。注意Edge结构体多了flow和cap两个变量，但是AddEdge却和Dijkstra中的 同名函数很接近。这便是得益于Edge结构体这一设计。

struct Edge

int from, to, cap, flow;

Edge(int u, int v, int c, int f):from(u),to(v),cap(c),flow(f)

};

struct EdmondsKarp

int n, m;

vector<Edge> edges;



vector<int> G[maxn]



int a[maxn];



int p[maxn];



// 边数的两倍

//邻接表，G ［幻j］表示结点i的第j条边在e数组中的序号

//当起点到i的可改进量 //最短路树上p的入弧编号

void init(int n)

for(int i = 0;



n; i++) G[i].clear();



edges.clear();

void AddEdge(int from, int to, int cap) {

edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); // 反向弧 m = edges.size();

G [ from ] .push_back(m-2);

G [to ] .push_back(m-1);

}

int Maxflow(int s, int t) { int flow = 0;



for(;;) {

memset(a, 0, sizeof(a)); queue<int> Q;

Q.push(s); a[s] = INF;

while(!Q.empty()) {

int x = Q.front(); Q.pop();

for(int i = 0; i < G[x].size(); i++) {

Edge& e = edges[G[x][i]];

if(!a [ e.to ] && e.cap > e.flow) {

p[e.to] = G[x][i];

e.cap-e.flow)



a[e.to] = min(a[x] Q.push(e.to);

}

if(a[t]) break;

}

if(!a[t]) break;

for(int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t];

edges[p[u]A1].flow -= a[t];

}

flow += a[t];

};

注意上面代码中的一个技巧：每条弧和对应的反向弧保存在一起。边0和1互为反向边； 边2和3互为反向边……一般地，边/的反向边为P1，其中“〃’为二进制异或运算符（想一想， 为什么）。

正如所见，上面的代码和普通的BFS并没有太大的不同。唯一需要注意的是，在扩展结 点的同时还需递推出从5到每个结点/的路径上的最小残量a[i]，则a[t]就是整条5-Z道路上的最 小残量。另外，由于a[i]总是正数，所以用它代替了原来的vis标志数组。上面的代码把流初 始化为零流，但这并不是必需的。只要初始流是可行的（满足3个限制条件），就可以用增

广路算法进行增广。

11.4.3 最小割最大流定理

有一个与最大流关系密切的问题：最小割。如图11-11所示，把所有顶点分成两个集 合5和7=7-5，其中源点5在集合S中，汇点Z在集合r中。

如果把“起点在中，终点在7中”的边全部删除，就无法从5到达Z了。这样的集合划分

（5.7）称为一个、•-/割，它的容量定义为：：,即起点在5中，终点在7中的所

有边的容量和。

还可从另外一个角度看待割。如图11-12所示，从5运送到Z的物品必然通过跨越5和7的

边，所以从5到/的净流量等于    。

WG T    UG.S ^VG.T

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-249.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-250.jpg)



注意这里的割以T)是任取的，因此得到了一个重要结论：对于任意^-/流/和任意W割以

n，有，、.门。

下面来看残量网络中没有增广路的情形。既然不存在增广路，在残量网络中5和Z并不连 通。当BFS没有找到任何5-Z道路时，把已标号结点(a[M]〉0的结点m )集合看成S ,令二V-S , 则在残量网络中S和T分离，因此在原图中跨越S和T的所有弧均满载(这样的边才不会存在于 残量网络中)，且没有从T回到S的流量，因此成立/<(S,T)成立。

前面说过，对于任意的/和以7),都有J/|<(S,T),而此处又找到了一组让等号成立的/和 (S，T)。这样，便同时证明了增广路定理和最小割最大流定理：在增广路算法结束 时，/是5々最大流，以7)是5-邊小割。

提示11-4 :增广路算法结束时，令已标号结点(a[U]>0的结点)集合为S ,其他结点 集合为T=V-S ,则(S,T)是图的s-t最小割。

11.4.4 最小费用最大流问题

下面给网络流增加—个因素：费用。假设每条边除了有—个容量限制外，还有—个单位 流量所需的费用 ( co5t)。 图11-13 (a)中分别用c和a来表示每条边的容量和费用，而图11-13 ( b )给出了一个在总流量最大的前提下，总费用最小的流(费用为10 ),即最小费用最 大流。另一个最大流是从5分别运送一个单位到和y ,但总费用为11 ,不是最优。

图11-13



最小费用最大流



在最小费用流问题中，平行边变得有意义了：可能会有两条从m到v的弧，费用分别为1

和2。在没有费用的情况下，可以把二者合并，但由于费用的出现，无法合并这两条弧。再 如，若边(M，V)和(V，M)均存在，且费用都是负数，则“同时从M流向V和从V流向M”是个不错的主 意。为了更方便地叙述算法，先假定图中不存在平行边和反向边。这样就可以用两个邻接矩 阵cap和cow保存各边的容量和费用。为了允许反向增广，规定cap[v][w]=0并且co5Z[v][M]=-cost[u][v],表示沿着(u，v)的相反方向增广时，费用减小co5t[u][v]。

限于篇幅，这里直接给出最小费用路算法。和Edmonds-Karp算法类似，但每次用 Bellman-Ford算法而非BFS找增广路。只要初始流是该流量下的最小费用可行流，每次增 广后的新流都是新流量下的最小费用流。另外，费用值是可正可负的。在下面的代码中， 为了减小溢出的可能，总费用cost采用long long来保存。

struct Edge {

int from, to, cap, flow, cost;

Edge(int u, int v, int c, int f, int w):from(u),to(v),cap(c),flow(f),cost(w)

{}

};

struct MCMF { int n, m;

vector<Edge> edges; vector<int> G[maxn]; int inq[maxn]; int d[maxn]; int p[maxn]; int a[maxn];

//是否在队列中

//Bellman-Ford

//上一条弧

//可改进量



void init(int n) { this->n = n;

for(int i = 0; i < n; i++) G[i].clear(); edges.clear();

void AddEdge(int from, int to, int cap, int cost) {

edges.push_back(Edge(from, to, cap, 0, cost)); edges.push_back(Edge(to, from, 0, 0, -cost)); m = edges.size();

G[from].push_back(m-2);

G[to].push_back(m-1);

}

bool BellmanFord(int s, int t, int& flow, long long& cost) { for(int i = 0; i < n; i++) d[i] = INF;

memset(inq, 0, sizeof(inq));

d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF;

queue<int> Q;

Q.push(s);

while(!Q.empty()) {

int u = Q.front(); Q.pop(); inq[u] = 0;

for(int i = 0; i < G[u].size(); i++) {

Edge& e = edges[G[u][i]];

if(e.cap > e.flow && d[e.to] > d[u] + e.cost) { d[e.to] = d[u] + e.cost; p[e.to] = G[u][i];

a[e.to] = min(a[u], e.cap - e.flow); if(!inq[e.to]) { Q.push(e.to); inq[e.to] = 1; }

}

}

}

if(d[t] == INF) return false;

flow += a[t];

cost += (long long)d[t] * (long long)a[t]; for(int u = t; u != s; u = edges[p[u]].from) {

edges[p[u]].flow += a[t]; edges[p[u]A1].flow -= a[t];

return true;

//需要保证初始网络中没有负权圈

int MincostMaxflow(int s, int t, long long& cost) { int flow = 0; cost = 0; while(BellmanFord(s, t, flow, cost)); return flow;

}

};

11.4.5 应用举例

首先需要明确一点：虽然本节介绍了最大流的Edmonds-Karp算法，但在实践中一般不 用这个算法，而是使用效率更高的Dinic算法或者ISAP算法。这两个算法虽然也不是很难 理解，但是较之Edmonds-Karp来说还是复杂了许多。另一方面，最小费用流也有更快的算 法，但在实践中一般仍用上述算法，因为最小费用流的快速算法(例如网络单纯型法)大都 很复杂，还没有广泛使用。对此，笔者的建议是：理解Edmonds-Karp算法的原理(包括正确 性证明)，但在比赛中使用Dinic或者ISAP。《算法竞赛入门经典——训练指南》对这两个 算法有较为详细介绍，还给出了完整的代码。事实上，读者无须搞清楚它们的原理，只需会 使用即可。换句话说，可以把它们当作像STL—样的黑盒代码。在算法竞赛中，一般把这样 的代码称为模板。

二分图匹配。网络流的一个经典的应用是二分图匹配。在图论中，匹配是指两两没有 公共点的边集，而二分图是指：可以把结点集分成两部分A和卩使得每条边恰好一个端点 在X，另一个端点在7。换句话说，可以把结点进行二染色(bicoloring)，使得同色结点不 相邻。为了方便叙述，在画图时一般把X结点和7结点画成左右两列。可以证明：一个图是二 分图，当且仅当它不含长度为奇数的圈。

常见的二分图匹配问题有两种。第一种是针对无权图的，需要求出包含边数最多的匹 配，即二分图的最大基数匹配(maximum cardinality bipartite matching )，如图 11-14 ( a )所 示。

这个问题可以这样求解：增加一个源点5和一个汇点Z ,从5到所有A结点各连一条容量为 1的弧，再从所有r结点各连一条容量为1的弧到z,最后把每条边变成一条由又指向r的有向 弧，容量为1。只要求出5到z的最大流，则原图中所有流量为1的弧对应了最大基数匹配。

第二种是针对带权图的，需要求出边权之和尽量大的匹配，如图11-14 (b )所示。有些 题目要求这个匹配本身是完美匹配(perfect matching),即每个点都被匹配到，而有些题目 并不对边的数量做出要求，只要权和最大就可以了。下面先考虑前一种情况，即最大权完美 匹配( maximum weighted perfect matching)。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-253.jpg)



(b)



图11-14 二分图匹配



聪明的读者相信已经找到解决方法了：和最大基数匹配类似，只是原图中所有边的费用 为权值的相反数(即前面加一个负号)，然后其他边的费用为0 ,然后求一个5到Z的最小费 用最大流即可。如果从s出发的所有弧并不是全部满载(即流量等于容量)，则说明完美匹

配不存在，问题无解；否则原图中的所有流量为1的弧对应最大权完美匹配。

用这样的方法也可以求解第二种情况，即匹配边数没有限制的最大权匹配，只是需要在 求解s-t最小费用流的过程中记录下流量为0，1, 2, 3，...时的最小费用流，然后加以比较，细节

留给读者思考。

例题 11-7 UNIX插头(A Plug for UNIX, UVa753 )

有打个插座，rn个设备和& ( n,m,k<100 )种转换器，每种转换器都有无限多。已知每个插 座的类型，每个设备的插头类型，以及每种转换器的插座类型和插头类型。插头和插座类型 都用不超过24个字母表示，插头只能插到类型名称相同的插座中。

例如，有4个插座，类型分别为A，B，C，D ;有5个设备，插头类型分别为B，C，B，B，X ; 还有3种转换器，分别是B->X , X->A和X->D。这里用B->X表示插座类型为B ,插头类型为 X ,因此一个插头类型为B的设备插上这种转换器之后就“变成”了一个插头类型为X的设备。 转换器可以级联使用，例如插头类型为A的设备依次接上A->B , B->C , C->D这3个转换器之 后会“变成”插头类型为D的设备。

要求插的设备尽量多。问最少剩几个不匹配的设备。

【分析】

首先要注意的是：k 个转换器中涉及的插头类型不一定是接线板或者设备中出现过的插 头类型。在最坏情况下， 100个设备， 100个插座， 100个转换器最多会出现400种插头。当 然， 400种插头的情况肯定是无解的，但是如果编码不当，这样的情况可能会让你的程序出 现下标越界等运行错误。

笔者第一次尝试本题时使用的方法如下：转换器有无限多，所以可以独立计算出每个设 备1是否可以接上0个或多个转换器之后插到第j个插座上，方法是建立有向图G ,结点表示插 头类型，边表示转换器，然后使用Floyd算法，计算出任意一种插头类型a是否能转化为另一 种插头类型b。

接下来构造网络：设设备1对应的插头类型编号为device[i],插座1对应的插头类型编号 为target[1],则源点s到所有dev1ce[1]连一条弧，容量为1 ,然后所有target[1]到汇点t连一条 弧，容量为1 ,对于所有设备1和插座j ,如果dev1ce[1]可以转化为target[j],则从dev1ce[1]连一

条弧到target[j]，容量为无穷大（代表允许任意多个设备从device[i]转化为target[j]），最后求 s-t最大流，答案就是m减去最大流量。

上述算法的优点是网络流模型中的点比较少（因为只有接线板和设备中出现过的插头类

型），缺点是弧比较多（任意一对可以转化的结点之间都有弧），并且编程稍微麻烦一些。

还有一个更加简单的方法：直接把所有插头类型（包括仅在转换器中出现的类型）纳入 到网络流模型中，则每个转换器对应一条弧，容量为无穷大。这个方法的优点是编程简单， 并且弧的个数比较少（只有k条），缺点是点数比较多。建议读者实现这两种算法，然后自 行比较它们的优劣。

例题 11-8 矩阵解压(Matrix Decompressing, UVa 11082 )

对于一个及行C列的正整数矩阵（1^R，C<20），设為为前/行所有元素之和，代为前/列

所有元素之和。已知氏C和数组乂和B，找一个满足条件的矩阵。矩阵中的元素必须是1〜20之 间的正整数。输入保证有解。

【分析】

首先根据為和代计算出第/行的元素之和和第/列的元素之和<。如果把矩阵里的每个数 都减1，则每个人会减少C，而每个5'z会减少及。这样一来，每个元素的范围变成了0〜19，它 的好处很快就能看到。

建立一个二分图，每行对应一个X结点，每列对应一个7结点，然后增加源点5和汇点Z。 对于每个结点X，从5到X连一条弧，容量为4-C ;从7到1k连一条弧，容量为B-R。而对于每 对结点（X，7.），从人向7.连一条弧，容量为19。接下来求5-z的最大流，如果所有5出发和到 达Z都满载，说明问题有解，结点X-〉7.的流量就是格子（i.）减1之后的值。

为什么这样做是对的呢？请读者思考。

例题 11-9 海军上将(Admiral, ACM/ICPC NWERC 2012, UVa1658 )

给出一个1 （ 3<v<1000 ）个点e （ 3<e<10000 ）条边的有向加权图，求1〜v的两条不相交 （除了起点和终点外没有公共点）的路径，使得权和最小。如图11-15所示，从1到6的两条

最优路径为1-3-6（权和为33）和1-2-5-4-6（权和为53）。

【分析】

把2到v-1的每个结点/拆成/和/'两个结点，中间连一条容量为1 ,费用为0的边，然后求1 到v的流量为2的最小费用流即可。

图11-15 从1到6的两条最优路径

本题的拆点法是解决结点容量的通用方法，请读者注意。

例题 11-10 最优巴士路线设计（Optimal Bus Route Design, ACM/ICPC Taiwan 2005, UVa12264 ）

给《个点（^<100 ）的有向带权图，找若干个有向圈，每个点恰好属于一个圈。要求权和 尽量小。注意即使（M，V）和（V，M）都存在，它们的权值也不一定相同。

分析】

每个点恰好属于一个有向圈，意味着每个点都有一个唯一的后继。反过来，只要每个点 都有唯一的后继，每个点一定恰好属于一个圈。 “每个东西恰好有唯一的……”让我们想到了 二分图匹配。把每个点/拆成;和r ,原图中的有向边M-〉V对应二分图中的边A；-〉rv ,则题目 转化为了这个二分图上的最小权完美匹配问题。

###### 11.5 竞赛题目选讲

例题 11-11 有趣的赛车比赛(Funny Car Racing, UVa 12661 )

在一个赛车比赛中，赛道有n （ n<300 ）个交叉点和m （ m<50000 ）条单向道路。有趣的 是：每条路都是周期性关闭的。每条路用5个整数w，V，久办，t表示（1<u，v<n , 1<a，b，t<105 ）, 表示起点是u ,终点是v ,通过时间为t秒。另外，这条路会打开a秒，然后关闭b秒，然后再 打开a秒，依此类推。当比赛开始时，每条道路刚刚打开。你的赛车必须在道路打开的时候 进入该道路，并且在它关闭之前离开（进出道路不花时间，所以可以在打开的瞬间进入，关 闭的瞬间离开）。

你的任务是从s出发，尽早到达目的地，（1<s，t<n ）。道路的起点和终点不会相同，但是 可能有两条道路的起点和终点分别相同。

【分析】

本题是一道最短路问题，但又和普通的最短路问题不太相同：花费的总时间并不是经过

的每条边的通过时间之和，还要加上在每个点等待的总时间。还记得第9章中的例题“基金管

理”吗？该题的决策不仅依赖于状态本身，还依赖于该状态下现金的最大值。本题也是一

样：仍然调用标准的D1jkstra算法，只是在计算一个结点u出发的边权时要考虑d[u]（即从s出 发达到u的最早时刻）。计算边权时要分情况讨论，细节留给读者思考。

例题 11-12 水塘(Pool construction, NWERC 2011, UVa1515 )

输入一个力行w列的字符矩阵，草地用“#”表示，洞用“”表示。你可以把草改成洞，每格 花费为^,也可以把洞填上草，每格花费为/。最后还需要在草和洞之间修围栏，每条边的花 费为b。整个矩阵第一行/列和最后一行/列必须都是草。求最小花费。2<w,h<50 , 1<d，    f，

b<10000。

例如，d=1，户8 , b=1 ,则图11-16中的最小花费为27 ,方法是先把第一行的洞填上草 （花费16），然后把第3行第3列的草挖成洞（花费1），再修10个单位的围栏）。

【分析】

围栏的作用是把草和洞隔开，让人联想到了“割”这个概念。可是“割”只是把图中的结点 分成了两个部分，而本题中，草和洞都能有多个连通块。怎么办呢？添加源点和汇点与 其他点相连，则所有本不连通的草地/洞就能通过源点和汇点间接连起来了

由于草和洞可以相互转换，而且转换还需要 费用，所以需要一并在“割”中体现出来。为此， 规定与5*连通的都是草，与r连通的都是 洞，则需要往所有草格子连一条容量为的边， 表示必须把这条弧切断（割的容量增加^）,这 个格子才能“叛逃”到r的“阵营”，成为洞。由于 题目说明了最外圈的草不能改成洞，从到这些 草格子的边容量应为正无穷（在这之前需要把边 界上的所有洞填成草，累加出这一步所需的费 用）。

同理，所有不在边界上的洞格子往r连一条 弧，费用为/,表示必须把这条弧切断（割的容 量增加/）,才能让这个洞变成草。相邻两个格 子M和V之间需要连两条边M-〉V和V-〉M ,容量均 为b ,表示如果W是草，V是洞，则需要切断弧W-〉V ；如果V是草，W是洞，则需要切断弧v-〉w。

这样，用最大流算法求出最小割，就可以得

到本题的最小花费。

\##‘##



图11-16水塘问题示意图



例题11-13混合图的欧拉回路（Euler Circuit, UVa10735 ）

给出一个F个点和冗条边（1<F<100 , 1<£<500 ）的混合图（即有的边是无向边，有的边 是有向边），试求出它的一条欧拉回路，如果没有，输出无解信息。输入保证在忽略边的方 向之后图是连通的。

【分析】

很多混合图问题（例如，混合图的最短路）都可以转化为有向图问题，方法是把无向边

拆成两条方向相反的有向边。可惜本题不能使用这种方法，因为本题中的无向边只能经过一

次，而拆成两条有向边之后变成了“沿着两个相反方向各经过一次”。所以本题不能拆边，而

只能给边定向，就像第9章的例题“一个调度问题”那样。

假设输入的原图为G。首先把它的无向边任意定向，然后把定向后的有向边单独组成另 外一个图G'。具体来说，初始时G'为空，对于G中的每条无向边M-v，把它改成有向边M-〉v， 然后在G'中连一条边w-〉v (注意这个定向是任意的。如果定向为v->M，则在G'中连一条边v-

〉M)。

接下来检查每个点i在G中的入度和出度。如果所有点的入度和出度相等，则现在的G已 经存在欧拉回路。假设一个点的入度为2，出度为4，则可以想办法把一条出边变成入边(前 提是那条出边原来是无向边，因为无向边才可以任意定向)，这样入度和出度就都等于3 了；一般地，如果一个点的入度为in(i)，出度为out(i)，则只需把出度增加(in(i)-out(i))/2即可 (因为总度数不变，此时入度一定会和出度相等)。如果in(i)和out(i)的奇偶性不同，则问题 无解。

如果把G'中的一条边M-〉V反向成V-〉M，则M的出度减1，V的出度加1，就像是把一个叫“出 度”的物品从结点M“运输”到了结点V。是不是很像网络流？也就是说，满足out(i)〉in(i)的每个 点能“提供”一些“出度”，而out(i)<in(i)的点则“需要”一些“出度”。如果能算出一个网络流，把 这些“出度”运输到需要它们的地方，问题就得到了解决(有流量的边对应"把边反向"的操 作)。

细节留给读者思考。相信经过了前面题目的锻炼，读者一定可以解决这个问题。

例题 11-14 星际游击队(Asteroid Rangers, ACM/ICPC World Finals 2012, UVa1279 )

三维空间里有《 ( 2<n<50 )个勻速移动的点，第i个点的初始坐标为(w)，速度为 (vx,vy,vz)。 求最小生成树会改变多少次。输入保证在任意时刻最小生成树总是唯一的，并且 每次变化时，新的最小生成树至少会保持10-6个单位时间。

【分析】

不难发现：最小生成树切换的时刻一定对应着某两条边(M1,v1)和(m2,v2)的权值相等。一 共有0(n2)条边，因此有0(n4)种可能的切换时间(称为事件点)。

最容易想到的做法是把所有可能的事件点按照时间从小到大排序，依次计算每个事件点 之后0.5*10-6时刻的最小生成树(题目保证了这期间最小生成树不会发生变化)，判断它是 否和上一个最小生成树相等。假设使用0(n2)时间复杂度的prim算法，总时间复杂度 为0(n6)，需要优化。

—个行之有效的优化是：假设一个事件点对应（u1，v1）和（u2，v2）的权值相等。只有当 （u1，v1）和（u2，v2）恰好有一个在当前最小生成树，且在该事件点之后这条边会变得比另一条边 大时，才有可能发生切换。实践中满足这个条件的事件点非常少，运行效率大幅度提高

例题 11-15 帮助小罗拉(Help Little Laura, Beijing 2007, UVa1659 )

平面上有m条有向线段连接了n个点。你从 某个点出发顺着有向线段行走，给沿途经过的每 条线段涂—种不同的颜色，最后回到起点。你可 以多次行走，给多个回路涂色。可以重复经过— 个点，但不能重复经过—条有向线段。如图11-17所示是—种涂色方法（虚线表示未涂色）。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-256.jpg)



每涂一个单位长度将得到x分，但每使用一

种颜料将扣掉y分。假定颜料有无限多种，如何涂色才能使得分最大？输入保证若存在有向 线段u->v ,则不会出现有向线段v->u。n<100 , m<500 , 1<x，y<1000。

分析】

本题的模型是：给出—张有向图，从中选出权和最大的边集，组成若干个有向圈。这里 的边权等于题目中的dx-y ,其中d为边的两个端点的欧几里德距离。

由于每个点并不—定只属于—个有向圈，因此例题“最优巴士路线设计”中“匹配后继”的 方法不再适用。尽管如此，还是可以建立—个费用流模型：在原图的基础上设每条边的容量 为1，费用为边权，要求找—个流，使得所有结点都满足流量平衡（入流等于出流）条件， 且总流量乘以费用的总和最大。这样的模型没有源也没有汇，而且每个结点都要满足流量平 衡，所以也没有“最大流”这种说法，称为循环流（ c1rculat1on）。 换句话说，此处要解决的问 题是最大费用循环流问题。

对于最大费用流问题，通常会把所有边权取负，变成最小费用流问题。最大费用循环也 不例外：把每条边的边权改成-dx+y ,则问题转化为最小费用循环流问题。这个问题的解决 方法和最小费用最大流有些类似，只不过每次不是求一条s-t的最小费用增广路，而是找整个 图的—个负费用增广圈。沿着负费用增广圈进行增广之后，每个结点的流量平衡不会被破 坏，而整个循环流的总费用变小了。换句话说，求解最小费用循环流的伪代码就是：

while(find_negative_cycle()) augment();

根据残量网络的概念不难得出：找负费用增广圈等价于在残量网络中找负权圈——这正

是Bellman-Ford算法的拿手好戏。

上述算法可以很好地解决本题，但是本题还有一个更有意思的方法，可以避开负圈：新 增附加源5和附加汇Z ,对于原图中的每条负权边M^V变成3条边：5一V , V^M和,容量均 为1 ,但是V^M的费用为原来的相反数，其他两条边的费用为0。原图中的正权边M^V保持不 变：容量为1，费用为权值。

经过这样的处理之后，所有的边都变成正权了，但是网络里出现了很多重边，需要处理 一下：对于任意点M ,假设5^M的弧有条，M^Z的弧有b条，则当fl〉b时只保留一条5^M的 弧，容量为^b ,删除所有M^Z的弧；^<b时类似；^=b时删除所有5^M和M^Z的弧。处理完毕 之后，只需求一次5-Z最小费用最大流，则求出的最小费用值再加上原图的所有负权之和就是 循环流的最小费用值。

是不是很神奇？作为本章最后的“压轴题”，请读者思考这样做的正确性。另外，这种处

理负权的方法具有一定的普遍性，有兴趣的读者可以自行研究。

###### 11.6 训练参考

本章的篇幅不长，内容也不多，不过非常重要。考虑到介绍图论算法的书籍和文章很

多，本章并没有很正式地介绍各种概念、算法的证明以及严格的复杂度分析，而是把重点放

在了程序实现技巧和建模技巧上。本章例题大都不难，建议读者除了掌握不带星号的题目之

外也努力弄懂带星号的题目，并且编程实现。例题列表如表11-1所示。

表11-1 例题列表

| 类别       | 题号     | 题目名称（英文）                 | 备注                        |
| ---------- | -------- | -------------------------------- | --------------------------- |
| 例题11-1   | UVa12219 | Common Subexpre55ion Elimination | 表达式树                    |
| 例题11-2   | UVa1395  | Slim Span                        | 最小生成树                  |
| 例题11-3   | UVa1151  | Buy or Build                     | 最小生成树                  |
| 例题11-4   | UVa247   | Calling Circles                  | Floyd算法、连通分量         |
| 例题11-5   | UVa10048 | Audiophobia                      | Floyd算法，最大值最小 路    |
| 例题11-6   | UVa658   | It'5 not a Bug, it'5 a Feature!  | 复杂状态的最短路            |
| 例题11-7   | UVa753   | A Plug for UNIX                  | Floyd算法、二分图最大 匹配  |
| 例题11-8   | UVa11082 | Matrix Decompressing             | 网络流建模                  |
| 例题11-9   | UVa1658  | Admiral                          | 拆点法，最小费用流          |
| 例题11-10  | UVa1349  | Optimal Bus Route Design         | 后继模型；二分图最小 权匹配 |
| 例题11-11  | UVa12661 | Funny Car Racing                 | 特殊图的Dij kstra算法       |
| *例题11-12 | UVa1515  | Pool construction                | 最小割模型                  |
| *例题11-13 | UVa10735 | Euler Circuit                    | 网络流建模                  |
|            |          |                                  |                             |

| *例题11-14 | UVa1279 | Asteroid Rangers  | 动点的最小生成树 |
| ---------- | ------- | ----------------- | ---------------- |
| *例题11-15 | UVa1659 | Help Little Laura | 最小费用循环流   |

下面是习题。本章的习题大都不难，建议读者至少完成10道题目。如果要达到更好的效

果，至少需要完成15道题目。

习题 11-1 网页跳跃(Page Hopping, ACM/ICPC World Finals 2000, UVa821 )

下面是习题。本章的习题大都不难，建议读者至少完成10道题目。如果要达到更好的效

果，至少需要完成15道题目。

最近的研究表明，互联网上任何一个网页在平均情况下最多只需要单击19次就能到达任

意一个其他网页。如果把网页看成一个有向图中的结点，则该图中任意两点间最短距离的平

均值为19。

输入一个《 ( 1<n<100 )个点的有向图，假定任意两点之间都相互到达，求任意两点间最 短距离的平均值。输入保证没有自环。

习题 11-2 奶酪里的老鼠(Say Cheese, ACM/ICPC World Finals 2001, UVa1001 )

无限大的奶酪里有n ( 0<n<100 )个球形的洞。你的任务是帮助小老鼠A用最短的时间到 达小老鼠O所在位置。奶酪里的移动速度为10秒一个单位，但是在洞里可以瞬间移动。洞和 洞可以相交。输入n个球的位置和半径，以及A和O的坐标，求最短时间。

习题 11-3 因特网带宽(Internet Bandwidth, ACM/ICPC World Finals 2000, UVa820 )

在因特网上，计算机是相互连通的，两台计

图 11-18 计算机和路径



算机之间可能有多条信息连通路径。流通容量是

指两台计算机之间单位时间内信息的最大流量。

不同路径上的信息流通是可以同时进行的。例

如，图11-18中有4台计算机，总共5条路径，每

条路径都标有流通容量。从计算机1到计算机4的

流通总容量是25，因为路径1-2-4的容量为10，

路径1-3-4的容量为10，路径1-2-3-4的容量为5。

请编写—个程序，在给出所有计算机之间的路径和路径容量后求出两个给定结点之间的

流通总容量(假设路径是双向的，且两方向流动的容量相同)。

习题11-4 电视网络( Cable TV Network, ACM/ICPC SEERC 2004, UVa1660)

给定一个打(n<50)个点的无向图，求它的点连通度，即最少删除多少个点，使得图不 连通。如图11-19所示，图11-19 ( a )的点连通度为3 ,图11-19 ( b )的点连通度为0 ,图11-19(c)的点连通度为2 (删除1和2或者1和3 )。

(a)    (b)    (c)

图11-19 点的连通度

习题11-5 方程( Equation, ACM/ICPC NEERC 2007, UVa1661)

输入一个后缀表达式f(x),解方程f(x)=0。表达式包含四则运算符，且x最多出现一次。

保证不会出现除以常数0的情况，即至少存在一个x ,使得不会除0。所谓后缀表达式，是

指把运算符写在运算数的后面。例如，(4^+2)/2的后缀表达式为4^ * 2+ 2/。样例输入与输出 如表11-2所示。

表11-2 样例输入与输出

| 样例输入      | 样例输出 |
| ------------- | -------- |
| 4 X * 2 + 2 / | X = -1/2 |
| 2 2 *         | NONE     |
| 0 2 X / *     | MULTIPLE |

习题 11-6 括号(Brackets Removal, NEERC 2005, UVa1662 )

给一个长度为《的表达式，包含字母、二元四则运算符和括号，要求去掉尽量多的括 号。去括号规则如下：若A和B是表达式，则A+(B)可变为A+B，A-(B)可变为A-B'，其中B'为 B把顶层“+”与“-”互换得到；若A和B为乘法项(term)，则A*(B)变为A*B，A/(B)变为A/B'， 其中B'为B把顶层“*”与“/”互换得到。本题只能用结合律，不能用交换律和分配律。

例如，((a-b)-(c-d)-(z*z*g/f)/(p*(t))*((y-u)))去掉括号以后为 a-b-c+d-z*z*g/f/p/t*(y-u)。

习题11-7 电梯换乘( Lift Hopping, UVa 10801)

在一个假想的大楼里，有编号为0〜99的100层楼，还有《 (必5 )座电梯。你的任务是从 第0楼到达第&楼。每个电梯都有一个运行速度，表示到达一个相邻楼层需要的时间(单位： 秒)。由于每个电梯不一定每层都停靠，有时需要从一个电梯换到另一个电梯。换电梯时间 总是1分钟，但前提是两座电梯都能停靠在换乘楼层。大楼里没有其他人和你抢电梯，但你 不能使用楼梯(这是一个假想的大楼，你无须关心它是否真实存在)。

例如，有3个电梯，速度分别为10、 50、 100，电梯1停靠0、 10、 30、 40楼，电梯2停靠 0、 20、 30楼，电梯3停靠第0、 20、 50楼，则从0楼到50楼至少需要3920秒，方法是坐电梯1 到达30楼( 300秒)，坐电梯2到达20楼( 500秒+换乘60秒)，再坐电梯3到达50楼( 3000秒 +换乘60秒)，一共300+50+60+3000+60=3920秒。

习题11-8 净化器( Purifying Machine, ACM/ICPC Beijing 2005, UVa1663)

给m个长度为n的模板串。每个模板串包含字符0，1和最多一个星号“*”，其中星号可以匹 配0或1。例如，模板01*可以匹配010和011两个串，而模板集合｛*01， 100， 011｝可以匹配串 ｛001， 101， 100， 011｝。

你的任务是改写这个模板集合，使得模板的个数最少。例如，上述模板集合｛*01， 100， 011｝可以改写成｛0*1，    10*｝，匹配到的字符串集合仍然是｛001，    101，    100，

011｝。 n<10， m<1000。

习题11-9 器人警卫( Sentry Robots, ACM/ICPC SWERC 2012, UVa12549)

在一个!行2列（1<r , X<100 ）的网格里有空地（.）,重要位置（* ）和障碍物（# ）, 如图11-20所示。用最少的机器人看守所有重要位置。每个机器人要放在—个格子里，面朝 上下左右4个方向之—。机器人会发出激光，—直射到障碍物为止，沿途都是看守范围。机 器人不会阻挡射线，但不同的机器人不能放在同—个格子。

| Grid          | Solution      |
| ------------- | ------------- |
| 本本          | -＞本         |
| 釋    .    ， | 嚤    署    ■ |
| -*#*-         | ,t # t ,      |
|               |               |
|               |               |

图11-20 “机器人警卫”问题示意图

习题 11-10 Risk游戏(Risk, NWERC 2010, UVa12011 )

有n （ n<100 ）个阵地。已知我方在每个阵地上的士兵数（0〜100的整数），其中士兵大 于0表示该阵地由我方占领，否则为敌方占领。对于—个我方阵地，如果其相邻的阵地中有

敌方阵地，则称为边界阵地（ border region）。

现在对我方士兵进行调动（每次可以把—个士兵从—个阵地移动到相邻的我方阵地，操

作可以进行任意多次），在保证我方不丢失阵地的情况下（即我方每个阵地上的人数不为

0），使得我方的边界阵地中人数最少的阵地的人数尽量多。

输入保证我方至少有—个阵地，敌方也至少有—个阵地，且至少有—个我方阵地与敌方

阵地相邻。

n（ n<200000 ）个城市形成一棵树，每条边有权值C（/J）。任意两个点的容量况/，力定义 为/与/唯一通路上容量的最小值。找一个点（它将成为中心城市），使得它到其他所有点的 容量之和最大。

习题11-12 岛屿( Islands, ACM/ICPC CERC 2009, UVa1665)

输入一个n*rn矩阵，每个格子里都有一个［1,109］正整数。再输入T7个整数

<ZT<109）,对于每个Zz ,输出大于，2的正整数组成多少个四连块。如图11-21所示，大于1的正 整数组成两块，大于2的组成3块。

评论：这个题目虽然和图论没什么关系，但是可以用到本章介绍的某个数据结构。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-259.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-260.jpg)



图11-21 “岛屿”问题示意图

习题11-13 最短路线( Walk, ACM/ICPC Jinhua 2012, UVa1666)

平面上有打（n<50 ）个建筑物，求从（^1j4）到（^2，y2）的一条路，使得转弯次数最少。建 筑物都是坐标平行于坐标轴的矩形，可以相互接触但不会重叠（接触的点或者边都不能通 过）。你只能沿着平行于坐标轴的直线走，可以沿着建筑物的边走，但不能穿过建筑物。无 解输出-1。

提示：本题在细节上容易出错。

有一棵以«<50)个叶子的无权树。输入两两叶子的距离，恢复出这棵树并输出每个非 叶子结点的度数。

习题11-15 绿色行动( Let's Go Green, ACM/ICPC Jakarta 2012, UVa1668)

输入一棵打(2<n<100000 )个结点的树，每条边上都有一个权值。要求用最少的路径覆 盖这些边，使得每条边被覆盖的次数等于它的权值，如图11-22所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-261.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-262.jpg)



图11-22 “绿色行动”问题示意图

习题11-16 交换房子( Holiday's Accomodation, ACM/ICPC Chengdu 2011, UVa1669)

有一棵n ( 2<n<105 )个结点的树，每个结点住着一个人。这些人想交换房子(即每个人 都要去另外一个人的房子，并且不同人不能去同一个房子)。要求安排每个人的行程，使得 所有人旅行的路程长度之和最大。

习题11-17 王国的道路图( Kingdom Roadmap, ACM/ICPC NEERC 2011, UVa1670)

输入一个打(n<100000 )个结点的树，添加尽量少的边，使得任意删除一条边之后图仍 然连通。如图11-23所示，最优方案用虚线表示。

图11-23 “王国的道路图”问题示意图

习题11-18 交通堵塞( Traffic Jam, ACM/ICPC Dhaka 2009, UVa12214)

有一条包含n （ 1<n<25 ）段的单向折线，你想开着一辆会“飞”的车从折线起点到折线终

点，且耗油量最少。沿着折线方向正常行驶时单位耗油量为1， “飞行”时单位耗油量

为f （ 2<f<5 ）。如图11-24所示，户2 ,折线为（0，0）-（2,2）-（2，-2）,沿折线行驶的耗油量为

2.828+4=6.828，最优解是从（0，0）“飞”到（2，-1.154），然后正常行驶到（2，-2），耗油量为

2*2.309+0.846=5.464。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-264.jpg)



习题11-19 火车延误( Train Delays, NWERC 2011, UVa1518)



有打（1<n<100 ）条火车线路，均为每小时发车一次。输入每条线路的起点站和终点站名



称、发车时间讲(0<m<59 )、正点运行时间Z ( 1<Z<300 )、到达时间、延误概率百分

比p ( 0<p<100 )和最大延误时间^ ( 1<必120 )。如果火车延误，实际延误时间为［1，切内均匀

分布的整数，并且只有在列车发车之后才能知道是否会延误(但此时已经无法换车)。

假定换乘不花时间(即使到达时刻等于要换乘的列车的发车时刻，也可以完成换乘)，

并且可以根据实际延误情况动态改变乘车计划，你的任务是让总时间的期望值最小。出发时

间可以自己定。

习题11-20 租车( Rent a Car, UVa12433)

你想经营一家租车公司。接下来的#天中已经有了一些订单，其中第/天需要辆车 (0<~<100 )。初始时，你的仓库是空的，需要从C家汽车公司里买车，其中第/家公司里 有^辆车，单价是pz ( 1<cz，pz<100 )。当一辆车被归还给租车公司之后，你必须把它送去保养 之后才能再次租出去。一共有及家服务中心，其中第/家保养一次需要或天，每辆车的费用 为\ ( 1<或，久<100 )。这些服务中心都很大，可以接受任意多辆车同时保养。你的仓库很 大，可以容纳任意多辆车。你的任务是用最小的费用满足所有订单。 1<N，C，R<50。

例如， N=3， C=2， R=1， r={10，20，30} ， c1=40， p1=90， c2=15， p2=100。 d1=1， s1=5，

最优方案是：先买50辆车，其中在公司1买40辆，公司2买10辆，费用为

90*40+100*10=4600。第一天白天租出去10辆车，晚上收回之后送到服务中心保养一天，费

用为5*10=50，第3天白天可以再次出租。第2天出租20辆车，第3天把剩下的20辆车和保养后

的10辆车一起出租。总费用为4600+50=4650。

习题11-21 矩阵中的符号( Sign of Matrix, UVa11671)

有一个n*n ( 2<n<100 )的全零矩阵，每次可以把某一行的所有元素加1或减1，也可以把 某一列的所有元素加1或减1。操作之后每个元素的正负号已知，问：至少需要多少次操作？ 无解输出-1。例如，要达到图11-25 ( a)中的正负号矩阵，至少需要3次操作，如图11-25 ( b )所示。

### B+B0

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-265.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-266.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-267.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-268.jpg)



0+00

e+eo

(a )

0+200 —1 +1 -1 -1

0+200

0+200

(b)



###### 11.7 总结与展望

至此，前11章的讲解就告一段落了。接下来该做什么？按照先后顺序，建议读者做3件

事：

巩固前11章的内容。先别急，在继续前进之前，笔者建议大家先把前11章的内容学扎

实。什么叫“学扎实”？每章的“小结和习题”部分都有具体描述，这里不再赘述。

但是有一点需要注意：理解一个题解和自己独立推导出所有细节还是不一样的，所以在

看完一个难题的题解之后最好把它做两遍：一遍是刚看完题解以后“趁热打铁”，一遍是等忘

掉题解后自己从头推导一遍。

学习《算法竞赛入门经典——训练指南》。确保前11章基础扎实之后，推荐学习《算

法竞赛入门经典——训练指南》。该书主要是讲解本书前11章中没有涉及的知识点，如表

11-3所示。

表11-3 《算法竞赛入门经典——训练指南》知识点介绍

| 容内    | 称名         | 点识知                                                       |
| ------- | ------------ | ------------------------------------------------------------ |
| 章1有第 | 法计础算设基 | 等不形边四法算呼法S解 jo推的递LIS吖 、题法、hh '锥H法、描式扫法算圈判oydFl |
| 章2菩第 | 数基         | _症一二ely、agupol幕、 pp、阵 g理矩遷11!NiBurTTQ辛对循秩应离解成阵的自适理换分矩值余定置元极余消数国剩程当消函 中国夫过当斯约- 求凸法逆尔科斯高分法法马乘马元和理消剩undLG |
| 章3有第 | 用据构实数结 | 用ho- 及Ah 以也树伸•ne和巧Trap 序 er树T并段合线方法分裂题、穿 问H和RLC次 、及W)组的(BITS组(后它们数机状动机树自动TicADasiAorC |
| 章第    | 几何问题     | 计mLG 关PS 相 球交和面圆平与半面积壳包的a 凸 靴.ql维边形卡(三多转础系旋何基关包几何线的凸三维直定三\ lh_1点内判形何边形量几在多本向点基算 |
|         | 论法图算     | 连树问稳定强树稳成图的生法向图小算卽次、\|量、桃Mi路'通 sKuh 连釀K的双小瓶题图最Arn无Ta无系)桥约束图和约形割顶差(树形图问题成树 嗣1向S用：2- 有sS量、！T取FSD通题 |

| 第5章 | 与模型       | 婚姻问题、二分图最大匹配的应用（最小覆盖、最大独立集、DAG最 小路径覆盖）、Dime算法和ISAP算法、网络流模型变换技巧（多源多 汇、下界、循环流、流量不固定的费用流）和经典应用（最大闭合子 图、最大密度子图等） |
| ----- | ------------ | ------------------------------------------------------------ |
| 第6章 | 多法题更算专 | 轮廓线动态规划（包括带连通信息的）、嵌套数据结构（二维线段树 等）、分袂数据结构、minimax搜索和alpha-beta剪枝、舞蹈链和DLX算 法、二维和三维仿射变换及其矩阵、离散化、几何扫描法（包括BST 的使用）、运动规划、Pick定理、Lucas定理、高次模方程和原根、多 项式乘法与FFT、线性规划 |

学习本书第12章。有了前11章和《算法竞赛入门经典——训练指南》的基础，现在可

以去“啃”第12章了。说“啃”，是因为这一章的内容实际上已经不属于入门的范畴，而是一些

高级内容，甚至还包括一些世界顶级比赛的压轴题。这样的安排是有意的，因为本书的目的

并不仅仅是让读者入门，而是“从入门开始一直伴随读者”。正如第2版前言所说，请把这一

章看作是游戏通关之后多出来的Hard模式。

难题主要分为3种。一是需要“生僻知识”的，二是思维难度大的，三是编程实现复杂

的。本书第12章在这3种难题中精选了一些值得学习的题目，顺便讲解了相关知识点和解题

方法，包括DFA、NFA和正规表达式、DAWG、树的分治、欧拉序列、轻重路径剖分（树链 剖分）、LCA转RMQ、Link-Cut树、可持久化数据结构、多边形的布尔运算和偏移、非完美 算法等。

准备好了吗？让我们开始迎接真正的挑战吧！
