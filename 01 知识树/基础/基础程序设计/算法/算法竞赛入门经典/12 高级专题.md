第12章 高级专题

学习目标

E 了解DFA、NFA和正规表达式的概念 E理解DAWG与后缀自动机的概念及常见用法 E掌握树的点分治算法

E理解树的欧拉路径以及LCA和RMQ的关系 叵理解树的轻重路径剖分和Link-Cut树 叵了解可持久化数据结构的原理和典型实现 E理解多边形布尔运算的原理和应用（如多边形偏移）

叵了解缓冲数据结构和分层数据结构的思想 E掌握启发式合并、块链表、懒标记等数据结构设计思想和工具 E学会用非完美算法求解问题 E初步了解OOP

叵初步了解函数式编程与LISP E初步了解交互式题目

本章是全书最后一章，也是难度最高的一章。在第11章的末尾我们已经提到，如要顺利

阅读本章内容，除了需要熟练掌握前11章的内容外，还需要熟悉本书的姊妹篇——《算法竞

赛入门经典——训练指南》（以下简称《训练指南》）的大部分内容。

###### 12.1 知识点选讲

12.1.1 自动机

有限自动机。 一^个DFA （ Deterministic Finite Automaton , 确定有限状态自动机）可以用 —个5元组（Q, Z, 5，q0, F）表示，其中Q为状态集，Z为字母表，5为转移函数，q0为起始状 态，F为终态集。

这个DFA代表一个字符串集合。如何判断一个字符串是否属于这个集合（称为“被这个 DFA接受”）呢？方法是边读边进行状态转移。一开始时，自动机在起始状态q0 ,每读入一

个字符c后，状态转移到5（q，c）,其中q为当前状态。当整个字符串读完之后，当且仅当q在终 态集F中时，DFA接受这个字符串。如图12-1所示，Q={ShS2}，Z={0, 1}，q0=Sh F={SJ （用 双圈表示），状态转移函数用转移弧来表示（如Si上面标有1的弧表示5（Sh1）=Si ）:

不难发现，上面的DFA接受的字符串集合是：0的个数为偶数的01串。

NFA（ Nondeterministic Finite Automata， 非确定自动机）和DFA差不多，唯一的区别是 状态转移函数返回的是—个集合（可能是空集！）而不是—个状态，实际转移到集合中的任 何一个状态（所以是“非确定性”）。如图12-2所示，从p出发有两条标记为1的弧，即5（p，1）= {p，q}。

图12-1 DFA示例



图12-2 NFA示例



不难发现，上面的NFA接受的字符串集合是：以1结尾的01串。NFA有一个变种，即s-NFA ,它和NFA的唯一区别是：可以有标记为s的转移弧，表示不需要输入任何一个字符就 可以完成转移。下面是—个例子，如图12-3所示，接收的字符串集合是： 0的个数为偶数或 者1的个数为偶数。

0

0

0

1

1

图12-3 £-NFA示例

仔细观察这个自动机会发现：它实际上是两个DFA的并。上面的DFA （起始状态为Si） 表示“0的个数为偶数”，下面的DFA （起始状态为S3 ）表示“1的个数为偶数”。

给定一个s-NFA，如何判断一个字符串是否被它接受？为方便起见，一般会先把s-NFA 转化为等价的NFA，方法是先求出每个状态的所谓“s-闭包”，即只允许经过s-转移弧时可以 到达的状态集（例如图12-3中呂0的闭包为｛S^S^SJ ），然后把每个状态转移5（q，c）=S改成

5（q，c）=S'，其中S'等于S中所有状态的s-闭包的并集。这样，就去掉了所有的s-转移。不过需 要注意的是，这个NFA的起始状态有多个，它等于原s-NFA的起始状态的s-闭包。例如，对 于图12-3，得到的NFA如图12-4所示，其中起始状态集为叫為為｝。注意，这个NFA包含了 3个互不相干的部分。

假定字符串为010，可以用递推的方法求出输入每个字符之后的状态集。

起始状态集：｛S0, Si，S3｝。

输入字符0之后：｛S2, S3｝。

输入字符1之后：｛S2, S4｝。

输入字符0之后：｛Sb S4｝。

因为状态集中包含终态Si ,串010被接受。不难把上述过程推广到一般情况，如果NFA 的状态个数为m ,字符串长度为《 ,则判断该串是否被接受的时间复杂度为O(rn«)。

例题 12-1 语言的历史(History of Languages, ACM/ICPC Hangzhou 2008, UVa1671 )

输入两个DFA ,判断是否等价。第一行为字母表的大小7( 2^7^26 )，然后是两个DFA 的描述。每个DFA的第一行为状态数《 ( ^<2000 ),以下n行每行描述一个状态，格式为夂 X0, X1，…，Xr1 ,其中^表示是否为终态(F=1表示是，0表示否)。-1<X<N ,表示该状态读 入i后转移到的状态，其中-1表示该转移不存在。两个DFA的起始状态均为0。

【析】

本题的做法不止一种，这里选择一个概念上最简单的做法：把“a和b等价”转化为“a的补 和b不相交，且b的补和a不相交”。

如何求DFA的补？也就是把接受的串变成不接受的串，不接受的串变成接受的串。由此 可以想到，只需把终态和非终态互换即可。

如何判断两个DFA不相交？可试着找一个同时被两个DFA接受的串，如果找不到，则说 明两个DFA不相交。如何找这个串？构造一个新的DFA ,它的每个状态都可以写成(^，幻)，

其中力和幻分别是两个DFA中的状态，当且仅当力和幻分别是两个DFA的终态时，(力，q2)是 新DFA的终态。这样，问题就转化为了：找一个被新DFA接受的串。这只需要用经典的图遍 历(DFS或BFS )即可，时间复杂度为0(«2)。

本题还有一个细节，即对于“该转移不存在”的处理。虽然可以直接处理，但更经典的方

法是加一个“所有转移都指向自己”的“孤岛状态”，把所有不存在的转移都改成转移到孤岛。

这样一来，所有转移都是存在的，程序比较好写。

例题12-2 不相交的正规表达式( Disjoint Regular Expressions, ACM/ICPC NEERC

2012, UVa1672 )

输入两个正规表达式，判断二者是否不相交(即不存在一个串同时满足两个正规表达

式)。本题的正规表达式比较简单，只包含以下几种情况。

□单个小写字符c。

□或：(P|Q)。如果字符串s满足P或者满足Q，则s满足(PQ)。

□连接：(PQ)。如果字符串Sj满足P，s2满足Q，则sa满足(PQ)。

□克莱因闭包：(P*)。如果字符串S可以写成0个或多个字符串^的连接S02...，且每个串都 满足P，则S满足(P*)。注意，空串也满足(P*)。

另外，多余的括号可以省略，克莱因闭包的优先级最高，其次是连接，最后是或。例 如，abc*|de表示(ab(c*))|(de)。

输入的两个正规表达式P和D均不超过100个字符。如果P和D不是不相交的，应输出一个 字符串，同时满足P和D。例如，a(ab)*b和a(a|b)*ab是不相交的，但a(ab)*a和a(a|b)*ba不是不 相交的，因为aaba同时满足二者。

【分析】

正规表达式(regular expression，也译为正则表达式)是进行文本处理的有力工具。对 它的完整讨论超出了本书的范围，但是本题的解法仍然是支持更复杂的正规表达式语法的基 础。

例12-2中用到的是DFA，但是本题似乎很难直接从正规表达式构造DFA，因为DFA有一 个很强的限制：每个转移都是确定性的。如果放宽这一限制，是否能构造出NFA甚至s-NFA 呢？

幸运的是，s-NFA并不难构造[m](#bookmark10)。图12-5中分别是单字符的自动机、(A|B)的自动机、 (AB)的自动机和(A*)的自动机。

对应的自动机

.4对極的自动机

对EZ的自动叽    j

5对椏的自动机 J

S对应机

图12-5单字符、(A|B)、(AB)和(A*)自动机

从上面的自动机可以清楚地看到构造原理，不过状态有点多。

□ (A|B)的自动机中可以把A、B和整个自动机的起点合并成一个点，把A、B和整个自动机 的终点也合并。

□    (AB)自动机中可以把整个自动机的起点和A的起点合并，A的终点和B的起点合并，B的 终点和整个自动机的终点合并。

□    (A*)自动机中可以把A的起点和终点合并。

现在已经拥有两个s-NFA了。为了方便起见，先把得到的两个s-NFA转化为NFA。接下 来就可以采用和上一题相同的思路，用BFS寻找一个同时被两个自动机接受的非空串了。注 意这个串必须非空，所以要用三元组(qhq2，    b)来描述状态，表示两个自动机分别处于状态

q^nq2 , b=0表示没有进行过非s转移，b=1表示进行过。

DAWG。有一种特殊的自动机DAWG ( Directed Acyclic Word Graph )[(2)](#bookmark12),简记为Dw ,可 以接受一个字符串w的所有子串，而且状态只有0(n)个，其中n是w的长度。

听上去很神奇吧？理解DAWG的关键是end-set。一个单词的end-set是它在w中出现位置 (从1开始编号)的右端点集合。例如，对于w=abcbc , end-setw(bc)=end-setw(c)={3，5}。在 DAWG中，end-set相同的子串属于同一个状态。如图12-6所示是w=abcbc的DAWG的两种画 法，其中图12-6 ( a )中的结点里写着end-set ,图12-6 ( b )的结点里写着子串集合本身。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-274.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-275.jpg)



对于任意结点S ,从根结点到的路径与中的字符串是一一对应的，并且所有路径上的 各个字母连接起来就是S中对应的那个字符串。例如，end-set为｛4｝的结点中有3个串abcb， bcb，cb ,从根结点到该结点的3条路径分别为a-〉b-〉c-〉b、b->c->b和c->b。另外，每个状态中 都有—个最长串，其他的都是它的后缀，并且长度连续。

任意两个结点的end-set要么不相交(没有公共元素)，要么其中一个为另一个的子集， 因此可以得到一个树状结构T(w),如图12-7所示。

图12-7 (a)中的虚线是DAWG中的边，实线是T(w)的边。这棵树其实是w的逆序串的后 缀树，如图12-7 ( b )所示。T(w)最重要的性质就是：对于任意一个结点S ,假设它的最长子 串为x ,则的所有后缀就是S及其所有袓先结点中的字符串集合。例如，字符串abc是结点 ｛abc｝的最长串，它和它的袓先｛bc，0与｛空串｝就是abc的后缀集。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-276.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-277.jpg)



图12-7树状结构T(w)

DAWG可以在线性时间内在线构造，即每次在字符串末尾添加一个字符后，只需0(1)时

间就可以更新DAWG。不过对该构造算法的具体讨论超出了本书的范围，强烈建议读者在网 上搜索相关资料，学会了DAWG的构造算法以后再看下面的例题。另外需要特别指出的 是，end-5ez中包含元素n的状态对应w的后缀。如果只把那些状态设为接受态，则可以得到一 个后缀自动机(suffix automaton，SAM )。一般来说，介绍后缀自动机的文献中讲的“后缀自 动机的构造算法”实际上就是DAWG的构造算法。

例题 12-3 数字子串的和(str2int, ACM/ICPC Tianjin 2012, UVa1673 )

输入《(«^10000 )个数字串(即由0〜9组成的字符串)，把所有数字串的所有连续子串 提取出来转化为整数，然后去掉重复整数。例如，两个数字串101和123可以得到8个整数：

1， 10， 101， 2， 3， 12， 23， 123。求这些整数之和除以2011的余数。所有数字串的长度之和不超过 105。

【分析】

DAWG在概念上很适合这道题目：每个状态里的字符串集合就是不同的子串集合。不过 要想完整地解决本题，还有两个障碍。第一，本题的数字串有多个，而DAWG是针对单个字 符串的；第二，因为数字0的存在，两个不同子串可能对应同一个整数。

第一个问题的解决方案在《训练指南》中已经介绍过了。设输入的数字串为wh w2，…，

wn，把它们拼成一个长串后，构造w的DAWG。第二个问题需要用递推来解

决。从根结点开始走，规定不能走$边，且第一次不能走0边。设c(u)和s(u)分别表示到达结点 u的方案数(也就是结点u中合法子串对应的整数个数)以及这些整数之和除以2011的余数， 就可以递推出结果了，细节留给读者思考。

需要注意的是：因为字符串的总长度比较大，最好先对DAWG的各个状态拓扑排序，再 递推，而不要直接进行记忆化搜索，否则可能会栈溢出。

12.1.2 树的经典问题和方法

路径统计。给定一棵《个结点的正权树，定义dist(M，v)为m，v两点间唯一路径的长度(即 所有边的权和)，再给定一个正数尺，统计有多少对结点(^)满足dist(^)认。

分析】

如果直接计算出任意个结点之间的距离，则时间复杂度高达0（«2）。因为一条路径要么 经过根结点，要么完全在一棵子树中，所以可以尝试使用分治算法：选取一个点将无根树转 为有根树，再递归处理每一棵以根结点的儿子为根的子树，如图12-8所示。

还记得第9章中介绍的“重心”吗？可以证明：如果选重心为根结点，每棵子树的结点个 数均不大于《/2 ,因此递归深度不超过O（logn）。

在确立了递归的算法框架之后，需要统计3类路径。

情况1：完全位于一棵子树内的路径。这一步是分治算法中的“递归”部分。

情况2 :其中一个端点是根结点。这一步只需要统计满足成/）认的非根结点/的个数，其 中成/）表示点/到根结点的路径长度。

情况3：经过根结点的路径。这种情况比较复杂，需要继续讨论。

记沁）表示根结点的哪棵子树包含/ ,那么要统计的就是：满足硪/）+成/）认且沁）不等 于s⑺的（/，力个数，如图12-9所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-278.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-279.jpg)



由图12-9可看出，任意两个s值不同的点之间都是一条经过根的路径，可以使用补集转

换。

设A为满足成/）+成/）汉的（/，力个数，B为满足硪/）+成/）认且＞s（/）=s⑺的（/，J）个数，则答案等 于A-B。如何计算A呢？首先把所有值排序，然后进行一次线性扫描即可。B的计算方法也 一样，只不过是对于根的每个子结点分别处理，把s值等于该子结点的所有值排序，然后线 性扫描。根据主定理，算法的总时间复杂度为O(n(logn)2)。

上面介绍的是基于点的分治算法。实际上，还有基于边和链的分治算法，有兴趣的读者

可以参考相关资料。

例题 12-4 铁人比赛( Ironman Race in Treeland, ACM/ICPC Kuala Lumpur 2008, UVa12161 )

给定一棵n个结点的树，每条边包含长度£和费用D ( 1<D, L<1000 )两个权值。要求选择 一条总费用不超过m的路径，使得路径总长度尽量大。输入保证有 解， 1<n<30000， 1<m<108。

【分析】

沿用前面的分治算法框架，关键问题就是如何计算经过树根的最优路径。首先用DFS求 出子树内所有结点到根的路径长度和费用，然后按照DFS序从小到大枚举这些结点。枚举到 结点i时，假设它到根的路径的费用为c(i),则需要在i之前的结点(即已经枚举过的结点)中 找一个费用不超过D-c(i)的前提下，到根结点距离最大的结点

注意，对于两个结点w和w',如果w到根的路径费用比w'大但路径长度比w'小，则w—定不 是最优解的端点，可以删除。这样，i之前的结点可以组织成单调集合：到根的路径长度和 路径费用同时递增。如果把这个单调集合保存到BST中，就可以在O(logn)的时间找到“费用 不超过给定值的前提下距离最大的结点”。这样，在O(nlogn)时间内求出了“经过树根的最优 路径”。根据主定理，总时间复杂度为O(n(logn)2)。

还有一种方法，即求解子树时“顺便”把单调集合也构造出来。如果细节处理得当(需要 避开BST ),还可以把计算“经过树根的最优路径”的时间复杂度降为0(n),细节留给读者思 考。

欧拉序列。对有根树T进行DFS (深度优先遍历)，无论是递归还是回溯，每次到达一 个结点时都将编号记录下来，可以得到一个长度为2N-1的序列，称为树T的欧拉序列F (类似 于欧拉回路)。

如图12-10所示，结点1的深度为0，结点2， 3， 4的深度为1，结点5， 6的深度为2，因此欧 拉序列F和深度序列B如表12-1所示。

图 12-10 欧拉序列

表12-1欧拉序列F和深度序列B

| 序号 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| F    | 1    | 2    | 5    | 2    | 6    | 2    | 1    | 3    | 1    | 4    |
| B    | 0    | 1    | 2    | 1    | 2    | I    | 0    | 1    | 0    | I    |

为了方便，把结点&在欧拉序列中第一次出现的序号记为pos(k)，则图12-10中各个结点 的pos值分别为1, 2, 8, 10，3, 5。欧拉序列中每个结点的第一次出现用灰色背景表示。

有了欧拉序列，LCA问题可以在线性时间内转化为RMQ问题：LCA(T, u，v) = RMQ(B， pos(u)，pos(v))。这里的RMQ返回值是下标而不是值本身。

这个等式不难理解：从u走到v的过程中一定会经过LCA(T，u，v)，但不会经过LCA(T，u，v) 的袓先。因此，从u走到v的过程中，深度最小的那个结点就是LCA(T，u，v)。

用DFS计算欧拉序列的时间复杂度是0(W)，且欧拉序列的长度为21-1 = O(N)，所以LCA 问题可以在O(N)的时间内转化为等规模的RMQ问题。

树的动态查询问题I。给定一棵带边权的树，要求支持两种操作：修改某条边的权值和 询问树中某两点间的距离。

首先把无根树变成有根树，则把一条边u-v (假定u是v的父结点)的权值增加通寸， 以V为根的整个子树的“到根结点的距离”同时增加么不难发现，一棵子树内的结点对应欧拉 序列中的一段连续序列，因此如果用dist[i]表示欧拉序列中第i个结点到根的距离，则修改操 作就是dist数组上的“区间增量”，而查询时的距离(u，v)等于dist(w)+dist(v)-2dlst(w),其 中狄=^人什/0。这样，只需用一个支持快速区间增量和单点查询的数据结构(例如Fenwick 树或者线段树)来维护dist数组，就可以在O(logn)时间内支持两个操作。

轻重路径剖分。给定一棵有根树，对于每个非叶结点u ,设u的子树中结点数最多的子 树的树根为v ,则标记(u，v)为重边，从u出发往下的其他边均为轻边，如图12-11所示(结点 中的数字代表结点的size值，即以该结点为根的子树的结点数)。

根据上面的定义，只需一次DFS就能把一棵有根树分解成若干重路径(重边组成的路 径)和若干轻边。有些资料也把重路径称为树链，因此轻重路径剖分也称树链剖分。

路径剖分中最重要的定理如下：若v是w的子结点，(w，v)是轻边，则size(v)<size(w)/2 ,其 中size(w)表示以w为根的子树中的结点总数。

证明并不复杂。由定义，所有非叶结点往下都有一条重边。假设size(v它size(w)/2 ,那么 对于w向下的重边(w，w)来说，size(w)>size(v)>size(w)/2 ,因此 size(w)>1+size(v)+size(w)>1+size(w),与假设矛盾。

由此可以得到如下的重要结论：对于任意非根结点w ,在w到根的路径上，轻边和重路径 的条数均不超过log2n ,因为每碰到一条轻边，size值就会减半。

树的动态查询问题II。给定一棵带边权的树，要求支持两种操作：修改某条边的权值和 询问树中某两点的唯一路径上最大边权。

首先把无根树变成有根树并且求出路径剖分。如图12-12所示，任意结点w到其袓先的 简单路径中包含一些轻边和重路径，但这些重路径可能并不是原树中的完整重路径，而只是 一些“片段”，因此可以在轻边中直接保存边权，而用线段树维护重路径。

这样，两个操作都不难实现。

修改：轻边直接修改，重边需要在重路径对应的线段树中修改。

查询：设LCA(w，v)=p ,则只需求出u到其袓先p之间的最大边权maxw(u，p),再用类似的方 法求出maxw(y),则答案为max{maxw(w，/»)，    maxw(v，/»)}。为 了求出maxw(w，/»),依次访

问权到加之间的每条重路径和轻边即可。根据刚才的结论，轻边和重路径的条数均不超过 log2n。这样，修改的时间复杂度为O(logn),查询的时间复杂度为O(log2«)。虽然存在时间复 杂度更低的方法[^](#bookmark18),但上述方法已经很实用了。

图 12-11 轻重路径剖分



图 12-12 树的动态查询



Link-Cut树。值得一提的是，轻重路径剖分有一个“动态版本”——Sleator和Tarjan的 Link-Cut树[(](#bookmark20)[4)](#bookmark20)。该数据结构解决的是所谓的动态树(Dynamic Tree )问题，即维护一个有根树

组成的森林。支持以下4个操作。

□    MAKE-7REE():创建一棵新树。

□    CUT(v):删除v到父亲的边，相当于把以v为根的子树独立出来。

□    JOIN(v，w):让v成为w的子结点。这里v必须是森林中一棵树的根，且w不在这棵树中。

□    FIND-ROOT(v):找出v所在树的根结点。

其中CUT和JOIN是两个最经典的操作，利用它们可以灵活地改变树的结构。“重路径”在

Link-Cut树中称为Preferred Path。每条Preferred Path用一棵辅助树表示(通常是伸展树[逆](#bookmark22)) 而不同的辅助树之间通过父结点指针连在一起。

图12-13展示了Link-Cut树最重要的操作：Access操作。Access(u)的作用是把从根结点到u 的路径变成重路径。为此，可能需要把一些其他的重边变成轻边以维持“每个非叶结点往下 最多有一条重边”这一性质。图12-13 ( a )执行Access(N)之后得到图12-13 ( b )，其中重边 A-B, H-J, I-K都变成了轻边。另外，根结点和执行Access操作的结点必须是重路径的两个端 点，所以N-O也必须变成轻边。

(a )



(b)



O



O



图 12-13 Link-Cut树中 Access 操作

如果把每条Preferred Path用一个序列表示(实际上用伸展树储存)，则上面两棵树如图 12-14所示。

D



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-286.jpg)



图12-14将Preferred Path用序列表示

对于Link-Cut树的完整讨论超出了本书的范围，建议读者熟练掌握它（包括时间复杂度 和程序实现），之后再阅读下面的例题。

例题 12-5 快乐涂色(Happy Painting, UVa11994 )

n个结点组成了若干棵有根树，树中的每条边都有一个特定的颜色。你的任务是执 行m条操作，输出结果。操作一共有3种，如表12-2所示。

表12-2 3种操作

| 操作    | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| 1 x y c | 把x的父结点改成y。如果x=y或者x是y的袓先，则忽略这条指令，否则 删除x和它原先父结点之间的边，而新边的颜色为c |
| 2 x y c | 把x和y的简单路径上的所有边涂成颜色c。如果x和y之间没有路径，则 忽略此指令 |
| 3 xy    | 统计x和y的简单路径上的边数，以及这些边一共有多少种颜色       |

每组数据第一行为n*m （ 1<n<50000 , 1<m<200000 ）,然后是每个结点的父结点编号和 该结点与父结点之间的边的颜色（对于根结点，父结点编号为0，且“与父结点之间的边的颜 色”无意义）。接下来是m条指令。对于所有指令，1<x，y<n ;对于类型2指令，1<c<30。结点 编号为1〜n ,颜色编号为1〜30。

对于每个类型3指令，输出对应的结果。

分析】

这是一个标准的动态树问题，不过多了一个“统计颜色数”操作。注意到颜色只有30种， 可以用一个32位整数表示一个颜色集合。由于辅助树用伸展树保存，可以在伸展树的每个结 点中加一个信息c ,即以该结点为根的子树所对应的重路径“片段”所拥有的颜色集，则操作2 和3都对应于经典的伸展树的修改和查询操作。

例题 12-6    闪电的能量(Lightning Energy Report, ACM/ICPC Jakarta 2010,

UVa1674 )

有打(n<50000 )座房子形成树状结构，还有2 ( 2<10000 )道闪电。每次闪电会打到两 个房子a，b，你需要把二者路径上的所有点(包括a，b )的闪电值加上c ( c<100)。最后输出 每个房子的总闪电值。

【分析】

出题者的标准解法是利用路径剖分：每次最多更新2logn条重路径，而每条重路径上的 区间更新需要O(logn)时间。

这样做也没有错，但是有点小题大做。其 实，对于询问(a，b，c),可以首先算出d = LCA(a， b),然后执行mark[a]+=c，mark[b]+=c， mark[d]-=c。如果d不是树根，还要让d的父结点p的mark 值减c。原理是这样的：^^汝[切=界的意思是u到 根的路径上每个点的权都要加上w ,即结点i的闪 电值等于根为i的子树的总mark值。如图12-15所 示，经过上述mark修改操作之后，只有a到b路径 上所有点的“子树总mark值”增加了c ,其他结点 保持不变。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-287.jpg)



最后用一次DFS ,即可求出以每个结点为根的子树的总mark值。

12.1.3 可持久化数据结构

《训练指南》中介绍了一些基本的数据结构，例如BIT、线段树等，也介绍了一些高级 数据结构技巧，例如嵌套数据结构和分块数据结构。但有一个重要的话题并来涉及，那就是 可持久化数据结构 ( persistent data structures)。

之前学过的很多数据结构都是可变的，所有修改操作都直接改变了数据结构本身。修改

之后，就无法得到修改之前的数据结构了。有时，需要在修改数据结构之后得到的是该数据

结构的一个新版本，同时保留修改前的“老版本”。该如何实现呢？

基本思路是：不许修改结点内的值；必要时创建或者复制结点；尽量复用存储空间。

如图12-16所示，我们希望在一个链表的第3个结点后面新加一个白色结点，只需要复制

前3个结点即可。

图12-16 在链表结点中加入结点

虽然整个结构看上去比较奇怪，但是从两个链表各自的表头指针开始访问，沿途访问到

的就是该链表自身的结点。

当然，这个例子并不是那么吸引人，因为平均情况下要复制一半的结点，不过这个方法 可以用来实现一个可持久化的栈——在链表的头部进行入栈和出栈，不仅时间是0(1)的，附 加空间也是0(1)的。

如果是一棵满的排序二叉树，没有插入和删除，只有修改，则不需要旋转操作，因此很 容易用上述方法改造成可持久化的排序二叉树。修改单个结点时，只需把从根结点到修改结 点的所有结点(只有0(logn)个)复制一份并设置好链接关系，其他结点保持不变即可，如 图12-17所示。把作为根访问到的就是老树，把作为根访问到的就是新树。

图12-17 将满的排序二叉树改造成可持久化的排序二叉树

顺便一提：已经有一些编程语言中“自带”了可持久化数据结构，例如Scala、Erlang和 Clojure ,有兴趣的读者可以参考这些语言的入门书籍，会对可持久化数据结构有一个更加清

晰具体的认识。

例题 12-7 自带版本控制功能的IDE ( Version Controlled IDE, ACM/ICPC Hatyai 2012, UVa12538 )

编写一个支持查询历史记录的编辑器，支持以下3种操作。

□    1 p 5 ：在位置p前插入字符串s。

□    2 p c :从位置p开始删除c个字符。

□    3 v p c :打印第v个版本中从位置p开始的c个字符。

缓冲区一开始是空串，是版本0，每次执行操作1或2之后版本号加1。每个查询回答之后 才能读到下一个查询。操作数n<50000 ,插入串总长不超过1MB ,输出总长保证不超过 200KB。

【分析】

本题要实现的数据结构就是一个典型的可持久化数据结构。在《训练指南》中曾经见过 一道类似的例题，但是只需非持久化版本的题目：《排列变换》。在那道题目中，用到了伸 展树的split和merge操作，本题可以如法炮制。

spltt操作。假定要把序列子树分裂成£和及两部分，其中左边有lef_size个结点。如果

lef_size小于左子树的结点个数，则可以先递归调用split操作把S的左子树分裂为Z和及'，其 中Z的结点个数为left_size ,然后创建一个值和一样的新结点及，左右子树分别为及'和的右 子树。不难发现，Z和及合起来正好是的所有元素，并且Z里有left_size个元素。left_size比较 大时也可以类似处理，如图12-18所示。

图 12-18 split 操作



merge操作。假定要把两个序列a和b合并成一个序列^。和split类似，也有两种方法合 并，但两种方法都可以用，并不是上面的“二选一”。例如，图12-19 ( a)就是先递归调用 merge操作把a的右子树和b合并成及，然后创建一个新结点S ,而图12-19 ( b )则是相反。不 管选哪种merge方式都有可能合并成一棵形态不好的树，所以随机合并。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-291.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-292.jpg)



图 12-19 merge 操作

实际上，这就是一个可持久化treap的split和merge操作。对上述方法的理论分析超出了本 书的范围，但可以告诉大家的是，它的实际效果非常好，并且程序易于实现，是可持久化数 据结构的经典例子。

值得指出的是，如果可以使用STL扩展，那么用rope实现本题也是一个不错的选择。有

兴趣的读者可以阅读维基百科

12.1.4 多边形的布尔运算

布尔运算是指把多边形看成一个点集，然后执行集合的布尔运算。最常见的布尔运算是

交和并。虽然概念简单，但实际上多边形的布尔运算不是那么容易实现的。如果要高效实

现，更是难上加难。

例题12-8    多 边形相交（ Polygon Intersections, ACM/ICPC World Finals 1998,

UVa805 ）

输入两个简单多边形，求二者相交的区域（如图12-20的深色区域所示）。如果有多个

区域，应分别输出。共线的相邻边应合并（细节请参考原题）。

图 12-20 多边形相交

分析】

为了叙述方便，设输入的多边形为A (用细线表示)和丑(用粗线表示)，答案为C (图 中未画出)，如图12-21所示。输入的是简单多边形，所以C是不会出现洞的，但是可能会不 连通。算法大概是这样的：首先对于每条线段求出它和其他线段的交点，然后在交点处把线 段打散(即切割成若干条线段)。不难发现，打散后的每条小线段要么完全在C的边界上， 要么不在。如何判断呢？只判断端点是不行的，例如在图12-21 (a)中，细线正方形的上边 和左边都有一个端点在C的边界上，但是这两条边本身却不在C的边界上。正确的做法是判 断每条小线段的中点。如果中点同时在A和B的内部或者边界上，则这条小线段是C的边界。

图12-21 ( b )和图12-21 ( c )也有些难以处理。在图12-21 ( b )中，A和B有一条公共线 段，但是并没有在C中出现；图12-21 ( c )中A和B也有一条公共线段(注意A的右边界已被 打断成3条线段)，但它却在C里出现了。解决这个不一致的方法有多种，这里只介绍笔者认 为相对常见和容易编写的一种：把多边形的边按照逆时针顺序定向，然后去掉重复的有向线 段，如图12-22所示。

(a)    (b)    (c)

图 12-21 多边形相交问题分析

经过上述处理之后，得到了若干有向线段。只要把它们拼起来，然后把退化的多边形 (折线)删除，只保留多边形区域，就得到了最终的答案。例如，图12-22 ( b )拼起来以后 得到了一个只有两个点的“多边形”，输入退化情况，应删除。

（a）    （b）

图 12-22 解决不一致问题的方法

例题 12-9 王国的重新合并(Kingdom Reunion, ACM/ICPC NEERC 2012, UVa1675 )

输入3个国家Aastria、Abstria和Aabstria的边界，判断Aastria、Abstria是否可以恰好不重 叠地合并成Aabstria。输入可能有误，即3个边界都可能不是多边形。输出有6种情况。

情况1 :如果Aastria的边界不是合法多边形，输出Aastria is not a polygon。

情况2 :如果Abstria的边界不是合法多边形，输出Abstria is not a polygon。

情况3 :如果Aabstria的边界不是合法多边形，输出Aabstria is not a polygon。

情况4 :如果Aastria和Abstria相交，输出 Aastria and Abstria intersect。

情况5 :如果Aastria和Abstria的合并不是Aabstria，输出The union of Aastria and Abstria is not equal to Aabstria。

情况6 :输出OK。

图12-23中4幅图分别对应情况6、情况1、情况4、情况5。输入中每个边界上的点数都不

超过10000。

图12-23 情况6、情况1、情况4和情况5

【分析】

本题的数据范围很大，但在优化之前要先思考一下：不考虑时间复杂度的情况下如何求 并。一般情况下，两个多边形A和B的“并”可能是一个“有洞多边形”，如图12-24所示。不过 本题只需要判断A和B的并是否等于C ,所以可以不考虑这种情况。

不难发现，此处仍然可以使用刚才介绍的方法：把每条边定向，打断线段并判重，然后

逐一判断。这个方法是正确的，可惜对于本题来说速度太慢，就连“判断多边形相交”和“打

断线段”这一步都不能用0 （ n2 ）的朴素算法进行判断，更别说判断每条（打断后的）线段是 否在两个多边形内了。

解决方法是《算法竞赛入门经典——训练指南》中的扫描法。具体写法有很多种，这里 只介绍一种相对不容易写错的方法，分为3个阶段。为了叙述方便，设Aastria和Abstria的轮 廓为A和B , Aabstria的轮廓为C。

阶段1 :用扫描法判断A、B、C是否为合法多边形。这一步看似简单，其实有陷阱。在 扫描法中，新增或者删除线段时会判断相邻线段是否相交。这个“相交”一般会理解成“只要 有公共点就算相交”，而不一定是规范相交。但是在本阶段中，如果这样写就错了（因为这 两条线段可能恰好是同一个顶点出发的两条边）。另一方面，也不能把这里的“相交”理解 成“规范相交”，因为图12-25中所示就不是规范相交，但它也不是一个合法多边形，应当被 检测出来。阶段1的另一个作用是用所有顶点去打断每条边，具体细节留给读者思考。

图 12-24 两个多边形的并    图 12-25 非规范相交

阶段2 :判断A和B是否相交。首先要排除内含的情况，然后对于每个点，判断从它出发 的所有边是否导致多边形相交。如图12-26所示，图12-26 ( a )的两个多边形没有相交，但是 图12-26 ( b )的多边形相交了。本阶段还需要计算出每条边的“反向边”(u - >v*v- >口互 为反向边)。

(a)    (b)

图 12-26 判断 A 和 B 是否相交

接下来就可以忽略同一个顶点出发的边了。再扫描一次，和阶段1一样判断线段相交。

但是这次不需要打断线段，而且每到一个事件点时要把与它关联的所有相邻边一次性加到扫

描线上，就不会认为这些边相交了。

阶段3 :判断A和B是否覆盖了C。以A为例，首先枚举A的每条边，看看C是否也 有一条从m出发的边。如果C中没有从m出发的边，则B中必须有边v->m，这样才能和A中 的>4目互“抵消”，让C的边界中不必出现这条边。类似地，如果C有一条完全相同的 边m->v，则B中不能有边v->m。因为之前已经算过了反向边，所以对于每个顶点m，只需

常数时间内就可以完成上述判断。

例题 12-10 清洁机器人(The Cleaning Robot, Rujia Liu's Present 4, UVa12314 )

有一个半径为r的圆形清洁机器人和一个《 (必100 )边形障碍。需要把机器人放到某个

地方，使得它无法移动到无穷远处，要求能清洁到的区域面积尽量大。如图12-27所示，图

12-27 ( a )的阴影部分就是能清洁到的区域，而图12-27 ( b )中有两个选择，其中右边那个 区域更大。

(a)    (b)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-300.jpg)



图12-27 “清洁机器人”问题示意图

【分析】

首先看看机器人的圆心可能在哪些位置。根据题意，圆心不可能在多边形内部，到多边 形的距离也不能小于r ,所以可以设计一个“膨胀”操作[仍](#bookmark12)，计算出圆心禁止出现的区域，它实 际上等于若干个矩形、若干个圆以及原多边形的并，如图12-28所示。

图 12-28 圆心禁止出现的区域



图12-28看上去很规则：每条边外扩，然后用每个顶点处的圆弧连接。但有时有些边会

消失，还是只能使用多边形并的算法，如图12-29所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-302.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-303.jpg)



图 12-29 多边形并的算法

现在假定已经写好了膨胀操作，主算法可以这样设计：首先让输入多边形往外“膨胀”，

得到一个带洞多边形（如果没有洞则无解），则每个洞都是一个机器人圆心可以出现的区

域。需要注意的是，这个“洞”可能退化成线段甚至是点（如题目中左图的例子）。为了避免

出问题，最好是把膨胀的偏移值缩小一点。

然后计算每个区域的可清洁面积，方法是再次“膨胀”，然后计算面积。注意，两次膨胀

得到的“多边形”都可能是带圆弧的，需要把直线段和圆弧都打断。

本题的算法虽然概念简单，但是实现起来还是颇有难度的，建议读者编程实践。

##### 12.2 难题选解

12.2.1 数据结构

例题 12-11 航班(Flights, ACM/ICPC NEERC 2012, UVa1520 )

某国在一条直线上进行军事演习。有《 ( ^<50000 )个导弹，用^、^、y3个整数表示 (0<P<X<50000，0<y<50)，表示起点是(p，0 )，沿着对称的抛物线飞行，如图12-30所 示，最高点是(^，y )。导弹按照输入顺序依次发射，相邻两个导弹的时间间隔是1分钟， 而导弹飞行本身瞬间完成。

另外还有m架飞机(1<m<20000 )，每架飞机用4个整数Z1、Z2、^1、^2表示，即飞行时 间为Z1〜Z2 ( 1<t1<t2<n，其中第一个导弹的发射时刻为1，最后一个导弹的发射时刻 为n )，坐标为义1〜^2 ( 0<X1<X2<50000 )。你的任务是为每架飞机计算出最小飞行高度乃， 使得时间区间［t1，t2 ］内所有导弹轨迹在X坐标x1〜x2的范围内高度都不超过^如果这个 范围没有导弹，则最小高度定义为0。

【分析】

建立一棵线段树，叶结点中保存一个导弹的轨迹(抛物线)，每个非叶结点m保存的是 一个连续的导弹区间［m1，m2 ］中所有轨迹的“轮廓线”，如图12-31所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-305.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-306.jpg)



图 12-31 所有轨迹的轮廓线

不难看出，这是一棵关于“时间”的线段树。对于每架飞机(t1 , t2 , x1 , x2 ),可以按 照传统的区间分解的方式，转化为对0 ( logn )条轮廓线的max ( x1 , x2 )查询(即在 ［x1 , x2 ］上的最大值)。

为了让轮廓线支持max (x1 ,x2)，需要用一个合适的数据结构表示轮廓线。抛物线之 间的交点把轮廓线分成了若干段，其中每个部分是一个导弹轨迹的一部分，因此可以用五元 组(“，^ , c , x1 , x2 )表示抛物线y = ox2 +如+ c在［x1 , x2 ］中的部分，而轮廓线就是上 述“抛物线片段”的序列(中间可能会有空白区域)。

只要把这些序列按照从左到右的顺序保存，然后创建一棵线段树(叶结点是抛物线片 段)，就可以在0 ( logn )时间内求出max ( x1 , x2 )。而一共需要查询0( logn )条轮廓 线，因此查询复杂度为0( log2n)。

最后考虑建树部分的时空复杂度。对于一个包含&个抛物线的轮廓线，使用类似于归并 排序的方法，可以在0 (幻o钬)的时间构造出一个空间为0 (幻的线段树，因此总的时间复 杂度为0 ( nlog2n ),空间复杂度为0 ( nlogn )。

例题 12-12 背单词(GRE Words Revenge, ACM/ICPC Chengdu 2013, UVa1676 )

为了准备GRE考试，你打算花打(n<105 )天时间背单词。每天可以做两件事之一：

J + w :学一^个单词w。

□ ?t:读一篇文章t,统计t有多少个连续子串是学过的单词。

为了简单起见，单词都是01串。学的单词长度总和不超过105，文章总长度不超过

5*106。

【分析】

最容易想到的算法就是维护“学过的所有单词”的AC自动机。由于AC自动机并不支持“快 速插入新字符串”的操作，所以每次学到一个新单词w之后，必须重建AC自动机。这样，虽 然“?t”操作非常高效(文章沖的每个字符只需0 ( 1 )时间)，但重建AC自动机的开销是巨 大的。如果一共学了&个单词，每个单词的长度均为Z ,则时间复杂度高达Z + 2Z + 3Z+...

+ kL = 0(k2L),系统是无法承受的。幸运的是，本题至少有3种高效解法，而且都有不错 的启发性。

解法1 :维护两个AC自动机big和small ,每次学到一个单词后合并到smaU里，等small的 字符总数超过一定数值后，合并到^8里(并且清空small )。查询时把big和small分别查一 遍，加起来即可，因此查询是每个字符0( 1)的。

假设每个单词都是单字符的，一共有m个单词。当small中的字符总数超过k时合并，则 每k次操作可以看的是一轮操作。时间复杂度为：

］更新small : 1+2+...+k=0(k2)。

□更新big ,清空small :第/轮为0 ( /*k )(为了方便分析，假设第一轮也重建了big ,虽然 实际上不需要)。

一共有m/k轮，所以总时间复杂度为m/k*0 ( k2 )+ k*0 ( ( m/k ) 2 ) =0( mk + m2/k )

=m ( k + m/k)。当k和m/k相近时最好，时间复杂度为0 ( m1.5 )。

解法2 :用多个AC自动机，字符个数分别为1 , 2 , 4 , 8 , 16 , 32 , 64 ,…，编号为 0 , 1 , 2…，即编号为/的自动机的“理论”大小(即字符总数)为2'。当自动机/的大小超过 2'时，把它所包含的字符串全部插入到自动机/+1中，并且清空自动机/。

假设所有单词的总长度为m ,则自动机的最大编号为Z = log2m。每个单词最多在自动机 0 , 1 ,…，k里各待一次，所以插入单词的总时间复杂度为0 ( mlogm)。查询时需要在每个 自动机里找，所以每个字符的查询时间为0 ( logm )。由于本题的查询比插入多一个数量

级，所以解法2的实际运行效率比解法1略差。不过这个思路很经典，值得学习。

解法3 :使用DAWG。设学习的单词为Wj，w2，…，增量式的构造w1$w2$w3…的

DAWG。对于“?t”操作，依次在DAWG中沿着边^，t2，…进行转移。假设已经走了边^.，当

前状态为S，所要统计的是t [ 1...1 ]有多少个后缀是学过的单词。根据前面的讨论，一个状 态的最长单词的所有后缀就是当前状态及其在T ( w )树中所有袓先状态的字符串集。但是 t[ 1...1 ]不一定是S的最长单词，所以需要统计两项内容：

□在状态S中，长度不超过/的所有串的权值之和(学过的单词权值为1，其他串权值为

0)。

□状态S在T ( w)中所有袓先状态的所有串的权值之和。

对于第一点，在DAWG的每个状态中保存一棵平衡树即可。第二点要困难一些：由于在 DAWG的构造算法中需要动态修改T ( w )中各个结点的父指针，所以需要用一个Link-Cut树 来维护T ( w )，从而支持“一个状态的所有袓先状态的权值之和”。其实还有一个相对容易 的方法可以代替动态树：用平衡树来维护T ( w )的DFS序列。这里的DFS序列很像欧拉序 列，不过记录的不是结点名称，而是带符号的权值，入栈时为正，出栈时为负。这样， DFS 序列的前缀和就是从根结点到该结点的路径上所有结点的权值之和，并且“修改父亲指针”对 应着把DFS序列的一个子序列剪切并粘贴到另外一个位置。在《训练指南》中已经介绍如何 用伸展树高效地实现这一操作。

例题12-13    瓦里奥世界( Rujia Liu Loves Wario Land!, Rujia Liu's Present 3,

UVa11998 )

很久很久以前，瓦里奥世界只有一些废弃的矿山，但没有任何连接这些矿山的道路。已 知各个矿山的初始矿藏值，你的任务是按顺序执行m条指令，根据要求输出所求结果。操 作指令及说明如表12-3所示。

表12-3 操作及含义

| 操作 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 1xy  | 修建一条直接连接x和y的道路。如果x和y已经连通(直接或者间接都 算)，则忽略此命令 |

| 2xv  | 把矿山x的矿藏值改为v （可能是因为发现了新宝物，或者一些宝物被 盗） |
| ---- | ------------------------------------------------------------ |
| 3xyv | 统计x和y的简单路径上（包括x和y本身）有多少座矿山的矿藏值不超 过v ,然后把这些矿藏值乘起来，输出乘积除以k的余数。如果满足条 件的矿山不存在，则输出一个0（而不是00或者01） |

限制：1<«<50000 , 1<m<100000 , 2<k<33333。对于每条指令，1<x , y<n , 1<v<k。输入 文件大小不超过10MB。

为了防止对所有指令进行预处理，本题的真实输入在前述输入格式基础上进行了“加

密”，即输入的各条指令中除了“类型”之外的其他值（x、y、v ）都增加了d ,其中是在处理 此指令之前上一个输出的整数（如果在此指令之前并未输出过任何指令，^=0 ）。

【分析】

这是一道综合性很强的题目，而且要求在线算法。维护树上信息的方法主要有欧拉序 列、动态树和树链剖分3种，但由于操作3的特殊性，动态树和欧拉序列都很难起作用：如果 采用动态树，需要在0（ 1）时间内根据左右子树的信息计算父结点的信息。遗憾的是，操 作3涉及的信息太复杂，通常需要树套树或者块链表实现，无法简单维护；如果采用欧拉序 列，维护的信息需要满足区间减法。遗憾的是，操作3涉及的信息不满足。

看来只能从树链剖分入手。首先不考虑操作1，只处理修改（操作2）和查询（操作 3 ）。用块链表维护每条重路径，如图12-32所示。每个块里最多保存5个结点，按照矿藏值 从小到大排序，其中ID[i]表示价值第/小（它1 ）的结点编号，prod[i]表示价值前1小的结点的 价值乘积。为了高效地执行链的分裂与合并（见后），不同块之间形成双向链表。

修改操作（2xv ）。首先要找到v所在的块b ,然后重建块b ,即把所有结点按照价值排 序，重新计算前缀积和。 “重建块”这个过程在其他地方也会用到，将其称为 process( b)。

查询操作(3xyv )。设答案为res1和res2 ,初始时res1 = 0 , res2= 1。首先按照LCA的思 路，每次把和y中靠下方的结点往上“提”，即统计所在链的首结点之间的路径，更新答 案res1和res2 ,然后把x改成x上一条链的尾结点，直到和y移到同一位置，即二者的LCA ,如 图12-33所示。

这样，问题就转化为了 一系列的update ( a , b , v , res1 , res2 )调用，表示已知a和b在 同一个链中，统计a-b路径上所有价值不超过v的结点，个数加到res1中，乘积乘到res2中。 注意本题的权值在结点上，所有轻边是完全不用考虑的。

如图12-34所示，update ( a , b , v , res1 , res2 )可以这样实现：在a和b所在的袂中需要 暴力查找，即枚举块内的所有结点，把所有高度在a和b之间且价值不超过v的结点找出来。a 和b之间的块因为是完整块，所以可以二分查找，找到价值不超过v的结点个数'，则prod[i]就 是这些结点的价值乘积。

为了简单起见，每个结点m只记录链编号C ( u ),而不记录块编号，因此修改操作中需 要先花0 ( L/5 )时间找到u所在的块，然后用0 ( BlogB )时间重建块。查询操作最多需要调 用0 ( logw )次update函数，而update函数的时间复杂度为0 ( L/B*log ( B ) +B )。

操作1的出现意味着树是会合并的，因此上面的讨论还不够。好在道路只增不减，所以 可以用启发式合并，即每次把小树合并到大树中，则每个结点最多参与0 ( lo奶)次合 并[^](#bookmark8)。这样，问题的关键就在于如何高效地合并两棵树的树链剖分。

执行操作1xy时，首先找到X和y所在树的树根，如果相同，则忽略本操作；否则假设X所 在的树结点比较多，y所在的树的结点比较少(否则可以交换x和y)。接下来，需要把，嫁 接”到结点x处。但是由于y所在树的树根可能是其他结点，首先要把y所在的树以y为树根重 建(包括重建树链剖分)，然后设x为y的父结点。

接下来是重头戏了：由于X多了一棵子树y，所以X往下的重边有可能会变化。例如^是 叶子，或者x原来的重边子结点妒(x )的子树没有y的子树大，即size ( W(x)) < size (y )。那么x往下的重边需要改成连到y，即把x所在的链分裂，如图12-35所示。部分 所有结点的“链编号”都发生了改变，但是根据合并的条件，修改的结点数不超过size (y )。 分裂之后还要把y所在的链(注意y是链首)接到x的下方。这需要修改y所在链的所有结点 的“链编号”，但是修改的结点数仍然不超过size (y )。

最后是修改x及其所有袓先p的size (p )。x的袓先可能很多，不能--修改，而只能一

个块一个块地修改，即每个块设一个懒标记，表示该块所有结点的整体size增量，当访问size 时再删除标记。这里有一个关键问题：x的所有袓先的size都变大了，所以它们到父结点的边 可能会从轻边改成重边，因此还需要一些复杂的操作。幸运的是，此处并不需要严格地使用 树链剖分的定义，而是可以让这些轻边保持原样。因为每个结点到根的路径上仍然最多 有0 ( logn )条链，所以时间复杂度并不会变坏。这样，通过分裂链、合并链和修改size这3 个步骤即完成了两棵树的合并。

还有两个细节没有提到：分裂链时需要分裂x所在的块，而在合并链时需要试着合 并x和y所在的两个块(它们是相邻块)。根据块链表的一般思路，只有当这两个块在合并之 后仍然不超过B时才合并。

这样，在合并过程中“修改链编号”的时间复杂度为0 ( size (y ))，分裂合并块的时间 复杂度为0 ( BlogB )，而修改size的时间复杂度为0 ( n/B )。由于时间复杂度的表达式里同 时出现了B和n/B，B既不能太大，又不能太小，取一个接近sqrt ( B )的值可以让各个操作的 时间复杂度趋于平均。由于各个操作的常数不同，而且链的实际长度还和测试数据相关， B

的最佳取值最好是通过做实验的方法确定（实测50〜300最佳）。

12.2.2 网络流

例题 12-14 芯片难题(Chips Challenge, ACM/ICPC World Finals 2011, UVa1104 )

作为芯片设计的一部分，你需要在一个#*#（#<40 ）网格里放置部件。其中有些格子已 经放了部件（用C表示），还有些格子不能放部件（用“/”表示），剩下的格子需要放置尽量 多的新部件（用W表示）。

CCA. CC/W.

./• // W/

■ •CC W.C.C

AC., /.C翻

A/C/ M/C/

（a ）    （b）

图12-36 防止部件的最优解

要求对于所有1<x<# ,第x行的部件个数（C和^之和）等于第x列的部件个数。为了保证 散热，任意行或列的部件个数不能超过整个芯片总部件数的^。如图12-36所示，若A/B = 3/10 ,则图12-36 （ a ）的最优解如图12-36 （ b ）所示，一共放置了7个新部件。

【分析】

根据经验，构造一个二分图，左边是行，右边是列，一个部件就是一条边^ ->!｝。如

何表示第/行的总流量等于第/列呢？从再连一条边到即可。因为每个r结点的出弧只有一

条（到^ ）,而每个只有一条入弧（从r ）,所以的流量肯定等于r的流量。进一步分析

可发现：其实这样做等价于把a；和r“粘”起来。也就是说，根本不需要构造二分图，一共n个

结点即可。一个部件（/ ,J ）就是有向弧/ -»。如果在（/ ,J ）上加上一个费用1 ,则总费

用就是新部件的个数。这样就转化为了求最大费用循环流问题，用第11章中介绍的方法求解

即可。

接下来还需要加上题目中的两个限制。首先是必须有流量的边，也就是C对应的边。有 两种做法，一是设容量下界也是1 ,二是设cost为负无穷。接下来考虑每行每列乂/B的限制。 方法是枚举每行/列部件数的最大值m ,给每个点增加结点容量讲(然后用标准方法拆成两 个点)，然后求最大费用循环流，看看费用是否至少为m*B/^。注意，m的值只有0~«这《 + 1种可能，所以时间复杂度只需乘以0 ( n ),仍然可以承受[凶](#bookmark13)。

例题12-15    《第七夜》、《时空轮回》与水的故事( Never7, Ever17 and Wa[t]er,

Rujia Liu's Present 6, UVa12567)

有一个n个点、m条有向边的网络，每条边都有容量上下界和c ,求一个循环流，使得所 有边中的最大流量和最小流量之差尽量小。n<50 , m^200。

【分析】

本题虽然是网络流问题，但是“最大流量和最小流量之差”似乎无法对应到经典的网络流

模型中。怎么办呢？

很多图论优化问题，包括最短路、最大流和最小费用流等，都可以用线性规划建模，本 题是不是也可以呢？下面尝试一下。设第'条边的流量为*，则容量限制可以列出两个不等 式，对于每个结点可以列出流量平衡“等式”，目标是最小化max{^} -mrn{^}。问题还是出 现在同一个位置：目标函数不是变量的线性组合，不符合“线性规划”的定义。

既然线性规划模型比较灵活，现在我们对目标函数进行代数变形。再引入两个变量^4 = min{^'} , B = max{^'},然后对每个*添加不等式^<xz<B，则目标变成了最小化B - ^ ,符合线 性规划模型。可是这能不能保证算出来最优解真的满足4 = mrn{^} ,B = max{^}呢？如果不 满足，例如，4<min{xJ (根据不等式约束，4<min{xJ ),那么把4改成min{xj之后，约束

仍然满足，并且目标函数变得更小，与最优解矛盾。因此，变形后的线性规划模型可以得到

原题的最优解。

例题 12-16 怪兽滴水嘴(Gargoyle, ACM/ICPC Xi'an 2006, UVa12110 )

城堡顶层有n个怪兽状滴水嘴，还有一个包含m个连接点和k个水管的水流系统 (1<n<25 , 1<m<50 , 1<k<1000 )。从滴水嘴流出的水直接进入蓄水池，通过水管后重新由 滴水嘴流出。假设水量无损失，每个连接点处的总入水速度应该等于总出水速度。水管中水 流的速度有上下界，单位水速有固定费用。

你的任务是设计各水管的水速，用尽量少的总费用让各滴水嘴的出水速度相同。

每个水管用5个整数a，b，l，u，c表示（0^，b<n + m，0<l<u<100，1<c<100 ），即每 个水管入口和出口编号（蓄水池编号为0，滴水嘴编号为1〜n，连接点编号为n+ 1 〜n + m），水速下限、上限，以及单位水速的费用。水管不会连接两个相同点，即水管入 口不会是滴水嘴，出口不会是蓄水池。每两个点之间最多一条水管（如果有水管从a到b，则 不会再有其他水管也从a到b，也不会有水管从b到a ）。输入结束标志为一个0。

【分析】

根据题意，蓄水池的编号为0。把它拆成两个点0和0'，则本题的模型就是求一个最小费

用流，使得进入0'点的所有流量均相同。根据题目背景，把那些流入蓄水池的弧称为“瀑布

弧”。下面来看一个例子。

如图12-37所示，除了弧0^4的容量上下界均为1之外，其他弧的容量下界为0，上界为 无穷大。所有水管的单位费用为1（注意，瀑布弧的费用为0）。不难发现这个例子的唯一可 行解如图12-38所示（边上的数代表流量）。

图12-37 瀑布弧



0.5



CO£t=l

图12-38唯一可行解



連布

cost^O



从图12-38可知，出现了非整数的流量。这样一来，就无法在修改模型之后只求一次费 用流就得到最终结果，只能寄希望于参数搜索——先确定瀑布弧的相同流量<，然后再求出 对应的最小费用c（/）。这样的想法是可行的，因为/确定下来以后问题就会转化为普通的带 上下界最小费用流问题。这样，就需要把注意力集中在函数c（/）上。

首先考虑/的可行域。不难证明/的可行域为连续区间[left , right],因此可以用二分法 确定这个可行域的边界：给瀑布弧设置下界0和上界/,如果网络没有可行流，则说明/< left ；如果网络有可行流但有的瀑布弧不满载，则说明/> right (想一想，为什么)。

接下来怎么办？直接输出最小流对应的费用？很可惜，最小的/并不对应最小的费用。

下面的例子很好地说明了这一点。

有两条弧的上下界均为1，因此流量必须为 1。如果要/最小，应该沿着0-*2—>3—>1—>0'的顺 序流动，但这样一来，经过了费用100的弧。另 一方面，如果沿着0>2>1>0'和0>3>1>0'流 动，虽然流量2不是最小的，但费用仅为4，如图

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-311.jpg)



12-39所示。

《训练指南》中介绍过“流量不固定的最小

费用流”问题，并且指出费用是流量的下凸函数。这个结论在本题中也成立，即在可行域 内c (/)是/的下凸函数，因此用三分法求解即可[⑽](#bookmark17)。

本题是笔者为2006年ACM/ICPC西安赛区所命的题目，上述算法便是笔者当时给出的“标 准算法”。虽然概念并不复杂，但是毕竟包含二分、三分以及容量有下界的最小费用流问题 等诸多因素，用程序实现并不容易。看到这里，聪明的你是否能想到一个“取巧”的方法呢？ 没错，可以用线性规划方法！只需要加一些“瀑布弧流量全相等”的等式，本题就转化成了线 性规划问题。不过，这个新算法和刚才介绍的传统方法相比，效率如何呢？读者不妨一试。

12.2.3 数学

例题12-17 简单加密法( Simple Encryption, ACM/ICPC Kuala Lumpur 2010, UVa12253 )

输入( 0<^<50000 ),解方程久• ■三人<    ) IH"，即的尺2次方的十进制

末12位等于尺2。注意，尺2的十进制必须恰好包含12个数字，不能有前导0。输入保证有解。 【分析】

很多数学题除了需要知识和技巧之外，还需要经验和直觉(而计算机是验证“直觉”的绝

好工具！），本题便是一例。本题的模1012很大，不妨先缩小一点，例如，把模改成103，那 么尺2的取值范围是100〜999 ,直接枚举即可。取^1 = 123 ,不难枚举到唯一解是547。如果把 模改成104 ,可以枚举到唯一解是2547。会不会是巧合？再换一个尺i = 234 ,可以枚举到模为

103时的唯一解是616， 104时的唯一解为1616。还有更神奇的： 123547的末4位为2547，而 234616的末4位是1616！

看上去可以得到一个猜想：如果/V| 以也结尾，则/、。也以也结尾。这里也是指把数字放 在n前面的数。试着验证一下：1232547的末5位是92547 , 12392547的末6位是692547。

123692547的末7位是1692547。看上去很不错。如果这个结论是对的，那么只需要用暴力法求 出一个很小的n使得/。丫以n结尾，然后用这个结论不断地往n的前面加数字，直到它拥有12个 数字为止——然后祈祷最后加上的那个数字不是0。这就是最终算法。

用数学归纳法可以证明上述结论[^](#bookmark22) ,不过比赛当中通常无暇考虑。只要最终算法够简 单，写程序的时间很可能还没有证明的时间长。即使写出来的程序是错的，也没有耽误太多 的时间。

例题12-18 伟大的游戏——石头剪刀布( The Great Game, ACM/ICPC Kuala Lumpur 2008, UVa12164 )

石头剪刀布的游戏规则是这样的：两个人一起出拳，必须出石头、剪刀、布之一。石头

胜剪刀，剪刀胜布，布胜石头。你和某人玩石头剪刀布游戏，分为若干轮，每轮

出6 （ 1<G<1000 ）次拳。胜者得1分（如果两个人出的一样，都不得分）。每轮结束后，得 分多的胜出（如果两人得分相同，则该轮没有人胜出）。当你的对手比你多赢£轮时，你就 算输掉了整个比赛；当你比对手多赢W轮时，你就算赢得了整个比赛。你的任务是找一个最 优策略，使赢得整个比赛的概率最大。 1<W， £<100。

假定你的对手的策略是固定的，而且每轮都一样：第/次出拳时分别有％% , '% , c%的 概率出石头、布和剪刀。输入保证巧+ ' + q = 100。

【分析】

你的任务是比对手多赢灰轮，而各轮之间是不相关的，所以你需要每一轮都玩得尽量 好。可是什么叫“玩得尽量好”呢？如果每一轮只有赢和输两种可能，那么“玩得尽量好”就是 指获胜的概率尽量大。但是在本题中，每一轮除了输赢之外还有可能是平局。如果有两种策

略，一种是20%概率赢， 80%概率平（因此不可能输），但另外一种是80%概率赢， 10%概 率平（因此还有10%的概率输），哪种策略更好呢？仔细思考后会发现：虽然第一种策略的 胜率比较低，但它是必胜的（即答案是100%） ——对手没有任何机会获胜；第二种策略虽

然赢的概率比较大，但却有概率输掉，如果£ = 1，答案肯定不是100%。

《训练指南》中曾经介绍过马尔科夫链。如果用一个编号为;c的结点表示“比对手多 赢^场”这个状态，则本题就是一个包含£+妒+ 1个结点（即-£，- （ L - 1 ），…，0，1，

...，W）的马尔科夫链，要求一个策略使得结点0首达结点W的概率最大。

假设最优策略使得每局获胜的概率为^win，输掉的概率为Aose，每个内结点（即不是 -L也不是W的结点）往左的转移概率为Aose，往右转移的概率为Awin，转移到自己的概率为 （1 - Awin - Aose ）。因为本题并不关心到达结点-L或W的具体时间，只关心先到达W的概

率，所以刚才的马尔科夫链等价于去掉自环（即每个状态到自身的转移），然后把往左往右 的概率归一化（即让二者加起来等于1）。此处要最大化的正是这条新马尔科夫链中的获胜 概率，即^0 ~Pw'^ （ Pwin + 乃。se ）。

至此，问题分成了两个完全独立的部分：如何最大化p0，以及已知p0之后如何求出状

态W的首达概率。后者的一般做法如下：设状态/时的获胜概率为^（/），根据边界d（ -L） =0，d（ W） =1以及马尔科夫方程联立求解。具体解法在《训练指南》中已有详细叙述。 对于本题中特殊的马尔科夫链，还可以直接求出解的封闭形式。另外，还可以用迭代法而非 高斯消元法求解方程组，这里不再详述。

前者也有两种解法：二分法和不动点迭代法。不动点迭代法及其收敛性的证明超出了本 书的讨论范围，因此这里只介绍二分法。二分答案p，看看是否有一种策略使 得PwinZ （Pwin+Plose ）改，即（1 - P ） *Pwin - P*Plose^0。接下来就只需用动态规划计算（1 -P ） *Pwin -P*Plose的最大值了。令“胜”的权值为1 - P，“负”的权值为-P，则问题转化为最

大化权值的数学期望。设状态d（ /，J ）表示前/次猜拳，得分为j （注意/可能为负数）时的最 大期望，分剪刀、石头、布3种情况讨论即可。

例题 12-19 自行车(Cycling, ACM/ICPC NWERC 2012, UVa1677 )

你有一个很棒的自行车：没有最大速度，加速度不超过0.5m/s2，但可以瞬间把速度减为

0到当前速度之间的任意速度。r=0时刻，你在x=0的位置。目标位置

是^=Xdest （ 1<Adest<10000 ）。一共有L （ 0<L<10 ）个红绿灯，每个红绿灯用3个整数描述： 位置Xi （ 0<A<Adest ）,红灯长度氏（10<代<500 ）,绿灯长度（10<6<500 ）。r=0时，所有 灯刚刚变红。不同红绿灯的位置保证不同。求到达目标位置的最短时间。

【分析】

用Z -义图（横坐标为时间，纵坐标为位置）可以直观地表示出一个合法解，如图12-40所 示。

从图中可以得到两个直观的结论。

结论1 :通过一个点（Z , x ）时，速度越大越好，因为可以任意减速。

结论2：不要在中间（没有红绿灯的地方）变速，且不等待时加速度保持最大。

证明：首先考虑没有红绿灯的情况。如何保证通过点（Z , x ）时速度最大？画一个速度 -时间图就一目了然了。相同时间（横轴）走相同路程（面积），而开始低速后加速最终得 到的速度更高（纵轴），如图12-41所示。也就是说：要么就等着，要加速就要是最大加速 度，并且等待／刹车一定是起点或者刚过红绿灯之后。

图 12-40 t-x图



图12-41 速度-时间图



这样就证明了，只需考虑红绿灯刚刚变化时的状态（t ,x）。注意，x只有L+ 1种取法 （起点或者某个红绿灯处），而t只能取该红绿灯刚刚变色的时刻（x= 0时t必须等于0）。稍

后将会分析状态（Z , x）的个数，不过现在先设计算法。

设d（ Z , x ）表示自行车处于状态（Z , x ）下的最大速度，则可以写一个“刷表法动态规 划”：枚举（/ , x ）的“下一个状态”（f , x'）（其中Z'>Z , x'>x）,更新d （ Z' , x'）。需要分 两种情况讨论。

情况1 :减速但不等待。这需要求解减速后的速度v ,使得保持最大加速度行驶后恰好到 达状态（Z' , x'）。注意：因为行驶距离x' - x和时间Z' - Z都已经固定，且加速度恒定为0.5 , 可以直接解出v。如果v>d（Z,x），说明这个解不合法（因为自行车不能瞬间加速！），而 如果v<0 ,其实已经变成了情况2。

情况2：把速度减为0，等待一段时间后重新开始加速。因为初速度为0，加速度恒定为

0.5，根据行驶距离可以直接算出加速时间，也就能算出等待时间了。

需要特别注意的是，不管是情况1还是情况2，算出具体路线以后却要判断这条路线会不 会“闯红灯”。只有不闯红灯时才能用到达（Z' , x'）时的速度更新^ （ Z' , x'）。另外，每个状 态d（ Z , x ）都有可能直接最大加速冲到终点，从而更新最终答案，但也要判断有没有闯红 灯。

状态有多少个呢？最坏的情况就是10个红绿灯把10000米分成11段，每段910米，且每次 都要从头加速，因此行驶时间为11*sqrt （ 4*910 ） =664秒。另外，每个红灯处最多等500 秒，因此总时间不超过5664秒，每个红绿灯最多经过5664/（ 10+ 10）< 300个周期。粗略计 算一下，上述算法的计算量是可以承受的，而且刚才的估算非常“悲观”，实际上很难达

到[（12）](#bookmark2)。

命题组最初设计的题目还要更难一点：自行车的速度还有一个上限值。有兴趣的读者可 以思考一下，如何求解这个“加强版”的题目。另外，上述算法还有很大的优化余地（例如， 计算d（Z,x）时不一定要枚举所有满足Z'<Z,x'<x的状态（Z',x'）），有兴趣的读者可以 深入思考。

例题12-20 折纸公理6( Huzita Axiom 6, ACM/ICPC NEERC 2011, UVa1678)

输入两条线^ , 和两个点/^ , ^2 ,找一条直线/ ,使得^的对称点落在上，且^2的对称 点落在/2上。换句话说，如果以/为折纸痕，灼会折到上，p2会折到/2上，如图12-42所示。

输入保证A，/2不同，但Pi，P2可以相同。P^ 多解，输出任意解；如无解输出4个0。

【分析】

给定P，l，哪些直线能把P折到l上呢？假 设l上有两个不同点A和B，则l上任意点可以写 成P' ( t) = A + t ( B - A )。如果把p折 到P' ( t)，则折纸痕为p-p'( t)的垂直平分 线，化简为 (t)x + b(t)y + c(t) =0，其 中( t )，b ( t )为t的线性函数，c ( t )为二次 函数。这是一个直线族，即任取一个t，都能得 到一条直线，把p折到l上。另一方面，对于任意 一条能把p折到l上的直线，都存在这样一个参 数t。此处把这个直线族记为(a ( t )，b(t)，c

t))。



在本题中，有两对点和两条直线，因此可以得到两个直线族 (a1 ( t ) ，b1 ( t ) ，c1 ( t ))和(a2 ( t) ，b2 ( t ) ，c2 ( t ))。目标是求出一条直线同时 属于两个直线族，这等价于求出两个参数tjnt2，使得直线“！ ( t1 ) x + b1 ( t1 ) y + c1 ( t1 ) = 0 和a2 ( t2 ) x + b2 ( t2 ) y + c2 ( t2 ) = 0是同一条直线。

—条直线有多种表示法(例如，x +y + 1 = 0和2x + 2y + 2 = 0是同一条直线)，不能简单 地认为a】(t1 ) = a2 ( t2 ) ，b1 ( t1 ) = b2 ( t2 ) ，c1 ( t1 )= c2 ( t2 )，而只能认为三者“成比 例”(但是要注意0不能做分母)。—种常见方法是将“二直线相等”变成以下两个条件：

□法线共线，即(ai ( ^ ) ，b1 ( t1 ))和(a2 ( t2 )，b2 ( t2 ))共线。

□其中一条直线上有一个点在第二条直线上。

根据这两个条件，可以列出两个关于^和巧的方程，消去t2后，能得到一个关于^的三次 方程，用二分法求解即可(要注意退化情况)。

例题12-21 简单几何( Easy Geometry, ACM/ICPC NEERC 2013, UVa1679)

输入一个凸《 ( 3<«<100000 )边形，在内部找一个面积最大，边平行于坐标轴的矩形，

如图12-43所示。



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-315.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-316.jpg)



图12-43 “简单几何”问题示意图

【分析】

虽然本题是几何题(而且题目名称里也有“几何”字样)，但用纯几何的方法解题很难奏 效。因为图形是凸的，可以从函数的角度考虑问题。对于任意横坐标x0 ,竖直线x = x0最多和 凸多边形相交于两个点，设h ( x0 )和^2 ( x0 )分别为低点和高点的坐标。对于任意给定 的x0 ,可以用二分查找的方法求出乃(x0 )和y2 ( x0 )。下面假设矩形的左端点为x ,宽度 为w ,则最大矩形包含在如图12-44所示的阴影部分梯形中。

根据图12-44 ,最大矩形的面积( x , w ) =w* ( min{y2 ( x ) ,y2 ( x + w ) }-max{yi (x) ,yHx + w)})。当 w 固定时，上

述表达式是x的凸函数，所以宽度为w的最大矩形 面积& ( w )可以通过三分法求出。类似 地，( w )也是关于w的凸函数，所以最大矩 形的面积也可以通过三分法求出。

图12-44二分查找求出yi ( x0 )和y2 ( x0 )



12.2.4 几何

例题 12-22 打怪物(Shooting the Monster, ACM/ICPC Kuala Lumpur 2008,

UVa12162)

你正在玩一个打怪物的游戏，其中怪物是一个巨大的不能动弹的n ( n<50)边形，位于

右半屏幕。你发的子弹也是一个多边形，从左半屏幕开始匀速水平向右飞到无穷远处，速度

为1。注意，怪物在被子弹打穿的过程中不会产生形变，也不会移动。

为了增加游戏的真实性，一发子弹对怪物的伤害等于子弹与怪物的公共部分面积对时间

的积分。例如，在图12-45中，Z分别为0和3 ,相交部分的面积分别为0和1。

对于上面的场景，可以画出相交面积随时间变化的曲线，如图12-46所示。

图12-45 t为0和3时相交部分面积



图12-46 相交面积随时间变化的曲线



根据定积分的定义，曲线下方的面积就是子弹对怪物的伤害。输入坐标均为绝对值小于

500的整数。屏幕中点的x坐标为0，怪物多边形顶点的x坐标均大于0，子弹多边形顶点的x坐 标均小于0。

分析】

本题在定义上是一个积分题，但不一定要按照定义计算积分。如果按照定义，则需要分

析两个多边形相交的面积随着时间的变化规律，而在题目中给出的那个曲线看上去毫无规

律。怎么办呢？

因为子弹是水平向右飞行的，可以把两个多边形划分成水平条而非竖直条，则不同水平

条之间的结果完全独立，依次求解后累加即可。具体来说，从两个多边形的所有顶点出发画

一条水平线，则每个水平条内都是一些梯形(或退化成三角形)，如图12-47所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-320.jpg)



对于一个水平条来说，同一个多边形划分出的梯形／三角形可以合并到一起（想一想，

为什么），如图12-48所示。所以问题转化为子弹和怪物都是单个梯形的情况，可以直接求

解（需要手工计算一个简单积分）。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-321.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-322.jpg)



图12-48 子弹和怪物形状转化为梯形

例题12-23 快乐的轮子( Merrily, We Roll Along!, World Finals 2002, UVa1017)

你有一个圆形的轮子，放在一条由水平线段和竖直线段组成的折线道路上，轮子的中心

在道路起点的正上方。在保持和折线接触的前提下，你沿着道路把轮子滚到尽头（即让轮子

的中心在道路终点的正上方）。你的任务是计算圆心移动的总距离。

在下面的例子中，假定轮子半径为2，道路第一段和最后一段的高度相同，长度都是2。

中间的水平线段长度为2.828427，比另两条水平线段低2个单位。滚动轮子时，轮子首先从

位置1（起点）水平移动到位置2，然后旋转45°到位置3，再旋转45°到位置4，最后水平移动

到位置5（终点），圆心移动距离为7.1416，如图12-49所示。

下面的例子更为复杂：两边是两条长度为3的水平线段，中间是一条长度为7，高度比两

边低7个单位的水平线段。轮子的半径为1，移动总距离为26.142，如图12-50所示。

输入轮子的半径r和道路的段数《 ( 1<^<50),以及每段道路的长度和道路右端处的高度 变化值(正数代表变高，负数代表变低，最后一段道路右端的高度变化值保证为0)，输出 圆心移动距离，保留3位小数。输入保证第一段和最后一段道路的长度严格大于r ,且在滚动 过程中轮子不会同时碰到两条竖直道路。

【分析】

本题有两个常用算法。第一种方法类似于“清洁机器人”问题，先将道路外扩距离及，打 散线段和圆弧，然后判断每条小线段和圆弧的中点与输入道路的距离是否小于及，如果是， 则不要统计这条线段／圆弧，如图12-51所示。

这个算法比较易于理解和编写，查错也很方便，但运行速度较慢。还有一个概念上较为

简单、速度快，但容易出错的算法：直接模拟。任何时刻有4个可能的状态：水平向右移动

( 0)、竖直向下移动( 1)、竖直向上移动( 2)、绕顶点顺时针旋转( 3)，可能的转移如 图12-52所示。

0->2    0->3



图12-52 4种可能的状态



3->0    3->1 3->2 3->3



例题12-24 客房服务( Room Services, ACM/ICPC World Finals 2012, UVa1286)

给定一个凸n ( 3<n<100 )边形和多边形内的一个点，要求从这个点出发，到达每条边恰 好一次，然后回到起点，使得总路程尽量短。注意：到达一个点相当于到达了它所在的两条 边。

【分析】

本题看上去相当困难，因为可行的路径有无穷多条。怎么办呢？物理老师曾经说过：光

线总是沿着最短路线走。那么是不是可以借鉴一个光路呢？如图12-53所示，假设要从A到 B，但是中间必须经过直线/。假设现在的路径是A - >C ->B。做A关于/的对称点A'，则 ACB的路径长度等于A'CB的路径长度。因为两点之间线段最短，A'CB最短时就是这三点共 线时，即C和C'重合。

这样，即可得到结论：到达一条边时，只要到达的是边的内部而不是端点，路线都满

足“光的反射定律”，即反射角等于入射角。另外，还能猜到一个直观(但不是很好证明)的

结论：存在一个最优解，使得所有边按照逆时针顺序到达。有了这两个结论，就可以设计出

主算法了。

首先枚举第一次到达的边，把环打断成线。为了方便，把第一次到达的边的终点编号为 1，其他点按照逆时针顺序依次编号为2〜n，起点编号为0，终点编号为n + 1 (起点和终点重 合)。接下来进行动态规划：设^( / )为表示当前点编号是/，还需要多长路径才能走到终 点。枚举下次走到的顶点编号/，则：

d(i) = min{w (i，j) + d (j ) j = i + 1…n + 1}

其中，w ( i，j )表示从顶点i出发，到达顶点j，中途按顺序经过i~j之间所有边的最短 路径长度，如图12-54所示。

图12-53 ACB的路径长度最短



图12-54经过i~j的所有边的最短路径长度



计算W （ i，j ）时需要不断地计算i关于各条边的对称点，最后和j相连，然后恢复出整条 折线。但是需要判断是否每次“到达—条边”时接触点都真的在线段的内部。如果接触点在线 段外面，则说明这条路线是非法的，W （ i，j ）应设为正无穷。细心的读者可能会问：如果 有接触点在线段外面，可以退而求其次，不走镜面反射路线，但也不该是正无穷啊？但其实 这样做的结果是直接走到多边形的—个顶点，已经被上述动态规划算法考虑到了。

当i或者/为0或者《+1时，需要一些特殊处理。另外，还要注意/= i+1的情况。细节留 给自行读者思考。

例题12-25 最短飞行路径( Shortest Flight Path, ACM/ICPC World Finals 2012, UVa1288)

如图12-55所示，地球表面有《个机场，要求从机场5飞到机场t时，飞行总距离最小（无 解输出impossible），且飞行过程中始终满足：离最近机场的距离不超过儿由于油箱限制， 最大连续飞行距离为c，所以可能需要中途在其他机场加油。本题距离都是指球面距离（假 定飞机沿着地球表面飞行）。地球是半径为6370km的球，有多组询问

（ 5， t， c）。 n<25， Q<100。

##### COCO



2C00



-2000



-4000



-6000



-^000



4OC0



-7ono

图 12-55



2000 4000

“最短飞行路径"问题示意图



i；OOC



6000



【分析】

虽然这个题一看就是最短路径问题，但是构图才是本题的难点。假设已经成功构图，剩

下的问题就是：有《'个点的图G ,其中有《个点是特殊点（机场）。给定起点5和终点Z ,找一 条最短路，使得路径上任意两个相邻特殊点的距离不超过心首先以特殊点出发做单源最短 路，求出每两个特殊点之间的最短路，然后构造一个新图G',结点是特殊点，边仏^的长 为G7上m-v的最短路。最短路大于c时不加这条边。

图G的结点是所有机场和每个机场的“保护圈”的交点。一共有〃个保护圈，交点数不超过 600个（ 2C（ n， 2） <600）。对于任意两个点，当且仅当二者可以“直达”时连一条边。 “可以 直达”意味着它们之间的大圆弧是安全的，即这个大圆弧完全位于所有保护圈的“并”的内 部。注意这个大圆弧的不同部分可能会在不同机场的保护圈内，所以不能简单地取弧的中点 后依次判断每个保护圈。

判断一条大圆线[O^](#bookmark12)a是否安全的正确方法是：对于每个保护圈5，求出a被5保护的范围， 然后把所有范围求并，看看是否是完全覆盖a。保护圈交点的个数是0( «2)，因此“需要判 断是否安全”的大圆弧个数是0 ( «4 )。对于0 ( « )个保护圈，求交点和区间并需 要0 ( nlogn )时间，因此总时间复杂度为0 ( n5logn)。

12.2.5 非完美算法

例题12-26 可爱的魔法曲线( Lovely M[a]gical Curves, Rujia Liu's Present 6, UVa12565)

NURBS曲线是一种可爱而又“有魔法”的曲线。它的样子多变，非常灵活，如图12-56所 示。

nurbs curve

basis functions of points

■gawi

图 12-56 NURBS 曲线



NURBS曲线的数学表达式是：

C⑻



/=l



[wA々⑻

###### i=l



其中，m是参数，n是控制点个数，&是曲线的度数，和是第i个控制点的位置和权

重。在上式中(计算过程中遇到的0/0按0算)

NURBS曲线的参数有严格的限制：

□度数是正整数。

□控制结点至少有&+ 1个，和曲线形状有直接关系。

□ Knot向量为［^，^，…，^ ］，其中讲= n + ^+ 1。相邻knot值满足诊…，定义了曲线 中参数［Zz，t+1 )的部分。整个NURBS曲线的定义域是［t1，tm)。

要求求出两条NURBS曲线的所有交点。n<20，度数为1，2，3或者5，控制点坐标范围 是［0，10 ］，权值范围(0，10 ］，Knot向量的第一个数保证为0，最后一个数保证为1。

输入保证NURBS曲线不病态，且没有特别接近的交点，输出保留3位小数。

【分析】

NURBS曲线和曲面是工业中常用的建模工具，也是工作中实际会用到的。NURBS曲线 的定义看起来比较吓人，但仔细观察后可以发现，它实际上就是一个分段多项式曲线，可以 用数学归纳法证明。N，0(u)是分段0次曲线(当u在^叫+ :之间时为1，其他时候为0 )， 而N.，k ( u )由两部分相加得到。注意，N.，k -1 ( u )和N+i，k -1 ( u )的第二个下标都是i -1，而且系数都是u的一次函数，因此Nz，k ( u )比N，，k-1(u)的次数要大1。

看清楚定义之后，至少可以做一件事：对于一个给定的参数u，计算曲线中参数u所对应 的点，即C ( u )。于是，第一个算法诞生了：对一条NURBS曲线，有一个很大的正整数^， 取步长>s= 1//»，然后对于参数i = 0，1，2，…，n - 1各求出一个点PfC (is)(想一想，为 什么不计算Pn = C ( 1 ))。只要足够大，折线P0 - P2 -…-Pp - 1可以很好地逼近一条 NURBS曲线。这样，用两条折线分别逼近两条NURBS曲线，然后求出两条折线的交点即

可。如何求两条折线的交点？因为交点很少，采取《训练指南》中介绍的扫描法，可以

在0 (plogp )时间内完成这个任务。

这个方法看上去非常不优美，但是它可以解决问题。学习算法的目的不正是解决问题

吗？在更好的算法被找到之前，应该尽可能地解决问题，不要轻易放弃。

上述方法只是一个基本梗概，有许多细节可以优化。例如，可以用二分法来“自适应”地

构造折线，而不是像刚才那样均分参数空间。还可以不用扫描法，而是把轴划分成一些相

互重叠的小窄条，在每个窄条里寻找交点[(14)](#bookmark18)。只要仔细选取上述方法的参数，就能更快、

更准地找出所有交点，并且不会遗漏。

例题12-27 奇怪的歌剧院( A Strange Opera House, UVa11188)

昨天晚上，我做了一个奇怪的梦，梦到我站在一个多边形的歌剧院舞台上演唱。我的声

音最多能被歌剧院的墙壁反射&次，如图12-57中的4幅图描绘了声音的反射方式，分别为歌 剧院轮廓、声音直射的可达区域、声音反射一次的可达区域、声音反射两次的可达区域。

观众都坐在墙边。你能帮我计算一下，有多少观众能听到我的歌声吗？

每组数据第一行为4个整数《 ,k,x,y( 3<i<50 , 0<k<5 )，其中，《为歌剧院多边形的 顶点数，k为最大反射次数，(x ,y)为我唱歌的位置(保证严格在多边形的内部，不在墙 上)。以下《行每行为歌剧院的一个顶点坐标。顶点按照顺时针或逆时针排列。所有坐标均 为绝对值不超过1000的整数。对于每组数据，输出能听到我的声音的观众所对应的墙的总长 度，保留两位小数。

【分析】

本题只需要按照题目意思反射声音，然后求出声音到达的墙的总长度即可。但这个概念

上简单的过程却并不容易转化成程序。因为歌剧院是不规则多边形，声波在传播过程中可能

经过多次反射，而且不同的声波的“反射序列”(即每次发生反射时由墙编号组成的序列)可

能完全不同。幸运的是，这些声波依然是可以“离散化”的，即按照角度划分成若干区间，使

得每个区间中声波的反射序列相同，如图12-58所示。

这样的“离散化”方案虽然概念正确，但是很难像其他题目那样通过一次预处理完成，因

为要事先考虑所有可能的反射序列(多达505种)。一种折中的方案是用深度优先搜索的方

式，递归地把声波角度逐步细分。

如图12-59 ( a )所示，从P点出发，角度范围为A到E的声波被分成了4部分：A到B，B到 C，C到D，D到E。接下来递归求解即可。为了递归求解，需要把子问题设计成和原问题相 同的形式，即子问题也应有一个“音源”。

如图12-59 ( b )所示，从P发出的声音，初始范围是向量v1和v2之间，其中向量    PA和

中间的部分反射出来的区域等价于P关于必的对称点P'直射4和5点，得到的区域中在有向

线段AS左侧的部分(这句话非常绕，请多读几遍)。这样，已经可以设计出递归过程了。 参数有5个：已经反射的次数/、等价音源位置P，上次反射墙的有向线段 AS和初始范围向 量v1和v2。在递归过程中，首先把角度区间分成若干个小区间，使得每个区间直射的是同一 面墙，然后计算出发射后的递归参数并进行递归调用。程序细节留给读者编写。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-334.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-335.jpg)



(a)



(b)



图12-59 将声波角度逐步细分

本题还有一个姐妹篇——奇怪的歌剧院11[^](#bookmark21)，其中把“长度”改成了“面积”，即要求计算 能听到歌手声音的区域面积。有兴趣的读者可以试一试。

例题 12-28 最小包围 长方体( Smallest Enclosing Box, Rujia Liu's Present 4, UVa12308)

给定三维空间中的n ( n<10)个点，求一个能包含所有点的体积最小的长方体。这个长 方体的各个面不一定要平行于坐标平面。只需输出最小长方体的体积。

【分析】

在《训练指南》中用旋转卡壳的方法计算了n个点的最小包围矩形，时间复杂度 为0 ( nlogn )。该方法基于这样一个定理：一定存在一个最小包围矩形(不管是面积最小还 是周长最小)，贴着凸包的一条边。

对于最小包围长方体，是否有这样的结论呢：一定存在一个最小包围长方体，贴着凸包 的一个面？如果这个结论成立，问题就简单多了。首先计算三维凸包，然后枚举凸包上的一 个面，再整体旋转所有点，使得这个面和z = 0平面平行。这样，就可以忽略所有点的z坐 标，求出面积最小的包围矩形及，则所求长方体的底就是及，高就是旋转之后所有点的z坐标 最大值与最小值之差。因为n的范围很小，既使用最慢的三维凸包和最小包围矩形算法，也 不会超时。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-336.jpg)



很可惜，上述结论是错的，即最小包围长方体不一定会贴住凸 60所示，正四面体（它的凸包是自身）就是一个 反例：最小包围长方体的每个面都贴住了一条 边，但是没有贴住任何一个面。

事实上，已知最强的结论是：最小包围长方 体中至少有两个相邻面均贴住凸包的某条边。 Joseph O'Rourke在论文《Finding Minimal Enclo5ing Boxe5》 中基于这个结论设计了一个三

维旋转卡壳算法，成功地在多项式时间内解决了

图12-60正四面体



最小包围长方体问题，但算法很抽象、复杂，难

以用到算法竞赛中。

前面曾经多次强调过，算法竞赛的目的是要解决问题。如果“正解”过于复杂，难以驾

驭，可以寻找非完美解决方案。刚才的算法其实只有第一步错了，那么只要用其他办法找到

最小包围长方体的一个面，还是可以用旋转、降维的方法进行求解。一个相对容易实现的方

法是使用随机调整：先随机生成大量的平面，求出对应的解，然后选一些比较优秀的解进

行“微调”——稍微旋转一下，如果旋转后的解更优，就更新答案。这样的随机调整方法有很

多不同的实现方法，常用的一种是模拟退火方法，有兴趣的读者可以查阅相关资料。

12.2.6 杂题选讲

例题12-29 旅行（ Journey, ACM/ICPC NEERC 2011, UVa1680）

有打（n<100 ）个绘图函数，包含GO （前走一步）、LEFT （左转）、RIGHT （右转）、 Fk （递归调用第k个函数然后继续执行本函数）4种指令。

例如程序：

f1: GO F2 GO F2 GO F2

f2: F3 F3 F3 F3

f3: GO LEFT

会画出如图12-61所示的图形。

有时，函数会无限执行下去，如GO F1。



每个函数最多包含100条指令。从（ 0， 0） 点开始执行f1，求画图过程中距离（0，0 ）点最 大的曼哈顿距离（即W + [y| ）。如果无限大，则 输出 Infinity。

【分析】

图12-61 程序绘制的图行



既然题目是递归，那么第一反应就是直接写个递归函数simulate （x，y，i，d），表示目 前在（x，y ），面朝方向d，执行函数^。在执行函数时不断更新|x| + |y|的最大值。

可惜这样做是不行的，因为题面已经给出了一个无限递归的例子。所以要想沿着这个思 路继续解题，必须避免无限递归。如何避免呢？最直接的方法就是检测无限递归，就像第6 章介绍的图的DFS—样。检测到以后怎么办呢？直接输出Infinity?这样可不行。“无限走下 去”也可能是“无限绕圈圈”，并不代表会离原点无限远。所以还应该记录一下出现无限递归 时的位移，当且仅当位移不是（0，0 ）时，输出Infinity。

现在的程序不会无限递归了，可惜还是会超时，因为走的步数可能会非常多。例如f1是 100个f2，f2是100个f3，f3是100个f4，…，f100是100个GO，则一共会执行100100个GO （这意 味着本题需要输出高精度整数）。怎么办呢？既然已排除了无限递归，就可以用像动态规划 一样的记忆化了 ：对于（i，^），记录面朝方向为d，执行完z，之后的方向、总位移 （dx，dy ）和路径上的max{|x| + |s|}，然后尝试递推。

记忆化时之所以不记录（x，y），是因为它们可能会很大，而且不同的（x，y），当湘 同时，执行Zi的路线“形状”都是一样的，因此位移也一样。可新的问题又出现了： max{|x|

+ y|}无法递推。具体来说，就是设位移为（x0，y0 ）时，无法根据max{|x| + y|}计算出 max{|x+ x0|， |y+ y0|}。

解决方法也非常巧妙。分别记录x+y，- x + y， - x - y，x - y这4个表达式的最大值。因 为没有绝对值符号，这4个值是可以递推的；当计算最终答案时，这4个值的最大值就是 max{|x| + |y|}（想一想，为什么）。

例题12-30 下雨( Rain, ACM/ICPC World Finals 2010, UVa1097)

有一个由许多不同形状的三角形沿边相互拼接而成的立体地形图，其中三角形的每条边

要么是地形图的边界，要么与另外一个三角形的某条边完全重合。此时在地形图的上空开始

下雨，雨水会被困在地形图中而形成湖。要求编写一个程序来确定所有的湖，以及每个湖水

位的海拔高度。假设雨非常大，所有湖的水位都到达了最高点。

对于一个湖，一艘大小可以任意小但不为0的船可以在湖面上的任意两点间航行。如果

两个湖在相接位置的水位深度均为0，则它们被认为是两个不同的湖。

输入第一行包含两个数和g (^^3，^>3)，分别表示地形图中点和边的个数。之后 的行描述每个点，每行首先是点的名字，接着是3个整数;c，y，力，表示这个点的三维坐 标，其中c、y (- 10000<x，y<10000 )为点在地平面上的坐标，A ( 0<^<8848 )为点的海拔 高度。接下来的q行描述每条边，每行包含两个点的名字，表示一条边的两个端点。

地形图在xy平面上的投影满足下列条件：

□任意两条边只可能在端点处相交。

□该图形是一个有许多三角形组成的连通区域。

□该图形的边界是一个封闭的多边形，内部没有空洞。

可以认为上述区域以外的点的海拔高度低于区域内任意一点的海拔高度，水在流到边界

后会紧接着流出这个区域。

对于每组输入，在第一行输出数据的编号，接下来以递增的顺序在每行输出一个湖的海

拔高度；如果没有湖，则输出一个0。

【分析】

首先建一个图，结点是所有区域(即三角形和“外界”无限大区域)。当且仅当两个区 域有公共边时，在图上连一条边，权值为m和v的两个公共顶点的较低高度，表示只要水 位高于这个高度，水就可以从m流到v，或者从v流到m。

下面这一步需要点创造性思维：考虑水从某一个区域流到“外界”的路径。这条路径上的

最大权重对应着一个“最小高度”，当水位达到这个高度时，水就可以顺着这条路径流到外

面。但是水可以有多条通往外界的路径，只要水位大于任何一条路径的最小高度，水就可以

顺着这条路径流出去。这正是一个最短路问题吗，只不过路径的“长度”是最大边权而非边权

之和而已。第11章中已经讨论过这样的“变形最短路”问题。

用Dijkstra算法求出以外界为起点的单源最短路（因为边都是无向的，以外界为终点相 当于以外界为起点）之后，对每个区域i都求出了一个d[i],即“能流到外界的最小水位”，只 要d[i]大于区域i的3个顶点的最小高度，则说明区域i是有积水的，并且水位就是d[i]。求出了 水位，用DFS或者BFS把连通的积水区域合并起来成为“湖”即可。

例题12-31 字典( Dictionary, ACM/ICPC NEERC 2013, UVa1681)

输入n （ 1<n<50 ）个不同的单词（每个单词的长度为1〜10 ）,设计一个结点数最少的树 状字典，使得每个单词w都可以找到一条从上到下（即远离根结点）的路径，使得路径上出 现的字母按顺序连接起来后可以得到w。如图12-62所示，7到5是north , 16到12是eastern , 29 到2是european , 3 到25 是regional , 1 到31 是contest。

1

分析】

首先把题目的要求放宽一点：必须从根开始走，而不是从任意结点开始走。这样，只需 要构造这些单词的Trie即可，如图12-63 ( a )所示。

这个Trie也可以理解成一个状态图，每个结点代表“当前得到的字符串前缀”，则本题 中“从任意结点出发”的条件只需要加一些虚线边即可，如图12-63 ( b )所示。例如，加上了 abc^c的虚线边之后，实际上可以从根走到abc ,然后走虚线边“扔掉前两个字符”得到c ,这 和从根直接走到c是完全等价的。更妙的是，从abc到c这条“边”实际上并不在最终的树状字 典中，所以用它来代替从根到c的这一条边，能让答案更优。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-339.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-340.jpg)



图 12-63 构选单词的 Trie

一般地，对于任意两个前缀p和q ,若q是p的后缀，则连一条从p到q的虚线边。在这个图 中，我们的目标是找到一些边，使得这些边形成“树状字典”，并且包含的实线边最少。设实 线边权为1，虚线边权为0，所求答案就是这个图的最小树形图。

例题 12-32 算符 破译( Equations in Disguise, Rujia Liu's Present 1, UVa11199[(16)](#bookmark4))

已知字母a，b，c，d，…，m和数字（0 - 9 ）、加号（ + ）、乘号（1* ）和等号（=）

之间有一个--对应关系（--映射）。你的任务是根据《 （ 1<«<20 ）个等式，尽可能地推

导出这些对应关系。每个等式恰好包含一个等号，等号两边都是中缀表达式，数字都是十进

制的，不含前导零（但整数0是允许的）。运算符均为二元的，乘法的优先级比加法高（没

有括号）。

对于每组数据，输出所有可以确定的符号对（一个字母和它代表的数字／运算符）。换 句话说，这些符号对应在所有解中均成立。无解，输出No ;如果有解，但没有可以确定的 符号对，则输出Oops。

例如，有两个等式｛abcdec、cdefe｝，输出为“a6 b* d = f+”（所有可能的解为｛6*2 = 12，2 = 1 + 1｝，｛6*4 = 24，4 = 2 + 2｝，｛6*8 = 48，8 = 4 + 4｝）。只有一个等式｛abcde｝，则 什么也确定不了（输出Oops ），而只有一个等式｛milim｝，则是无解（输出No ）。

【分析】

本题的条件太苛刻，连运算符都没有给出，看上去非搜索莫属了。不难发现，应当先搜 索等号、加号和乘号的位置，因为这三者出现的位置最苛刻（等号在每个等式中必须恰好出 现一次，并且这三者中的任意两个都不能连续出现，也不能在等式的首尾位置）。例如，若 有一个等式abcab，则c肯定是等号，因为只有c恰好出现一次。枚举完等号以后还有一个小 优化：如果某些等式在等号左右两边的字符串完全相等，则不管怎么搜，这个等式都会成 立，因此只需要标记出来，今后在搜索时就可以避开无谓的判断了。

接下来搜索各个数字。a + b = c这样的等式只需搜索a和b，则c就能直接计算出，所以需 要重新安排各个数字的搜索顺序，使得更多的数字能够尽快直接计算出。例如， ab+cd=ef 的一个较好的搜索顺序是：b，d，f，a，c，e。其中搜索完b，d之后可以直接计算出f（注意 此时还要检查其他等式是否存在矛盾），而搜索完a，c后可以直接计算出e。

abc = d + e + f是不可能成立的，因为3个一位数加起来不可能是3位数。一般地，可以求 出每个数的最小值和最大值，进而计算出等式两边的取值范围。例如，abc的取值范围是100 -999 （虽然不如123 -987准确，但比较容易求），d + e + f的取值范围是0 - 27，因为 27<100，所以无解。这个方法有一个软肋：0乘以任何数都等于0，所以在a*b = a*cdefg这样 的等式里，这个方法完全不奏效。幸运的是，有一个办法可以减少这种情况的发生：先搜索 0。等0确定下来以后，上下界估计就会准确一些。

看上去很吸引人吧？这个剪枝的效果很不错（即可以剪掉大量枝叶），但是效率却不

佳。也就是说，有可能花费大量的运行时间在“判断是否满足剪枝条件上，这就舍本逐末

了。一般来说，可以尝试以下方法来调整这种“低效剪枝”：牺牲效果（即少剪一点）而提高

效率，或者只在搜索的前几层才检查剪枝条件，因此那时的结点还不多，效率不会太受影

响，而剪枝成功后的好处更大。

还有一个剪枝更有意思：因为并不是要找出所有解，所以如果已经Oops7（即有解，但 所有字母都是多解），直接终止整个搜索过程即可。一般地，设ans（ c）表示“当前最终答 案”中c的值（可能是“?”）, val （ c ）表示“当前解”中c映射到的字符（必须是0〜9或者加 号、乘号或者等号），则还没有搜索的所有字符的ans都是“?”，已经搜索的字符c满足：要么 ans （ c ）= ‘？’，要么ans （ c ）= val （ c ）,即继续搜索下去，不管val能不能变成一个合法 解，都不会改变“最终答案”。所以应该终止当前解的搜索。注意，初始时ans为空，此时无 论如何都要先搜出一个解。

刚才的描述比较抽象，下面举一个例子。假设目前已经得到了两个解：a = 4 , b = 6 , c =3 , d= 1 ; a = 8 , b = 6 , c = 1 , d = 3 ,因此ans是a = ? , b = 6 ,c = ? ,d = ?。再假设现在已 经搜了a = 2 , b = 6 ,但c和d还没搜。在这种情况下不管有没有解，有何种解，都改变不了 ans。

有了这些优化，最终的程序速度会非常快。不过本题还有一个不起眼的“陷阱”：在输入

中没有出现的字符并不一定是不确定的——因为是一一映射，如果已经确定了12个字母，剩

下的那一个也就确定了。

例题 12-33 独占访问(Exclusive Access, NEERC 2008, UVa1682 )

多线程编程中的一个重要问题就是确保共享资源的独占访问。需要独占访问的资源称为 临界区（CS ）,确保独占访问的算法称为互斥协议。

在本题中，假设每个程序恰好有两个线程，每个线程都是一个无限循环，重复进行以下 工作：执行其他指令（与临界区无关的代码，称为NCS ）,调用enterCS ,执行CS （即临界 区代码），调用exitCS ,然后继续循环。NCS和CS内的代码和协议完全无关。

在本题中，用共享的单比特变量（即每个变量只能储存0或者1）来实现互斥协议（即上 述的enterCS和exitCS ）。所有变量初始化为0 ,且读写任意一个变量只需要一条语句。两个 线程可以有一个局部指令计数器IP指向下一条需要执行的指令。初始时，两个线程的IP都指 向第一条指令。程序执行的每一步，计算机随机选择一个线程，执行它的IP所指向的指令， 然后修改该线程的IP。为了分析互斥协议，定义“合法执行过程”如下：两个线程都执行了无 限多条指令；或者其中一个线程执行了无限多指令，另一个线程执行了有限多条指令以后终 止，且IP在NCS中。

表12-4中展示了3个互斥协议的伪代码。两个线程的id分别为0和1，变量want[0]、 want[1]和turn为共享单比特变量。以“ + ”开头的代码实现了enterCS，而以“-”开头的代码实 现了exitCS。NCS()和CS()表示执行NCS代码和CS代码，这些代码的具体内容和本题无关 (假设它们不会修改共享变量)。

表12-4 3个互斥协议的伪代码

| 算法1             | 算法2                   | 算法3                                         |
| ----------------- | ----------------------- | --------------------------------------------- |
| loop forever      | loop forever            | loop forever                                  |
| NCS()             | NCS()                   | NCS()                                         |
| + loop while      | + want[id] <- 1         | + want[id] <• 1                               |
| + (turn = 1 - id) | + loop while            | + turn <- (1 - id)                            |
| cs()              | + (want[l - id] = 1)    | + loop while                                  |
| -turn <- (1 - id) | cs()                    | +    (want[l - id] = 1 and                    |
| end loop          | -wanl[id] <- 0 end loop | +    turn = 1 - id)cso-want[id] <- 0 end loop |

本题的任务是判断一个给定算法是否满足以下3个条件。

□互斥性：在任意合法执行过程中，两个线程的IP不可能同时位于CS。

□无死锁：在任意合法执行过程中，CS都执行了无限多次。

□无饥饿：在任意合法执行过程中，执行了无限多条指令的线程执行了无限多次CS。

互斥性很容易满足：一个什么都不干的死循环就符合条件。上述3个算法均满足互斥 性，但前两个算法不满足“无死锁”，而第3个算法(由Gary    Peterson发明)满足所有3个条

件。

输入包含多组数据。每组数据第一行为两个整数叫，rn2 ( 2<m<9)，即线程1和线程2的

代码行数。接下来的m1行是线程1的代码，再接下来的m2行是线程2的代码。每个线程的代 码都是一条指令占一行。每条指令的格式如下：首先是指令编号(顺序编号为1 -mz.，仅是 为了可读性才放在输入中)，然后是指令助记符，后面跟着若干个参数。有一种特殊的参数

称为NIP ,即下一条指令的编号（保证为1之间的整数）。一共有3个单比特共享变量： A , B , C。指令助记符有以下4种。

□    NCS :非临界区代码。唯一的参数是NIP。

□    CS :临界区代码。唯一的参数是NIP。

□    SET :写入共享变量。包含3个参数v , x , g。v是写入的变量（A , B或C ）, x是写入的 值（0或1 ）, g是NIP。

□    TEST :读取共享变量并判断它的值。包含3个参数v , g0 , g1 ,其中v是读取的变量 （人，丑或匸）,g0是v = 0时的NIP , g1是v= 1时的NIP。

在每个线程的代码中，NCS和CS恰好各出现一次。代码不一定是一个典型的无限循环， 但保证交替执行CS和NCS。输入结束标志为文件结束符（EOF ）。

对于每组数据，输出3个字母Y或者N ,分别表示是否满足互斥性、无死锁和无饥饿条 件。

【分析】

这是一道难题，即使在NEERC这样高水平的区域赛中，也只有一支队伍在比赛时通过 此题。在考虑核心算法之前，要先把程序存起来（假设程序编号为0和1）。一个合理的数据 结构是保存每条指令的字母c , var , op1 , op2和nip ,然后定义本题的“状态”为三元组 （ip0 , ip1 , vars ）,即两个程序的“当前指令编号”以及3个变量的值（最多只有23 = 8种取 值）。

接下来可以写一个Next （ state , p ）函数，即从状态state开始让程序p执行一条指令以后 达到的新状态，然后从初始状态开始BFS/DFS ,得到所有可能达到的状态，设为states数组。 接下来的所有讨论都针对这个状态集。为了方便分析时间复杂度，设一共有n个可达状态。 根据上面的讨论，n<9*9*8 = 648。

本题的3个定义各不相同，下面分别验证。首先推敲一下“合法执行过程”的定义： “两个 线程都执行了无限多条指令，或者其中一个线程执行了无限多指令，另一个线程执行了有限 多条指令以后终止，且IP在NCS中”。也就是说，至少有一个线程会无限循环下去。对应到 此处“状态”中，这表明状态会无限转移下去。但是在无限循环过程中如果有一个程序的IP始 终没有变化，这个IP必须在NCS中。

exclusion的判定。这个相对比较容易，在计算可达状态集的同时顺便判断即可。

deadlock的判定。回忆“无死锁”的定义：在任意合法执行过程中，CS都执行了无限多 次。从反面看，试着找一个执行方式，使得从某个时刻开始CS再也不执行了，这就表明出 现了死锁。也就是说，存在一个满足以下3个条件之一的环。

条件1 :进入环之后，程序0执行过，但从没有到达过CS ,而程序1始终停止在NCS。

条件2 :进入环之后，程序1执行过，但从没有到达过CS ,而程序0始终停止在NCS。

条件3 :进入环之后，程序0和程序1都不断执行，且都没有到达过CS。

starvation的判定。和死锁类似，饥饿的出现意味着某程序执行了无数条语句，但只有 有限多次CS。也就是说，存在一个环，使得在该环中某程序曾经执行过，但没到达过CS。

主算法。既然死锁和饥饿都可以归结为找一个满足特定条件的环，可以枚举环的起点 s0 ,然后用DFS找环。由于判定条件比较复杂，需要在DFS过程中加几个参数，用来记录各 个条件是否满足。具体来说，可以编写递归过程dfs ( s , mo ,    , c0 , ci ),表示当前状态

为s , mi表示程序i有没有被执行过，&表示程序i是否执行过CS。当8 = 8。且呀)和爪1至少有一个 为true (说明找到圈)时判断。

情况一：两个程序都执行过(mo =    = true )。如果两个程序中至少一个没进过

CS (即!cjq ),说明发生饥饿；如果两个程序都没进过CS (即!。0&&一)，说明发生死 锁。

情况二：存在0耷夕使得程序p始终在NCS(即mp = false且s状态中程序p在NCS)且程序1-p 没进过CS(c1-p = false),则同时发生死锁和饥饿。

对于每个确定的起始状态s0 , dfs需要0⑻时间，因此总时间复杂度为0(«2)。

例题 12-34 压缩(Compressor, UVa11521)

你的任务是压缩一个字符串。在压缩串中，［S］k表示S重复&次，［S^SJtJSJV. {Sr}tr(1<Z/<^, Zz<Z/+1)表示S重复女次，然后在其中第Z^S后面插入Si。这里的S称为压缩单元。

压缩是递归进行的，因此上面的S, Si，S2，…也可以是压缩串。你的任务是使得压缩串的长度 最小。

例如，I_am_WhatWhat_is_WhatWhat的最优压缩结果是I_am_[What]4{_is_}2。注意，上 述k，t1, t2,……的长度均算作1 ,即使它们的十进制表示中包含超过1个数字。一个递归压缩 的例子是aaaabaaaaaaaabaaaaaaaabaaaa ,最优结果是[[a]8{b}4]3 ,长度为 11。

输入包含不超过20组数据。每组数据包含不超过200个可打印字符，但不含空白字符、

括号(小括号()、方括号[]或者花括号{}都算括号)或者数字。字母是大小写敏感的。

对于每组数据，输出长度和压缩串。如果有多解，任意输出一个压缩串即可。

【分析】

这是一道很难的动态规划题目，思路不难想到，但是细节处很容易想复杂或者写错。建

议读者先自行思考一下，写一个程序试试，然后再阅读下面的题解。

设输入串为A。令f(x，y)表示字符串人^…^[^](#bookmark8)的最短压缩长度，则有两种状态转移方 式：一是连接，只需枚举划分点m ,转化为取m)+/(rn+1，yX如图12-64所示)；二是压缩，需要 枚举压缩单元的长度£ ,转移到/(v+£-1)+3+g(W£),这里的“+3”是方括号和数字^ , g(x,y,L) 是指：用d[x...x+L-1]作为单元来压缩d[x...y]时，后面的{SJ/p..{5^/部分的最短长度。

图 12-64 连接

注意，这个L必须满足4[x...y]的前L个字符等于后L个字符，因为即不允许在最后 面添加字符串。用0(n2)时间预处理出任意两个位置/和/开始的LCP(最长公共前缀)长度lcp[/]

［/•］之后，则Z满足条件，当且仅当lcpM［y-Z+1］〉= Z。 如何求解g（W，£）?同样需要进行动态规划。

首先枚举压缩单元下一次出现的位置/（需要满足lcpM［/］4），如果中间有缝隙（i〉c+Z）， 则说明有插入串［^+厶/-1］（如图12-65所示），需要递归压缩插入串（长度为3+/（^+厶/-1））。然后 问题转化为了g（/，y，Z），即压缩［/，y］，压缩单元为S［/.../+r-1］。

图12-65 有插入串

这样，综合f和g的状态转移方程，就可以求出最优解的长度了。如何输出方案？用递归 比较方便，写起来和动态规划部分类似，只是当发现当前解和最优解一样时立即递归打印。 需要注意的是，在输出f的方案时，要先得到g部分的方案，同时统计单位串的重复次数，然 后再输出。

算法的理论时间复杂度为0（n4），但因为L的选取有限制，实际上效率很高。

例题 12-35 公式编辑器(Formula Editor, UVa12417)

你的任务是编写一个类似于MathType的公式编辑器。从技术上讲，公式就是一个表达 式，它是由元素组成的序列。有3种元素：基本元素（算术运算符、括号、数字和字母）、矩 阵和分式。

公式编辑器为每个表达式创建了一个看不见的编辑框。由于矩阵中的每个单元格都是表

达式，所以每个单元格也都有一个编辑框。类似地，每个分式的分子和分母分别有一个编辑

框。

在如图12-66所示的表达式中，有5个编辑框。F1包围了整个表达式，F2和F3各包围一个 矩阵单元格，F4包围了分子，而F5包围了分母。

图12-66表达式中的编辑框

不难发现，编辑框相互嵌套。如果编辑框A直接包含编辑框B ,则称A是B的父编辑框（例 如，在图12-66中，F1是F2和F3的父编辑框，F3是F4和F5的父编辑框）。如果A和B拥有相同 的父编辑框，则称A和B是兄弟（例如，在图12-66中F4和F5是兄弟，F2和F3也是兄弟）。

下面介绍光标移动的实现。在任意时刻，光标总是直接包含在某个编辑框中。它可能位 于该编辑框中所有元素的左边（即“框首”），也可能位于所有元素的右边（即“框尾”），还可能 位于某两个相邻元素之间。如果光标在元素X和元素Y之间，并且X在Y的左边，则称光标的 左相邻元素为X ,右相邻元素为Y。

光标支持6种移动方式：Up、Down、Left、Right、Home和End。假定直接包含光标的编 辑框为A ,则各种移动方式的细节如下。

Home（End）:把光标移到A的框首（框尾）。注意，光标仍然被A所直接包含。

Up（Down）:如果A的上（下）方有一个兄弟B ,则把光标移动到B的框首，否则检查A的父

编辑框。如果A的父编辑框有这样一个兄弟，则继续移动光标会移到该兄弟编缉框上。如果 A的所有袓先编辑框均不含这样的兄弟，则忽略此命令。

Left（Right）:有以下4种情况。

□如果光标在A的框首（框尾），则把它放到A的左（右）兄弟B的框尾（框首）。如果没有这样的

B ,把光标放到A的父编辑框C中（如果存在），紧挨着A的左边（右边）。

□如果光标的左（右）相邻元素是一个分式，把它放到分子的框尾（框首）。

□如果光标的左（右）相邻元素是一个n行m列的矩阵，把它放到第［n/2］行第1列（第m列）的编

辑框的框尾（框首）。

□如果光标的左（右）相邻元素是一个基本元素，把它放到该元素的左（右）相邻位置。

输出格式化。本题的输出为ASCII格式，因此需要把每个编辑框格式化成一个ASCII字 符矩形（尽管多数字符都是空格）。表达式的字符矩形由组成它的各个元素的字符矩形（称为内 矩形）经过水平拼接而成。各个内矩形根据基线进行对齐，相邻两个矩形之间没有空白，而 内矩形和整个矩形的边界之间也没有空白。

每个元素都可以格式化为一个字符矩形，规则如下：

□基本元素恰好占一行，该行也是它的基线。用“-”（注意前后各有一个空格）来表示减号， 而其他基本元素都格式化为单个字符。

□矩阵元素的格式化步骤为：首先，格式化所有单元格，然后排成一个矩阵，同一行的各 个ASCII矩形按它们的基线对齐，同一列的ASCII矩形水平对齐，相邻两行之间有一个空 行，而相邻两列之间有一个空列；最后，在每行的前后分别加一个方括号。当行数为奇 数时，整个矩阵的基线为中间那一行的基线；当行数为偶数时，整个矩阵的基线为中间 那个空行。

□分式元素的格式化步骤为：首先格式化分子和分母，然后在中间画一条水平线（由一些 连续的“-”字符组成）。这也是整个分式的基线，这一行的宽度等于分子分母的较大宽度 加2（即前后各加一个字符）。分子和分母水平对齐。

前面提到的“水平对齐”是这样的：首先把水平宽度最大的矩形固定下来，然后水平移动

其他矩形，使得它们的水平中心线尽量整齐。如果对不齐（即该矩形的宽度和最大宽度的奇

偶性不同），可以往左移动0.5个单位的宽度，如图12-67所示。

# ssxx

## XXX

图12-67向左移动0.5个单位宽度

注意有一个特例：当整个表达式为空时，ASCII矩形是一个空行——它的宽度为0，但高 度为1。这一点在拼接和对齐时尤为重要。

输入处理。输入已转化为了一个命令字符串序列。对于每个字符串：

□如果它是单个字符，说明它是一个基本元素。在光标处插入此元素，然后把光标移动到 它的右相邻位置。

□如果是字符串Matrix（Fraction），在光标处插入一个1行1列矩阵（空分式），然后将光标右 移一次。注意，光标右移之前，新的矩阵（分式）在光标的右相邻位置。

□如果是字符串AddRow（AddCol），首先找到直接包含光标的矩阵，然后在最上方（最左方） 添加一行（一列） ，并把光标移动到此行（列）中，保持列（行）不变。如果直接包含光标的编 辑框A并不是矩阵的单元格，需要检查A的父编辑框，直到找到一个矩阵。如果找不 到，忽略此命令。

□如果是字符串Home、End、Left、Right、Up、Down之一，按前述规则移动光标。

输入包含多组数据，每组数据以命令Done结束。单个数据包含不超过1000条命令，输入 总大小不超过200KB。

分析】

这道题目的主要难点是理清思路，建立合理的数据结构，使得编程难度、调试难度都达

到一个不错的平衡点。

相关概念。题目中定义的主要概念有两个：元素和编辑框（即表达式），其中元素有3 种：基本元素（单个字符）、分式和矩阵。这两个概念是交织在一起的，因为每个元素都有一 个或多个编辑框，而编辑框就是一个或多个元素的有序序列。这里有个特别容易搞错的地 方：元素的外面是没有编辑框的。例如，题目中的例子，4、 “+”和矩阵外面都没有编辑框。 6/7的外面有编辑框F3 ,但那是因为矩阵的每个单元格自带一个编辑框，如图12-68所示。

每个编辑框有一个“父元素”，而每个元素都有一个“父编辑框”，整个结构是一棵有两种

结点的树。题目中的例子对应如图12-69所示。

图12-68元素外无编辑框



F1

6/7]

[5

F2

F3

6/7

F5

6

7

图12-69 父元素与父编辑框



因为很多操作涉及在编辑框中寻找“上一个元素”、 “下一个元素”和“首尾元素”的操作， 而且还有插入元素的操作，所以编辑框可以用链表来实现。光标要么位于编辑框的尾部，要 么位于某个元素e的前面，则光标位置实际上可以表示为e的指针[^](#bookmark13)。

另外，父元素相同的编辑框可以组织成十字链表（即有上下左右4个指针），从而支持快

速的光标移动。当然，也可以写4个函数，动态计算每个编辑框上下左右的编辑框。这样，

可得到如下的数据结构：

□元素和编辑框都有一个父亲指针，其中元素的父亲是编辑框，编辑框的父亲是元素。

□每个编辑框中保存“第一个子元素”和“最后一个子元素”，而每个元素中保存“下一个元

素”和“上一个子元素”。

□每个元素保存一些子编辑框，每个编辑框保存上下左右4个“兄弟”编辑框。这里的“一 些”需要注意。基本元素只有一个框，分式也只有两个框，但是矩阵元素不仅会有多个 子编辑框，而且个数还会动态改变。最容易想到的方法是直接定义一个编辑框的二维数 组，但是占用空间较大。推荐的方法是只保存每行每列的首尾元素，通过十字链表访问 其他元素。

格式化输出。编辑框和元素都可以进行格式化输出，也有两种常见的思路。一是递归 计算出所有子结点的格式化结果，得到二维字符矩阵，然后把这些字符矩阵拼起来。这样做 的好处是直观，坏处是需要大量的字符复制。第二种方式是提供两个函数，一是计算尺寸， 二是以某个点为左上角把字符矩阵“画”到一个固定的字符矩阵中。这样，格式化某个结点 时，先计算所有子结点的尺寸，进行排版，得到每个子结点左上角的坐标，然后让每个子结 点“绘制”自己(即写到一个叫output的全局二维数组中)。这种方法最大的好处是避免了大量的 字符复制，也是常见GUI软件实现布局的方法。

落实到程序上，最传统的方法是使用面向对象程序设计方法(OOP)，设计两个类Element 和EditBox，以及Element的3个子类：Character、Fraction和Matrix。还有一种不很“优美”但很 实用的方法：把所有类合在一起为Object，通过一个名为type的字段加以区别。例如，type = 0表示编辑框，type = 1、2、3分别表示基本元素、分式和矩阵。这样做的好处是代码紧凑(一 些重复代码可以写在一起)[(19)](#bookmark16)，坏处是代码看上去没那么好维护，而且还会遭到软件工程师 们的批评[(20)](#bookmark18)。本书是算法书籍，无意讨论这些工程性问题，但有一点是肯定的：要具体问 题具体分析，不存在适用于所有场合的“银弹”[(21)](#bookmark19)。

例题 12-36 疯狂的谜题(Killer Puzzle, UVa12666) 你有没有做过下面这个疯狂的谜题[(22)](#bookmark21)？ 请回答下面10个问题，各题都恰有一个答案是正确的 (1 )第一个答案是B的问题是哪一个？

A．2

B．3

C．4

D．5

E．6

（2）    恰好有两个连续问题的答案是一样的，它们是：

A．2，3

B．3，4

C．4，5

D．5，6

E．6，7

（3）    本问题答案和哪一个问题的答案相同？

A．1

B．2

C．4

D．7

E．6

（4）答案是A的问题的个数是：

A．0

B．1

C．2

D．3

E．4

( 5)本问题答案和哪一个问题的答案相同？

A．10

B．9

C．8

D．7

E．6

(6)答案是A的问题的个数和答案是什么的问题的个数相同？

A．B

B．C

C．D

D．E

E .以上都不是

( 7)按照字母顺序，本问题的答案和下一个问题的答案相差几个字母？

A.    4

B.    3

C. 2

D. 1

E . 0 （注：A和B相差一个字母）

（ 8）答案是元音字母的问题的个数是：

A．2

B．3

C．4

D．5

E ■ 6 （注：A和E是元音字母）

（ 9）答案是辅音字母的问题的个数是： A . —个质数

B.    —个阶乘数

C.    一个平方数

D.    —个立方数

E.    5的倍数

（ 10）本问题的答案是：

注意：

(1)    你的答案不能自相矛盾。例如，第一题的答案不能是B。

(2)    你需要确保每道题的选项中只有你的答案是正确的，其他都是错误的。例如，若问 题(5)的答案是A ,那么问题(6)、(7)、(8)、(9)的答案都不能是A。

(3)    你需要确保每道题目都是有效的。例如，若问题(2)和问题(3)的答案相同，且问题(8) 和问题(9)的答案也相同，则问题(2)是非法的，因为并不是恰好有两个连续问题的答案一 样。

这道题目当然可以手算，但是作为程序员，编程求解会更有意思。

编程求解。最容易想到的方法就是穷举法，即考虑所有510 = 9765625种可能，依此检查 答案是否合法(即每道题有且只有你的答案是正确的)。伪代码如下：

forall(answer_list):

bad = False

for testing_question in [1,2,3,4,5,6,7,8,9,10]: for testing_option in ["a","b","c","d","e"]:

\# your answer should be correct

if testing_option == answer_list[testing_question] and

check(testing_question, testing_option) == False: bad = True

\# other options must be incorrect

if testing_option != answer_list[testing_question] and

check(testing_question, testing_option) == True: bad = True

if not bad: print answer_list

在上述伪代码中，answer_list是一个字母列表(下标从1开始)，其中第/个字母表示第/个 问题的答案。本题的唯一解是cdebeedcba(如果每道题目的答案前加上题目编号，它是 1c2d3e4b5e6e7d8c9b10a)。

是不是很神奇？还有更神奇的。你可以写一个更加通用一些的程序，以求解其他类似的

谜题，而不仅仅是解上面这一个谜题。不过在此之前，需要把问题描述加以形式化。

问题的形式化描述。本题采用一种LISP方言来描述谜题。LISP的语法很简单。(fa b)表 示用参数a和b调用函数f ,相当于C/C++/Java的f(a，b)。类似地，(f a (g b c) d)相当于 C/C++/Java中的f(a, g(b, c), d)。下面是一道问题的例子：

\3. (equal (answer 3) (answer (option-value)))

a. 1

上面的问题涉及两个重要的内置函数，如表12-5所示

表12-5 两个重要的内置函数

| 函数           | 说明                                                       |
| -------------- | ---------------------------------------------------------- |
| (answer idx)   | 返回伪代码中的 answer_list[idx]                            |
| (option-value) | 返回伪代码中testing_option的计算结果(即把它看作一个表达式) |

在上面的例子中，如果testing_option的计算结果是c ,则(option-value)返回4(整型)，因为 4是选项c所对应的计算结果。注意，testing_option的文本可以是一个复杂的表达式，参见样 例输入。

上面用到的函数check(testing_question，testing_option)可以这样实现： check(testing_question, testing_option):

\1. set-up the function (option-value) so that it returns the evaluation result of testing_option of testing_question

\2. evaluate the lisp expression of testing_question (e.g. the expression (equal (answer 3)

(answer (option-value))) in the example above)

\3. if an unhandled exception is raised during the evaluation, returns False

\4. if the result of step 2 is boolean, return it; otherwise return False

有一个特殊的表达式叫做none-of-above，其计算结果取决于其他选项的计算结果。每个 问题最多只有一^个none-of-above的选项，并且一定是最后一^个选项。

下面是本题所用LISP方言的一些细节。

□ 一共有4种数据类型：整型、字符串、布尔型和函数。

□布尔型只有两个值：true和false。注意，布尔值没有常量表示方法，所以无须考虑是用

Scheme里的#^#f还是Common Lisp里的t和nil来表示布尔常量。

□整型都是非负整数。

□字符串都用双引号包围，例如“a string”。

□所有由字母和横线组成的字符序列都是预定义函数。没有变量。

下面是预定义函数列表。所有以“！”开头的函数有可能抛出异常，而以“@”开头的函数 会处理异常。和C++/Java/Python—样，当异常从一个函数抛出后，表达式计算的过程将会终 止，除非有该函数的调用者处理异常。

基本函数如表12-6所示。

表12-6 基本函数

| 函数               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| (equal a b)        | 返回伪代码中的answer_list[idx]                               |
| (option-value)     | 上面已经讨论过                                               |
| !(answer idx)      | 上面已经讨论过。如果idx不是整数或不在范围1 ~«内（其中《是问题总 数），则抛出异常 |
| !(answer-valueidx) | 返回answer_list[idx]对应的表达式的值。Idx耳又值非法时会抛出异常 |

谓词是一类特殊的函数，唯一参数是个任意类型的值，返回一个布尔值，不会抛出异

常，如表12-7所示。

表12-7 谓词

| 函数        | 说明                                             |
| ----------- | ------------------------------------------------ |
| primp-p     | 当且仅当参数是一个正素数时返回true               |
| factorial-p | 当且仅当参数是一个阶乘数时返回true               |
| square-p    | 当且仅当参数是一个平方数时返回true               |
| cubic-p     | 当且仅当参数是一个立方数时返回true               |
| vowel-p     | 当且仅当参数是单个字符的串，并且是元音时返回true |
| consonant-p | 当且仅当参数是单个字符的串，并且是辅音时返回true |

查询和统计函数如表12-8所示。

表12-8 查询和统计函数

| 函数                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| !@(first-question pred)  | 返回满足谓词pred的第一个问题编号1〜心如果不存 在，则抛出异常 |
| !@(last-question pred)   | 返回满足谓词pred的最后一个问题编号1〜《。如果不 存在，则抛出异常 |
| !@(only-question pred)   | 返回满足谓词pred的唯一问题编号1〜《。如果不存在 或者不唯一，则抛出异常 |
| @(count-question pred)   | 返回满足谓词pred的问题个数                                   |
| !(diff-answer idx1 idx2) | 返回问题ldx1和ldx2的答案之差（例如，a和b相差1）。 返回值总是0~讲的整数。如果ldx1或ldx2非法，则抛 出异常 |

注意：表12-8中的前4个函数（即有“@”标记的函数）可以处理异常，即如果在计算pred

的过程中抛出了异常，这4个函数不会把异常传递给它的调用者，而是当作pred返回了 false。例如，如果answerjist是abc ,则表达式(count-question    (make-answer-diff-next-

equal 0))返回0 ,而不会抛出异常，尽管计算((make-answer-diff-next-equal 0)3)时会抛出 异常。注意，所有其他函数都不会处理异常，例如，若一共只有3个问题，则(factorial-p (answer-value 5))会抛出异常，而不是返回false。

谓词生成器如表12-9所示。

表12-9 谓词生成器

| 函数                               | 说明                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| !(make-answer-diff-next-equal num) | 返回一^个谓词(p idx)。该谓词先计算(diff-answer idx idx+1),当计算结果等于num时返回true。当num不是 整数时抛出异常 |
| (make-answer-equal a)              | 返回一个谓词(p idx)。该谓词先计算(answer idx)。当 计算结果等于a时返回true |
| (make-answer-is pred)              | 返回一个谓词(p idx)。该谓词先计算(answer idx)。当 计算结果满足谓词pred时返回true |
| (make-answer-value-equal a)        | 和上面类似。计算的是(answer-value idx)                       |
| (make-answer-value-is pred)        | 和上面类似。计算的是(answer-value idx)                       |
| !(make-is-multiple num)            | 返回谓词(p i)。该谓词返回true当且仅当i是整数且是 num的倍数。当num不是整数时抛出异常 |
| !(make-equal val)                  | 返回谓词(p v)。该谓词返回true当且仅当(equal v val) 为真。当val既不是整数也不是字符串时抛出异常 |
| (make-not pred)                    | 返回谓词(p v)。当且仅当(pred v)为false时该谓词返 回 true     |
| (make-and pred1 pred2)             | 返回谓词(p v)。当且仅当(predl v)和(pred2v)均为true 时返回true。注意，predl和pred2都要测试，不能进行短路操作 |
| (make-or pred1 pred2)              | 返回谓词(p v)。当且仅当(predl v)和(pred2v)至少有 一个为true时返回true。注意，predl和pred2都要测 试，不能进行短路操作 |

例如，(make-is-multiple 3)返回谓词“是3的倍数”，因此((make-is-multiple 3)6)返回true， 而((make-is-multiple 3)10)返回false。类似地，(make-not (make-or square-p prime-p))返回谓 词“既不是平方数也不是素数”。

输入包含不超过50组数据。每组数据的第一行是问题的个数《和选项的个 数m(2^«^10，2<m<5)，每个问题用m+1行表示，即问题的表达式和各个选项的表达式。问题 按输入顺序编号为1~«，选项编号为〜e。选项保证是合法的表达式，并且不会调用(option-value)(否则会引起无限递归！)。每个问题后有一个空行。输入的大部分数据都是简单的。

对于每组数据，输出数据编号和所有答案，按照字典序从小到大排列，各占一行。

样例输入(节选)：

3 3

(equal (option-value) (count-question (make-answer-equal "a")))

3

0

1

(equal (option-value) "a")

"c"

"b"

"a"

((option-value) (count-question (make-answer-equal "c")))

(make-and (make-is-multiple 2) (make-or factorial-p prime-p))

(make-not prime-p)

样例输出（节选）：

Case 1:

bcb

【分析】

这是笔者为第9届湖南省大学生程序设计竞赛所命的一道压轴题目。本题的背景与Lisp 相关，但为了题目的清晰简洁以及“公平”起见，有些细节与Scheme和Common Lisp不同。实 际上，Common    Lisp是笔者最喜欢的语言之一[^](#bookmark23) ,所以“让更多参加算法竞赛的人知道

Lisp”成为了本题的另一个目标。

本题的题干很长，不过核心内容并不多，主要是预定义函数太多。其实整个题目的意思 很简单，就是用穷举法求解一个复杂的逻辑谜题。因为这个谜题的题干和选项都采用LISP方 言来描述，而且这个方言（即预定义函数）还要足够强大到可以描述题目最初提到的那个经典 谜题，所以题目的复杂程度可想而知。

主算法就是穷举所有可能的answer_list ,依次判断是否正确；判断answer_list是否正确 的方法就是依次判断每个问题的每个选项是否满足条件——answer_list中选中的选项必须正 确，其他选项必须错误（还要加上对none-of-above的特判）。所以其实问题的核心在于：给定 answer_list， 计算一个表达式。

表达式是按照字符串的格式输入的，但是为了效率，应当事先把它解析并保存在合理的

数据结构中，这样才能快速求值。这个过程相当于程序设计语言的“编译”。不过这个编译的 结果并不是机器指令，而是我们自己设计的内部格式，例如，一个称为Expression的类。具 体来说，它有两种情况，一是常数（例如字符串、布尔值），另一个是函数调用。

每个Expression都可以计算，得到一^个计算结果，因此Expression应该有一^个eval（context） 函数，返回一个Value类型的变量，这里的context是指“上下文”，即所有的question表达 式，option表达式，还有answer_list等。计算表达式所需要的所有内容都在context里。

根据题意，Value类型除了C++中的int、bool或者字符串char*之外[^](#bookmark25)，还可以是函数(实 际上用于“闭包”，后面还会讨论)，因此需要自定义一个Function类。由于Value类主要用于承 载数据，此处不再用继承的方式编写int、bool等子类，而是用不同的TYPE加以区分。例

如[(25)](#bookmark27)：

struct Value {

ValueType type; //值的类型，有 INTEGER、 BOOLEAN等

bool boolVal;

int intVal;

const char * strVal;

Function * funVal; // 自定义的Function类

//还有一些GetBoolean()、GetFunction ()以及MakeBoolean ()、MakeFunction ()等函

数，其作用望文知义，具体实现略

}

class Function { public:

virtual ~Function() {}

virtual Value Call(const Context & c, const Value* params, int paramsCou

};

对于上述代码中的技巧，特别是纯虚函数，请读者自行阅读相关资料。有了这些，就可 以定义Expression类了。

class Expression {

public:

virtual ~Expression() {}

virtual Value Evaluate(const Context & context) = 0;

};

class LiteralExpression : public Expression { Value _arg;

public: //构造函数略

virtual Value Evaluate(const Context &) { return _arg; }

};

class CallExpression : public Expression {

Expression * _functionExpression;

Expression ** _params; //也可以用vector ,但速度稍慢，因为最多只有两个params int _paramsCount;

public:

// 构造 / 析构函数略

virtual Value Evaluate(const Context & context) {

Value fn = _functionExpression->Evaluate(context); if (fn.GetType() == ERROR) return Value::MakeError(); // 抛出异常 assert(fn.GetType() == FUNCTION); //必须是函数

Value evaluatedParams[2]; // 最多是二元函数

for (int i = 0; i < _paramsCount; ++i)

evaluatedParams[i] = _params[i]->Evaluate(context); return fn.GetFunction()->Call(context, evaluatedParams, _paramsCount);

}

};

这里有一^个地方需要特别注意：CallExpression里的_finctionExpression的类型是 Expression，因此它既有可能是LiteralExpression又有可能是CallExpression。例如(equal 1 1)， 这里的_functionalExpression就是LiteralExpression，即equal ;但是对于((make-equal    1)

1)，_fmctionExpression就是(make-equal 1)，是一^个CallExpression。

另外，上面的代码包含了异常处理。在Value中增加了一种类型：ERROR。如果在计算 fn时抛出了异常，则整个表达式都应抛出异常。

接下来有3个任务：写Parser、编写预定义函数和编写主程序。主程序在题目中已经给 出，这里不再赘述。Parser不难编写，但是在处理常量表达式时要注意。根据题目，一共只 有3种常量表达式：遇到数字串，得到的Value是整型，例如10 ;遇到带引号的字符序列，得 到的Value是字符串，例如“none-of-above” ；遇到不带引号的字符序列，得到的Value是函 数，例如equal。换句话说，所有预定义函数都必须是Function类或者它的子类，否则无法保

存到Value中。

因此接下来的工作重点是编写预定义函数。这个工作理论上并不困难，但代码量大（占

到总程序的一半以上），并且容易出错。所以在编码之前，有必要把一些细节想清楚。

之前说过，所有预定义函数应当是Function类或者它的子类，但具体来说还是有两种不 同的写法。一种是写一^个巨大的PredefinedFunction类，保存一^个functionName ,然后在Call函 数中根据functionName判断。还有一种写法是每个函数写一个单独的子类。两种写法各有利 弊，读者可以根据需要进行选用。

不管使用哪种方法，都面临一个问题：如何保存动态生成的函数（即闭包）。其实动态生 成的函数并不是任意生成的。例如，所有由make-equal生成的函数都较相似，只是有一个参 数a不一样。所以可以把所有“由make-equal生成的函数”统一处理。

如果采用方法一（即一^个巨大的PredefinedFunction类），可以用functionName = “generated-by-make-equal”来表示由make- equal生成的函数，另外在类中增加成员变量a和functionName , 一同代表（make-equal a）的返回值。

如果采用方法二(每个函数是一个类)，推荐把由make-equal生成的类写成MakeEqual函数 的内部类，因为其他类都不会用到这个类。这样一来，甚至没必要给它命名。例如：

class MakeEqual : public Function1 { class _F : public Function1 { //内部类

Value _val; public:

inline _F(const Value & val) : _val(val) {} virtual Value Call(const Context & context, const Value & a) {

return Equal().Call(context, a, _val);

}

};

public:

virtual Value Call(const Context &, const Value & val) { return Value::MakeFunction(new _F(val));

};

上面的代码还展示了方法二的一个重要技巧：由于最多是二元函数，可以编写Function 的3个子类：Function0、Function1、Function2（即有0个、1个、2个参数的类），然后让具体的 函数继承这3个类[（26）](#bookmark29)。这样做可以把一些与具体函数无关的操作（例如，检查参数个数，以及 是否有参数是ERROR类型）移到这3个类中，还可以加一些方便调试的语句，让具体函数的实 现更简洁。由于本题的特殊性，还可以编写IntegerPredicate和StringPredicate两个子类，进一 步地避免重复代码（主要是参数类型检查）。

至此，整个题目就分析完毕了。按照上述方法编写的代码效率很高，可以在很短的时间

内通过测试数据。但优化是无止境的。如果把本题的主算法改成回溯（而非完全枚举），可以

实现一个杀手级的剪枝，程序运行效率可以提高几十倍甚至上百倍。剪枝的思路如下：在

answer_list没有枚举完时，虽然有些表达式无法算出结果，但有些表达式仍是能算出结果的 （例如，前两题的答案确定后，（diff-answer 1 2）就能算出来了）。不确定的结果可以在Value类 中新增一个NA类型，然后在函数求值时判断：当函数本身和所有参数都不是NA类型时，答 案也是确定性的。这个剪枝思路很直观，不过需要注意细节，有兴趣的读者可以自行尝试。

例题 12-37 太空站之谜(Mysterious Space Station, Rujia Liu's Present 7[(27)](#bookmark2), UVa12731)

3000年的一天，人们在茫茫的宇宙中发现了一些奇怪的太空站。科学家们用高科技探测

出了它们的精确位置，并绘制了地图，准备派一批机器人到那里进行深入的研究。

地图是一个的矩形网格，如图12-70所示每个格子要么是可以穿梭自如的真空（用白 色表示），要么是无法逾越的未知物质（用阴影表示）。机器人每次可以沿着东（E）、南（S）、西 （W）、北（N）中的一个方向前进到相邻格子）如果那里没有未知物质阻挡）。由于太空站内没有 任何光线和其他可被机器人感知的物质，机器人只有在尝试往某一个方向行进并失败以后才 能知道该方向的相邻格子无法到达，而不能事先知道某一方向上是否有障碍。

有趣的是，太空站里所有未知物质连成一片（沿东、南、西、北4个方向连通），把所有 真空格围在中间，形成一个真空大厅，机器人从任何一个真空格出发都可以走到其他所有真 空格中。另外，太空站内没有“狭窄的通道”，即对于每个真空格子来说，它的南北方向至少 有一个相邻格子是真空，东西方向也至少有一个相邻格子是真空。为了方便，把所有的真空 格按照从北到南，从西到东标号为1,2,3……。如图12-71所示就是其中一个叫FT的太空站的 地图标记。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-346.jpg)



图12-71 FT太空站的地图标记



图12-70 地图



真空格 来知物质 传迭门

机器人一号被运送到了FT的12号真空格（由于技术限制，机器人们只能被运送到某个和

未知物质有公共边的格子）后开始工作。机器人从起始位置出发往东走一格，再往北走一

格，以为到达了8号格。但当它试着往北移动时，发现竟然没有被阻挡，而是成功地走到8号

格上方那个地图上标记为未知物质的格子。这一重大发现很快传遍了所有在太空站内工作的

机器人。它们一致认为地图有误，因而用集体罢工的方式向人类提出抗议。

针对这一情况，科学家们解释说：地图并没有绘制错，该现象的发生是因为太空站中存

在着某种神秘的传送装置——虽然机器人一号在行走中已经被瞬间转移到其他格子中去了，

但他自己却一点也感觉不到。

科学家们指出，太空站中有尺个传送装置，每一个装置逻辑上连接着两个不同的真空格 子，称为传送门。每个传送门只能属于一个传送装置，并且任意传送门周围的8个格子中不 会有其他传送门或者未知物质。如果两个传送门属于同一个传送装置，那么当机器人沿某一 个方向进入其中一个传送门，它就会被瞬间转移到另一个传送门并沿该方向再前进一格。在 机器人看来，这一过程和普通的行走并没有区别，因此它们无法感知瞬间转移的进行。以FT 为例，由于有一个传送装置连接着10号格和13号格，机器人一号的实际路线是12->11->5-

\>1，根本没有到达格子8上面那个不能去的格子。

机器人明白了其中的奥秘以后，迫不及待地想要找出这些传送装置，但又担心自己在太

空站中的工作时间会过长。经过一番慎重的考虑，科学家们决定请你编写一个智能控制程

序，帮助机器人用不超过32767步数找到所有传送装置。

本题是一道交互式题目。对于每组数据，你的程序应当首先读入整数况    M

K(6<N , M<15 , H^5)的值，然后是一个N行M列的地图，其中“ ”表示真空，“*”表示未知 物质，“S”表示起点。起始位置保证与至少一个未知物质格有公共边，真空格保证不出现在 地图的边或角上。输入数据保证无错，行末无多余空格。

接下来，你的程序应当向标准输出打印一些移动机器人的指令，每个指令占一行，格式 为MoveRobot D ,其中D为4个字符N, E, S, W之一。然后你的程序可以从标准输入中读到指令 的执行结果， 0表示失败， 1表示成功。

算出结果之后，你的程序应当向标准输出打印恰好K条输出指令，每个指令占一行，格 式为Answer posl pos2 ,表示有一个传送装置连接真空格posl和pos2。每个传送装置应恰好 输出一次，顺序任意。当所有K条输出完毕之后，你的程序应准备求解下一组数据测试(即再 次读取N，M, K)。当N=M=K=0时输入结束。

注意，向标准输出打印每一行之后必须执行flush标准输出(例如，C/C++可以执行函 数 fflush(stdout))。

如图12-72所示是一个交互范例。

图12-72 交互范例

【分析】

本题是笔者第一次给正式比赛命的题目，参加现场比赛的20位IOI国家集训队员的最好 成绩是解决10个测试点中的2个。

在此之前，IOI99中出现过一道看上去类似的题目“地下城市”[■](#bookmark4):给定一张地图，但是 不知道你的当前位置。要求使用look和move指令来算出你的当前位置，其中look可以判断当 前位置的某个方向是空地O还是墙W , move则是往某个方向移动一格。目标是look的次数尽 量少。这道题目可以用筛法解决。初始时所有空地都有可能是“当前位置”，根据look指令的 返回值，可以排除一些可能性，当可能性只有一种时，它就是正确答案。当然，还有一些细 节问题要考虑（例如，需要计算一下到哪个位置去look比较容易排除更多的可能性），但算法 的主框架就是这样。因为最多只有100*100 = 10000个可能的位置，所以并不是很困难。

本题却是完全不同的。最多有112= 121个不与未知物质相邻的真空格，任选5对格子的

方法有很多种（有兴趣的读者可以自己算一下），而且很难简单地通过几条指令来排除一种方

案，看来需要放弃“筛法”。

怎么办呢？看来只好用逻辑思考的方法设计方案了。一开始机器人是知道自己位置的， 可是走了几次以后就不知道自己在哪里了。根据题目给出的信息，移动是可逆的，即如果成 功执行了移动序列EENWN，则执行序列SESWW的结果一定是每步都成功，并且回到了执行 EENWN之前的位置。有了这个结论，就不怕“走丢”了，大不了原路返回，继续下一次探 索。

尽管如此， “走丢”这件事情还是应该尽量避免，因为在不知道当前位置的情况下，能获 得的信息十分有限。所以机器人应当遵循以下基本原则：尽量在肯定没有传送门的格子中行 走。不过，未知格子总是避不开的，因为我们必须找到传送门。如图12-73所示，白色格子 是肯定没有传送门的，因为它们和未知物质相邻。但是灰色格子就不一定了：它们可能是传 送门，也可能不是。如何判断呢？

设需要判断A是不是传送门。首先走到B，然后执行移动序列SW，则当且仅当A不是传 送门时，移动序列SW可以成功，并且当前位置是C。是否可能执行S时从A传送到另外一 个位置D，然后执行W时再传送回C呢？不可能，因为一个传送门只能属于一个传送装置， 而从D往W走一步后不可能走到与A配对的传送门（从D往N走才能走到与A配对的传送门）。

这样一来，问题的关键就变成了判断当前位置是不是C。首先，如果当前格子不“靠 边”，说明它肯定不是C，直接排除；否则可以用“单手扶墙法”来“绕圈”[⑽](#bookmark6)。例如，从A开始 左手扶墙，可以得到这样一个移动序列：NESESWWN，然后回到A。如果从A上面的格子出 发，移动序列应当是ESESWWNN，如图12-74所示。不难发现，如果把移动序列看成一个环 状串，每个格子的移动序列对应的都是这个环状串的一种线性表示。换句话说，根据一 个“靠墙点”的“扶墙移动序列”，就能确定这个点的具体位置。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-350.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-351.jpg)



这样，用“假设-验证”的方法确定了A是不是传送门——先假设A不是传送门，然后执行 一些事先设计好的指令，看看结果是否和预想的一样。在上面的例子中，绕墙一周只需要十 几次MoveRobot指令(注意绕墙的过程中可能会“碰壁”，所以实际执行的指令往往比移动序列 长)，非常方便。

按照“从外向里”的顺序，可以 依次确定每个未知格是不是传送门。具体来说，对于每 一个待判断的格子，首先假设它不是传送门，然后进入格子，从另一个方向离开格子，走到 墙边，再用绕墙法判断假设是否正确。因为传送门互不相邻，所以第一步“进入格子”和第三 步“走到墙边”都可以完美地避开未知格子和传送门，只在肯定不是传送门的真空格中移动。 需要特别指出的是，如果假设不成立，说明该格子是传送门，这时必须原路返回，否则会继 续“走丢”。

现在只需确定2K个传送门之间的配对关系即可。不难发现，这一步也可以用“假设-验

证”法，细节留给读者思考。

需要说明的是，上述算法只是一个梗概，还有很多细节可以优化，例如， “绕墙”过程不 一定要执行完毕。一旦发现假设是错误的，可以原路返回，而不必求出完整的“扶墙移动序 列”。其他还有很多地方可以减少不必要的指令，实际效果也非常好[(30)](#bookmark8)，读者不妨一试。

###### 12.3 小结与习题

至此，本书内容已经全部讲完。仔细看完本章的读者想必已经掌握了《算法竞赛入门经

典》和《算法竞赛入门经典——训练指南》中最精髓的部分，在理论和实践上都相当有经验

了。按照惯例，下面是例题列表，如表12-10所示。

表12-10 例题列表

| 类别      | 题号     | 题目名称（英文）             | 备 注                                         |
| --------- | -------- | ---------------------------- | --------------------------------------------- |
| 例题12-1  | UVa1671  | History of Languages         | DFA                                           |
| 例题12-2  | UVa1672  | Disjoint Regular Expressions | 正规表达式；NFA                               |
| 例题12-3  | UVa1673  | str2int                      | DAWG（或后缀自动机）                          |
| 例题12-4  | UVa12161 | Ironman Race in Treeland     | 树的分治                                      |
| 例题12-5  | UVa11994 | Happy Painting               | Link-Cut树                                    |
| 例题12-6  | UVa1674  | Lightning Energy Report      | 树链剖分或LCA                                 |
| 例题12-7  | UVa12538 | Version Controlled IDE       | 可持久化treap                                 |
| 例题12-8  | UVa805   | Polygon Intersections        | 多边形交                                      |
| 例题12-9  | UVa1675  | Kingdom Reunion              | 扫描法； DSLG                                 |
| 例题12-10 | UVa12314 | The Cleaning Robot           | 多边形偏移                                    |
| 例题12-11 | UVa1520  | Flights                      | 嵌套线段树；扫描法                            |
| 例题12-12 | UVa1676  | GRE Words Revenge            | 数据结构的组合；分层 数据结构；DAWG的综合应用 |
| 例题12-13 | UVa11998 | Rujia Liu Loves Wario Land!  | 启发式合并；树链剖分的综合应用；块链表        |
| 例题12-14 | 1UVa1104 | Chips Challenge              | 网络流建模                                    |
| 例题12-15 | UVa12567 | Never7, Ever17 and           | 线性规划                                      |

|           |          | Wa[t]er                 |                                      |
| --------- | -------- | ----------------------- | ------------------------------------ |
| 例题12-16 | UVa12110 | Gargoyle                | 特殊费用流或线性规划                 |
| 例题12-17 | UVa12253 | Simple Encryption       | 数论；数学猜想                       |
| 例题12-18 | UVa12164 | The Great Game          | 马尔科夫过程；二分法（或不动点迭代） |
| 例题12-19 | UVa1677  | Cycling                 | 数形结合；对最优解性质的分析         |
| 例题12-20 | UVa1678  | Huzita Axiom 6          | 解析几何；三次方程                   |
| 例题12-21 | UVa1679  | Easy Geometry           | 凸函数                               |
| 例题12-22 | UVa12162 | Shooting the Monster    | 离散化                               |
| 例题12-23 | UVa1017  | Merrily, We Roll Along! | 模拟或离散化                         |
| 例题12-24 | UVa1286  | Room Services           | 几何猜想；动态规划                   |
| 例题12-25 | UVa1288  | Shortest Flight Path    | 球面几何；区间覆盖；简单图论         |
| 例题12-26 | UVa12565 | Lovely M[a]gical Curves | NURBS曲线；近似算法                  |
| 例题12-27 | UVa11188 | A Strange Opera House   | 几何计算；暴力法                     |
| 例题12-28 | UVa12308 | Smallest Enclosing Box  | 旋转卡壳；近似算法                   |
| 例题12-29 | UVa1680  | Journey                 | 递归；记忆化搜索；绝对值的处理       |
| 例题12-30 | UVa1097  | Rain                    | 最短路；图遍历                       |
| 例题12-31 | UVa1681  | Dictionary              | 字符串和图论综合题                   |
| 例题12-32 | UVa11199 | Equations in Disguise   | 搜索；优化                           |
| 例题12-33 | UVa1682  | Exclusive Access        | 互斥算法验证；找圈                   |
| 例题12-34 | UVa11521 | Compressor              | 复杂动态规划                         |
| 例题12-35 | UVa12417 | Formula Editor          | 复杂模拟题； OOP                     |

| 例题12-36 | UVa12666 | Killer Puzzle            | 复杂模拟题； Lisp      |
| --------- | -------- | ------------------------ | ---------------------- |
| 例题12-37 | UVa12720 | Mysterious Space Station | 算法综合题；交互式题目 |

由于篇幅限制，上述内容无法全部详细地介绍给读者。请读者以“可持久化数据结构”、

“后缀自动机”、“动态树”等关键字在网上搜索，能获得很多详细、实用的资料，包括讲解、

代码和更多精彩例题。另外要强烈推荐的是MIT的6.851课程：高级数据结构（Advanced Data

Structures）， 2012年的课程主页是： <http://courses.csail.mit.edu/6>. 85 1/spring12/。

然而，知识是永无止境的，高水平的竞赛中还有许多本书以《训练指南》中没有涉及的

知识、技巧和题型。表12-11中将列举新知识点以及相关题目，以供参加高水平竞赛的选手

查漏补缺。

表12-11 新知识及相关题目

| 题号     | 题目名称（英文）            | 备注                                            |
| -------- | --------------------------- | ----------------------------------------------- |
| UVa1683  | In case of failure          | 可以用Delaunay三角剖分或者k-d树                 |
| UVa12629 | Rectangle XOR Game          | Nim积                                           |
| UVa12698 | Safari Park                 | 梯形剖分                                        |
| UVa12711 | Game of Throne              | 任意图最大权匹配（实现最基本的Edmonds算法即可） |
| UVa12713 | Pearl Chains                | Delannoy数；Lucas定理                           |
| UVa12513 | Safe Places                 | 三维凸包；多面体的交                            |
| UVa11594 | All Pairs Maximum Flow      | Gomory-Hu树                                     |
| UVa12415 | Digit Patterns              | NFA转DFA （动态）                               |
| UVa11993 | Girls' Celebration          | PQ树                                            |
| UVa10766 | Organising the Organisation | Matrix-Tree 定理                                |
| UVa11118 |                             | 非常精彩的题目。虽然没有什么                    |

|          | Prisoners, Boxes and Pieces of Paper | 扩展性，但是强烈推荐    |
| -------- | ------------------------------------ | ----------------------- |
| UVa11915 | Recurrence                           | 钩子公式                |
| UVa1684  | Escape Plan                          | K短路(结点可以重复经过) |
| UVa1685  | Enjoyable Commutation                | K短路(结点不能重复经过) |

下面的习题不一定可以用来练习本章中介绍的各种知识点和技巧，也不一定有很高的难

度。在这里把它们翻译出来，只是因为笔者比较喜欢这些题目，希望能与读者分享。

习题 12-1 自编 SketchUp(My SketchUp, Rujia Liu's Present 4, UVa12306)

Google SketchUp是一个很棒的软件，可以用来创建、修改和分享3D模型。在本题中，你 需要编写它的一个2D简化版，即My SketchUp。

My    SketchUp的使用非常直观。例如，画两条交叉线段后，两条线段会被自动截断成4

条，因此在图12-75(a)中单击小圆点后只会选中一条线段(粗线部分)，删除后如图12-75(b)所 示。此时单击图12-75(b)中的小圆点，会选中另一条线段。把该线段删除后剩下的两条线段 会自动合并成一条线段，如图12-75(c)所示。另外，在任何时候，重复的线段都会合并成一 条。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-352.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-353.jpg)



换句话说，对于一个图形来说，它的“长相”决定了它的实际结构，与“这个图形是如何

画出来的”无关。一个图形看上去是什么样的实际就是什么样的。例如图12-76包含14个顶点

和15条线段。

输入是《^100条DRAW和REMOVE语句，输出是图形中的各个点的坐标和各条线段两端 的点编号，按照字典序排列。DRAW的参数一条折线(最多包含20个点)，而REMOVE语句有 3个参数xy d ,功能是删除离(\y)的距离不超过d的所有线段。

评注：这是一道很考验编程能力的题目，稍不注意就会让程序变得很复杂而且非常容易

出错。

习题 12-2 平铺(Tiling, ACM/ICPC Jakarta 2012, UVa1686)

输入6个整数DX1 , DY1 , DX2 , DY2 , DX3 , DY3 ,……(绝对值均不超过10000),所有 可以写成(/DX1+/DX2+&DX3, /DY1+/DY2+&DY3)的位置都有一个点，如图12-77所示。

图12-77(a)是一个周期，图12-77(b)是铺贴方法。你的任务是求最小周期。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-355.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-356.jpg)



图 12-77 平铺问题示意图

评注：本题的结论就是一个简单公式，但是得到这个公式却不容易。

习题 12-3 切片树(Slicing Tree, ACM/ICPC Daejeon 2012, UVa1687)

有《(1^«^1000)个矩形的长宽值和一棵切片树，要求把矩形按照切片树的规则摆放，使 得最小包围盒面积最小。如图12-78所示，切片树是一棵二叉树，每个叶子代表一个矩形， 每个内结点是H或者V，表示左子树中所有矩形位于右子树中所有矩形的下方/左方。注意： 矩形可以横放也可以竖放。

图12-78中是一棵切片树和符合该树的两种摆放方法。

图 12-78 切片树和两种摆放方法



习题 12-4 虫洞(Wormhole, ACM/ICPC NWERC 2009, UVa12227)

科幻小说里常提到虫洞。所谓虫洞，就是一个可以把你传送到遥远地方的东西。更神奇

的是，虫洞还能带你到过去或者未来。

在本题中，假定空间里有蜞0^«^50)个虫洞，你的任务是在时刻0从起点出发，借助这些

虫洞在最早的时刻到达终点。每个虫洞用入口坐标(xs, ys, zs)、出口坐标(xe, ye, ze)、创建时

间Z和时间偏移痛描述(|Z|，|<106)。当你在Z时刻或更晚时刻到达入口时，将会转移到出口，

并且当前时刻加上硪当为负时，相当于时光倒流)。坐标均为绝对值不超过10000的整数， 且所有点都不相同。

提示：本题并不是特别难，但很有启发意义。

习题 12-5 屋顶(Roof, Seoul 2005, UVa1688)

给一个边平行于坐标轴的多边形P ,所有边同时向内以相同速度收缩，并且以这个速度 向上(+Z)移动，最终得到一个屋顶，如图12-79所示。求屋顶的高度。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-358.jpg)



(b)

图12-79 屋顶



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-360.jpg)



提示：方法不止一种，且复杂程度差异较大。

习题 12-6 国际活动(International Event, ACM/ICPC Daejeon 2013, UVa1689)

有一个盛大的国际活动，一年举办一届。在活动现场，有<2^^100000)个旗杆排成一 行，每个旗杆上都有一面国旗迎风飘扬。

每个旗杆用3个数Zp〜b表示，即旗杆的坐标为/,,去年挂着国家的国旗，今年需要换 成国家b.的国旗。你有一个机器人，初始位置为^ ,要求为机器人设计一条路线，把所有旗 杆上的国旗换成今年的，且移动总距离最小。

国家编号为1〜风1^凝^1000),且每个国家的国旗至少挂在一个旗杆上，并且去年和今 年的旗杆数不变(即对于任意12^似，满足％ = c的i的个数等于满足b;= ^的/的个数)。假设机 器人的手很大，可以捧着任意多面国旗。如图12-80所示，每个旗杆用两个数(％bz)表示，箭 头表示了最优路径：4-5-1-7-4。

(1/2) (t 2)    (2,1) a (2,1) (2,3) (3,2)

—■-■-■-■-■-■-■—

1    2    3    4    5    6    7

图12-80 旗杆及最优路径



习题 12-7 拿行李(极限版)(Collecting Luggage EXTREME, UVa11425)

有一个《（«^100）边形传送带，上面有你的行李。已知你和行李的初始位置、传送带移动 的速率和你行走的最大速度，求拿到行李的最短时间。

评注：本题是ACM/ICPC 2007世界总决赛中一道难题的加强版。原题规定人的速度大于

传送带移动的速度，因此可以二分。原题的详细分析参见《算法竞赛入门经典——训练指

南》。

习题 12-8 加速器(Accelerator, ACM/ICPC Daejeon 2011, UVa1570)

圆周上等距排列着《个点，其中有个红点 （用圆形表示）和个蓝点（用方形表示），要求每个 红点配一个蓝点，每个蓝点最多配一个红点，使 得连线的总长度最小。两个匹配点的连线长度等 于二者的劣弧长度。例如图12-81中的最优解 为：位置1， 3， 9的红点分别匹配位置 5， 4， 10，连线长度为6。所有红蓝点位置均不 同。1<«<106，1<^<^<106，2<a+b<n。

习题 12-9 寻找缩图 （Find a Minor, Beijing 2007, UVa1690）

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-362.jpg)



对于无向图G，缩边e的操作是这样的：假 定e的两个端点为w和v，用一个新结点来代替 边e，然后把原先关联到w或者v的边（除了e之外）改成关联到这个新点。执行一次缩边操作 后，新图比原图少一条边(注意，新图可以有重边)。如果图好可以由图G经过一次或多次删 边、缩边和删除孤立点操作后得到，则称好是G的缩图。

缩图在图论中扮演着重要角色。例如，一个无向平面图要么有缩图尺3,3(两边各3个结点 的完全二分图)，要么有缩图尺5(5个结点的完全图)。

给一个包含F(3^d2)个结点的简单无向图G，你的任务是判断它是否含有某个形 如或^(1分，的给定缩图。

习题 12-10 赌博(Hey, Better Bettor, ACM/ICPC World Finals 2013, UVa1573)

你在赌场上玩一个游戏，每次的赌注是1美元，赢了会得到2美元，输了什么也得不到。 赌场有一个优惠：在任何时候，赌场可以补偿x%的损失。使用优惠之后你可以继续玩，也 可以退出赌场。退出赌场之前最多只能使用一次这样的优惠。

例如，x = 20，你玩了 10次，赢了 3次，总共损失10-3*2 = 4元，使用优惠后损失3.2元。 但如果你赢了6次，总共获利6*2-10 = 2元。

假定每局比赛获胜概率为/»%，输入x，/»(0<x<100，0<^<50)，输出最优策略下最大的期 望获利。

提示：本题和“伟大的游戏”一题有些相像，但也有区别。

习题 12-11 完全平方子集(Hip To Be Square, ACM/ICPC NWERC 2012, UVa1691)

6，10，15均不是完全平方数，但是它们的乘积900是完全平方数。输入两个整数^，办 (1<^<^<4900)，找｛^，^+1，...力｝的一个非空子集，其所有元素的乘积为完全平方数女2，要

求女尽量小。输入保证答案小于263。无解输出none。例如，20 30的解为5，101 110的解为 none， 2337 2392的解为3580746020392020480。

提示：本题的方法并不优美，所以请使出浑身解数吧。

习题 12-12 米诺陶洛斯的迷宫(Labyrinth of the Minotaur, ACM/ICPC NEERC 2012, UVa1692)

输入一个宽为w、高为力(2<w，A<1500)的矩形迷宫，左上角(1,1)是出口，右下角(w，A)是怪

兽。放一个尽量小的正方形障碍(不能放在入口或者怪兽上)使得怪兽无法从出口出去。初始 时保证怪兽和出口之间有通路。多解输出任意解，无解输出impossible。如图12-82所示，矩 形是一个最优解，边长为2。

\#####，###

ft####-.

图12-82 最优解

提示：“太空站之谜”的题解看了吗？如果还没有，现在就看看吧。

习题12-13 XAR(XAR, ACM/ICPC Beijing 2006, UVa1693)

机器兄\尺08有《个(《^128)8位寄存器，可以存储8位无符号整数，支持4种操作(每个操作 都同时作用于所有寄存器)：

□    X n (0<n<256),即乂 = V xor n。

□    A n (0<n<256),即V = (V+n) mod 256 ,

□    R n (0<n<8),循环左移n位，等价于C语言的V = (((V〉〉(8-n))|(V<<n))&0xFF)。

□    E n (0<n<256),忽略n ,程序终止。

给出n个寄存器的初始状态或(0<或<128且各不相同)，设计不超过40000条指令，使得执行 后各寄存器的值分别为◦丄…，^。

习题 12-14 收购游戏(Takeover Wars, ACM/ICPC World Finals 2012, UVa1290)

T公司有n(1<n<105)个子公司，B公司有rn(1<rn<105)个子公司。每个子公司有一^个市场价 值，均为不超过1012的正整数。

每次可以合并两个公司。合并同一个公司的两个子公司没有限制。合并之后市场价值等

于合并前的两个公司之和。

每个公司都可以用己方的一个子公司A吃掉对方的一个子公司B，条件是A的市场价值严 格大于B的市场价值。被吃掉的子公司B消失，而子公司A的市场价值不变。为了简单起见， 假定任意操作序列都不会产生两个母公司且市场价值相同的子公司。

两个公司轮流操作，T公司先。如果无法操作，则再次轮到对手操作。你的任务是判断

谁赢。

习题 12-15 历史课(History course, ACM/ICPC CERC 2013, UVa1694)

给定n(1<n<50000)个历史事件，各用一个区间［az，bz］表示，即事件的开始时刻和结束时

刻。如果两个历史事件的区间有公共点，说明两个历史事件是相关的。我们需要给学生讲这 些历史事件，其中每堂课讲一个事件。我们希望相关历史事件在排课时尽量排在一起，即要 找一个最小的^，使得相关历史事件的课堂编号之差不超过怂另外，不相关的历史事件必须 按顺序讲，即如果有两个不相关事件/和/，/在/之前发生，则/的课也必须排在/之前。要求输

出任意解。

习题12-16 Quall[e]? Quale?(Quall[e]? Quale?, Rujia Liu's Present 6, UVa12570)

有n道题，每道题的标题有多语言版(一共有m种语言)。已知每道题的每种语言的版本以 什么字母开头，要求前n个字母的题目各一道。问：实际用到的语言集合有哪几种可能？例 如，有5道题， 3种语言。每道题目的每种语言版开头字母如图12-83所示。

一个合法解如图12-84所示。

| Problem A | Problew 1 in English  |
| --------- | --------------------- |
| Problem B | Problem 3 in French   |
| Problem C | Problem 5 in English  |
| Problem D | Problem 2 in English  |
| Problem E | Problein 4 in Chinese |

图12-84 合理解法之一

实际用到的语言是｛English，French，Chinese｝，3<n<26，1<m<5。

评注：本题可以用《训练指南》中介绍的DLX算法解决，也有实际效率更高的方法。

习题 12-17 单后对单车(Queen vs Rook, UVa10383)

你的任务是解决国际象棋里的著名残局“单后对单车”。输入4个棋子的位置和下一个移

动的棋子颜色。要求在第一行输出获胜方及获胜的最少步数，第二行输出下一次移动方的最

优策略（若是必胜方，应输出获胜最快的策略；若是必败方，应输出失败最慢的策略；若是

平局，输出导致平局的策略）。本题不允许后和车易位。

输入最多有1000组数据，保证任何两个棋子不会位于同一个格子里，并且后和车的颜色 保证不同。不该移动的一方不会“已经被将死”，但是该移动的一方有可能“已经被将死”。输 出中用X表示吃子，“+”表示将军，“#”表示将死。

评注：本题容易超时，需要优化，且有些优化本身的代码量比较大。

习题 12-18 谱曲(Melod[y] "Creation", Rujia Liu's Present 6, UVa12566)

可以用字符串来表示一个简谱，其中小节线为“I”，s1 =s2表示一个转调，即该音符在转 调前是s1 ,转调后是s2。例如，下面的简谱是一个“诡异版”的生日歌：

5 5 6 5 1 =4 3 | 1 1 2 1 5 4 | 1=5 5 5 3 1 7 = 3 2 | b7 b7 6 4 5 = 2 1 ||

输入一个简谱，要求将它改写，使得升降号不超过&个，在此前提下转调的次数最少。 多解时，输出字典序最小的解。要求音符数不超过100。音乐知识和题目背景请参考原题。

习题 12-19 大逃亡(Escape, ACM/ICPC CERC 2013, UVa1695)

有一棵w（1<«<200000）个结点的树，初始时你在结点1 ,生命值HP = 0 ,目标是从结点t的 出口逃出来。每个结点有一个怪兽或者一个鸡腿。当第一次到达一个结点时，你的HP会发 生变化：打怪之后HP减少，吃鸡腿之后HP增加，改变量等于结点权值的绝对值，负数表示 怪兽，正数表示鸡腿，0表示什么都没有。注意，如果终点Z内有怪兽，必须先打怪兽然后才 能逃出。问是否能成功逃出。

习题 12-20 蜘蛛旅行家(Travelling Spider, ACM/ICPC Daejeon 2011, UVa1696)

把一个魔方的每个面分成《*«（2分<50）的正方形，如图12-85所示（《 = 4）。不难发现，每 个正方形恰好有4个相邻正方形。

图12-85 n*n正方形

在两个正方形的中心点分别放一只公蜘蛛和一只母蜘蛛，求一条路径，从公蜘蛛出发，

经过所有正方形的中点恰好一次后到达母蜘蛛。换句话说，包括起点和终点，求出的路径应 恰好包含6n2个互不相同的正方形，且路径上相邻的两个正方形在魔方上也相邻。

无解输出-1 ，多解输出任意解。

[⑴](#bookmark31)下面的方法称TCA (Thompson's Construction Algorithm)。

[(2)](#bookmark33)    见A. Blumer等人于1985年写的经典论文： 《The Smallest Awtomaton Recognizing the Swbwords of a Text》。

[(3)](#bookmark35)    出于时间和空间上的考虑，在竞赛中我们往往不是给每条重路径建一棵线段树，而是用一棵全局线段树保存所有树 链，限于篇幅，这里不再详细介绍。

[⑷](#bookmark37)原始论文：http://www.cs.cmu.edu/- sleator/papers/self-adjusting.pdf。这里介绍的版本和原始论文有差异，在实践中更

为常用。

[(5)](#bookmark39)    原论文中不是使用的伸展树，因为Link-Cut树比伸展树更早发明。

[(6)](#bookmark41)    <http://en.wikipedia>. org/wiki/Rope_%28computer_science%29。

[(7)](#bookmark43)[    ](#bookmark43)它的正式名称为多边形偏移(offseting )。

[(8)](#bookmark45)    《训练指南》中的“图询问”问题也用到了这个技巧。

[(9)](#bookmark47)    仔细分析后可以发现：因为流量可以复用，所以其实复杂度连O ( n )都不需要乘。不过对于本题的规模，这个优 化不是必需的。

[(10)](#bookmark49)    本题还有一个有意思的结论：最小费用对应的/一定是有理数，且分母不超过n (即滴水嘴的数量)。这个结论并 不容易证明，有兴趣的读者可以一试。

[(W](#bookmark51)事实上，还可以证明一个更强的结论：如果不考虑“尺2不能有前导0”这个条件，尺2是唯一存在的。

[(12)](#bookmark53)    官方数据中的最大答案为1685.830。

[(13)](#bookmark55)    大圆(Great Circle )是球面上半径等于球体半径的圆弧。连接两点的最短“球面线段”等于经过两点的大圆上的劣 弧。

[(14)](#bookmark57)    比赛中唯一通过此题的Anton Lunyov就是采用的这种方法。

[(15)](#bookmark59)    A Strange Opera House II, Rujia Liu's Present 4, UVa12309

[(16)](#bookmark61)    题目来源：NOI2000，命题人：李申杰。UVa中的数据经过加强，难度大大高于NOI中的测试数据。

[(17)](#bookmark63)    习惯上用A[x+ + + y]表示子序列A[x]，A[x+1]，…，A[y]，后同。

[(18)](#bookmark65)    为了方便，还可以保存光标在每个级别的编辑框的元素指针。

[(19)](#bookmark67)    它可以把代码压缩到5 - 6KB。而传统的OOP写法往往需要8 - 10KB。

[(20)](#bookmark69)    这些批评也是有道理的。事实上，很多ACM/ICPC选手因为过于习惯编写独立、简短的代码，在工作初期会不适

应大型软件的协作开发。

[(21)](#bookmark71)    在软件工程领域，不同的遗留代码情况、团队情况以及软件的预计规模、需求变化情况等，都会影响到程序架构

和设计决策。

[(22)](#bookmark73)    相信看过《算法艺术与信息学竞赛》的读者对这个题目不陌生。

[(23)](#bookmark75)    这是一个很特别的程序设计语言，看过《黑客与画家》的读者相信对它并不陌生。这个语言有不少吸引人的地 方，但它的复杂程度却是大大超过普通人的预期。对此，笔者在实际项目的开发中已略有体会。有兴趣的读者可阅读

《ANSI Common Lisp》入门，然后在《On Lisp》和《Practical Common Lisp》等经典著作中找到更多信息。

[(24)](#bookmark77)    当然可以用STL的string来表示字符串。但是因为本题的字符串大都非常短，所以使用STL字符串带来的效率损失

是比较明显的。

[(25)](#bookmark79)    intVal、strVal等成员可以写成联合(union)的形式以节省空间，不过和本题的核心关系不大，这里就不叙述了。

[(26)](#bookmark81)    这个设计也许会让scala程序员会心一笑。另外，熟悉STL的读者也许会更倾向于复用STL中的functor。

[(27)](#bookmark0)    题目来源：NOI冬令营2002。命题人：刘汝佳。

[(28)](#bookmark3)    [http://olympiads.win.tue.nl/ioi/ioi99/contest/official/under.html](http://olympiads.win.tue.nl/ioi/ioi99/contest/official/under.html%e3%80%82)[。](http://olympiads.win.tue.nl/ioi/ioi99/contest/official/under.html%e3%80%82)

[(29)](#bookmark5)    [http://en.wikipedia.org/wiki/Maze_solving_algorithm#Wall_follower](http://en.wikipedia.org/wiki/Maze_solving_algorithm%23Wall_follower%e3%80%82)[。](http://en.wikipedia.org/wiki/Maze_solving_algorithm%23Wall_follower%e3%80%82)

[(30)](#bookmark7)    对于原题的10组官方数据，优化前的最坏情况需要走20000步左右，优化后只需不到2000步。
