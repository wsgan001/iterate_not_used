---
author: evo
comments: true
date: 2018-04-04 13:19:26+00:00
layout: post
link: http://106.15.37.116/2018/04/04/algorithm-tree/
slug: algorithm-tree
title: 算法：树
wordpress_id: 3010
categories:
- 随想与反思
tags:
- '@todo'
---

<!-- more -->

缘由：

对树相关的算法进行总结。


# 树——主要内容


二叉查找树
 增删改查
 其他结构的基础：如平衡二叉树
 前序中序后序遍历
 三种遍历本身
 通过前序中序求后序
 平衡二叉树
 四种分类：左左、左右、右左、右右
 四种旋转：左旋和右旋；单旋转和双旋转
 增删改查
 B树及其变种
 分裂结点、合并结点
 R树
 实践中的应用


# 树和二叉树


 一般地说，树的结点间是无序的，即：
 一个结点有m个孩子，则L 1 L 2 …L m 可以互换位置，
仍然认为是一颗树。
 二叉树的两个孩子，一般称为左孩子、右孩子，不
能互换位置。
 之所以这样定义，是因为有些算法，需要严格区分左右
孩子，如前序-中序-后序遍历、堆排序等问题。
 从这个意义上说，树和二叉树是两个概念，不能说
二叉树是树的子集。
 注：这种区分非常弱而且乱，因为树还有“有序树”“无序
树”的说法。

树转换成二叉树


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cc3d03c09.png)





## 树转换得到的二叉树右孩子


 任意一颗树转换成二叉树，右孩子为空的数目为原
树非叶结点+1。
 对于一颗树(非二叉树)，因为任何一个非叶结点必然有孩
子，所以，它必然有最右孩子。从而，这个最右孩子转
换到二叉树结点后，右指针必然为空。
 同时，根结点必然没有兄弟，所以，根结点转换成二叉
树结点后，必然右孩子为空。
 任意颗树转换成二叉树，右孩子为空的数目为原树
非叶结点+1。
 如果是若干个树转二叉树，这若干个树最右边的那个
树，是没有右孩子的。


## 树基本操作


 插入
 删除
 查找
 前序遍历
 中序遍历
 后序遍历


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cc505ce0f.png)





# 二叉查找树


 二叉查找树(二叉搜索树)是满足以下条件的
二叉树：
 左子树上的所有结点值均小于根结点值，
 右子树上的所有结点值均不小于根结点值，
 左右子树也满足上述两个条件


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cc6804e89.png)





## 二叉查找树的查找


 给定一颗二叉查找树，查找某结点p的过程如下：
 将当前结点cur赋值为根结点root；
 若p的值小于当前结点cur的值，查找cur的左子树；
 若p的值不小于当前结点cur的值，查找cur的右子树；
 递归上述过程，直到cur的值等于p的值或者cur为空；
 当然，若结点是结构体，注意定义“小于”“不小于”“等
于”的具体函数。

Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cc84344e2.png)





## 二叉查找树的插入


 插入过程如下：
 若当前的二叉查找树为空，则插入的元素为根
结点，
 若插入的元素值小于根结点值，则将元素插入
到左子树中，
 若插入的元素值不小于根结点值，则将元素插
入到右子树中，
 递归上述过程，直到找到插入点为叶子结点。


## Code (recursion)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cc91b648f.png)





## Code




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cc9e00d0b.png)





# 二叉树的建立


 依次插入：15,5,3,12,16,20,23,13,18,10,6,7


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ccac25d4c.png)





## 二叉查找树的删除


 记待删除的结点为p，分三种情况进行处
理：
 p为叶子结点
 p为单支结点
 p的左子树和右子树均不空


## 待删除点为叶子结点


 p为叶子结点，直接删除该结点，再修改p的
父结点的指针


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ccc42531f.png)





## 待删除点只有一个孩子


 若p为单支结点(即只有左子树或右子树)，则
将p的子树与p的父亲结点相连，删除p即可


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cccebe921.png)





## 待删除点有两个孩子


 若p的左子树和右子树均不空，则找到p的直
接后继d(p的右孩子的最左子孙)，因为d一定
没有左子树，所以使用删除单支结点的方
法：删除d，并让d的父亲结点dp成为d的右
子树的父亲结点；同时，用d的值代替p的
值；
 对偶的，可以找到p的直接前驱x(p的左孩子的最
右子孙)，x一定没有右子树，所以可以删除x，
并让x的父亲结点成为x的左子树的父亲结点。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cce3b4911.png)





## 待删除点有两个孩子


 任务：删除p
 过程：两步走
 将p的直接后继的值拷贝到p处
 删除p的直接后继


## Code




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cd0146a2e.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cd07ecd04.png)





# 二叉树的遍历


 前序遍历：
 访问根结点
 前序遍历左子树
 前序遍历右子树
 中序遍历：
 中序遍历左子树
 访问根结点
 中序遍历右子树
 后序遍历：
 后序遍历左子树
 后序遍历右子树
 访问根结点


## 前序遍历




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cd1d241b3.png)


前序遍历：15,5,3,12,10,6,7,13,16,20,18,23

Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cd2edc59c.png)





## 中序遍历




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cd34d4fc1.png)


中序遍历：3,5,6,7,10,12,13,15,16,18,20,23
 二叉查找树的中序遍历，即为数据的升序过程



Code


## ![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cd4990b1a.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cd6f6b6ad.png)


后序遍历


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cd74b8f98.png)


后序遍历：3,7,6,10,13,12,5,18,23,20,16,15

Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cd80f12c4.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cd8af110e.png)





## 根据前序中序，计算后序


如：已知某二叉树的遍历结果如下，求它的
后序遍历序列
 前序遍历：GDAFEMHZ
 中序遍历：ADEFGHMZ
 两个步骤：
 根据前序中序，构造二叉树
 后序遍历二叉树

 前序遍历：GDAFEMHZ
 中序遍历：ADEFGHMZ
 根据前序遍历的特点得知，根结点为G；
 根结点将中序遍历结果ADEFGHMZ分成
ADEF和HMZ两个左子树、右子树。
 递归确定中序遍历序列ADEF和前序遍历序
列DAEF的子树结构；
 递归确定中序遍历序列HMZ和前序遍历序列
MHZ的子树结构；


## 根据前序中序，构造二叉树


前序遍历：GDAFEMHZ
中序遍历：ADEFGHMZ


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cdac8ad68.png)


Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cdbf37f2d.png)





## 思考


 若已知二叉树的中序和后序遍历序列，如何
求二叉树、如何求二叉树的前序遍历序列
呢？


## 根据中序后序遍历，求前序遍历


 中序遍历：ADEFGHMZ
 后序遍历：AEFDHZMG
 提示：后序遍历最后一个结点即为根结点，即
根结点为G
 递归



Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cde5c2a2a.png)





## 思考


 给定整数数组，判断该数组有无可能是一颗二叉查
找树后序遍历的结果。假定数组中没有重复元素。
 编程如何实现？
 以下序列中不可能是一棵二叉查找树的后序遍历结
果的是_______。
 1,2,3,4,5
 3,5,1,4,2
 1,2,5,4,3
 5,4,3,2,1



算法描述

 1,2,5,4,3
 由于后序遍历的最后一个元素为根结点，根
据该结点，将数组分成前后两段，使得前半
段都小于根结点，后半段都大于根结点；如
果不存在这样的划分，则不可能是后序遍历
的结果。
 递归判断前后半段是否满足同样的要求。

Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce0337732.png)





# 平衡二叉树


 平衡二叉树是第一个引入平衡概念的二叉树
 Balanced Binary Tree，1962年由G.M.Adelson
Velsky、E.M.Landis发明，又称AVL树。
 每个结点的左右子树的高度之差不超过1，
 如果插入或者删除结点后高差大于1，则进行结
点旋转，重新维护平衡状态。
 解决了二叉查找树退化成链表的问题，插入、
查找、删除的时间复杂度最坏情况是O(logN)。
 最好情况也是O(logN)


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce0dbdfe3.png)


AVL实现举例


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce1922591.png)





## 二叉查找树与平衡二叉树




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce2141c7f.png)





## 分析高度不平衡结点


 维护不平衡的直接手段是选择不平衡结点X
的某孩子C作为父结点，当前结点X作为原
子结点C的子结点。这显然会影响到X的子
结点、孙结点，因此，分成如下四种情况：
 高度不平衡结点的两颗子树的高度差2


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce2b5a399.png)





## 高度不平衡1：左左


 6结点的左子树3结点高度比右子树7结点大
2，左子树3结点的左子树1结点高度大于右
子树4结点，这种情况称为左左。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce374c46e.png)





## 高度不平衡2：左右


 6结点的左子树2结点高度比右子树7结点大
2，左子树2结点的左子树1结点高度小于右
子树4结点，这种情况成为左右。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce43b1ab4.png)





## 高度不平衡3：右左


 2结点的左子树1结点高度比右子树5结点小
2，右子树5结点的左子树3结点高度大于右
子树6结点，这种情况成为右左。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce4d24bed.png)





## 高度不平衡4：右右


 2结点的左子树1结点高度比右子树4结点小
2，右子树4结点的左子树3结点高度小于右
子树6结点，这种情况成为右右。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce5765104.png)





## 对称与旋转




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce5ecd4e6.png)


左左和右右对称；左右和右左对称
 左左和右右两种情况是对称的，这两种情况
的旋转算法是一致的，只需要经过一次旋转
就可以达到目标，称之为单旋转。
 左右和右左两种情况也是对称的，这两种情
况的旋转算法也是一致的，需要进行两次旋
转，称之为双旋转。


## 左左单旋转


 结点K2不满足平衡特性，因为它的左子树k1
比右子树Z深2层，而且K1子树中，更深的
一层的是K1的左子树X子树，所以属于左左
情况。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce6d90861.png)





## 单旋转：对左孩子做旋转 (顺时针)


假设K2不平衡：中序遍历X-K1-Y-K2-Z
 把K1作为新的根结点
 K2＞K1，所以，把K2置于K1的右子树上
 K2＞Y＞K1，所以，把Y置于K2的左子树上


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce7a6703f.png)





## AVL单旋转


 把K1变成根结点
 把K2置于K1的右子树
 把Y置于K2的左子树


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce8fea7c1.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce8b482a8.png)





## 双旋转


 对于左右和右左两种情况，单旋转不能使它
达到一个平衡状态，要经过两次旋转。
 左右：结点K3不平衡，左子树K1比右子树D
深2层，且K1的子树中更深的是右子树K2。
 K1右旋，然后K3左旋


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4ce9e631fc.png)


Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cebfcb432.png)





# 平衡二叉树的插入


 插入的方法和二叉查找树基本一样，区别
是，插入完成后需要从插入的结点开始维护
一个到根结点的路径，每经过一个结点都要
维持树的平衡。维持树的平衡要根据高度差
的特点选择不同的旋转算法。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cecb2770d.png)





## 平衡二叉树的查找


 平衡二叉树使用和二叉查找树完全相同的查
找方法，不过根据高度基本平衡存储的特
性，平衡二叉树能保持O(logN)的稳定时间
复杂度，而二叉查找树极端情况会退化成链
表。


## 平衡二叉树的删除


 删除的方法也和二叉查找树的一致，区别
是，删除完成后，需要从删除结点的父亲开
始向上维护树的平衡一直到根结点。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cee4b8ffa.png)





## 二叉到多叉的思考


 一个结点存一个值，则有2个孩子：W
 一个结点存两个值，则有3个孩子：MO
 一个结点存三个值，则有4个孩子：MO


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cefe98b71.png)




2-3-4树


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cf06b62ef.png)




查找L


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cf0c83bd8.png)


插入B


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cf1304e00.png)


插入X


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cf193bad5.png)


插入H


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cf225b1ae.png)


分裂结点


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4cf2a4c024.png)





# B树的定义


 m阶B树需要满足的条件：
 每个结点至多有m个孩子；
 除根结点外，其他结点至少有m/2个孩子；
 根结点至少有2个孩子；
 所有叶结点在同一层；
 有α个孩子的非叶结点有α-1个关键字；结点内
部，关键字递增排列。


## B树




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4d067585c2.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4d06b442d7.png)





## B树的变种




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4d079dcaf0.png)





## 二维上的B树——R树




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4d0830af86.png)





## 三维空间中的R树




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4d0972479d.png)





# 总结


 树是最重要的数据结构，没有之一。
 从根节点到叶子的过程，是逐渐细化精确的
过程，所以，实践中往往作为海量数据索
引。
 树只是数据结构，非存储结构。实践中，可
以使用数组来存储树。
 思考实例Huffman编码、堆排序、并查集等。


# COMMENT：





# REF：





 	
  1. 七月在线 算法



