
# 时间复杂度


 假定函数MyFunc()的时间复杂度为O(1)，则
下列代码的时间复杂度关于整数n是多少？


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5913f0678c.png)


 Θ(NlogN) /Θ(N)
 注： Θ表示复杂度是紧的，
 如堆排序中，建堆的时间复杂
度为Θ (N)，而非Θ (NlogN)；
 当然，可以说建堆的时间复杂
度为O(NlogN)，因为O记号不要
求上确界。

时间复杂度分析


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5916c99809.png)


图示分析

从下面的图示能够清楚的反映这一问题：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5917a2eb95.png)


上图中，当外层循环的i位于紫色位置时，内
层循环执行的是紫色的①；下次循环，当外
层循环的i位于红色位置 3*i时，内层循环执
行的是红色的②，依次类推。所以，循环次
数的上限为N。从而，时间复杂度为O(N)。


# 集合的表达


将全集I划分为若干子集S 1 ,S 2 …,S n ，使得
S 1 ∪S 2 ∪…∪S n =I，且S 1 ∩S 2 ∩…∩S n =∅。则
S 1 ,S 2 …,S n 称为全集I的一个可行划分。
 思考：用何种数据结构方便表达呢？


## 集合的性质


自反性(a)，对称性(a、b)
 传递性：如果c是b的子结点，b是a的子结
点，则a、b、c位于相同的集合中。
 由于集合中元素是等价的，选择任意一个元
素作为代表，其他元素都指向该元素，即完
成一个集合的表达；称指向元素为子结点，
被指向元素为父结点。

Code：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59ad5cd67d.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59ae4c8f74.png)





# 并查集的应用


 某国家有N个小岛组成，经过多年的基础设
施积累，若干岛屿之间建立了若干桥梁。先
重新完善该国的行政区划，规定只要有桥梁
连接的岛屿则归属同一个城市(可以通过其
他岛屿中转)，问该国一共多少个城市？
 求给定图G的连通分量的数目。
 解决方案：集合划分


## Code：




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59b035113d.png)





## 思考：有向图呢？


 对一个有向图，如果每个节点都存在到达其他任何
节点的路径，那么就称它是强连通的。
 判断图是强连通图的算法：任取有向图G的某结点
S，从S开始进行深度优先搜索，若可以遍历G的所
有结点，则将G的所有边反向，再次从S开始进行
深度优先搜索，如果再次能够遍历G的所有结点，
则G是强连通图，两次搜索有一次无法遍历所有结
点，则G不是强连通图。此外，上述搜索可以换成
广度优先搜索等其他方案。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59c21eb9d2.png)







# Trie树


 Trie树是一种哈希多叉树，又称字典树、单
词查找树或前缀树，用于在大量字符串中快
速检索。
 英文字母的字典树是一个26叉树
 数字的字典树是一个10叉树。

Trie数的特点及性质

 典型应用：统计和排序大量的字符串(但不仅限于
字符串)，所以经常被文字处理系统用于文本词频
统计。
 优点：利用字符串的公共前缀来节约存储空间,最大限度
地减少无谓的字符串比较，查询效率比哈希表高。
 缺点：如果存在大量字符串且这些字符串基本没有公共
前缀，则相应的Trie树将非常消耗内存。
 三个基本性质：
 根结点不包含字符，除根结点外每一个结点都只包含一
个字符。
 从根结点到某一结点，路径上经过的字符连接起来，为
该结点对应的字符串。
 每个结点的所有子结点包含的字符都不相同。



Trie树举例
 词典：
 a、b、c、aa、
ab、ac、ba、
ca、aba、abc、
baa、bab、bac、
cab、abba、
baba、caba、
abaca、caaba


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59c42da80d.png)


Trie树举例


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59c4cbad3a.png)


压缩：左孩子-右兄弟


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59c5602371.png)


对左孩子-右兄弟表示法的思考

只记录有效索引指针，形成如下结构


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59c65d7757.png)


 利用“左孩子-右兄弟”表示方法，如何将一颗
树转换成二叉树？
 如何将N颗树(森林)转换成二叉树？



树转换成二叉树


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59c761cce9.png)


树转二叉树的右孩子
 任意一颗树转换成二叉树，右孩子为空的数目为原
树非叶结点+1。
 对于一颗树(非二叉树)，因为任何一个非叶结点必然有孩
子，所以，它必然有最右孩子。从而，这个最右孩子转
换到二叉树结点后，右指针必然为空。
 同时，根结点必然没有兄弟，所以，根结点转换成二叉
树结点后，必然右孩子为空。
 任意颗树转换成二叉树，右孩子为空的数目为原树
非叶结点+1。
 如果是若干个树转二叉树，这若干个树最右边的那个
树，是没有右孩子的。


## Trie树应用举例


 给定一颗边的权值都是正整数的树，求某两
个结点间的路径S，使得该路径所包含的所
有边权的异或值最大。
 A-B-C 3^4=7(最优解)
 A-B-D 3^6=5
 C-B-D 4^6=2


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59c8542999.png)


算法分析
 朴素解法
 枚举所有结点对，求得所有路径异或权。时间复杂度
O(n^2)
 问题分析
 异或的性质：a^b = (a^c)^(b^c)
 求出从根节点到每个节点的异或值X[i]，这样任意两个点
(i, j)做异或X[i]^X[j]即是他们之间的异或权(相同部分异
或抵消)
 从根节点到每个节点的异或值可以通过一次深度优先搜
索解决，时间复杂度O(n)
 问题转化为求n个数中异或值最大的两个数字

利用Trie树
 将数字看成二进制的0/1串，先将所有数字从最高位起放入一
个二叉Trie树中；
 枚举每个数字a，从最高位开始，寻找尽量与a对应位不同的
数字；时间复杂度O(len)；
 总体时间复杂度O(N*len)


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59c99f2590.png)


空间复杂度的简化
 Trie树的状态转移函数：g(s,c)=t
 s表示当前状态，c表示转移条件，t表示下一
个可接受状态： (DFA的状态转移)
 base数组中的每一个元素相当于Trie树的一个节
点，其值做状态转移的基值，check数组相当于
校验值，用于检查该状态是否存在。
 base[s]+c=t
 check[t]=s


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59ca7c8cca.png)


Trie树的双数组表示法


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59cb83153a.png)


Trie树逻辑结构


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59cc8bce16.png)





## Trie树的资源号修改




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59cd11d290.png)


资源号修改伪代码


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59ce13c2b9.png)





## 字符串的插入


 记待插入字符串为a 1 a 2 …a h-1 a h a h+1 …a n ，其中，在当
前Trie树中找到了前缀a 1 a 2 …a h-1 ，而a h 是第一个未
找到的字符，记Trie树中字符a h-1 转移得到的结点为
s r 。
 算法：
 以s r 为根，插入新结点s t ：s t 由a h 转移得到
 将s t 指向尾后缀a h+1 …a n
 这里，将后缀串a h+1 …a n 直接加入后缀池，减少不必
要的分支，进一步降低空间复杂度。
 由于后缀池的引入，如果插入的字符串最后查找成功的
字符没有分支，而是在后缀池中，如何操作？


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59ce7e60c6.png)


字符串的插入
 记待插入字符串为a 1 a 2 …a h-1 a h …a h+k-1 a h+k …a n ，其
中，在当前Trie树中找到了前缀a 1 a 2 …a h-1 ，而
a h …a h+k-1 b 1 …b m 是在后缀池中，记Trie树中最后一
个分支结点为s r ，即字符a h-1 转移得到s r 。
 算法：
 以s r 为根，插入新结点s t ：s t 由a h …a h+k-1 转移得到
 以s t 为根，插入新结点s u ：s u 由b 1 转移得到
 将s u 指向后缀池中的b 2 …b m
 以s t 为根，插入新结点s v ：s v 由a h+k 转移得到
 将s v 指向后缀池中的a h+k+1 …a n


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59cfb7f4dc.png)


双数组Trie树结构总结
 Trie树逻辑结构清晰简练，优雅自然，在海量数据
中查找某数据，和海量数据规模无关，只和待查找
数据长度本身有关，时间复杂度为O(len)，常常可
以认为是O(1)。
 可以看做是以数据元素为关键字的多Hash结构；
 海量数据的复杂度分析未考虑内存调度等问题。
 双数组的存储结构晦涩难懂，增删困难。实践中，
往往离线将海量数据建立Trie树双数组结构，少量
删除时可以继续使用。若大量删除，则离线建立新
的Trie树双数组结构，适时替换。




# 围棋中的正方形


 围棋棋盘由横纵19*19条线组成，请问这些
线共组成多少个正方形？假定只考虑横纵方
向，忽略倾斜方向。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59d1141c01.png)


算法分析


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59d2062ff9.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59d2b02cf7.png)


算法结论


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59d3a52f0a.png)


Code：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59d44bc0f1.png)


思考


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59d53a6154.png)


Code2


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59d62837c3.png)


如果手头没有编译器呢？
 如果数一下边长是1、2、3……18的正方形
各有多少个，能够很快得到结论。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59d74991bf.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59d7cf31d3.png)





# 字符串的交替连接


 输入三个字符串s1、s2和s3，判断第三个字
符串s3是否由前两个字符串s1和s2交错而
成，即不改变s1和s2中各个字符原有的相对
顺序，例如当s1=“aabcc”，s2=“dbbca”，
s3=“aadbbcbcac”时，则输出true，但如果
s3=“accabdbbca”，则输出false。
 换个表述：
 s1和s2是s3的子序列，且s1∪s2=s3

问题说明
 若s1和s2没有字符重复：遍历s3的同时，考
察是否是s1和s2的字符即可；
 若字符重复：可以用压栈的方式解决；
 此外，还能用动态规划，代码更为简洁。

状态转移函数
 为算法表述方便，从1开始数：
 令dp[i,j]表示s3[1...i+j]是否由s1[1...i]和s2[1...j]
的字符组成：即dp[i,j]取值范围为true/false
 s1[i]==s3[i+j]且dp[i-1,j]为真，则dp[i][j]为真；
 s2[j]==s3[i+j]且dp[i,j-1]为真，则dp[i][j]为真；
 其它情况，dp[i][j]为假。
 可以使用滚动数组降低空间复杂度。

Code：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59d9997fdd.png)


Code2


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59da35a30c.png)





# 聪明的博弈 \(\frac{2}{3}\cdot E\)


现有N个人，每人都从1到100按照自己的判
断选一个整数，根据这N个数求均值E。规
定选择最接近\(\frac{2}{3}\cdot E\)的那个人是获胜者。聪明
的你作为参与者之一，你会选择哪个数呢？




## 问题分析


 如果每个人都随机选择，则N个数的期望收敛于
50。因此，选择50*2/3=33.3的人将获胜。如果所
有人都如此思考，则大家都会选择33.3，从而获
胜的人应该是选择33.3*2/3=22.2，继续塌缩，最
终所有人都选择最小数1，从而期望是0.66，大家
全获胜。
 问题是：
 不是所有人都足够聪明；
 总有“更”聪明的人选择对自己更有利的数；
 总有不打算胜利的人搅局：随机选数甚至选100等；


## 将人群分成若干类别


 最直接想法的人
 什么都不想，随便从1-100中选一个，碰运气：假定占比是25%
 稍微思考的人
 稍作思考发现：如果所有人都随机选择，那么平均是应该是
50。所以，将50的2/3，即33.33作为我的选择：假定占比25%
 继续思考的人
 如果所有人都选33.33，则平均数为33.33，那么，33.33的2/3，
即22.22是胜利者。既然我会这么想，别人也会这么想，那
么，如果大家都选22.22，则22.22的2/3，即14.8133是胜利者。
继续塌缩下去，大家会选择1。所以，我应该选择最小的数1：
假定占比30%
 注意：由于是从1-100选数，是不能选0的。

 再思考的人
 不是所有人都会进行理性思考，从而不是所有人都选择
1。因此，这个数字应该很小，但由于前面三类人的存
在，大体应该是10左右。所以，我选择10
 假定这部分人的占比是19%
 最聪明的人：
 建立了“后验”模型，能够预知未来，他们能够直接判断
出包括自己在内的N个数的平均值；
 假定这部分人的占比是1%
 不打算胜利的搅局人：
 随机选数或者直接选100等
 假定以上5类人中，以1%的概率随机产生

六类人的总结
 人群分类
 A.最直接想法的人：25% B.稍微思考的人：25%
 C.继续思考的人：30% D.再思考的人：19%
 E.最聪明的人：1% F.搅局的人：低概率随机产生
 若选中A类的人，则均匀分布随机产生1-100的值；
 若选中B/C/D类，则产生均值为33.3/1/10的高斯分布的值，方差
影响可以忽略，假定B/C/D的标准差分别为10/3/3；
 由于E类绝顶聪明，他们的值和答案非常接近，则E类的均值和
答案相同。所以，选中E类，则样本不累加，直接丢弃即可；
 搅局者可能异常聪明或愚钝，无关智商，因此在上述五类人群
中以2%的概率随机产生搅局者。
 1万/10万/100万个样本的均值模拟为：25.84/25.25/25.18
 如果在 大量现实人群中，推荐选择25。

Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59e9bc5a8c.png)







# 任务安排


 给定一台有m个储存空间的单进程机器；现有n个
请求：第i个请求计算时需要占用R[i]个空间，计算
完成后，储存计算结果需要占用O[i]个空间(其中
O[i]<R[i])。问如何安排这n个请求的顺序，使得所
有请求都能完成。
 如：m=14，n=2，R[1,2]=[10,8]，O[1,2]=[5,6]。可以先运
行第一个任务，计算时占用10个空间，计算完成后占用5
个空间，剩余9个空间执行第二个任务；但如果先运行第
二个任务，则计算完成后仅剩余8个空间，第一个任务的
计算空间就不够了


## 算法分析


 第k个任务的计算占用空间加上前面k-1个任
务的空间占用量之和，越小越好。从而：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59eb94406d.png)


 得：将任务按照R[i]-O[i]降序排列即可。


## Code




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59ecc512fc.png)





# Palindrome Partitioning II


给定一个字符串str，将str划分成若干子串，
使得每一个子串都是回文串。在所有可能的
划分中，子串数目最少是多少？
 s=“aab”，最少子串数目为2
 “aa”，“b”
 “abacdccdaa”：最少子串数目为4
 “aba”、 “c”、 “dccd”、 “aa”



贪心法是不对的
 贪心法：
 计算字符串S的最长回文子串，假定为A，则将S
切分成B|A|C三部分，对B和C分别递归计算最长
回文子串。
 反例：ADACDCAEA
 贪心划分：A|D|ACDCA|E|A
 最少回文划分：ADA|CDC|AEA

Palindrome Partitioning
 假设当前已经计算完成前缀串str[0…i-1]的最少划
分数目d[0…i-1]，其中d[j]表示前缀串str[0…j]的最
少划分数目；
 则：要划分前缀串str[0…i]，假定划分方案的最后
一个子串为str[j+1…i]，显然，根据题意str[j+1…i]
为回文串，并且str[0…j]一定是最少划分，即：
 d[i]=min{d[j]+1|s[j+1…i]是回文串，i-1≥j≥0}
 注意：
 str[j…i]是否为回文串，本身是个小的动态规划
 若已知str[j+1…i-1] 是回文串，则只需判断
str[j]==str[i]；
 上述整个过程从后向前分析仍然可以得到类似的结论；

复习：题中题
 在计算str[i,i+1…j]是否是回文串这一子问题中，暴
力也是无可厚非的。线性探索：j从i到n-1遍历即
可。
 事实上，可以事先缓存所有的str[i,i+1...j]是回文串
的那些记录：用二维布尔数组p[n][n]就够了：p[i][j]
的true/false表示了str[i,i+1...j]是否是回文串；
 它本身是个小的动态规划：
 如果已知str[i+1...j-1]是回文串，那么，判断str[i,i+1...j]是
否是回文串，只需要判断str[i]==str[j]就可以。

Code：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59f1d4d0c1.png)


思考
 如果不止计算最小回文划分的切分数目，还
要求最小回文划分本身，如何处理？
 记录前驱：
 每一个前缀串最小回文划分的前驱

Code2


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59f2d8d750.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59f397dd2e.png)





# 迷离傍地走


 为庆祝强汉文武盛世暨废除和亲七百周年，武后决
定拜孙武和王翦对春夏秋冬四官细君、昭君、探
春、文成做军事训练。
 孙武和王翦分别负责四官的站军姿和踢正步科目。
根据军训要求，只有在学会站军姿之后才能进行踢
正步训练。由于四官天资差别，学习时间如下表。
 问：应该如何安排四官的学习时间，能够使得所有
人学会这两项技能的时间最短？


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59f6834dda.png)


分析事件
 若一个事件位于第一阶段且耗时较长，则不能将其
放在第一个执行，因为这将导致其他所有事件都需
等待。如果一个事件位于第二阶段且耗时较长，则
不能将其放在最后一个执行，因为这将延缓全部完
成的时间。
 策略：所有事件中的最短时间是昭君踢正步(1小
时)，由于该事件是第二阶段，则将其最后执行；
此短时间是探春站军姿(2小时)，由于该事件是第一
阶段，则将其优先执行；以此类推。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59fd2d642d.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59fe089858.png)


Code：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac59ffa828ac.png)





# 三字母字符串组合


 仅由三个字符A、B、C构成字符串，且字符
串任意三个相邻元素不能完全相同。如
“ACCCAB”不合法，“ABBCBCA”合法。求
满足条件的长度为n的字符串个数。
 假定不考虑整数溢出
 要求时间和空间复杂度不高于O(N)。

问题分析
 若当前已经有了所有长度为n-1的合法字符
串，如何在末端增加一个字符，形成长度为
n的字符串呢？
 将长度为n-1字符串分成“末尾两个字符不相
等”和“末尾两个字符相等”两种情况，各自
数目记做dp[n-1][0], dp[n-1][1]：



dp[n][0]结尾不相等 / dp[n][1]结尾相等

 ♂♀◎
 ××……×♂♀ /××……×♂♂
 dp[n][0]=2*dp[n-1][0]+ 2*dp[n-1][1]
 ××……× ♂♀ ♂，××……×♂♀ ◎
 ××……× ♂♂ ♀，××……×♂♂ ◎
 dp[n][1]=dp[n-1][0]
 ××……×♂♀ ♀
 初始条件
 dp[1][0]=3
 dp[1][1]=0

状态转移方程总结与改进


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5a042ad269.png)


Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5a05195c6f.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5a055b9c8b.png)


矩阵表示与O(logN)时间复杂度


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5a06ef0525.png)


Code2


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5a07dc0e0e.png)


算法
 所学并非无用，而是知识体系尚未达到能够
用它的程度。
 思想恒久远，算法永流传
 据传，三国时期诸葛亮实施空城计。
 傅作义偷袭西柏坡，毛主席重演空城计。
 三千年前欧几里德发明
辗转相除法，迄今仍被
广大程序员所使用



结束语
 知识的掌握是1,2,4,8,16……的速度；
 每天递增0.01：1.01 365 =?
 设置适合自己的“学习率”。
 掌握算法的根本途径是多练习代码。
 书读百遍，其义自见。
 算法远远没有到此为止……
 下列属于算法范畴吗？
 网站开发/OA工作流
 操作系统资源调度/编译原理词法、语法、语义分析/数据
库设计/计算机网络协议包解析
 机器学习/数据挖掘/计算机视觉
 ……


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5aa31d3f79.png)





# COMMENT：





# REF：






  1. 七月在线 算法
