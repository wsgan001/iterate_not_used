
# 主要内容


 动态规划和贪心的认识
 工具：马尔科夫过程
 贪心法
 Prim算法
 Kruskal算法
 Dijkstra算法
 动态规划
 最长递增子序列LIS
 矩阵连乘的最少乘法
 字符串的交替连接
 走棋盘/格子取数问题及其应用
 带陷阱的走棋盘问题
 两次走棋盘问题
 Catalan数简介


# Palindrome Partitioning所有划分


 给定一个字符串str，将str划分成若干子串，
使得每一个子串都是回文串。计算str的所有
可能的划分。
 单个字符构成的字符串，显然是回文串；所
以，这个的划分一定是存在的。
 如：s=“aab”，返回
 “aa”，“b”；
 “a”，“a”，“b”。




## 回文划分问题Palindrome Partitioning


 思考：若当前计算得到了str[0…i-1]的所有划
分，可否添加str[i…j]，得到更大的划分呢？
 显然，若str[i…j]是回文串，则可以添加。
 剪枝：在每一步都可以判断中间结果是否为
合法结果。
 回溯+剪枝——如果某一次发现划分不合法，立
刻对该分支限界。
 一个长度为n的字符串，最多有n-1个位置可以截
断，每个位置有两种选择，因此时间复杂度为
O(2 n-1 )=O(2 n ) 。


## Code




## ![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57720bc176.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57746b025a.png)





## 继续思考：动态规划


 如果已知：str[0…i-1]的所有回文划分φ(i)，
 如何求str[0…i]的所有划分呢？
 如果子串str[j…i]是回文串，则将该子串和φ(j-1)共同添
加到φ(i+1)中。
 算法：
 将集合φ(i+1)置空；
 遍历j(0≤j＜i)，若str[j,j+1…i]是回文串，则将{str[j…i]，
φ(j-1)}添加到φ(i+1)中；
 i从0到n，依次调用上面两步，最终返回φ(n)即为所求。

代码如下：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5775355ef5.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5775815c56.png)





## Palindrome Partitioning思考


 与之类似的：
 给定仅包含数字的字符串，返回所有可能的有
效IP地址组合。如：“25525511135”，返回
“255.255.11.135”，“255.255.111.35”。
 该问题只插入3个分割位置。
 只有添加了第3个分割符后，才能判断当前划分
是否合法。
 如： 2.5.5.25511135，才能判断出是非法的。
 当然，它可以通过“25511135”大于“255.255”等其他限界
条件“事先”判断。




# DFS与DP深刻认识


 DFS的过程，是计算完成了str[0…i]的切分，然后
递归调用，继续计算str[i+1,i+2…n-1]的过程；
 而DP中，假定得到了str[0…i-1]的所有可能切分方
案，如何扩展得到str[0…i]的切分；
 上述两种方法都可以从后向前计算得到对偶的分析。
 从本质上说，二者是等价的：最终都搜索了一颗隐
式树。
 DFS显然是深度优先搜索的过程，而DP更像层序遍历的
过程。
 如果只计算回文划分的最少数目，动态规划更有优势；
如果计算所有回文划分，DFS的空间复杂度比DP略优。




# 认识论


 认识事物的方法：概念、判断、推理
 推理中，又分为归纳、演绎。
 重点考察归纳推理的具体方法。
 形式化表述：
 已知：问题规模为n的前提A
 求解/求证：未知解B/结论B
 记号：用A n 表示“问题规模为n的已知条件”




# 对归纳推理的理解


 若将问题规模降低到0，即已知A 0 ，很容易计算或
证明B，则有： A 0 →B
 同时，考察从A 0 增加一个元素，得到A1的变化过
程。即：A 0 →A 1 ；
 进一步考察A 1 →A 2 ，A 2 →A 3 ……A i →A i+1
 这种方法是(严格的)归纳推理，常常被称作数学归纳法。
 此时，由于上述推导往往不是等价推导(A i 和A i+1 不是互
为充要条件)，导致随着i的增加，有价值的前提信息越来
越少；为避免这一问题，采取如下方案：
 {A 1 }→A 2 ，{A 1 A 2 }→A 3 …… {A 1 A 2 …A i }→A i+1
 相对应的，修正后的方法依然是(严格的)归纳推理，有时
被称作第二数学归纳法。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5778d0cac9.png)





## 对归纳推理的理解


 基本归纳法：对于A i+1 ，只需考察前一个状态A i 即可完成整个推理
过程，它的特点是只要状态A i 确定，则计算A i+1 时不需要考察更前
序的状态A 1 …A i-1 ，在图论中，常常称之为马尔科夫模型；

 高阶归纳法：相应的，对于A i+1 ，需考察前i个状态集{A 1 A 2 …A i-1 A i }
才可完成整个推理过程，往往称之为高阶马尔科夫模型；
 在计算机算法中，高阶马尔科夫模型的推理，叫做“动态规划”，而
马尔科夫模型的推理，对应“贪心法”。

![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac577a83a686.png)


## 以上理解的说明


 无论动态规划还是贪心法，都是根据A[0…i]计算
A[i+1]的过程
 计算A[i+1]不需要A[i+2]、A[i+3]……，
 一旦计算完成A[i+1]，再后面计算A[i+2]、A[i+3]……
时，不会更改A[i+1]的值。
 这即无后效性。
 亦可以如下理解动态规划：计算A[i+1]只需要知道
A[0…i]的值，无需知道A[0…i]是通过何种途径计
算得到的——只需知道它们当前的状态值本身即
可。如果将A[0…i]的全体作为一个整体，则可以认
为动态规划法是马尔科夫过程，而非高阶马尔科夫
过程。


# 贪心法


 根据实际问题，选取一种度量标准。然后按照这种
标准对n个输入排序，并按序一次输入一个量。
 如果输入和当前已构成在这种量度意义下的部分最
优解加在一起不能产生一个可行解，则不把此输入
加到这部分解中。否则，将当前输入合并到部分解
中从而得到包含当前输入的新的部分解。
 这一处理过程一直持续到n个输入都被考虑完毕，
则记入最优解集合中的输入子集构成这种量度意义
下的问题的最优解。
 这种能够得到某种量度意义下的最优解的分级处理
方法称为贪心方法。




## 最小生成树MST


 最小生成树要求从一个带权无向连通图中选择n－1
条边并使这个图仍然连通(也即得到了一棵生成
树)，同时还要考虑使树的权最小。为了得到最小
生成树，人们设计了很多算法，最著名的有Prim算
法和Kruskal算法，这两个算法都是贪心算法。
 Prim算法：从某个(任意一个)结点出发，选择与该结点邻
接的权值最小的边；随着结点的不断加入，每次都选择
这些结点发出的边中权值最小的：重复n-1次。
 Kruskal算法：将边按照权值递增排序，每次选择权值最
小并且不构成环的边，重复n-1次。


## 最短路径


 将Prim算法稍做调整，就得到Dijkstra最短路
径算法：
 结点集V初始化为源点S一个元素：V={S}，到
每个点的最短路径的距离初始化为
dist[u]=graph[S][u]；
 选择最小的dist[u]：记dist[v]是最小的，则v是当
前找到的不在V中且距离S最近的结点，更新
V=V∪{v}，调整
dist[u]=min{dist[u],dist[v]+graph[v][u]}；
 重复n-1次。




## 贪心法的思考


 可以看到，在从A i 到A i+1 的扩展过程中，上
述三个算法都没有使用A[0…i-1]的值。
 往往看名字，认为它很简单；事实上，贪心
法其实并不轻松，它需要严格证明一定与更
先序的值无关。
 思考：从1元、2元、5元的纸币，问给定总价值
N元，最少需要几张纸币？




# 最长递增子序列LIS


 Longest Increasing Subsequence
 给定一个长度为N的数组，找出一个最长的
单调递增子序列(不一定连续，但是顺序不
能乱)。例如：给定一个长度为6的数组
A{5， 6， 7， 1， 2， 8}，则其最长的单调
递增子序列为{5，6，7，8}，长度为4。
 分析：其实此LIS问题可以转换成最长公子序列
问题，为什么呢？




## 附：使用LCS解LIS问题


 原数组为A {5， 6， 7， 1， 2， 8}
 排序后：A’{1， 2， 5， 6， 7， 8}
 因为，原数组A的子序列顺序保持不变，而
且排序后A’本身就是递增的，这样，就保证
了两序列的最长公共子序列的递增特性。如
此，若想求数组A的最长递增子序列，其实
就是求数组A与它的排序数组A’的最长公共
子序列。




## 前缀分析


 “1”：1
 “14”：14
 “146”：146
 “1462”：146
 “14628”：1468
 “146289”：14689
 “1462897”：14689


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5782f20f3d.png)





## 最长递增子序列LIS记号


 长度为N的数组记为A={a 0 a 1 a 2 ...a n-1 }；
 记A的前i个字符构成的前缀串为A i =
a 0 a 1 a 2 ...a i-1 ，以a i 结尾的最长递增子序列记做
L i ，其长度记为b[i]；
 假定已经计算得到了b[0,1…,i-1]，如何计算
b[i]呢？
 已知L 0 L 1 ……L i-1 的前提下，如何求L i ？


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5783b65251.png)





## 求解LIS


 根据定义， L i 必须以a i 结尾；
 如果将a i 分别缀到L 0 L 1 ……L i-1 后面，是否允许呢？
 如果a i ≥a j ，则可以将a i 缀到L j 的后面，得到比L j 更长
的字符串。
 从而：b[i]={max(b[j])+1, 0≤j＜i且a j ≤a i }
 计算b[i]：遍历在i之前的所有位置j，找出满足条件
a j ≤a i 的最大的b[j]+1；
 计算得到b[0…n-1]后，遍历所有的b[i]，找出最大值
即为最大递增子序列的长度。
 时间复杂度为O(N 2 )。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57847d0950.png)


LIS的思考
 思考：如何求最大递增子序列本身？
 记录前驱


## Code1：




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5785ee1637.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57876ec843.png)





## O(NlogN)的最长递增子序列算法


 对于数组A={1,4,6,2,8,9,7}
 1
 1,4
 1,4,6
 1,2,6
 1,2,6,8
 1,2,6,8,9
 1,2,6,7,9


## Code2





## ![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57899d052f.png)





# 矩阵乘积


 根据矩阵相乘的定义来计算 C=A×B，需要m*n*s
次乘法。
 三个矩阵A、B、C的阶分别是a 0 ×a 1 , a 1 ×a 2 ,
a 2 ×a 3 ，从而(A×B)×C和A×(B×C)的乘法次数是
a 0 a 1 a 2 +a 0 a 2 a 3 、 a 1 a 2 a 3 +a 0 a 1 a 3 ，二者一般情况是不相
等的。
 问：给定n个矩阵的连乘积：A 1 ×A 2 ×A 3 ……×A n ，如
何添加括号来改变计算次序，使得乘法的计算量最小？
 此外：若A、B都是n阶方阵，C的计算时间复杂度
为O(n 3 )
 问：可否设计更快的算法？
 答：分治法：Strassen分块——理论意义大于实践意义。


## 矩阵连乘的提法


 给定n个矩阵{A 1 ,A 2 ,…,A n }，其中A i 与A i+1 是
可乘的，i=1，2…，n-1。考察该n个矩阵的
连乘积： A 1 ×A 2 ×A 3 ……×A n ，确定计算
矩阵连乘积的计算次序，使得依此次序计算
矩阵连乘积需要的乘法次数最少。
 即：利用结合律，通过加括号的方式，改变计
算过程，使得数乘的次数最少。




## 分析


 将矩阵连乘积 记为A[i:j] ，这里i≤j
 显然，若i==j，则A[i:j]即A[i]本身。
 考察计算A[i:j]的最优计算次序。设这个计算
次序在矩阵A k 和A k+1 之间将矩阵链断开，
i≤k<j，则其相应的完全加括号方式为


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57c794d4bd.png)


 计算量：A[i:k]的计算量加上A[k+1:j]的计算
量，再加上A[i:k]和A[k+1:j]相乘的计算量


## 最优子结构


 特征：计算A[i:j]的最优次序所包含的计算矩
阵子链 A[i:k]和A[k+1:j]的次序也是最优的。
 矩阵连乘计算次序问题的最优解包含着其子
问题的最优解。这种性质称为最优子结构性
质。
 最优子结构性质是可以使用动态规划算法求
解的显著特征。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57c91594e9.png)





## 矩阵连乘问题从算法到实现




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57c9f16b38.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57ca24a643.png)





## 代码如下：




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57cb3523ef.png)





# 找零钱


 给定某不超过100万元的现金总额，兑换成
数量不限的100、50、10、5、2、1的组合，
共有多少种组合呢？


## 该问题的思考过程


 此问题涉及两个类别：面额和总额。
 如果面额都是1元的，则无论总额多少，可行的
组合数显然都为1。
 如果面额多一种，则组合数有什么变化呢？
 定义dp[i][j]：使用面额小于等于i的钱币，凑
成j元钱，共有多少种组合方法。
 dp[100][500] = dp[50][500] + dp[100][400]
 dp[i][j] = dp[i small ][j] + dp[i][j-i]
 不考虑 j-i 下溢出等边界问题


## 递推公式 dp[i][j] = dp[i small ][j] + dp[i][j-i]




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57cdbac5f6.png)


Code：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57ceb41df8.png)





## 滚动数组


将状态转移方程去掉第一维，很容易使用滚
动数组，降低空间使用量。
 原状态转移方程：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57cfb4d2e6.png)


滚动数组版本的状态转移方程：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57d055c80f.png)




Code：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57d0cef30b.png)





## 总结与思考


 请问：本问题的时间复杂度是多少？
 在动态规划的问题中，如果不求具体解的内
容，而只是求解的数目，往往可以使用滚动
数组的方式降低空间使用量（甚至空间复杂
度）
 由于滚动数组减少了维度，甚至代码会更简单
 思考0-1背包问题和格子取数问题。






## 走棋盘/格子取数


 给定m×n的矩阵，每个位置是一个非负整
数，从左上角开始，每次只能朝右和下走，
走到右下角，求总和最小的路径。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57d27352f5.png)





## 状态转移方程


 走的方向决定了同一个格
子不会经过两次。
 若当前位于(x,y)处，它来自于哪些格子呢？
 dp[0,0]=a[0,0] / 第一行(列)累积
 dp[x,y] = min(dp[x-1,y]+a[x,y],dp[x,y-1]+a[x,y])
 即：dp[x,y] = min(dp[x-1,y],dp[x,y-1]) +a[x,y]
 思考：若将上述问题改成“求从左上到右下
的最大路径”呢？


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57d351a631.png)





## 状态转移方程




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57d6fa444a.png)





## Code：




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57d7f72fd1.png)





## GIS中的应用




## ![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57d904b8c1.png)


如果三维曲线是封闭线…


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57d99f0ffc.png)


GIS中三维建模的实际应用

右上：未使用引导线
 左下：输入的引导线
 右下：过引导线的曲面


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57dabe5e72.png)





# 带陷阱的走棋盘


 有一个n*m的棋盘网格，机器人最开始在左
上角，机器人每一步只能往右或者往下移
动。棋盘中有些格子是禁止机器人踏入的，
该信息存放在二维数组blocked中，如果
blocked[i][j]为true，那么机器人不能踏入格
子(i,j)。请计算有多少条路径能让机器人从
左上角移动到右下角。


## 状态转移方程


 dp[i][j]表示从起点到(i,j)的路径条数。
 只能从左边或者上边进入一个格子
 如果(i,j)被占用
 dp[i][j]=0
 如果(i,j)不被占用
 dp[i][j]=dp[i-1][j]+dp[i][j–1]
 思考：如果没有占用的格子呢？
 一共要走m+n–2步，其中(m–1)步向右，(n-1)步向
下。组合数C(m+n–2,m-1)=C(m+n-2,n-1)


## 陷阱走棋盘


 在8×6的矩阵中，每次只能向上或向右移动一
格，并且不能经过P。试计算从A移动到B一共有
多少种走法。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5863384495.png)





## 解题过程


 从A到B共需要移动12步，其中7步向右，5
步向上，可行走法数目为\(C_12^5=792\)
 从A到P共需要8步，其中5步向右，3步向
上，可行走法数目为\(C_8^5=56\)
 从P到B共需要4步，其中2步向右，2步向
上，可行走法数目为\(C_4^2=6\)
 则，从A到B经过P的路线有56*6=336种；
 从A到B不经过P的路线有792-336=456种。


## 方格的可行路径数目




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57e32ece2b.png)


思考题：两次走棋盘
 给定m*n的矩阵，每个位置是一个非负的权
值，从左上角开始，每次只能朝右和下走，
走到右下角；然后，从右下角开始，每次只
能朝左和朝上走，走到左上角。求权值总和
最大的路径。若相同格子走过两次，则该位
置的权值只算一次。

代码如下：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57e47c0028.png)





# 动态规划总结


 动态规划是方法论，是解决一大类问题的通用思路。
事实上，很多内容都可以归结为动态规划的思想。
 KMP中求next数组：已知next[0…i-1]，求next[i]；
 最长回文子串Manacher算法中，已知P[0…i-1]求P[i]
 何时可以考虑使用动态规划：
 初始规模下能够方便的得出结论
 空串、长度为0的数组、自身等
 能够得到问题规模增大导致的变化
 递推式——状态转移方程


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57e4fdd47c.png)





## 动态规划总结


 无后效性
 计算A[i]时只读取A[0…i-1]，不修改——历史
 计算A[i]时不需要A[i+1…n-1]的值——未来
 在实践中往往忽略无后效性：
 问题本身决定了它是成立的：格子取数问题
 通过更改计算次序可以达到该要求：矩阵连乘问题
 哪些题目不适合用动态规划？
 状态转移方程的推导，往往陷入局部而忽略全局。
在重视动态规划的同时，别忘了从总体把握问题。


# 思考题：字符串的交替连接


 输入三个字符串s1、s2和s3，判断第三个字
符串s3是否由前两个字符串s1和s2交错而
成，即不改变s1和s2中各个字符原有的相对
顺序，例如当s1=“aabcc”，s2=“dbbca”，
s3=“aadbbcbcac”时，则输出true，但如果
s3=“accabdbbca”，则输出false。
 换个表述：
 s1和s2是s3的子序列，且s1∪s2=s3

Code：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57e898d296.png)


Code2：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57e9372c33.png)





# COMMENT：




# REF：

1. 七月在线 算法
