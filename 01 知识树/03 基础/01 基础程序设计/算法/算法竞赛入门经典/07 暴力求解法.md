第7章 暴力求解法

学习目标

E掌握整数、子串等简单对象的枚举方法

E熟练掌握排列生成的递归方法

叵熟练掌握用“下一个排列”枚举全排列的方法

E理解解答树，并能估算典型解答树的结点数

E熟练掌握子集生成的增量法、位向量法和二进制法

E熟练掌握回溯法框架，并能理解为什么它往往比生成-测试法高效

叵掌握回溯法的常见优化方法

叵熟练掌握八数码问题的BFS实现，包括结点查找表的哈希实现和STL集合实现 叵熟练掌握埃及分数问题的IDA*实现

很多问题都可以“暴力解决”——不用动太多脑筋，把所有可能性都列举出来，然后一一

试验。尽管这样的方法显得很“笨”，但却常常是行之有效的。

###### 7.1 简单枚举

在枚举复杂对象之前，先尝试着枚举一些相对简单的内容，如整数、子串等。尽管暴力

枚举不用太动脑筋，但对问题进行一定的分析往往会让算法更加简洁、高效。

提示7-1：即使采用暴力法求解问题，对问题进行一定的分析往往会让算法更简洁、高

效。

例题7-1 除法( Division, UVa 725)

输入正整数《 ,按从小到大的顺序输出所有形如冰汝加；/ = «的表达式，其中恰好 为数字0〜9的一个排列（可以有前导0 ） , 2<n<79。

样例输入：

62

样例输出：

79546 / 01283 = 62

94736 / 01528 = 62

【分析】

枚举0〜9的所有排列？没这个必要。只需要枚举:就可以算出泌,然后判断是否 所有数字都不相同即可。不仅程序简单，而且枚举量也从10!=3628800降低至不到1万，而且 当abcde和fghj加起来超过10位时可以终止枚举。由此可见，即使采用暴力枚举，也是需要认

真分析问题的。

例题7-2 最大乘积(Maximum Product, UVa 11059 )

输入n个元素组成的序列^ ,你需要找出一个乘积最大的连续子序列。如果这个最大的乘 积不是正数，应输出0（表示无解）。 1<n<18， -10<Si<10。

样例输入：

2 4-3

5

2 5 -1 2 -1 样例输出：

8

20

分析】

连续子序列有两个要素：起点和终点，因此只需枚举起点和终点即可。由于每个元素的 绝对值不超过10且不超过18个元素，最大可能的乘积不会超过1018 ,可以用long long存储。

例题7-3 分数拆分(Fractions Again?!, UVa 10976 )

输入正整数A ,找到所有的正整数,



使得



样例输入：

2

12

样例输出：

2

1/2 = 1/6 + 1/3 1/2 = 1/4 + 1/4

1/12 = 1/156 + 1/13

1/12 = 1/84 + 1/14

1/12 = 1/60 + 1/15 1/12 = 1/48 + 1/16 1/12 = 1/36 + 1/18 1/12 = 1/30 + 1/20 1/12 = 1/28 + 1/21

1/12 = 1/24 + 1/24

【分析】

既然要求找出所有的^、y ,枚举对象自然就是^、y了。可问题在于，枚举的范围如何？ 从1/12=1/156+1/13可以看出，义可以比y大很多。难道要无休止地枚举下去？当然不是。由

于论y，有i ,因此    ,即y<2怂这样，只需要在2&范围之内枚举y ,然后根据y尝试

x y    k y y

计算出即可。

###### 7.2 枚举排列

有没有想过如何打印所有排列呢？输入整数n ,按字典序从小到大的顺序输出前n个数的 所有排列。前面讲过，两个序列的字典序大小关系等价于从头开始第一个不相同位置处的大 小关系。例如，（1,3,2） < （2,1,3）,字典序最小的排列是（1,2, 3, 4,…，n）,最大的排列是（n, n-1, n-2,…，1）。n=3时，所有排列的排序结果是（1, 2, 3）、（1, 3, 2）、（2, 1, 3）、（2, 3, 1）、（3, 1, 2）、 （3, 2, 1）。

7.2.1 生成1~ n的排列

我们尝试用递归的思想解决：先输出所有以1开头的排列（这一步是递归调用），然后 输出以2开头的排列（又是递归调用），接着是以3开头的排列……最后才是以n开头的排 列。

以1开头的排列的特点是：第一位是1 ,后面是2〜9的排列。根据字典序的定义，这些2 〜9的排列也必须按照字典序排列。换句话说，需要“按照字典序输出2〜9的排列”，不过需 注意的是，在输出时，每个排列的最前面要加上“1”。这样一来，所设计的递归函数需要以 下参数：

□已经确定的“前缀”序列，以便输出。

□需要进行全排列的元素集合，以便依次选做第一个元素。

这样可得到一个伪代码：

void print_permutation（ 序列A,集合S）

{

if（S为空）输出序列A;

else 按照从小到大的顺序依次考虑S的每个元素v

{

print_permutation （在A的末尾填加v后得到的新序列，S-{v}）;

}

暂时不用考虑序列A和集合S如何表示，首先理解一下上面的伪代码。递归边界是S为空 的情形，这很好理解：现在序列A就是一个完整的排列，直接输出即可。接下来按照从小到

大的顺序考虑S中的每个元素，每次递归调用以A开头。

下面考虑程序实现。不难想到用数组表示序列A ,而集合S根本不用保存，因为它可以 由序列A完全确定——A中没有出现的元素都可以选。C语言中的函数在接受数组参数时无法 得知数组的元素个数，所以需要传一个已经填好的位置个数，或者当前需要确定的元素位置 cur ,代码如下：

void print_permutation(int n, int* A, int cur) { if(cur == n) {    //递归边界

for(int i = 0; i < n; i++) printf("%d ", A[i]); printf("\n");

}

else for(int i = 1; i <= n; i++) {    //尝试在A[cur]中填各种整数i

int ok = 1;

for(int j = 0; j < cur; j++)

if(A[j] == i) ok = 0;    //如果i已经在A[0] ~A[cur-1]出现过，则不能再选

if(ok) {

A[cur] = i;

pr int_permutati on ( n, A, cur+1); // 递归调用

循环变量i是当前考察的A[cur]。为了检查元素1是否已经用过，上面的程序用到了一个 标志变量ok ,初始值为1 (真)，如果发现有某个A[j]==i时，则改为0 (假)。如果最终ok仍 为1 ,则说明i没有在序列中出现过，把它添加到序列末尾(A[cur]=i )后递归调用。

声明一个足够大的数组A ,然后调用print_permutation(n, A, 0),即可按字典序输出1〜n的 所有排列。

7.2.2 生成可重集的排列

如果把问题改成：输入数组P ,并按字典序输出数组A各元素的所有全排列，则需要对

上述程序进行修改-把P加到print_permutation的参数列表中，然后把代码中的if(A[j] == i)

和A[cur] = i分别改成if(A[j] == P[i])和A[cur] = P[i]。这样，只要把P的所有元素按从小到大的

顺序排序，然后调用print_permutation(n, P, A, 0)即可。

这个方法看上去不错，可惜有一个小问题：输入1 1 1后，程序什么也不输出(正确答案 应该是唯一的全排列1 1 1)，原因在于，这样禁止A数组中出现重复，而在P中本来就有重

复元素时，这个“禁令”是错误的。

—个解决方法是统计A[0]〜A[cur-1]中P[i]的出现次数c1 ,以及P数组中P[i]的出现次数 c2。只要c1<c2 ,就能递归调用。

| else for(int | i =  | 0;   | i < n; i++) {               |         |
| ------------ | ---- | ---- | --------------------------- | ------- |
| int c1 = 0,  | c2   | =    | 0;                          |         |
| for(int j =  | 0;   | j    | < cur; j++) if(A[j] == P[i] | ) c1++; |
| for(int j =  | 0;   | j    | < n; j++) if(P[i] == P[j])  | c2++;   |
| if(c1 < c2)  | {    |      |                             |         |
| A[cur] =     | P[i] | ;    |                             |         |

print_permutation(n, P, A, cur+1);

}

结果又如何呢？输入1 1 1，输出了27个1 1 1。遗漏没有了，但是出现了重复：先试着把 第1个1作为开头，递归调用结束后再尝试用第2个1作为开头，递归调用结束后再尝试用第3 个1作为开头，再—次递归调用。可实际上这3个1是相同的，应只递归1次，而不是3次。

换句话说，我们枚举的下标i应不重复、不遗漏地取遍所有P[i]值。由于P数组已经排过 序，所以只需检查P的第一个元素和所有“与前一个元素不相同”的元素，即只需在“for(i = 0; i < n; i++)”和其后的花括号之前加上“if(!i || P[i] != P[i-1])”即可。

至此，结果终于正确了。

7.2.3 解答树

假设《=4 ,序列为{1,2,3,4},如图7-1所示的树显示出了递归函数的调用过程。其中，结 点内部的序列表示A ,位置cur用高亮表示，另外，由于从该处开始的元素和算法无关，因此 用星号表示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-75.jpg)



这棵树和前面介绍过的二叉树不同。第0层(根)结点有《个子结点，第1层结点各有《-1 个子结点，第2层结点各有仏2个子结点，第3层结点各有《-3个子结点，……,第《层结点都 没有子结点(即都是叶子)，而每个叶子对应于一个排列，共有《!个叶子。由于这棵树展示 的是从“什么都没做”逐步生成完整解的过程，因此将其称为解答树。

提示7-2 ：如果某问题的解可以由多个步骤得到，而每个步骤都有若干种选择(这些候 选方案集可能会依赖于先前作出的选择)，且可以用递归枚举法实现，则它的工作方式可以 用解答树来描述。

这棵解答树一共有多少个结点呢？可以逐层查看：第0层有1个结点，第1层《个，第2层 有^>1)个结点(因为第1层的每个结点都有《-1个结点)，第3层有^>1)*(什2)个(因为第 2层的每个结点都有《-2个结点)， ，第《层有《*(«-1)*(«-2)*...*2*1=«!个。

下面把它们加起来。为了推导方便，把w*(«-1)*(«-2)*…*(«-k)写成《!/(«-k-1)!,则所有结 点之和为：

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-76.jpg)



根据高等数学中的泰勒展开公式，⑴，因此门川由于叶子有《!

个，倒数第二层也有《!个结点，因此上面的各层全部加起来也不到《!。这是一个很重要的结

论：在多数情况下，解答树上的结点几乎全部来源于最后一两层。和它们相比，上面的结点

数可以忽略不计。

不熟悉泰勒展开公式也没有关系：



可以写一个程序，输脊着漱时的变化，并发



现它能很快收敛。这就是计算机的优点之一——可以通过模拟避开数学推导。即使无法严密

而精确地求解，也可以找到令人信服的实验数据。

7.2.4 下一个排列

枚举所有排列的另一个方法是从字典序最小排列开始，不停调用“求下一个排列”的过 程。如何求下一^个排列呢？ C++的STL中提供了 一^个库函数neX_permutation。看看下面的代 码片段，就会明白如何使用它了。

\#include<cstdio>

\#include<algorithm> / / 包含next_permutation using namespace std; int main( )    {

int n, p[10]; scanf("%d", &n);

for(int i = 0; i < n; i++) scanf("%d", sort(p, p+n); do {

&p[i]);

//排序，得到p的最小排列

",p[i] )；    //输出排列p

//求下一个排列



for(int i = 0; i < n; i++) printf("%d printf("\n");

} while(next_permutation(p, p+n)); return 0;

}

需要注意的是，上述代码同样适用于可重集。

提示7-3 :枚举排列的常见方法有两种：一是递归枚举，二是用STL中的

next_permutation。

###### 7.3 子集生成

第7.2节中介绍了排列生成算法。本节介绍子集生成算法：给定—个集合，枚举所有可

能的子集。为了简单起见，本节讨论的集合中没有重复元素。

7.3.1    增量构造法

第—种思路是—次选出—个元素放到集合中，程序如下：

void print_subset(int n, int* A, int cur) ｛ for(int i = 0; i < cur; i++) printf("%d ", A[i]);    // 打印当前集合

printf("\n");

int s = cur ? A[cur-1]+1 : 0;    // 确定当前元素的最小可能值

for(int i = s; i < n; i++) ｛

A[cur] = i;

print_subset(n, A, cur+1);    // 递归构造子集

｝

｝

和前面不同，由于中的元素个数不确定，每次递归调用都要输出当前集合。另外，递 归边界也不需要显式确定——如果无法继续添加元素，自然就不会再递归了。

上面的代码用到了定序的技巧：规定集合乂中所有元素的编号从小到大排列，就不会把 集合｛1, 2｝按照｛1, 2｝和｛2, 1｝输出两次了。

提示7-4：在枚举子集的增量法中，需要使用定序的技巧，避免同—个集合枚举两次。

这棵解答树上有1024个结点。这不难理解：每个可能的乂都对应一个结点，而《元素集合 恰好有2"个子集，210=1024。

7.3.2    位向量法

第二种思路是构造一个位向量珂/],而不是直接构造子集本身，其中研/]=1 ,当且仅 当/在子集4中。递归实现如下：

void print_subset(int n, int* B, int cur) {

for(int i = 0; i < cur; i++) if(B[i]) printf("%d ",    i);

printf("\n");

return;

}

B[cur] = 1;

print_subset(n, B, cur+1); B[cur] = 0;

print_subset(n, B, cur+1);

}

// 打印当前集合



//选第cur个元素

//不选第cur个元素



必须当“所有元素是否选择”全部确定完毕后才是一个完整的子集，因此仍然像以前那样 当if（cur == n）成立时才输出。现在的解答树上有2047个结点，比刚才的方法略多。这个也不 难理解：所有部分解（不完整的解）也对应着解答树上的结点。

提示7-5 ：在枚举子集的位向量法中，解答树的结点数略多，但在多数情况下仍然够

快。

这是一棵n+1层的二叉树（cur的范围从0〜n ）,第0层有1个结点，第1层有2个结点，第 2层有4个结点，第3层有8个结点，......,第/层有2'个结点，总数为1+2+4+8+...+2n=2n+M ,

和实验结果一致。如图7-2所示为这棵解答树。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-77.jpg)



这棵树依然符合前面的观察结果：最后几层结点数占整棵树的绝大多数。

7.3.3 二进制法

另外，还可以用二进制来表示｛0, 1, 2，...，"-1｝的子集^ :从右往左第/位（各位从0开始编 号）表示元素z•是否在集合S中。图7-3展示了二进制0100011000110111是如何表示集合｛0，1, 2, 4, 5, 9, 10, 14｝的。

图7-3 用二进制表示子集

注意：为了处理方便，最右边的位总是对应元素0，而不是元素1。

提示7-6 :可以用二进制表示子集，其中从右往左第1位（从0开始编号）表示元素i是否 在集合中（ 1表示“在”， 0表示“不在”）。

此时仅表示出集合是不够的，还需要对集合进行操作。幸运的是，常见的集合运算都可 以用位运算符简单实现。最常见的二元位运算是与（ &）、或（ |）、非（ !），它们和对应 的逻辑运算非常相似，如表7-1所示。

表7-1 C语言中的二元位运算

| A    | B    | A& B | A \| B | A AB |
| ---- | ---- | ---- | ------ | ---- |
| 0    | 0    | 0    | 0      | 0    |
| 0    | 1    | 0    | 1      | 1    |
| 1    | 0    | 0    | 1      | 1    |
| 1    | 1    | 1    | 1      | 0    |

表7-1中包括了“异或（XOR） ”运算符“A”，其规则是“如果A和B不相同，则AAB为1 ,否 则为0”。异或运算最重要的性质就是“开关性”——异或两次以后相当于没有异或，即 Aabab=a。另外，与、或和异或都满足交换律：A&B=B&A , A|B=B|A , AAB=BAA。

与逻辑运算符不同的是，位运算符（bitwise operator ）是逐位进行的——两个32位整数 的“按位与”相当于32对0/1值之间的运算。表7-2中表示了二进制数10110（十进制为22）和

01100(十进制为12)之间的按位与、按位或、按位异或的值，以及对应的集合运算的含

义。

表7-2 位运算与集合运算

|        | A       | B     | A&B   | A\|B      | AAB     |
| ------ | ------- | ----- | ----- | --------- | ------- |
| 二进制 | 10110   | 01100 | 00100 | 11110     | 11010   |
| 集合   | {1,2,4} | {2,3} | {2}   | {1,2,3,4} | {1,3,4} |

不难看出，A&B、A|B和AAB分别对应集合的交、并和对称差。另外，空集为0 ,全集｛0,

1,    2,…，«-1｝的二进制为《个1 ,即十进制的2"-1。为了方便，往往在程序中把全集定义为

ALL_BITS= (1<<n)-1 ,则A的补集就是ALL_BITSAA。当然，直接用整数减法ALL_BITS -A也 可以，但速度比位运算“A”慢。

提示7-7 ：当用二进制表示子集时，位运算中的按位与、或、异或对应集合的交、并和 对称差。

这样，不难用下面的程序输出子集S对应的各个元素：

void print_subset (int n, int s) {    //打印{0, 1, 2,..., n-1}的子集 S

for(int i = 0; i < n; i++)

if (s& (1<<i) ) printf ( "%d ", i);    //这里利用了C语言"非0值都为真”的规定

printf("\n");

}

而枚举子集和枚举整数一样简单：

for(int i = 0; i < (1<<n); i++)    //枚举各子集所对应的编码0, 1, 2,..., 2n-1

print_subset(n, i);

提示7-8：从代码量看，枚举子集的最简单方法是二进制法。

###### 7.4 回溯法

无论是排列生成还是子集枚举，前面都给出了两种思路：递归构造和直接枚举。直接枚

举法的优点是思路和程序都很简单，缺点在于无法简便地减小枚举量——必须生成

( generate )所有可能的解，然后一一检查( test)。

另一方面，在递归构造中，生成和检查过程可以有机结合起来，从而减少不必要的枚

举。这就是本节的主题——回溯法( backtracking)。

回溯法的应用范围很广，只要能把待求解的问题分成不太多的步骤，每个步骤又只有不

太多的选择，都可以考虑应用回溯法。为什么说“不太多”呢？想象一棵包含£层，每层的分

支因子均为A的解答树，其结点数高达卜\    心无论是A太大还是£太大，结点

b — \

数都会是一个天文数字。

回溯法是初学者学习暴力法的第一个障碍，学习时间短则数天，长则数月甚至一年

以上。为了减少不必要的困扰，在学习回溯法之前，请读者确保7.2节和7.3节的所有递归程

序都可以熟练、准确地写出。

7.4.1 八皇后问题

在棋盘上放置8个皇后，使得它们互不攻击，此时每个皇后的攻击范围为同行同列和同

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-79.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-80.jpg)



(a )皇后的攻击范围



(b)—个可行解

图7-4 八皇后问题

【分析】

最简单的思路是把问题转化为“从64个格子中选一个子集”，使得“子集中恰好有8个格 子，且任意两个选出的格子都不在同一行、同一列或同一个对角线上”。这正是子集枚举问 题。然而， 64个格子的子集有264个，太大了，这并不是一个很好的模型。

第二个思路是把问题转化为“从64个格子中选8个格子”，这是组合生成问题。根据组合 数学，有，＞ 。种方案，比第一种方案优秀，但仍然不够好。

经过思考，不难发现以下事实：恰好每行每列各放置一个皇后。如果用cm表示第行 皇后的列编号，则问题变成了全排列生成问题。而0〜7的排列一共只有8!=40320个，枚举量 不会超过它。

提示7-9：在编写递归枚举程序之前，需要深入分析问题，对模型精雕细琢。一般还应

对解答树的结点数有一个粗略的估计，作为评价模型的重要依据，如图7-5所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-81.jpg)



图7-5中给出了四皇后问题的完整解答树。它只有17个结点，比4!=24小。为什么会这样

呢？这是因为有些结点无法继续扩展。例如，在(0,2,*,*)中，第2行无论将皇后放到哪里，都

会和第0行和第1行中已放好的皇后发生冲突，其他还未放置的皇后更是如此。

在这种情况下，递归函数将不再递归调用它自身，而是返回上一层调用，这种现象称为

回溯 (backtracking)。

提示7-10：当把问题分成若干步骤并递归求解时，如果当前步骤没有合法选择，则函

数将返回上一级递归调用，这种现象称为回溯。正是因为这个原因，递归枚举算法常被称为

回溯法，应用十分普遍。

下面的程序简洁地求解了八皇后问题。在主程序中读入《,并为tot清零，然后调用 search(0),即可得到解的个数tot。

void search(int cur) {

i f(cur == n) tot++;    / /递归边界。只要走到了这里，所有皇后必然不冲突

else for(int i = 0; i < n; i++)    {

int ok = 1;

C[cur] = i;    //尝试把第 cur 行的皇后放在第i列

for(int j = 0; j < cur; j++) //检查是否和前面的皇后冲突

if(C[cur] == C[j] || cur - C[cur] == j-C[j] || cur+C[cur] == j+C[j] )

{ ok = 0; break; }

if(ok) search(cur+1 ) ;    //如果合法，则继续递归

注意：既然是逐行放置的，则皇后肯定不会横向攻击，因此只需检查是否纵向和斜向攻

击即可。条件“cur-C[cur] == j-C[j] || cur+C[cur] == j+C[j]”用来判断皇后(cur,C[cur])和 (j,C[j])是否在同一条对角线上。其原理可以用图7-6来说明。

a )格子(x,y)的y-x值标识了主对角线



(b)格子(x,y)的x+y值标识了副对角线



图7-6 棋盘中的对角线标识

结点数似乎很难进一步减少了，但程序效率可以继续提高：利用二维数组vis[2][]直接 判断当前尝试的皇后所在的列和两个对角线是否已有其他皇后。注意到主对角线标识y-x可 能为负，存取时要加上n。

void sea r ch(int cur) { if(cur == n) tot++; else for(int i = 0; i < n; i++) {

if(!vis[0][i] && !vis[1][cur+i] && !vis[2][cur-i+n]) {

//利用二维数组直接判断

C[cur] = i;    //如果不用打印解，整个c数组都可以省略

vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 1;    / /修改全局变量

search(cur+1);

vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 0;    / /切记！一定要改回来

上面的程序有个极其关键的地方：vis数组的使用。vis数组的确切含义是什么？它表示 已经放置的皇后占据了哪些列、主对角线和副对角线。将来放置的皇后不应该修改这些值

——至少“看上去没有修改”。一般地，如果在回溯法中修改了辅助的全局变量，则一定要及

时把它们恢复原状(除非故意保留所做修改)。若不信，可以把“vis[0][i]= vis[1][cur+i]= vis[2][cur-i+n] = 0”注释掉，验证还能否正确求解八皇后问题。另外，在调用之前一定要把 vis数组清空。

提示7-11：如果在回溯法中使用了辅助的全局变量，则一定要及时把它们恢复原状。

特别地，若函数有多个出口，则需在每个出口处恢复被修改的值。

7.4.2 其他应用举例

例题7-4 素数环(Prime Ring Problem, UVa 524 )

输入正整数《，把整数1, 2, 3,…，«组成一个环，使得相邻两个整数之和均为素数。输出 时从整数1开始逆时针排列。同一个环应恰好输出一次。必16。

样例输入：

6

样例输出：

1 4 3 2 5 6 1 6 5 2 3 4

【分析】

由模型不难得到：每个环对应于1〜n的一个排列，但排列总数高达16!=2*1013 ,生成-测

试法会超时吗？下面进行实验：

for(int i = 2; i <= n*2; i++) isp[i] = is_prime(i) ;//生成素数表，加快后续判断 for(int i = 0; i < n; i++) A[i] = i+1;    //第一个排列

do {

int ok = 1;

for(int i = 0; i < n; i++)    if(!isp[A[i]+A[(i+1)%n]])    { ok = 0; break; }

//判断合法性

if(ok){

printf("\n");

}

}while(next_permutation(A+1, A+n));    //1的位置不变

运行后发现，当《=12时就已经很慢，而当《=16时无法运行出结果。下面试试回溯法：

void dfs(int cur){

if(cur == n && isp[A[0]+A[n-1]]){    // 递归边界。别忘了测试第一个数和最后一个数

for(int i = 0; i < n; i++) printf("%d ", A[i]);    //打印方案

printf("\n");

}

else for(int i = 2; i <= n; i++)    //尝试放置每个数i

if(!vis[i] && isp[i+A[cur-1] ] ) {    //如果i没有用过，并且与前一个数之和为素数

A[cur] = i;

vis[i] = 1;    //设置使用标志

dfs(cur+1);

vis[i] = 0;    // 清除标志

}

}

回溯法比生成-测试法快了很多，即使《=18速度也不错。将上面的函数名设为dfs并不是 巧合——从解答树的角度讲，回溯法正是按照深度优先的顺序在遍历解答树。在后面的内容 中，还将学习更多遍历解答树的方法。

提示7-12：如果最坏情况下的枚举量很大，应该使用回溯法而不是生成-测试法。

例题 7-5 困难的串(Krypton Factor, UVa 129 )

如果一个字符串包含两个相邻的重复子串，则称它是“容易的串”，其他串称为“困难的 串”。例如，BB、ABCDACABCAB、ABCDABCD都是容易的串，而D、DC、ABDAB、 CBABCBA都是困难的串。

输入正整数《和Z ,输出由前£个字符组成的、字典序第刎、的困难的串。例如，当1=3 时，前7个困难的串分别为A、AB、ABA、ABAC、ABACA、ABACAB、ABACABA。输入

保证答案不超过80个字符。

样例输入：

7 3 30 3

样例输出：

ABACABA

ABACABCACBABCABACABCACBACABA

【分析】

基本框架不难确定：从左到右依次考虑每个位置上的字符。因此，问题的关键在于如何

判断当前字符串是否已经存在连续的重复子串。例如，如何判断ABACABA是否包含连续重

复子串呢？一种方法是检查所有长度为偶数的子串，分别判断每个字串的前一半是否等于后

一半。尽管是正确的，但这个方法做了很多无用功。还记得八皇后问题中是怎么判断合法性

的吗？判断当前皇后是否和前面的皇后冲突，但并不判断以前的皇后是否相互冲突——那些

皇后在以前已经判断过了。同样的道理，我们只需要判断当前串的后缀，而非所有子串。

提示7-13：在回溯法中，应注意避免不必要的判断，就像在八皇后问题中那样，只需

判断新皇后和之前的皇后是否冲突，而不必判断以前的皇后是否相互冲突。

程序如下：

int dfs(int cur){    // 返回0表示已经得到解，无须继续搜索

if(cnt++ == n){

for(int i = 0; i < cur; i++) printf("%c", 'A'+S[i]); // 输出方案

printf("\n"); return 0;

}

for(int i = 0; i < L; i++){ S[cur] = i; int ok = 1;

for(int j = 1; j*2 <= cur+1; j++){    //尝试长度为j*2的后缀

int equal = 1;

for(int k = 0; k < j; k++)    / /检查后一半是否等于前一半

if(S[cur-k] != S[cur-k-j ]) { equal = 0; break; } if(equal) { ok = 0; break; }    //后一半等于前一半，方案不合法

}

if(ok) if(!dfs(cur+1)) return 0;    / / 递归搜索。如果已经找到解，则直接退出

}

return 1;

}

有意思的是，Z = 2时一共只有6个串；当£23时就很少回溯了。事实上，当£=3时，可以 构造出无限长的串，不存在相邻重复子串。

例题7-6 带宽(Bandwidth, UVa 140 )

给出一个《 (必8 )个结点的图G和一个结点的排列，定义结点/的带宽吣)为/和相邻结点 在排列中的最远距离，而所有6(/)的最大值就是整个图的带宽。给定图G ,求出让带宽最小 的结点排列，如图7-7所示。

下面两个排列的带宽分别为6和5。具体来说，图7-8 ( a)中各个结点的带宽分别为6, 6, 1, 4, 1, 1, 6, 6 ,图7-8 ( b )中各个结点的带宽分别为5, 3, 1, 4, 3, 5, 1, 4。

( a)

( b)

图7-8 两个排列的带宽

【分析】

如果不考虑效率，本题可以递归枚举全排列，分别计算带宽，然后选取最小的一种方

案。能否优化呢？和八皇后问题不同的是：八皇后问题有很多可行性约束(feasibility constraint ) ，可以在得到完整解之前避免扩展那些不可行的结点，但本题并没有可行性约束 ——任何排列都是合法的。难道只能扩展所有结点吗？当然不是。

可以记录下目前已经找到的最小带宽怂如果发现已经有某两个结点的距离大于或等 于女，再怎么扩展也不可能比当前解更优，应当强制把它“剪”掉，就像园丁在花园里为树修 剪枝叶一样，也可以为解答树“剪枝(prune ) ”。

除此之外，还可以剪掉更多的枝叶。如果在搜索到结点m时，m结点还有m个相邻点没有 确定位置，那么对于结点m来说，最理想的情况就是这m个结点紧跟在m后面，这样的结点带 宽为m ,而其他任何“非理想情况”的带宽至少为m+1。这样，如果m2女，即“在最理想的情况 下都不能得到比当前最优解更好的方案”，则应当剪枝。

提示7-14：在求最优解的问题中，应尽量考虑最优性剪枝。这往往需要记录下当前最

优解，并且想办法“预测”一下从当前结点出发是否可以扩展到更好的方案。具体来说，先计

算一下最理想情况可以得到怎样的解，如果连理想情况都无法得到比当前最优解更好的方

案，则剪枝。

例题 7-7 天平难题(Mobile Computing, ACM/ICPC Tokyo 2005, UVa1354 )

给出房间的宽度r和5个挂坠的重量wz。设计一个尽量宽(但宽度不能超过房间宽度r )的 天平，挂着所有挂坠。

天平由一些长度为1的木棍组成。木棍的每一端要么挂一个挂坠，要么挂另外一个木 棍。如图7-9所示，设n和m分别是两端挂的总重量，要让天平平衡，必须满足n*a=m*办。

图7-9 天平



例如，如果有3个重量分别为1, 1, 2的挂坠，有3种平衡的天平，如图7-10所示。

width = 1 + (1/2)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-88.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-89.jpg)



width = 1 + (2/3) 图7-10 3种平衡的天平

挂坠的宽度忽略不计，且不同的子天平可以相互重叠。如图7-11所示，宽度为(1/3)+1+

(1/4)。

输入第一行为数据组数。每组数据前两行为房间宽度r和挂坠数 目s ( 0<r<10 , 1Ss$6 )。以下s行每行为一个挂坠的重量％ ( 1^w在1000 )。输入保证不存在

天平的宽度恰好在r-10-5和r+10-5之间(这样可以保证不会出现精度问题)。对于每组数据， 输出最优天平的宽度。如果无解，输出-1。你的输出和标准答案的绝对误差不应超过10-8。

【分析】

如果把挂坠和木棍都作为结点，则一个天平对应一棵二叉树，如题目中给出的，挂坠为 1, 1, 2的3个天平如图7-12所示。

图7-11 子天平相互重叠



图7-12 与天平对应的二叉树



对于一棵确定二叉树，可以计算出每个挂坠的确切位置，进而计算出整个天平的宽度，

所以本题的核心任务是：枚举二叉树。

如何枚举二叉树呢？最直观的方法是沿用回溯法框架，每次选择两个结点组成一棵子

树，递归s-1层即可。以4个挂坠1, 1, 2, 3为例，下面是解答树的一部分（每个结点的子树并没 有全部画出），如图7-13所示。

图7-13 解答树



上面的方法已经足够解决本题，但还有优化的余地，因为有些二叉树被枚举了多次（如

图7-13中的两个粗框结点）。

推荐的枚举方法是：自顶向下构造，每次枚举左子树用到哪个子集，则右子树就是使用

剩下的子集（细节请参考代码仓库）。在第9章中会专门讨论“枚举子集”的高效算法，建议

读者在学习之后重新实现本题。

###### 7.5路径寻找问题

在第6章中曾经介绍过图的遍历。很多问题都可以归结为图的遍历，但这些问题中的图

却不是事先给定、从程序读入的，而是由程序动态生成的，称为隐式图。本节和前面介绍的

回溯法不同：回溯法一般是要找到一个（或者所有）满足约束的解（或者某种意义下的最优

解），而状态空间搜索一般是要找到一个从初始状态到终止状态的路径。

提示7-15：路径寻找问题可以归结为隐式图的遍历，它的任务是找到一条从初始状态

到终止状态的最优路径，而不是像回溯法那样找到一个符合某些要求的解。

八数码问题。编号为1〜8的8个正方形滑块被摆成3行3列（有一个格子留空），如图7-

14所示。每次可以把与空格相邻的滑块（有公共边才算相邻）移到空格中，而它原来的位置

就成为了新的空格。给定初始局面和目标局面（用0表示空格），你的任务是计算出最少的

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-93.jpg)



|      | i    | 5    |
| ---- | ---- | ---- |
| 7    | 3    | 6    |
| 4    |      | 2    |



图7-14八数码问题举例

样例输入：

2 6 4 1 3 7 0 5 8 8 1 5 7 3 6 4 0 2 样例输出：

分析】

不难把八数码问题归结为图上的最短路问题，图的“结点”就是9个格子中的滑块编号

（从上到下、从左到右把它们放到一个包含9个元素的数组中）。根据第6章的讲解，无权图

上的最短路问题可以用BFS求解，代码如下：

typedef int State[9];    // 定义" 状态"类型

const int maxstate = 1000000;

State st[maxstate], goal;    //状态数组。所有状态都保存在这里

int dist[maxstate];    // 距离数组

//如果需要打印方案，可以在这里加一个"父亲编号"数组 int fa[maxstate]

const int dx[ ] = {-1, 1, 0, 0};

const int dy[ ] = {0, 0, -1, 1};

//BFS ,返回目标状态在st数组下标

int bfs( ) {

init_lookup_table( );    // 初始化查找表

int front = 1, rear = 2;    //不使用下标0，因为 0被看作"不存在

while(front < rear) {

State& s = st[front];    // 用"引用"简化代码

if(memcmp(goal, s, sizeof(s)) == 0) return front;// 找到目标状态，成功返回

int z;

for(z = 0; z < 9; z++) if(!s[z]) break; int x = z/3, y = z%3; for(int d = 0; d < 4; d++) {

int newx = x + dx[d]; int newy = y + dy[d]; int newz = newx * 3 + newy;



// 找"0"的位置 // 获取行列编号（0~2 ）



if(newx >=



0 && newx < 3 && newy >= 0 && newy < 3){



//如果移动合法



State& t = s t[rear];

memcpy(&t, &s, sizeof(s));    / / 扩展新结点

t[newz] = s[z];

t[z] = s[newz];

dis t[rear] = dist[front] + 1;    / / 更新新结点的距离值

if(try_to_insert(rear)) rear++;



// 如果成功插入查找表，修改队尾指针



front++;



}

return 0;



// 扩展完毕后再修改队首指针

// 失败

注意，此处用到了cstring中的memcmp和memcpy完成整袂内存的比较和复制，比用循环

比较和循环赋值要快。主程序很容易实现：

| int main( ) | {          |         |             |        |      |           |                       |
| ----------- | ---------- | ------- | ----------- | ------ | ---- | --------- | --------------------- |
| for(int i   | = 0;       | i <     | 9; i++)     | scanf( | %d", | &st[1][i] | );    / /起始状态     |
| for(int i   | = 0;       | i <     | 9; i++)     | scanf( | %d", | &goal[i]) | ; // 目标状态         |
| int ans =   | bfs(       | );      |             |        |      |           | // 返回目标状态的下标 |
| if(ans >    | 0) printf( | "%d\n", | dist[ans]); |        |      |           |                       |

else printf("-1\n"); return 0;

}

注意，应在调用bfs函数之前设置好st[1]和goal。上面的代码几乎是完整的，唯一没有涉 及的是init_lookup_table( ^try_to_insert(rear)的实现。为什么会有这两项呢？还记得BFS中 的“判重”操作吗？在DFS中可以检查idx来判断结点是否已经访问过；在求最短路的BFS中用 d值是否为-1来判断结点是否访问过，不管用哪种方法，作用是相同的：避免同一个结点访 问多次。树的BFS不需要判重，因为根本不会重复；但对于图来说，如果不判重，时间和空 间都将产生极大的浪费。

如何判重呢？难道要声明一个9维数组vis ,然后执行if(vis[s[0]][s[1]][s[2]]…s[8])) ?无论 程序好不好看， 9维数组的每维都要包含9个元素，一共有99=387420489项，太多了，数组开 不下。实际的结点数并没有这么多(0〜8的排列总共只有9!=362880个)，为什么9维数组开 不下呢？原因在于，这样的用法存在大量的浪费——数组中有很多项都没有被用到，但却占 据了空间。

下面通过讨论3种常见的方法来解决这个问题，同时将它们用到八数码问题中。

第1种方法是：把排列“变成”整数，然后只开一个一维数组。也就是说，设计一套排列

的编码( encoding )和解码(decoding )函数，把0〜8的全排列和0〜362879的整数--对应

起来。第10章中将详细讨论编码和解码问题，这里先给出代码以便读者形成一个感性认识：

int vis[362880], fact[9];

void init_lookup_table( ){ fact[0] = 1;

for(int i = 1; i < 9; i++) fact[i] = fact[i-1] * i;

}

int try_to_insert(int s){

int code = 0;    //把st[s]映射到整数 code

for(int i = 0; i < 9; i++){

int cnt = 0;

for(int j = i+1; j < 9; j++) if(st[s][j] < st[s][i]) cnt++; code += fact [8-i] * cnt;

}

if(vi s [ code ] ) return 0; return vis[code] = 1;

}

尽管原理巧妙，时间效率也非常高，但编码解码法的适用范围并不大：如果隐式图的总

结点数非常大，编码也将会很大，数组还是开不下。

第2种方法是使用哈希(hash)技术。简单地说，就是要把结点“变成”整数，但不必是一 一对应。换句话说，只需要设计一个所谓的哈希函数叹^),然后将任意结点x映射到某个给定 范围[0, M1]的整数即可，其中M是程序员根据可用内存大小自选的。在理想情况下，只需 开一个大小为似的数组就能完成判重，但此时往往会有不同结点的哈希值相同，因此需要把

哈希值相同的状态组织成链表，细节参见下面的代码：

const int hashsize = 1000003;

int head[hashsize], next[maxstate];

void init_lookup_table( ) { memset(head, 0, sizeof(head)); }

int hash(State& s){ int v = 0;

for(int i



0; i < 9; i + +) v = v * 10 + s[幻；//把9个数字组合成9位数

int try_to_insert(int s){

int h = hash(st[s]);

int u = head[h];    // 从表头开始查找链表

while(u){

if(memcmp(st[u],st[s], sizeof(st[s]))==0)return 0;    // 找到了，插入失败

u = next[u];    // 顺着链表继续找

}

next[s] = head[h];    // 插入到链表中

head[h] = s; return 1;

}

哈希表的执行效率高，适用范围也很广。除了BFS中的结点判重外，还可以用到其他需 要快速查找的地方。不过需要注意的是：在哈希表中，对效率起到关键作用的是哈希函数。 如果哈希函数选取得当，几乎不会有结点的哈希值相同，且此时链表查找的速度也较快；但

如果冲突严重，整个哈希表会退化成少数几条长长的链表，查找速度将非常缓慢。有趣的

是，前面的编码函数可以看作是一个完美的哈希函数，不需要解决冲突。不过，如果事 先并不知道它是完美的，也就不敢像前面一样只开一个vis数组。哈希技术还有很多值得探

讨的地方，建议读者在网上查找相关资料。

第3种方法是用STL集合t。把状态转化成9位十进制整数，就可以用set<int>判重了：

set<int> vis;

void init_lookup_table( ) { vis.clear( ); }

int try_to_insert(int s){ int v = 0;

for(int i = 0; i < 9; i++) v = v * 10 + s t[ s][i];

if(vis.count(v)) return 0;

vis.insert(v);

return 1;

在刚才的3种实现中，使用STL集合的代码最简单，但时间效率也最低（若此时不用-O2

优化则速度劣势更加明显）。建议读者在时间紧迫或对效率要求不太高的情况下使用，或者

仅把它作为“跳板”——先写一个STL版的程序，确保主算法正确，然后把set替换成自己写的

哈希表。

提示7-16 :隐式图遍历需要用一个结点查找表来判重。一般来说，使用STL集合实现 的代码最简单，但效率也较低。如果题目对时间要求很高，可以先把STL集合版的程序调试

通过，然后转化为哈希表甚至完美哈希表。

某些特定的STL实现中还有hash_set ,它正是基于前面的哈希表，但它并不是标准C++的 一部分，因此不是所有情况下都可用。

例题7-8 倒水问题（ Fill, UVa 10603）

有装满水的6升的杯子、空的3升杯子和1升杯子， 3个杯子中都没有刻度。在不使用其他

道具的情况下，是否可以量出4升的水呢？

方法如图7-15所示。

图7-15 倒水问题：一种方法是(6,0,0)^(3,3,0)^(3,2,1)4(4,2,0)

注意：由于没有刻度，用杯子x给杯子y倒水时必须一直持续到把杯子y倒满或者把杯 子x倒空，而不能中途停止。

你的任务是解决一般性的问题：设3个杯子的容量分别为％么c ,最初只有第3个杯子装 满了c升水，其他两个杯子为空。最少需要倒多少升水才能让某一个杯子中的水有升呢？如 果无法做到恰好升，就让某一个杯子里的水是，升，其中，＜^并且尽量接近A （1义么c，必200 ）。要求输出最少的倒水量和目标水量（d或者，）。

【分析】

假设在某一时刻，第1个杯子中有v0升水，第2个杯子中有V1升水，第3个杯子中有12升 水，称当时的系统状态为（v0，vhv2）。这里再次提到了“状态”这个词，它是理解很多概念和算

法的关键。简单地说，它就是“对系统当前状况的描述”。例如，在国际象棋中，当前游戏者

和棋盘上的局面就是刻画游戏进程的状态。

把“状态”想象成图中的结点，可以得到如图 7-16所示的状态图（state graph ）。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-95.jpg)



由于无论如何倒，杯子中的水量都是整数

（按照倒水次数归纳即可），因此第3个杯子的

水量最多只有0, 1, 2,…，c共c+1种可能；同理， 第2个杯子的水量一共只有6+1种可能，第1个杯 子一共只有^+1种可能，因此理论上状态最多有 （好1）（办+1）（c+1）=8120601种可能性，有点大。幸 运的是，上面的估计是不精确的。由于水的总 量;v永远不变，如果有两个状态的前两个杯子的 水量都相同，则第3个杯子的水量也相同。换句 话说，最多可能的状态数不会超过2012=40401。

注意：本题的目标是倒的水量最少，而不是步数最少。实际上，水量最少时步数不一定 最少，例如a = l, b=12, c=15, d=7 ,倒水量最少的方案是C->A, A->B重复7次，最后C里有7 升水。一共14步，总水量也是14。还有一种方法是C->B ,然后B->A, A->C重复4次，最后C 里有7升水。一共只有10步，但总水量多达20。

因此，需要改一下算法：不是每次取出步数最少的结点进行扩展，而是取出水量最少的 结点进行扩展。这样的程序只需要把队列queue换成优先队列priority_queue ,其他部分的代码 不变。下面的代码把状态（三元组）和dist合起来定义为了一个Node类型，是一种常见的写 法。如果要打印路径，需要把访问过的所有结点放在一个nodes数组中，然后在Node中加一 个变量fa ,表示父结点在nodes数组中的下标，而在队列中只存结点在nodes数组中的下标而 非结点本身。如果内存充足，也可以直接在Node中用一个vector保存路径，省去顺着fa往回 找的麻烦。

\#include<cstdio>

\#include<cstring>

\#include<queue> using namespace std;

struct Node {

int v[3], dist;

bool operator < (const Node& rhs) const { return dist > rhs.dist;

}

};

const int maxn = 200 + 5;

int v i s [ maxn ] [ maxn ] , cap[3], ans[maxn];

void update_ans(const Node& u) {

for(int i = 0; i < 3; i++) { int d = u.v[i];

if(ans[d] < 0 || u.dist < ans[d]) ans[d] = u.dist;

}

}

void solve(int a, int b, int c, int d) {

cap[0] = a; cap[1] = b; cap[2] = c; memset(vis, 0, sizeof(vis));

memset(ans, -1, sizeof(ans ) ) ; priority_queue<Node> q;

Node start; start.dist = 0;

start.v[0] = 0; start.v[1] = 0; start.v[2] = c;

q.push(start);

vis[0][0] = 1;

while(!q.empty( )) {

Node u = q.top( ); q.pop( ); update_ans(u);

if(ans[d] >= 0) break ;

for(int i = 0; i < 3; i++) for(int j = 0; j < 3; j++) if(i != j) {

if(u.v[i] == 0 || u.v[j] == cap[j]) continue;

int amount = min(cap[j], u.v[i] + u.v[j]) - u.v[j]; Node u2;

memcpy(&u2, &u, sizeof(u) ) ; u2.dist = u.dist + amount ; u2.v[i] -= amount ; u2.v[j] += amount ;

if(!vis[u2.v[0]][u2.v[1]]) { vis[u2.v[0]][u2.v[1]] = 1;

q.push(u2) ;

}

}

}

while(d >= 0) {

if(ans[d] >= 0) {

printf("%d %d\n", ans[d], d); ret urn ;

}

d--;

}

}

int main( ) {

int T, a, b, c, d; scanf("%d", &T); while(T——) {

scanf("%d%d%d%d", &a, &b, &c, &d); solve(a, b, c, d);

}

需要注意的是：上述算法非常直观，正确性却不是显然的。事实上，笔者目前没有找

到反例，但也无法严格证明它是正确的[m](#bookmark3)。幸运的是，上述算法稍加修改，就可以得到第11 章中要介绍的Dijkstra算法，从而保证算法的正确性。等学完Dijkstra算法之后，读者不妨回

来再看看这道题目，相信会有新的体会。希望读者能够通过这个例题看到搜索和图论这两个

看似无关的主题之间的联系。

例题7-9 万圣节后的早晨(The Morning after Halloween, Japan 2007, UVa1601 )

w*h ( w,h<16 )网格上有《 ( «^3 )个小写字母(代表鬼)。要求把它们分别移动到对应 的大写字母里。每步可以有多个鬼同时移动(均为往上下左右4个方向之一移动)，但每步 结束之后任何两个鬼不能占用同一个位置，也不能在一步之内交换位置。例如如图7-17所示 的局面：一共有4种移动方式，如图7-18所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-96.jpg)



\####

ab#

\#c##

\####



\#### a b# #c## ####



\#### acb# # ## ####



\#### ab # #c## ####



图7-18 4种移动方式



输入保证所有空格连通，所有障碍格也连通，且任何一个2*2子网格中至少有一个障碍

格。输出最少的步数。输入保证有解。

分析】

以当前3个小写字母的位置为状态，则问题转化为图上的最短路问题。状态总数为

2563，每次转移时需要53枚举每一个小写字母下一步的走法（上下左右加上“不动”）。可惜

状态数已经很大了，转移代价又比较高，很容易超时，需要优化。

首先是优化转移代价。条件“任何一个2*2子网格中至少有一个障碍格”暗示着很多格子 都是障碍，并且大部分空地都和障碍相邻，因此不是所有4个方向都能移动，因此可以把所 有空格提出来建立一张图，而不是每次临时判断5种方案是否合法。加入这个优化以后BFS 就可以通过本题的数据了，但还有改进的空间。

其次是换一个算法，例如双向广度优先搜索[@](#bookmark7)。这种算法在前面并没有介绍，但是对 于“暴力搜索”这样的非常规算法来说，并不一定要严格遵守所谓的“标准方法”。例如，提 到“双向广度优先算法”，可以“想当然”地设计出这样的算法：正着搜索一层，反着搜索一 层，然后继续这样交替下去，直到两层中出现相同的状态，读者不妨一试。

本题非常经典，强烈推荐读者编写程序。

###### 7.6迭代加深搜索

迭代加深搜索是一个应用范围很广的算法，不仅可以像回溯法那样找一个解，也可以像

状态空间搜索那样找一条路径。下面先举一个经典的例子。

埃及分数问题。在古埃及，人们使用单位分数的和(即1“，是自然数)表示一切有理

数。例如， 2/3=1/2+1/6 ，但不允许2/3=1/3+1/3 ，因为在加数中不允许有相同的。

对于一个分数^^ ,表示方法有很多种，其中加数少的比加数多的好，如果加数个数相

同，则最小的分数越大越好。例如， 19/45=1/5+1/6+1/18是最优方案。

输入整数(0<a<b<500 ),试编程计算最佳表达式。

样例输入：

495 499 样例输出：

Case 1: 495/499=1/2+1/5+1/6+1/8+1/3992+1/14970

【分析】

这道题目理论上可以用回溯法求解，但是解答树非常“恐怖”——不仅深度没有明显的上

界，而且加数的选择在理论上也是无限的。换句话说，如果用宽度优先遍历，连一层都扩展

不完(因为每一层都是无限大的)。

解决方案是采用迭代加深搜索(iterative deepening ):从小到大枚举深度上限maxd ,每 次执行只考虑深度不超过maxd的结点。这样，只要解的深度有限，则一定可以在有限时间内 枚举到。

提示7-17：对于可以用回溯法求解但解答树的深度没有明显上限的题目，可以考虑使 用迭代加深搜索( iterative deepening ) 。

深度上限maxd还可以用来“剪枝”。按照分母递增的顺序来进行扩展，如果扩展到/层 时，前/个分数之和为c/人而第z•个分数为1/e ,则接下来至少还需要(a/b-c/^)/(1/e)个分数，总 和才能达到a/b。例如，当前搜索到19/45=1/5+1/100+...，则后面的分数每个最大为1/101 ,至 少需要(19/45-1/5) / (1/101) =23项总和才能达到19/45 ，因此前22次迭代是根本不会考虑这棵 子树的。这里的关键在于：可以估计至少还要多少步才能出解。

注意，这里的估计都是乐观的，因为用了“至少”这个词。说得学术一点，设深度上限为 maxd ,当前结点《的深度为g(«),乐观估价函数为力(《),则当g(«)+A(«)〉maxd时应该剪枝。这 样的算法就是IDA*。当然，在实战中不需要严格地在代码里写出g(«)和枞《),只需要像刚才 那样设计出乐观估价函数，想清楚在什么情况下不可能在当前的深度限制下出解即可。

提示7-18：如果可以设计出一个乐观估价函数，预测从当前结点至少还需要扩展几层 结点才有可能得到解，则迭代加深搜索变成了IDA*算法。

本题的主框架就是一个简单循环：

int ok = 0;

for(maxd = 1; ; maxd++) { memset(ans, -1, sizeof(ans)); if(dfs(0, get_first(a, b), a, b)) { ok = 1; break; }

其中get_first(a, b)是满足1/Ga/b的最小c。迭代加深搜索过程如下(约分的原理详见第10

章)：

//如果当前解v比目前最优解ans更优，更新ans

bool better(int d) {

for(int i = d; i >= 0; i--) if(v[i] != ans[i]) { return ans[i] == -1 || v[i] < ans[i];

}

return false;

} //当前深度为d ,分母不能小于f rom， 分数之和恰好为 aa/bb bool dfs(int d, int from, LL aa, LL bb) {

if(d == maxd) {

if(bb % aa) return false; //aa/bb必须是埃及分数 v[d] = bb/aa;

if(better(d)) memcpy(ans, v, sizeof(LL) * (d+1)); return true;

}

bool ok = false;

from = max(from, get_first(aa, bb)); // 枚举的起点 for(int i = from; ; i++) {

//剪枝：如果剩下的maxd+1-d个分数全部都是1/i ,加起来仍然不超过aa/bb ,则无解 if(bb * (maxd+1-d) <= i * aa) break;

v[d] = i;

//计算aa/bb - 1/i ,设结果为a2/b2

LL b2 = bb*i;

LL a2 = aa*i - bb;

LL g = gcd(a2, b2); //以便约分 if(dfs(d+1, i+1, a2/g, b2/g)) ok = true;

}

return ok;

}

例题7-10 编辑书稿(Editing a Book, UVa 11212 )

你有一篇由《（ 2$必9）个自然段组成的文章，希望将它们排列成1，    2，...，n。可以用

Ctrl+X （剪切）和Ctrl+V （粘贴）快捷键来完成任务。每次可以剪切一段连续的自然段，粘 贴时按照顺序粘贴。注意，剪贴板只有一个，所以不能连续剪切两次，只能剪切和粘贴交 替。

例如，为了将｛2，4，1，5，3，6｝变为升序，可以剪切1将其放到2前，然后剪切3将其放到4 前。再如，对于排列｛3，4，5，1，2｝ ，只需一次剪切和一次粘贴即可——将｛3，4，5｝放在｛1，2｝后，

或者将｛1，2｝放在｛3，4，5｝前。

【分析】

本题是典型的状态空间搜索问题，“状态”就是1〜n的排列，初始状态是输入，终止状态 是1, 2, 3,…，n。因为n$9 ,排列最多有9!=362880个。虽然这个数字不算大，但是每个状态的 后继状态也比较多（有很多剪切和粘贴的方式），所以仍有超时的危险。比赛时很多选手使

用了一些“加速策略”。

策略1 ：每次只剪切一段连续的数字。例如，不要剪切2 4这样数字不连续的片段。

策略2 :假设剪切片段的第一个数字为a ,最后一个数字为b ,要么把这个片段粘贴到a_

1的下一个位置，要么粘贴到b+1的前一个位置。

策略3：永远不要“破坏”一个已经连续排列的数字片段。例如，不能把1 2 3 4中的2 3剪 切出来。

3种策略都能缩小状态空间，但它们并不都是正确的。很多程序都无法得到“5 4 3 2 1”的 正确结果（答案是3步而不是4步：5 4 3 2 1——>3 2 5 4 1—3 4 1 2 5—1 2 3 4 5 ）,读者不妨 自行验证上面的3种策略是否可以得到这组数据的正确答案。

本题可以用IDA*算法求解。不难发现《<9时最多只需要8步，因此深度上限为8。IDA*的 关键在于启发函数。考虑后继不正确的数字个数h ,可以证明每次剪切时h最多减少3 ,因此 当3^+h〉3maxd时可以剪枝，其中为当前深度，maxd为深度限制[纽](#bookmark12)。

如何证明每次剪切时h最多减少3呢？如图7-19所示，因为最多只有3个数字的后继数字 发生了改变（即图中的a, b, c ） , h自然最多减少3。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-97.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-98.jpg)



###### 7.7 竞赛题目选讲

本章的篇幅不少，但实际上介绍的算法很有系统性，并不杂乱。这里先把这些算法和常

见解决问题的思路总结一下，然后选讲一些例题，

直接枚举。例如，类似“1〜n的整数中有多少个满足……”，“输入一个长度为《的序列， 有多少个连续子序列满足……”的问题都可以用直接枚举法。枚举法可以解决问题，但是效 率不一定足够高。第8章中将详细讨论算法效率的分析方法。

枚举子集和排列。《个元素的子集有2"个，可以用递归的方法枚举（前面介绍的增量法 和位向量法都属于递归枚举），也可以用二进制的方法枚举。递归法的优点在于效率高，方 便剪枝，缺点在于代码比较长。一般来说，当"很小（如"25 ）时，会使用二进制的方式枚 举。

"个不同元素的全排列有"!个。除了用递归的方法枚举之外，还可以用STL的 next_permutation来枚举，它也适用于有重复元素的情形。

回溯法。简单地说，回溯法几乎就是递归枚举，只是多了一条：违反题目要求时及时终 止当前递归过程，即回溯（ backtracking）。 回溯法最经典的题目就是八皇后问题，这个问题

也常常被作为“判断有没有学过回溯法”的依据。 7.4节的几个例题非常经典，覆盖了回溯法的

几个常见话题：搜索对象的选取（天平难题）、最优性剪枝（带宽），以及减少无用功（困

难的串）。

状态空间搜索。从本质上讲，状态空间搜索算法和图算法的相似度比较大，但是图往 往是“隐式”给出，所以这些算法又称“隐式图搜索”或者“产生式系统”[^](#bookmark3)。如果仔细品味前面 《八数码问题》的解法，可以发现这个解法其实就是一个普通的BFS加上了“结点查找表”。 前面介绍了3种方法实现结点查找表，各有用武之地。建议读者先熟练掌握后面两种（哈希 表和STL集合），待学习完第10章后再尝试使用第一种方法（一一映射，或称“完美哈 希”）。这些方法不仅能加快状态空间搜索的速度，还能给其他算法加速。第8章和第9章中 将继续讨论这个问题。另外，双向广度优先搜索和A*等算法也有各自的用武之地，虽然限于 篇幅未加介绍，但是笔者鼓励大家花一些时间搜索相关资料，并加以学习。例题中的“万圣 节后的早晨”就是一处很好的“试验田”。

迭代加深搜索。本章最后介绍了迭代加深搜索。这是一个长期以来被“低估”了的算 法，可以用来解决很多看起来更适合用BFS或者回溯法解决的问题，埃及分数问题就是一个 绝好的例子，而例题“编辑书稿”也非常经典。

例题7-11 宝箱( Zombie's Treasure Chest, Shanghai 2011, UVa12325)

你有一个体积为#的箱子和两种数量无限的宝物。宝物1的体积为幻，价值为n ;宝物2 的体积为沿，价值为F2。输入均为32位带符号整数。你的任务是计算最多能装多大价值的宝 物。例如，n=100 , 51=71=34,52=5 , F2=3 ,答案为86 ,方案是装两个宝物1 ,再装6个宝物 2。每种宝物都必须拿非负整数个。

【分析】

最容易想到的方法是：枚举宝物1的个数，然后尽量多拿宝物2。这样做的时间复杂度 为O(N/S1),当N和S1相差非常悬殊时效率很低。当然，如果N/S2很小时可以改成枚举宝物2 的个数，所以这个方法不奏效的条件是：S1和S2都很小，而N很大。

幸运的是，S1和S2都很小时，有另外一种枚举法B : S2个宝物1和S1个宝物2的体积相 等，而价值分别为52*71和51*72。如果前者比较大，则宝物2最多只会拿51-1个(否则可以 把51个宝物2换成52个宝物1)；如果后者比较大，则宝物1最多只会拿52-1个。不管是哪种 情况，枚举量都只有51或者52。

这样，就得到了一个比较“另类”的分类枚举算法：

当N/S1比较小时枚举宝物1的个数，时间复杂度为O(N/S1),否则，当N/S2比较小时枚举 宝物2的个数，时间复杂度为O(N/S2),否则说明S1和S2都比较小，执行枚举法B ,时间复杂 度为 O(max{51， 52})。

例题7-12 旋转游戏( The Rotation Game, Shanghai 2004, UVa1343)

如图7-20所示形状的棋盘上分别有8个1、2、3 ,要往A~H方向旋转棋盘，使中间8个方 格数字相同。图7-20 ( a )进行A操作后变为图7-20 ( b ),再进行C操作后变为图7-20(c),这正是一个目标状态(因为中间8个方格数字相同)。要求旋转次数最少。如果有 多解，操作序列的字典序应尽量小。

图 7-20 旋转游戏示意图

【分析】

本题是一个典型的状态空间搜索问题，可惜如果直接套用八数码问题的框架会超时。为 什么？学完第10章的组合计数部分后会知道： 8个1、8个2、8个3的全排列个数为 24!/(8!*8!*8!)=9465511770。换句话说，最坏情况下最多要处理这么多结点！

解决方法很巧妙：本题要求的是中间8个数字相同，即8个1或者8个2或者8个3。因此可 以分3次求解。当目标是“中间8个数字都是1”时， 2和3就没有区别了(都是“非1”)，因此状 态总数变成了8个1， 16个“非1”的全排列个数，即24!/(8!*16!)=735471，在可以接受的范围内 了[我](#bookmark7)另外，除了BFS外还可以用IDA* ,代码更清晰易懂(详见代码仓库)。

例题7-13 快速幂计算( Power Calculus, ACM/ICPC Yokohama 2006, UVa1374)

输入正整数《 ( 1<^<1000 ),问最少需要几次乘除法可以从^得到，？例如，^31需要6

次：-    .:。计算过程中的指数应

•A-    «/V    «/V J a/V    «/V    >/V    ， a/V    vV 9    </V    «/V    ，    </V    «/V    ，    «/V    / »<V

当总是正整数(如r3=w是不允许的)。

【分析】

这个题有一点“埃及分数”的味道，可以考虑迭代加深搜索。当前状态是已经得到的指数

集合，操作是任选两个数进行加法和减法，并且不能产生重复的数，如图7-21所示。

沿用之前的符号，d表示当前深度，maxd表示深度上限，则如果当前序列最大的数乘以

2胃d-d之后仍小于"，则剪枝(想一想，为什么)。另外，为了尽快接近目标，不应该“任 选”两个数，而应该先选较大的数，并且先试加法再试减法[(6)](#bookmark10)。这样做可以在最后一次迭代 (即找到解的那次迭代)中比较快地找到解，从而终止整个搜索过程，而不需要等整个解答

树扩展完毕。

因为题目一共只有1000种可能的输入，写完程序之后可以试试是否对所有输入都能足够 快地出解。只要比赛允许，甚至可以预先把"=1〜1000范围的所有解算出来，输出成如下源 代码：

\#include<cstdio>

int answer[ ] = {0, 0, 1, ...}; / / an swer[1]=0, answer[2]=1, ...

int main( ) { int n;

while(scanf("%d", &n) == 1 && n) print f("%d\n", answer[n]); return 0;

这样的技巧俗称“打表”。本题还有一些常见的优化，例如，限制减法的次数(实际上大

部分时候都是最大的数乘以2)，或者限制超过"的数的个数(事实上，可以证明最多有一个

数需要超过")，读者不妨一试。另外还有一个猜想：每次总是使用“刚刚得到”的那个数。

限于水平，笔者无法证明这个猜想，但是1000以内没有找到反例。

例题7-14 网格动物( Lattice Animals, ACM/ICPC NEERC 2004, UVa1602)

输入n、w、A ( 1<n<10 , 1<w , h<n ),求能放在w*h网格里的不同的n连袂的个数(注 意，平移、旋转、翻转后相同的算作同一种)。例如， 2*4里的5连块有5种(第一行)，而 3*3里的8连块有以下3种(第二行)，如图7-22所示。

【分析】

本题看上去没有什么好办法，只能用回溯法求解。如何求解呢？首先需要确定搜索对

象。因为要求各个格子连通，所以可以把“连通块”作为搜索对象，每次枚举一个位置，然后

放一个新的块，最后判重，如图7-23所示。

图7-22 网格动物例题示意图



图7-23回溯法求解

需要注意的是，如果采用最简单的写法，每个n连块都会被重复枚举很多次(想一想， 为什么)。也可以用前面介绍过的方法判重，但实际上有办法确保每个n连块恰好被枚举一 次，由Redelmeier发现，有兴趣的读者可以自行研究[仍](#bookmark13)。

本题非常经典，强烈建议读者编写程序。

可以参考 en.wikipedia.org/wiki/Polyomino。

例题7-15 破坏正方形( Square Destroyer, ACM/ICPC Taejon 2001, UVa1603)

有一个火柴棍组成的正方形网格，每条边有n根火柴，共2n(n+1)根。从上到下、从左到 右给各个火柴编号，如图7-24 ( a )所示。现在拿走一些火柴，问在剩下的火柴中，至少还 要拿走多少根火柴才能破坏所有正方形？例如，在图7-24 ( b )中，拿掉3根火柴就可以破坏 掉仅有的5个正方形。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-102.jpg)



|         |      |      |      | hi   |      |      |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| C       | 厂   |      | C    | r    |      |      |
| 1 ]     |      | 12   |      |      | 13   |      |
|         |      |      |      |      |      | 17   |
|         | C    | 厂   |      | C    | r    |      |
| 18      |      | 19   |      |      | 20   |      |
| f1    — | 22 [ |      | 23   |      | c~i= | 24   |

0

14

3

21

（a）



（b）



图7-24 破坏正方形示意图

分析】

不难想到用迭代加深搜索作为主算法框架。搜索对象有两种：（ 1）每次考虑一个没有 被破坏的正方形，在边界上找一根火柴拿掉；（ 2）每次找一个至少能破坏一个正方形的火 柴，然后拿掉。两种方法各有不同的优化方法：

搜索对象是正方形。应先考虑小正方形，再考虑大正方形，因为破坏完小正方形之

后，很多大正方形已经被破坏了，但是反过来却不一定。还可以加入最优性剪枝，即把每个

正方形看成一个顶点，有公共火柴的正方形连一条边，则每个连通分量至少要拿走一根火

柴。

搜索对象是火柴。应先搜索能破坏尽量多正方形的火柴。这需要计算出待考虑的每根 火柴可以破坏掉多少个正方形，从大到小排序为d[1], d[2], d[3],……当d[1]=1时即可停止搜 索，因为此时可以直接计算出还需要的火柴个数（想一想，为什么）。这个d数组也可以用 于最优性剪枝，找到最小的/ ,使得d[1]+d[2]+...+d[/]j （其中励还剩的正方形个数），则 至少还要/根火柴。

值得一提的是：本题还可以用经典的DLX算法解决。该算法超出了本章的范围，但在

《算法竞赛入门经典——训练指南》中有详细叙述。

###### 7.8 训练参考

前面已经提到过，本章介绍的算法比较有系统性，因此也没有选择太多的例题。建议读

者独立完成所有例题。本章例题列表及说明如表7-3所示。

表7-3 例题列表

| 类别     | 题号     | 题目名称（英文）            | 备注                      |
| -------- | -------- | --------------------------- | ------------------------- |
| 例题7-1  | UVa725   | Division                    | 选择合适的枚举对象        |
| 例题7-2  | UVa11059 | MaximumProduct              | 枚举连续子序列            |
| 例题7-3  | UVa10976 | FractionsAgain?!            | 缩小枚举范围              |
| 例题7-4  | UVa524   | Prime Ring Problem          | 回溯法和生成-测试法的比较 |
| 例题7-5  | UVa129   | Krypton Factor              | 回溯法；避免无用判断      |
| 例题7-6  | UVa140   | Bandwidth                   | 回溯法；最优性剪枝        |
| 例题7-7  | UVa1354  | MobileComputing             | 回溯法；枚举二叉树        |
| 例题7-8  | UVa10603 | Fill                        | 状态图，Dijkstra算法      |
| 例题7-9  | UVa1601  | The Morning after Halloween | 路径寻找问题的“试验田”    |
| 例题7-10 | UVa11212 | Editing a Book              | IDA*                      |
| 例题7-11 | UVa12325 | Zombie's Treasure Chest     | 两种枚举法                |
| 例题7-12 | UVa1343  | The Rotation Game           | 状态空间分析              |
| 例题7-13 | UVa1374  | Power Calculus              | IDA* ,各种优化            |
|          |          |                             |                           |

| 例题7-14 | UVa1602 | Lattice Animals | 经典问题：生成n连块 |
| -------- | ------- | --------------- | ------------------- |
| 例题7-15 | UVa1603 | SquareDestroyer | 搜索对象及优化      |

下面是本章的习题。这些题目大都具有一定的复杂性，读者可以选择自己有兴趣的5道

题目完成。如果想达到更好的效果，建议完成至少10道题目。

习题7-1 消防车( Firetruck, ACM/ICPC World Finals 1991, UVa208)

输入一个打(n<20)个结点的无向图以及某个结点k ,按照字典序从小到大顺序输出从结 点1到结点k的所有路径，要求结点不能重复经过。

提示：要事先判断结点1是否可以到达结点k ,否则会超时。

习题7-2 黄金图形( Golygons, ACM/ICPC World Finals 1993, UVa225)

平面上有々个障碍点。从(0,0)点出发，第一次走1个单位，第二次走2个单位，……,

第n次走n个单位，恰好回到(0,0)。要求只能沿着东南西北方向走，且每次必须转弯90° (不

能沿着同一个方向继续走，也不能后退)。走出的图形可以自交，但不能经过障碍点，如图

7-25所示。

图 7-25 黄金图形示意图

输入《、^ ( 1<n<20 , 0<k<50 )和所有障碍点的坐标，输出所有满足要求的移动序列(用 news表示北、东、西、南)，按照字典序从小到大排列，最后输出移动序列的总数。

习题7-3 多米诺效应( The Domino Effect, ACM/ICPC World Finals 1991, UVa211)

一副“双六”多米诺骨牌包含28张，编号如图7-26所示

图 7-26 多米诺骨牌编号



| □    | 8    | 1 \| 1 | 15   | 2 \| | 3    | 22   | 3    |      |      |      |      |      |
| ---- | ---- | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | 1    | 9      | 1    |      | 2    | 16   | 2    |      | 4    | 23   |      |      |
|      | 2    | 10     | 1    |      | 3    | 17   | 2    |      | 5    | 24   | 4    |      |
|      | 3    | 11     | 1    |      | 4    | 18   | 2    |      | 6    | 25   |      |      |
|      | 4    | 12     | 1    |      | 5    | 19   | 3    |      | 3    | 26   | 5    |      |
|      | .5   | 13     | 1    |      | 6    | 20   | 3    |      | 4    | 27   | 5    |      |
|      | 6    | 14     | 2    |      | 2    | 21   | 3    |      | 5    | 28   | 6    |      |



在7*8网格中每张牌各摆一张，如图7-27所示，左边是各个格子的点数，右边是各个格

子所属的骨牌编号。

4 4-2 5 3

3 5 15 0

0 6 14 6

1 6 2 0 2

□ 4360

2    2 4 3 4

3    3 0 1 5

1115 5

图 7-27 7*8 网格中骨牌摆放



119 6 1

2 2 2

2 3 3 5 8 1 1 1

2 5 5 5 3

2 1

7 5 5 2 3 2 12

4 5 6 2 4 1112 2

0 4 4 2 4 11 2_

038 27 1 12



输入左图，你的任务是输出所有可能的右图

习题7-4 切断圆环链( Cutting Chains, ACM/ICPC World Finals 2000, UVa818)

有《(«<15)个圆环，其中有一些已经扣在了一起。现在需要打开尽量少的圆环，使得 所有圆环可以组成一条链(当然，所有打开的圆环最后都要再次闭合)。例如，有5个圆 环， 1-2, 2-3, 4-5，则需要打开一个圆环，如圆环4，然后用它穿过圆环3和圆环5后再次闭合 圆环4，就可以形成一条链：1-2-3-4-5。

习题7-5 流 水线调度( Pipeline Scheduling, UVa690)

你有一台包含5个工作单元的计算机，还有10个完全相同的程序需要执行。每个程序需 要打(n<20)个时间片来执行，可以用一个5行n列的保留表( reservation table )来表示，其 中每行代表一个工作单元(umt0~umt4 ),每列代表一个时间片，行i列j的字符为X表示“在 程序执行的第j个时间片中需要工作单元1”。例如，如图7-28 ( a )所示就是一张保留表，其 中程序在执行的第0, 1, 2,......个时间片中分别需要unit0, unit1, unit2......

同一个工作单元不能同时执行多个程序，因此若两个程序分别从时间片0和1开始执行， 则在时间片5时会发生冲突(两个程序都想使用unit0 ),如图7-28 ( b )所示。

输入一个5行打(n<20 )列的保留表，输出所有10个程序执行完毕所需的最少时间。例 如，对于图7-28 ( a )的保留表，执行完10个程序最少需要34个时间片。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-107.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-108.jpg)



图7-28 流水线调度示意图

习题7-6 重叠的正方形( Overlapping Squares, Xia'an 2006, UVa12113)

给定一个4*4的棋盘和棋盘上所呈现出来的纸张边缘，如图7-29所示，问用不超过6张

2*2的纸能否摆出这样的形状。

|      | 2    |      |      |
| ---- | ---- | ---- | ---- |
| 1    |      |      |      |
|      |      |      |      |

图 7-29 重叠正方形示意图

习题7-7 埃及分数( Eg[y]ptian Fractions (HARD version), Rujia Liu's Present 6, UVa 12558)

把写成不同的埃及分数之和，要求项数尽量小，在此前提下最小的分数尽量大，然 后第二小的分数尽量大......另外有^ ( 0<k<5 )个数不能用作分母。例如，k=0时

5/121=1/33+1/121+1/363，不能使用33时最优解为5/121=1/45+1/55+1/1089。

输入保证2<aK876 , gcd(a,b)=1 ,且会挑选比较容易求解的数据。

习题7-8 数字谜( Digit Puzzle, ACM/ICPC Xi'an 2006,UVa12107)

给出一个数字谜，要求修改尽量少的数，使修改后的数字谜只有唯一解。例如，如图7-

30所示的两个数字谜就有唯一解。

7父口口=8口

□□xnn=ini

图7-30数字谜示意图

修改指的是空格和数字可以随意替换，但不能增删。即空格换数字、数字换空格或数字

替换。数字谜中所有涉及的数必须是没有前导零的正数。输入数字谜一定形如^6=c,其 中c分别最多有2、2、4位。

输入保证有解。如果有多种修改方案，则输出字典序最小的。字典序中空格小于数字。

习题7-9 立体八数码问题( Cubic Eight-Puzzle , ACM/ICPC Japan 2006, UVa1604)

有8个立方体，按照相同方式着色(如图7-31 ( a )所示，相对的面总是着相同颜色)， 然后以相同的朝向摆成一个3*3的方阵，空出一个位置(如图7-31 ( b )所示，空位由输入决 定)。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-109.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-110.jpg)



图7-31 立体八数码问题示意图

每次可以把一个立方体“滚动”一格进入空位，使它原来的位置成为空位，如图7-32所

示。

white

㈡

7

Sefore

After

blue

图 7-32 “ 滚动 ”后效果



你的任务是用最少的移动使得上表面呈现出指定的图案。输入空位的坐标和目标状态中

上表面各个位置的颜色，输出最小移动步数。

习题7-10 守卫棋盘 （ Guarding the Chessboard, UVa11214）

输入一个n*rn棋盘（n,m<10 ）,某些格子有标记。用最少的皇后守卫（即占据或者攻 击）所有带标记的格子。

习题7-11    树上的机器 人规划(简 单版)( Planning mobile robot on Tree (EASY

Version), UVa12569)

有一棵n （ 4<n<15 ）个结点的树，其中一个结点有一个机器人，还有一些结点有石头。 每步可以把一个机器人或者石头移到一个相邻结点。任何情况下一个结点里不能有两个东西 （石头或者机器人）。输入每个石头的位置和机器人的起点和终点，求最小步数的方案。如 果有多解，可以输出任意解。如图7-33所示，>s=1 , Z=5时，最少需要16步：机器人1-6 ,石头 2-1-7，机器人6-1-2-8，石头3-2-1-6，石头4-3-2-1，最后机器人8-2-3-4-5。

习题7-12 移动小球( Moving Pegs, ACM/ICPC Taejon 2000, UVa1533)

如图7-34所示，一共有15个洞，其中一个空着，剩下的洞里各有一个小球。每次可以让

一个小球越过同一条直线上的一个或多个连续的小球，落到最近的空洞（不能越过空洞），

然后拿走被跳过的小球。例如，让14跳到空洞5中，则洞9里的小球会被拿走，因此操作之后

洞9和14会变空，而5里面会有一个小球。你的任务是用最少的步数让整个棋盘只剩下一个小

球，并且位于初始时的那个空洞中。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-112.jpg)



图 7-34 移动小球示意图



输入仅包含一个整数，即空洞编号，输出最短序列的长度m ,然后是m个整数对，分别 表示每次跳跃的小球所在的洞编号以及目标洞的编号。

习题7-13 数字表达式( According to Bartjens, ACM/ICPC World Finals 2000, UVa 817)

输入一个以等号结尾、前面只包含数字的表达式，插入一些加号、减号和乘号，使得运

算结果等于2000。表达式里的整数不能有前导零（例如，0100或者000都是非法的），运算

符都是二元的（例如，2*-100*-10+0=是非法的），并且符合通常的运算优先级法则。

输入数字个数不超过9。如果有多解，按照字典序从小到大输出；如果无解，输出 IMPOSSIBLE。例如，2100100=有3组解，按照字典序依次为2*100*10+0= 2*100*10-0=和 2100-100=。

习题7-14 小木棍( Sticks, ACM/ICPC CERC 1995, UVa 307)

乔治有一些同样长的小木棍，他把这些木棍随意地砍成几段，直到每段的长度都不超过

50。现在，他想把小木棍拼接成原来的样子，但是却忘记了自己最开始时有多少根木棍和它 们的分别长度。给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。例如，若 砍完后有4根，长度分别为1, 2, 3, 4，则原来可能是2根长度为5的木棍，也可能是1根长度为 10的木棍，其中5是最小可能长度。另一个例子是：砍之后的木棍有9根，长度分别为5, 2, 1, 5, 2, 1, 5, 2, 1，则最小可能长度为6（ 5+1=5+1=5+1=2+2+2=6），而不是8（ 5+2+1=8）。

习题7-15 最大的数( Biggest Number, UVa11882)

在一个及行C列（2”，C<15 , R*C<30 ）的矩阵里有障碍物和数字格（包含1〜9的数 字）。你可以从任意一个数字格出发，每次沿着上下左右之一的方向走一格，但不能走到障 碍格中，也不能重复经过一个数字格，然后把沿途经过的所有数字连起来，如图7-35所示。

如图7-35可以得到9784、 4832145等整数。问：能得到的最大整数是多少？

习题 7-16 找座位( Finding Seats Again, UVa11846)

有一个n*n （ n<20 ）的座位矩阵里坐着女（k<26 ）个研究小组。每个小组的座位都是矩形 形状。输入每个小组组长的位置和该组的成员个数，找到一种可能的座位方案。如图7-36所 示是一组输入和对应的输出。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-114.jpg)



| ...4.2.      | AAAAECC  |
| ------------ | -------- |
| ■ + ■45. ■   | DDLDEEF  |
| 222 , , 3 .  | GHIIEEF  |
| ■ • ,2 ■ . 3 | GHJKEEF  |
| ■ 2马■ ■ .2  | LLJKE1IH |
| ■ "2.3.      | NOJPQQQ  |
| 22 , . 3 .,  | MOJPRRR  |

图7-36 找座位问题示意图



习题7-17 Gokigen Naname谜题(Gokigen Naname, UVa11694 ) 在一个《*« ( «^7 )网格中，有些交叉点上有数字。你的任务是给每个格子画一条斜线

(一共只有“\”和“/”两种)，使得每个交叉点的数字等于和它相连的斜线条数，且这些斜线

不会构成环，如图7-37所示。

图7-37 Gokgen Naname谜题示意图



习题7-18 推门游戏( The Wall Pusher, UVa10384)

如图7-38所示，从S处出发，每次可以往东、南、西、北4个方向之一前进。如果前方有 墙壁，游戏者可以把墙壁往前推一格。如果有两堵或者多堵连续的墙，则不能推动。另外，

游戏者也不能推动游戏区域边界上的墙。

图 7-38 推门游戏示意图

用最少的步数走出迷宫(边界处没有墙的地方就是出口)。迷宫总是有4行6列，多解时 任意输出一个移动序列即可(用NEWS这4字符表示移动方向)。

[(1)](#bookmark34)    如果有读者找到反例或者正确性证明，请联系笔者或者出版社，我们会在重印时更正。

[(2)](#bookmark36)    还有一个不错的候选算法是A* ,可惜超出了本书的范围，有兴趣的读者可以自行搜索相关资料。

[(3)](#bookmark38)    此处故意没有用前面介绍的叫5)、g(5)等记号。事实上，经常采用这种直观的方式来思考，而不去理会那些记号。

[(4)](#bookmark2)    这个术语多用在传统人工智能书籍中，虽有一些描述上的差别，但本质相同。

[(5)](#bookmark6)    一般来说，状态总数不超过106时都在可接受范围内。不过这只是一般规律，还要具体问题具体分析。

[⑹](#bookmark9)这种技巧称为结点排序(node ordering )。

[(7)](#bookmark12)可以参考 en. wikipedia. org/wiki/P olyomino。

|      | 2    |      |
| ---- | ---- | ---- |
| 1    |      | 3    |
|      |      |      |



|      | 2    |      |      |
| ---- | ---- | ---- | ---- |
| 1    | 4    |      |      |
|      |      |      | 3    |



第3部分 竞赛篇
