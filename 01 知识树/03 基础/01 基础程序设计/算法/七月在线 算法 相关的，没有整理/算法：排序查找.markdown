---
author: evo
comments: true
date: 2018-04-05 01:06:33+00:00
layout: post
link: http://106.15.37.116/2018/04/05/algorithm-sort-and-search/
slug: algorithm-sort-and-search
title: 算法：排序查找
wordpress_id: 3137
categories:
- 随想与反思
tags:
- '@todo'
---

<!-- more -->


# 主要内容与目标


 排序
 找到一个O(NlogN)的排序算法
 插入排序、选择排序、希尔排序、冒泡排序
 堆排序及其思考
 快速排序及其思考
 非比较方案的排序：记数排序、桶排序、基数排序
 总结与思考
 排序的目的是什么？


# 排序问题的提法


 给定n个元素的集合A，按照某种方法将A中
的元素按非降或非增次序排列。
 分类：内排序，外排序
 常见内排序方法
 插入排序 / 希尔排序
 选择排序 / 锦标赛排序 / 堆排序
 冒泡排序 / 快速排序
 归并排序
 基数排序




# 插入排序


 //将A(1：n)中的元素按非降次序分类，n≥1
 procedure INSERTIONSORT(A,n)
 A(0)←-∞//设置初始边界值
 for j←2 to n do //A(1:j-1)已分类
 item←A(j);i←j-1
 while item<A(i) do //0≤i<j
 A(i+1)←A(i); i←i-1
 repeat
 A(i+1) ←item;
 repeat
 end INSERTIONSORT


# 锦标赛排序




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac560f3a269f.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac56102d6298.png)





# 归并排序


 基本思想：将数组A[0…n-1]中的元素分成两
个子数组：A_1 [0…n/2]和A_2 [n/2+1…n-1]。分
别对这两个子数组单独排序，然后将已排序
的两个子数组归并成一个含有n个元素的有
序数组。


## 代码如下：




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac56129cfcc4.png)





## 归并排序的时间复杂度性能分析




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5613ad3a0e.png)





## 归并排序的两点改进


 在数组长度比较短的情况下，不进行递归，
而是选择其他排序方案：如插入排序；
 归并过程中，可以用记录数组下标的方式代
替申请新内存空间；从而避免A和辅助数组
间的频繁数据移动。
 注：基于关键字比较的排序算法的平均时间复杂度
的下界为 O(nlogn)




# 外排序


 外排序(External sorting)是指处理超过内存限
度的数据的排序算法。通常将中间结果放在
读写较慢的外存储器(通常是硬盘)上。
 外排序常采用“排序-归并”策略。
 排序阶段，读入能放在内存中的数据量，将其
排序输出到临时文件，依次进行，将待排序数
据组织为多个有序的临时文件。
 归并阶段，将这些临时文件组合为大的有序文
件。


## 外排序举例


 使用100M内存对900MB的数据进行排序：
 读入100M数据至内存，用常规方式(如堆排序)排序。
 将排序后的数据写入磁盘。
 重复前两个步骤，得到9个100MB的块(临时文件)中。
 将100M内存划分为10份，前9份中为输入缓冲区，第10
份为输出缓冲区。
 如前9份各8M，第10份18M；或10份大小同时为10M。
 执行九路归并算法，将结果输出到输出缓冲区。
 若输出缓冲区满，将数据写至目标文件，清空缓冲区。
 若输入缓冲区空，读入相应文件的下一份数据。




# 逆序数问题


 给定一个数组A[0…N-1]，若对于某两个元
素a[i]、a[j]，若i＜j且a[i]＞a[j]，则称
(a[i],a[j])为逆序对。一个数组中包含的逆序
对的数目称为该数组的逆序数。试设计算
法，求一个数组的逆序数。
 如：3,56,2,7的逆序数为3。

算法分析：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac561947332a.png)


代码如下：




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac561a7759aa.png)





# 堆的定义和表示


 定义：对于一棵完全二叉树，若树中任一非
叶子结点的关键字均不大于(或不小于)其左
右孩子(若存在)结点的关键字，则这棵二叉
树，叫做小顶堆(大顶堆)。
 完全二叉树可以用数组完美存储，对于长度
为n的数组a[0…n-1]，若
 ∀0≤i≤n-1，a[i]≤a[2i+1]且a[i]≤a[2i+2]
那么，a表示一个小顶堆。
 重要结论：大顶堆的堆顶元素是最大的。




## 堆的存储和树型表示


 16,14,10,8,7,9,3,2,4,1
 9,8,3,4,7,1,2


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac561df03136.png)





## 孩子与父亲的相互索引


 k的孩子结点是2k+1,2k+2(如果存在)
 k的父结点：
 若k为左孩子，则k的父结点为k/2
 若k为右孩子，则k的父结点为(k/2) - 1
 二者公式不一样，十分不便。发现：
 若k为左孩子，则k为奇数，则((k+1)/2)-1与k/2相等
 若k为右孩子，则k为偶数，则((k+1)/2)-1与(k/2) - 1相等
 结论：若待考查结点为k，记k+1为K，则k的父结
点为：(K/2) - 1


## 堆排序的整体思路


 ① 初始化操作：将a[0..n-1]构造为堆(如大顶堆)；
 ② 第i(n＞i≥1)趟排序：将堆顶记录a[0]和a[n-i] 交
换，然后将a[0…n-i-1] 调整为堆(即：重建大顶
堆)；
 ③进行n-1趟，完成排序。
 堆排序的时间复杂度？
 初始化堆的过程：O(N)
 注意，一般教科书给出的O(NlogN)不是紧的。
 调整堆的过程：O(NlogN)


## 堆排序的调整过程




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac573be421fe.png)





## 堆排序Code




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac573ca0a681.png)


堆排序实际运行效率


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac573dc24e14.png)





# N个数中，选择前k个最大的数


 建立一个小顶堆，小顶堆的大小为k
 for 每个数
 if 这个数比小顶堆的堆顶元素大
 弹出小 顶 堆的最小元素
 把这个数插入到小 顶 堆
 小顶堆中的k个元素就是所要求的元素
 小顶堆的作用：
 保持始终有k个最大元素——利于最后的输出
 k个元素中最小的元素在堆顶——利于后续元素的比较
 时间复杂度：O(N*logk)




# 对比：选择前k个最大的数


 算法描述：
 1、建立全部n个元素的大顶堆；
 2、利用堆排序，但得到前k个元素后即完成算法。
 时间复杂度分析：
 1、建堆O(N)
 2、选择1个元素的时间是O(logN)，所以，第二步的总时
间复杂度为O(klogN)
 该算法时间复杂度为O(N+klogN)
 思考：
 O(N+klogN)与O(N*logk)哪个更快？




## 最大的k个数——算法2 Code




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5740e4f23d.png)





## 最大的k个数——算法1 Code




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac574352937c.png)





## 最大的k个数——算法1 Code’




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac574599091a.png)





## “求前K大的数”算法总结


 实践证明，算法1的方案相对于算法2更优
 事实上，有更快的BFPRT算法。
 这不能抹杀算法1和算法2在实际中的存在价值
 稍后马上介绍


## K叉堆的结论


 对 n 个元素建立初始 K 叉堆的最多比较次数
不超过(k/k-1)*n 次；
 对 n 个元素的 K 叉堆，每次删去堆顶元素并
调整使之恢复 K 叉堆，这样 m 次过程的最
多比较次数不超过 m*k*[log k ((k-1)n] 次。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac574841b966.png)





## 堆排序中的思考


 得到一个堆后，堆排序仅输出堆顶元素，便
又重新组织新堆了，没有利用完全堆的全部
信息。根据堆的逻辑结构和特征，堆顶结点
的左右孩子之一必有一个是数据中的第二大
(小)者，完全可以随着堆顶一起交换到末
尾。然后，分别对次顶堆和顶堆调整即可。

稳定堆排序？
 1、建堆的时候，相等则不调整；
 2、调整堆的时候：
 2.1 如果与根相等，与左右孩子不相等，则调整到
孩子；
 2.2 如果与根、左孩子都相等，与右孩子不等，则
调整到左孩子这一支，递归考察2.1；
 2.3 如果与根、右孩子都相等，则调整到右孩子这
一支，递归考察2.1；
 此情况其实包含了根、左孩子、右孩子都相等的情况


## 稳定与非稳定


 事实上，任何一个非稳定的排序，如果能够
将元素值value与元素所在位置index共同排
序，即可得到稳定的排序。




# 快速排序


 快速排序是一种基于划分的排序方法；
 划分Partitioning ：选取待排序集合A中的某
个元素t，按照与t的大小关系重新整理A中元
素，使得整理后的序列中所有在t以前出现的
元素均小于t，而所有出现在t以后的元素均
大于等于t；元素t称为划分元素。
 快速排序：通过反复地对A进行划分达到排
序的目的。


## 划分算法


 对于数组a[0…n-1]
 设置两个变量i、j：i=0，j=n-1；
 以a[0]作为关键数据，即key=A[0]；
 从j开始向前搜索，直到找到第一个小于key的值
a[j]，将a[i] = a[j]；
 从i开始向后搜索，直到找到第一个大于等于key
的值a[i]，a[j] = a[i]；
 重复第3、4步，直到i≥j.


# 链表划分


 给定一个链表和一个值x，将链表划分成两
部分，使得划分后小于x的结点在前，大于
等于x的结点在后。在这两部分中要保持原
链表中的出现顺序。
 如：给定链表1->4->3->2->5->2和x = 3，返回1-
>2->2->4->3->5。




## 问题分析


 分别申请两个指针p1和p2，小于x的添加到
p1中，大于等于x的添加到p2中；最后，将
p2链接到p1的末端即可。
 时间复杂度是O(N)，空间复杂度为O(1)；该
问题其实说明：快速排序对于单链表存储结
构仍然适用。
 注：不是所有排序都方便使用链表存储，如堆
排序，将不断的查找数组的n/2和n的位置，用链
表做存储结构会不太方便。

代码如下：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac574f491ff9.png)





## 快速排序Code




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5750a0a84b.png)





## 快速排序与归并排序的联系


 都是分治的思想；
 经过一次划分后，实现了对A的调整：其中
一个子集合的所有元素均小于等于另外一个
子集合的所有元素；
 按同样的策略对两个子集合进行分类处理。
当子集合分类完毕后，整个集合的分类也完
成了。这一过程避免了子集合的归并操作。


## 快速排序的性能分析


 在最好的情况，每次运行一次分区，我们会
把一个数列分为两个几近相等的片段。然
后，递归调用两个一半大小的数列。
 一次分区中，i、j一共遍历了n个数，即O(n)
 记：快速排序的时间复杂度为T(n)，有，
 T(n) = 2*T(n/2) + cn c是某常数
 T(n)=O(n*logn)




## 快速排序的性能分析


 在最坏的情况下，两个子数组的长度为 1 和
n-1
 T(n) = T(1) + T(n - 1) + cn
 演示：计算得到T(n) = O(n 2 )
 思考：如果每次分区，都把数组分成1%和
99%的两个子数组，时间复杂度是多少？




## 附：根据前序中序，计算后序


 前序遍历：GDAFEMHZ
 中序遍历：ADEFGHMZ
 根据前序遍历的特点得知，根结点为G；
 根结点将中序遍历结果ADEFGHMZ分成
ADEF和HMZ两个左子树、右子树。
 递归确定中序遍历序列ADEF和前序遍历序
列DAEF的子树结构；
 递归确定中序遍历序列HMZ和前序遍历序列
MHZ的子树结构；

Code——问：时间复杂度是多少？


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac57544bee43.png)





# Heap VS Quick


 快速排序的最直接竞争者是堆排序。堆排序
通常比快速排序稍微慢，但是最坏情况的运
行时间总是O(n log n)。快速排序是经常比较
快，但仍然有最坏情况性能的机会。
 堆排序拥有重要的特点：仅使用固定额外的
空间，即堆排序是原地排序，而快速排序需
要O(log n)的空间。




## 快速排序为什么这么快？


 乱数快速排序有一个值得注意的特性，在任意输入数据的状况下，它
只需要O(n log n)的期望时间。是什么让随机的基准变成一个好的选
择？
 假设我们排序一个数列，然后把它分为四个部份。在中央的两个部份
将会包含最好的基准值；他们的每一个至少都会比25%的元素大，且
至少比25%的元素小。如果我们可以一致地从这两个中央的部份选出
一个元素，在到达大小为1的数列前，我们可能最多仅需要把数列分
区2log 2 n次，产生一个 O(nlogn)算法。
 不幸地，乱数选择只有一半的时间会从中间的部份选择。出人意外的
事实是这样就已经足够好了。想像你正在投掷一枚硬币，直到有 k 次
国徽朝上。尽管这需要很长的时间，平均来说只需要 2k 次投掷。且
在 100k 次投掷中得不到 k 次国徽朝上的概率，是像天文数字一样的
非常小[注]。借由同样的论证，快速排序的递归平均只要2(2log 2 n)的
调用深度就会终止。
 注：该概率小于7.9E-31
 如果它的平均调用深度是O(log n)且每一阶的调用树状过程最多有 n 个
元素，则全部完成的工作量就是 O(n log n)。






# BFPRT算法


 题目：求第k大的数，如何解决？
 得到了前k大的数，显然顺便得到第k大的数，
即：该问题至少存在O(Nlogk)的算法
 事实上，通过快速排序的Partition思想，第k大
的数可以在期望是O(N)的算法内解决
 最坏情况是O(N 2 )，但可以使用二次取中的办法避
免最坏情况的发生
 借鉴第k大的数的思想，如何解决前k大的数
 Partition之后的前面的k个即为所求。
 Blum 、 Floyd 、 Pratt 、 Rivest 、 Tarjan




## n个数中，选择第k大的数


 数组a[0…n-1]，选择第k大的数
 利用快速排序的思想，随机选择划分元素t，将数组
分成大于t和小于等于t两部分。记为a[0…m-1]和
a[m+1…n-1]，若m=k-1，则t即为所求；若m>k-1，则
递归计算a[0…m-1]中第k大的数；若m>k-1，则递归
计算a[m+1…n-1]中第k-m大的数。
 平均时间复杂度O(n)，最差O(n^2)。
 快排的时候,左右两个分支都要进行递归，找k大的时候
只需要对其中一边进行递归。
 可使用“二次取中”的规则得到最坏情况是O(n)的算
法。


## 如果遇到相等的数，怎么处理


 数组中M出现次数很多，而恰好选了M作为
PivotKey，那么，将导致Partition之后，一部
分很长，一部分很短。(比如：极限情况：
数组中都是M，划分后，一部分是整体本
身，一部分为0)
 数据分成“大于M、小于M、等于M”三部
分，可类比荷兰国旗问题。


## 考虑相等元素的O(N)时间选择算法




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5758a58eb8.png)


各种排序算法的时间复杂度


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac575aa5f550.png)


排序算法效率比较  注：该数据来自网络，可信度低


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac575b2c6663.png)





## 稳定性


 一般的说，如果排序过程中，只有相邻元素进行比
较，是稳定的，如冒泡排序、归并排序；如果间隔
元素进行了比较，往往是非稳定的，如堆排序、快
速排序。
 归并排序是指针逐次后移，姑且算相邻元素的比较
 直接插入排序可以将新增数据放在排序的相等数据的后
面，使得直接插入排序是稳定的；但二分插入排序本身
不稳定，如果要稳定，需要向后探测
 一般的说，如果能够方便整理数据，对于不稳定的
排序，可以使用(A[i],i)键对来进行算法，可以使得
不稳定排序变成稳定排序。




# 计数排序


 计数排序的核心思想，是用空间换取时间，
本质是建立了基于元素的Hash表。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac575d3cf409.png)







# 桶排序/基数排序


 将元素分到若干个桶中，每个桶分别排序，然后归
并
 由于桶之间往往是有序的(如：洗牌中的1-13个点
数，整数按照数位0-9基数排序等)，所以，它们的
时间复杂度不是(完全)基于比较的，时间复杂度下
限不是O(NlogN)
 如果桶的个数和待排序数目相同，则退化为记数排
序。
 ——每个桶内只有1个元素
 思考：如果每个桶内最多有2个元素呢？
 求给定N个数的最大间距，要求O(N)的时间复杂度
 如：8,3,17,6,14, 4的最大间距为6


## 附：最大间隔


 给定整数数组A[0…N-1]，求这N个数排序后
最大间隔。如：1,7,14,9,4,13的最大间隔为
4。
 排序后：1,4,7,9,13,14，最大间隔是13-9=4
 显然，对原数组排序，然后求后项减前项的最
大值，即为解。
 可否有更好的方法？

代码如下：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac575f65ab0b.png)





# 寻找和为定值的两个数


 输入一个数组A[0…N-1]和一个数字Sum，在
数组中查找两个数A i ,A j ，使得A i +A j =Sum。


## 暴力求解


 从数组中任意选取两个数x,y，判定它们的和
是否为输入的数字Sum。时间复杂度为
O(N 2 )，空间复杂度O(1)。


## 稍好一点的方法


 两头扫
 如果数组是无序的，先排序O(NlogN)，然后用两个指针
i，j，各自指向数组的首尾两端，令i=0，j=n-1，然后
i++，j--，逐次判断a[i]+a[j]是否等于Sum：
 若a[i]+a[j]>sum，则i不变，j--；
 若a[i]+a[j]<sum，则i++，j不变；
 若a[i]+a[j]==sum，如果只要求输出一个结果，则退出；
否则，输出结果后i++，j--；
 数组无序的时候，时间复杂度最终为
O(NlogN+N)=O(NlogN)。


## 代码如下：




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac5764fadae7.png)





## 讨论：Hash方案的可行性


 算法步骤
 选择适当的Hash函数，对原数组建立Hash结构
 遍历数组a[i]，计算Hash(Sum-a[i])是否存在
 算法可行性
 时间复杂度，空间复杂度






# 排序的目的


 排序本身：得到有序的序列
 方便查找
 如：体会“2-sum问题”的求解过程。
 长度为N的有序数组，查找某元素的时间复杂度
是多少？
 长度为N的有序链表，查找某元素的时间复杂度
是多少？
 单链表、双向链表
 如何解决该问题？




# 跳跃链表(Skip List)


 AVL-Tree/RB-Tree/BTree
 跳跃链表是一种随机化数据结构，基于并联的链
表，其效率可比拟于二叉查找树(对于大多数操作
需要O(logn)平均时间)。具有简单、高效、动态
(Simple、Effective、Dynamic)的特点。
 基本上，跳跃列表是对有序的链表附加辅助链表，
增加是以随机化的方式进行的，所以在列表中的查
找可以快速的跳过部分结点(因此得名)。查找结
点、增加结点、删除结点操作的期望时间都是logN
的(with high probability≈1-1/(n^α), W.H.P.)。
 将在后面的课程中详细阐述。




# COMMENT：




# REF：





 	
  1. 七月在线 算法



