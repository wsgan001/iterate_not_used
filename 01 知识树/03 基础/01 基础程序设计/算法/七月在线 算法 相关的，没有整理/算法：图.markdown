---
author: evo
comments: true
date: 2018-04-04 15:29:08+00:00
layout: post
link: http://106.15.37.116/2018/04/04/algorithm-graph/
slug: algorithm-graph
title: 算法：图
wordpress_id: 3067
categories:
- 随想与反思
tags:
- '@todo'
---

<!-- more -->


# 缘由：


对图相关的算法进行总结。


# 图的表述与搜索


 图的表示
 邻接矩阵
 n*n的矩阵，有边是1，无边是0
 邻接表
 为每个点建立一个链表(数组)存放与之连接的点
 搜索
 BFS (Breadth-First-Search) 广(宽)度优先
 DFS (Depth-First-Search) 深度优先


# 主要内容


 树的遍历和搜索
 (隐式)图的搜索 (连通性)
 重点
 8皇后
 最短路径
 单源图 (Dijkstra)
 任意两点(floyd)
 有负边 (bellman-ford)
 最小生成树 (MST)
 Prim
 Krusal
 拓扑排序 (topsort)




# 广度优先搜索：Breadth First Search，BFS


 最简单、直接的图搜索算法
 从起点开始层层扩展
 第一层是离起点距离为1的
 第二层是离起点距离为2的
 ….
 本质就是按层(距离)扩展，无回退


## BFS分析


 给定某起点a，将a放入缓冲区，开始搜索；
 过程：假定某时刻缓冲区内结点为abc，则
访问结点a的邻接点a 1 a 2 a x ，同时，缓冲区变
成bc a 1 a 2 a x ，为下一次访问做准备；
 辅助数据结构：队列
 先进先出
 从队尾入队，从队首出队
 只有队首元素可见


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4d9b696e18.png)





## BFS分析的两个要点


 结点判重
 如果在扩展中发现某结点在前期已经访问过，则本次不
再访问该结点；显然，第一次访问到该结点时，是访问
次数最少的：最少、最短；
 路径记录
 一个结点可能扩展出多个结点：多后继a 1 a 2 …a x ，
 但是任意一个结点最多只可能有1个前驱(起始结点没有
前驱)：单前驱
 用结点数目等长的数组pre[0…N-1]：
 pre[i]=j：第i个结点的前一个结点是j
 注：再次用到“存索引，不存数据本身”的思路。


## BFS算法框架


 辅助数据结构
 队列q；
 结点是第几次被访问到的d[0…N-1]：简称步数；
 结点的前驱pre[0…N-1]；
 算法描述：
 起点start入队q
 记录步数d[start]=0；
 记录start的前驱pre[start]=-1；
 如果队列q非空，则队首结点x出队，尝试扩展x
 找到x的邻接点集合{y|(x,y)∈E}
 对每个新扩展结点y判重，如果y是新结点，则入队q；
 同时，记录步数d[y]=d[x]+1；前驱pre[y]=x；


## BFS算法的思考


 隐式图：实践中，往往乍看不是关于图的问题，但如果是给定
一个起始状态和一些规则，求解决方案的问题：往往可以根据
这些规则，将各个状态(动态的)建立连接边，然后使用BFS/DFS
框架，一步一步的在解空间中搜索。
 树的层序遍历，是按照从根到结点的距离遍历，可以看做是图
的BFS过程。
 树的先序/后序/中序遍历，是从根搜索到树的叶子结点，然后
回溯，可以看做是图的DFS过程。
 对BFS的改进——双向BFS
 从起点和终点分别走，直到相遇；
 将树形搜索结构变成纺锤形；
 经典BFS中，树形搜索结构若树的高度非常高时，叶子非常多
(树的宽度大)，而把一棵高度为h的树，用两个近似为h/2的树
代替，宽度相对较小。


# 单词变换问题Word ladder


 给定字典和一个起点单词、一个终点单词，
每次只能变换一个字母，问从起点单词是否
可以到达终点单词？最短多少步？
 如：
 start= "hit"
 end = "cog"
 dict = ["hot","dot","dog","lot","log"]
 "hit" -> "hot" -> "dot" -> "dog" -> "cog"




## Word Ladder问题分析


 使用临界表，建立单词间的联系
 单词为图的结点，若能够变换，则两个单词存在无向边；
 若单词A和B只有1个字母不同，则(A-B)存在边；
 建图：
 预处理：对字典中的所有单词建立map、hash或者trie结构，利于后续的查
找
 对于某单词w，单词中的第i位记为β，则将β 替换 为[β+1,’ Z ’] ，查找新
的串nw是否在字典中。如果在，将(w-nw)添加到邻接表项w和nw中(无向
边)
 循环处理第二步
 若使用map，串在字典中的查找认为是O(logN)的，那么，整体时间复杂
度为O(N*len*13*logN)，即O(N*logN)。若使用hash或者trie，整体复杂度
为O(N)
 从起始单词开始，广度优先搜索，看能否到达终点单词。若可以到
达，则这条路径上的变化是最快的。
 思考：是否需要事先计算图本身？
 体会路径记录问题。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4d9fd49f78.png)





## 思考


 有趣的是：虽然从起点单词开始到终点单词
的路径内的单词，必须在词典内，但起点和
终点本身是无要求的。
 是否需要事先计算图本身？
 体会路径记录问题。

Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4da1abbf6e.png)





# 周围区域问题 Surrounded Regions


 给定二维平面，格点处要么是‘X’，要么是
‘O’。求出所有由‘X’围成的区域。
 找到这样的(多个)区域后，将所有的‘O’翻转
成‘X’即可。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4da3b957fd.png)


Surrounded Regions分析

反向思索最简单：哪些‘O’是应该保留的？
 从上下左右四个边界往里走，凡是能碰到的
‘O’ ，都是跟边界接壤的，应该保留。
 思路：
 对于每一个边界上的‘O’作为起点，做若干次广
度优先搜索，对于碰到的‘O’，标记为其他某字
符Y；
 最后遍历一遍整个地图，把所有的Y恢复成
‘O’，把所有现有的‘O’都改成‘X’。

Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4da65c4892.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4da752ea9d.png)





## 思考与拓展


 如果目标区域是三维的呢？


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4da95015a3.png)





# 深度优先搜索DFS


 理念：
 不断深入，“走到头”回退。(回溯思想)
 一般所谓“暴力枚举”搜索都是指DFS
 回忆数组章节中“N-Sum问题”的解法
 实现
 一般使用堆栈，或者递归
 用途：
 DFS的过程中，能够获得的信息
 “时间戳”、“颜色”、父子关系、高度




# 所有括号匹配的字符串


 N对括号能够得到的有效括号序列有哪些？
 如N=3时，有效括号串共5个，分别为：
 1：()()()
 2：()(())
 3：(())()
 4：(()())
 5：((()))




## 问题分析


 任何一个括号序列，都可以写成形式A(B)
 A、B都是若干括号对形成的合法串(可为空串)
 若N=0，括号序列为空。
 若N=1，括号序列只能是()这一种。
 算法描述：i∈[0,N-1]
 计算i对括号的可行序列A ；
 计算N-i-1对括号的可行序列B ；
 组合得到A(B) 。
 注：加上额外一对括号()，总括号共N对



Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4dac571b41.png)





## 思考


可以通过增加缓存的方式，对已经计算得到的字串
直接获取，以空间换时间，降低时间复杂度。
 如果只是计算可行括号串的数目，如何计算？
 事实上，数组A[i]表示长度为i的括号串的可行数目，即
著名的Catalan数。
 该问题在动态规划中继续讨论。
 Calalan数(从0开始数)：
 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,
208012, 742900, 2674440, 9694845, 35357670, 129644790,
477638700, 1767263190, 6564120420, 24466267020,
91482563640, 343059613650, 1289904147324,
4861946401452……


## Code




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4dae1b923d.png)





# 最小平方划分


 一个 正 整数可以由若干个 正 整数的平方和表示，
求整数201314最小的平方划分数目。
 如10，可以写成1 2 +3 2 ，或者1 2 +1 2 +2 2 +2 2 ，显然， 1 2 +3 2
只需要划分为2个完全平方数的和，因此，应该返回2。
 如64，本身是完全平方数8 2 ，返回1。
 这种平方划分是一定存在的。
 如：将任意正整数n划分成n个1显然是一个合理划分(不
一定最小)。
 类似的有Word Break问题、最小回文划分问题。


## 贪心？


 对于给定的整数n，找到比n小的最大的完全
平方数k，继续计算n-k……直到1为止。
 贪心不能解决问题。
 如12，第一次找到9，继续计算3。最终得到
12=9+1+1+1，划分数目为4；
 但12=4+4+4，最小划分数目为3。




## 问题分析


 如果已经求出了1…n-1的所有数的最小划
分，如何求数n的最小划分呢？
 若a+k 2 =n，则在a的划分方案上加上数字k，
即为n的划分方案。




## 代码实现


 可以使用动态规划，在得到1…n-1的最小平
方划分的前提下计算n；n从1到N遍历，即最
终得到N的最小平方划分。
 或使用递归；辅助数组split[1…n]的作用是
记忆小规模问题，防止重复计算。
 动态规划和记忆递归的时间复杂度都是\(O(n\dot \sqrt{n})\)
 计算n的划分，迭代次数是\(\sqrt{n}\)
 一共计算n次。




# 题中题：如何判断完全平方数


 给定正整数n，如果判断n是否是一个完全平
方数？
 调用系统函数float sqrt(float)，记返回值取整
后为a，计算a 2 是否等于n。
 系统函数本身仍然需要浮点运算(如Taylor展式)
 使用牛顿迭代法。




## 平方根算法的证明


 在任意点x 0 处Taylor展开




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4db43ee1a8.png)


数的平方根
 一般若干次
(5、6次)迭代
即可获得比较
好的近似值。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4db4d45cc8.png)


动态规划Code

 201314=4^2 +227^2 +387^2


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4db6718a05.png)





# 题外话：四平方和定理


每个正整数均可表示为最多4个整数的平方和。
 欧拉发现的恒等式：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4e9ac6efd2.png)


 如果正整数m和n能表示为4个整数的平方和，则其
乘积mn也能表示为4个整数的平方和。
 只需再证明每个素数可以表示成4个整数的平方和即可。
 拉格朗日和欧拉分别在1770年和1773年作出证明。

附：递归Code

 整数的平方根


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4e9bcd932c.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4e9d92198c.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4eef8e522b.png)







# COMMENT：




# REF：





 	
  1. 七月在线  算法



