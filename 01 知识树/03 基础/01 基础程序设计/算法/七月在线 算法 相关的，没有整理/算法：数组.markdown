
# 缘由：


对数组相关算法进行整理：


# 求局部最大值


给定一个无重复元素的数组A[0…N-1]，求
找到一个该数组的局部最大值。规定：在数
组边界外的值无穷小。即：A[0]＞A[-1]，
A[N-1] ＞A[N]。
 显然，遍历一遍可以找到全局最大值，而全
局最大值显然是局部最大值。
 可否有更快的办法？




## 问题分析


 定义：若子数组Array[from,…,to]满足
 Array[from]＞Array[from-1]
 Array[to]＞Array[to+1]
 称该子数组为“高原数组”。
 若高原数组长度为1，则该高原数组的元素为局
部最大值。




## 算法描述


 使用索引left、right分别指向数组首尾，根据定义，
该数组为高原数组。
 求中点mid=(left+right)/2
 A[mid]＞A[mid+1]，子数组A[left…mid]为高原数组
 丢弃后半段：right=mid
 A[mid+1]＞A[mid]，子数组A[mid…right]高原数组
 丢弃前半段：left=mid+1
 递归直至left==right
 时间复杂度为O(logN)。



Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c5c4107e7.png)





# 第一个缺失的整数


给定一个数组A[0…N-1]，找到从1开始，第
一个不在数组中的正整数。
 如3,5,1,2,-3,7,14,8输出4。




## 循环不变式


 思路：将找到的元素放到正确的位置上，如
果最终发现某个元素一直没有找到，则该元
素即为所求。
 循环不变式：如果某命题初始为真，且每次
更改后仍然保持该命题为真，则若干次更改
后该命题仍然为真。
 为表述方便，下面的算法描述从1开始数。


## 利用循环不变式设计算法


 假定前i-1个数已经找到，并且依次存放在
A[1,2,…,i-1]中，继续考察A[i]：
 若A[i]＜i且A[i]≥1，则A[i]在A[1,2,…,i-1]中已经出现
过，可以直接丢弃。
 若A[i]为负，则更应该丢弃它。
 若A[i]＞i且A[i]≤N，则A[i]应该位于后面的位置上，则
将A[A[i]]和A[i]交换。
 若A[i]≥N，由于缺失数据一定小于N，则A[i]丢弃。
 若A[i]＝i，则A[i]位于正确的位置上，则i加1，循环不变
式扩大，继续比较后面的元素。




## 合并相同的分支


 整理算法描述：
 若A[i]＜i或者A[i]＞N，则丢弃A[i]
 若A[i]＞i，则将A[A[i]]和A[i]交换。
 若A[i]＝i，i加1，继续比较后面的元素。
 思考：如何快速丢弃A[i]？
 将A[N]赋值给A[i]，然后N减1。

Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c5e9353eb.png)





# 查找旋转数组的最小值


 假定一个排序数组以某个未知元素为支点做
了旋转，如：原数组0 1 2 4 5 6 7旋转后得到
4 5 6 7 0 1 2。请找出旋转后数组的最小值。
假定数组中没有重复数字。


## 分析


 旋转之后的数组实际上可以划分成两个有序
的子数组：前面子数组的大小都大于后面子
数组中的元素；
 4 5 6 7 0 1 2
 注意到实际上最小的元素就是两个子数组的分
界线。




## 寻找循环数组最小值：4 5 6 7 0 1 2


 用索引left，right分别指向首尾元素，元素不重复。
 若子数组是普通升序数组，则A[left]<A[right]。
 若子数组是循环升序数组，前半段子数组的元素全都大
于后半段子数组中的元素：A[left]>A[right]
 计算中间位置mid = (low+high)/2;
 显然，A[low…mid]与A[mid+1…high]必有一个是循环升
序数组，一个是普通升序数组。
 若：A[mid]>A[high]，说明子数组A[mid+1,mid+2,…high]
循环升序；更新low=mid+1；
 若：A[mid]<A[high] ，说明子数组A[mid+1,mid+2,…high]
普通升序；更新：high=mid

代码


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c60b651a9.png)





# 零子数组


 求对于长度为N的数组A，求连续子数组的
和最接近0的值。
 如：
 数组A、1, -2, 3, 10, -4, 7, 2, -5
 它是所有子数组中，和最接近0的是哪个？




## 算法流程


 申请比A长1的空间sum[-1,0…,N-1]，sum[i]
是A的前i项和。
 trick：定义sum[-1] = 0
 显然有：


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c62459b4f.png)



 算法思路：
 对sum[-1,0…,N-1]排序，然后计算sum相邻元素
的差的绝对值，最小值即为所求
 在A中任意取两个前缀子数组的和求差的最小值


## 零子数组的讨论


计算前n项和数组sum和计算sum相邻元素差
的时间复杂度，都是O(N)，排序的时间复杂
度认为是O(NlogN)，因此，总时间复杂度：
O(NlogN)。
 思考：如果需要返回绝对值最小的子数组本
身呢？


## Code




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c63a960ce.png)





# 最大子数组和


 给定一个数组A[0,…,n-1]，求A的连续子数
组，使得该子数组的和最大。
 例如
 数组： 1, -2, 3, 10, -4, 7, 2, -5，
 最大子数组：3, 10, -4, 7, 2


## 分析


 定义：前缀和sum[i] = a[0] + a[1] + ...+a[i]
 则：a[i,j]=sum[j]-sum[i-1](定义p[-1] = 0)


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c659f3005.png)



 算法过程
 1. 求i前缀sum[i]：
 遍历i：0≤i≤n-1
 sum[i]=sum[i-1]+a[i]
 2. 计算以a[i]结尾的子数组的最大值
 对于某个i：遍历0≤j≤i，求sum[j]的最小值m
 sum[i]-m即为以a[i]结尾的数组中最大的子数组的值
 3. 统计sum[i]-m的最大值， 0≤i≤n-1
 1、2、3步都是线性的，因此，时间复杂度O(n)。


## 进一步的分析


 记S[i]为以A[i]结尾的数组中和最大的子数组
 则：S[i+1] = max(S[i]+A[i+1], A[i+1])
 S[0]=A[0]
 遍历i： 0≤i ≤n-1
 动态规划：最优子问题
 时间复杂度：O(n)


## 动态规划Code




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c66aa5e93.png)





## 思考


 若除了输出最大子数组的和，还需要输出最
大子数组本身，应该怎么做？


## 参考代码




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c681d17aa.png)





# 最大间隔


 给定整数数组A[0…N-1]，求这N个数排序后
最大间隔。如：1,7,14,9,4,13的最大间隔为
4。
 排序后：1,4,7,9,13,14，最大间隔是13-9=4
 显然，对原数组排序，然后求后项减前项的最
大值，即为解。
 可否有更好的方法？




## 问题分析


 假定N个数的最大最小值为max，min，则这
N个数形成N-1个间隔，其最小值是\(\frac{max-min}{N-1}\)
 如果N个数完全均匀分布，则间距全部是\(\frac{max-min}{N-1}\)
且最小；
 如果N个数不是均匀分布，间距不均衡，则最大
间距必然大于\(\frac{max-min}{N-1}\)


## 解决思路


 思路：将N个数用间距 \(\frac{max-min}{N-1}\)分成N-1个区
间，则落在同一区间内的数不可能有最大间
距。统计后一区间的最小值与前一区间的最
大值的差即可。
 若没有任何数落在某区间，则该区间无效，不
参与统计。
 显然，这是借鉴桶排序/Hash映射的思想。


## 桶的数目


 同时，N-1个桶是理论值，会造成若干个桶
的数目比其他桶大1，从而造成统计误差。
 如：7个数，假设最值为10、80，如果适用6个
桶，则桶的大小为70/6=11.66，每个桶分别为：
[10,21]、 [22,33]、 [34,44]、 [45,56]、 [57,68]、
[69,80]，存在大小为12的桶，比理论下界11.66
大。
 因此，使用N个桶。

Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c7032793f.png)





#




# 子集和数问题 N-Sum


 已知数组A[0…N-1]，给定某数值sum，找出
数组中的若干个数，使得这些数的和为
sum。
 布尔向量x[0…N-1]
 x[i]=0表示不取A[i]，x[i]=1表示取A[i]
 假定数组中的元素都大于0：A[i]＞0
 这是个NP问题！


## 分析方法


 直接递归法(枚举)
 分支限界
 存在负数的处理办法


## 直接递归法




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c75f8e4e8.png)





## 考虑对于分支如何限界


 前提：数组A[0…N-1]的元素都大于0
 考察向量x[0…N-1]，假定已经确定了前i个
值，现在要判定第i+1个值x[i]为0还是1。
 假定由x[0…i-1]确定的A[0…i-1]的和为has；
 A[i,i+1,…N-1]的和为residue(简记为r)；
 has+a[i]≤sum并且has+r≥sum：x[i]可以为1；
 has+(r-a[i])>= sum：x[i]可以为0；
 注意，这里是“可以”——可以能够：可能。


## 分支限界法




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c786e3594.png)





## 数理逻辑的重要应用：分支限界的条件


 分支限界的条件是充分条件吗？
 在新题目中，如何发现分支限界的条件。
 学会该方法，比此问题本身更重要


## 考虑负数的情况


 枚举法肯定能得到正确的解
 如何对负数进行分支限界？
 可对整个数组A[0…N-1]正负排序，使得负数都
在前面，正数都在后面，使用剩余正数的和作
为分支限界的约束：
 如果A[i]为负数：如果全部正数都算上还不够，
就不能选A[i]；
 如果递归进入了正数范围，按照数组是全正数
的情况正常处理；

带负数的分支限界


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c7a1b7ae7.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c7d663076.png)





# 求字符串的最长回文子串


 回文子串的定义：
 给定字符串str，若s同时满足以下条件：
 s是str的子串
 s是回文串
 则，s是str的回文子串。
 该算法的要求，是求str中最长的那个回文子
串。


## 解法1 – 枚举中心位置


 int LongestPalindrome(const char *s, int n)
 {
 int i, j, max;
 if (s == 0 || n < 1)
 return 0;
 max = 0;
 for (i = 0; i < n; ++i) { // i is the middle point of the palindrome
 for (j = 0; (i - j >= 0) && (i + j < n); ++j) // if the length of the palindrome is odd
 if (s[i - j] != s[i + j])
 break;
 if (j * 2 + 1 > max)
 max = j * 2 + 1;
 for (j = 0; (i - j >= 0) && (i + j + 1 < n); ++j) // for the even case
 if (s[i - j] != s[i + j + 1])
 break;
 if (j * 2 + 2 > max)
 max = j * 2 + 2;
 }
 return max;
 }


## 算法解析 step1——预处理


 因为回文串有奇数和偶数的不同。判断一个串是否
是回文串，往往要分开编写，造成代码的拖沓。
 一个简单的事实：长度为n的字符串，共有n-1个
“邻接”，加上首字符的前面，和末字符的后面，共
n+1的“空”(gap)。因此，字符串本身和gap一起，共
有2n+1个，必定是奇数；
 abbc → #a#b#b#c#
 aba → #a#b#a#
 因此，将待计算母串扩展成gap串，计算回文子串
的过程中，只考虑奇数匹配即可。


## 数组int P[size]


 字符串12212321→ S[] = "$#1#2#2#1#2#3#2#1#";
 trick：为处理统一，最前面加一位未出现的字符，如$
 用一个数组P[i]来记录以字符S[i]为中心的最长回文
子串向左/右扩张的长度(包括S[i])，比如S和P的对
应关系：
 S # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 #
 P 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1
 P[i]-1正好是原字符串中回文串的总长度
 若P[i]为偶数，考察x=P[i]/2、 2*x-1
 思考：若P[i]为奇数呢？
 答：不考虑！(为何？)


## 分析算法核心


 我们的任务：假定已经得到了前i个值，考察i+1如何计算
 即：在P[0...i-1]已知的前提下，计算P[i]的值。换句话说，算法
的核心，是在P[0...i-1]已知的前提下，能否给P[i]的计算提供一
点有用的信息呢？
 1、通过简单的遍历，得到i个三元组{k,P[k],k+P[k]}，0≤k≤i-1
 trick：以k为中心的字符形成的最大回文子串的最右位置是k+P[k]-1
 2、以k+P[k]为关键字，挑选出这i个三元组中，k+P[k]最大的那个
三元组，不妨记做(id, P[id]，P[id]+id)。进一步，为了简化，记
mx=P[id]+id，因此，得到三元组为(id,P[id],mx)，这个三元组的含
义非常明显：所有i个三元组中，向右到达最远的位置，就是mx；
 3、在计算P[i]的时候，考察i是否落在了区间[0,mx)中；
 若i在mx的右侧，说明[0,mx)没有能够控制住i，P[0..i-1]的已
知，无法给P[i]的计算带来有价值信息；
 若i在mx的左侧，说明[0,mx)控制(也有可能部分控制)了i，现在
以图示来详细考察这种情况。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c82533b10.png)





## Manacher递推关系


 记i关于id的对称点为j(=2*id-i)，若此时满足条件
mx-i>P[j]：
 记my为mx关于id的对称点(my=2*id-mx) ；
 由于以S[id]为中心的最大回文子串为
S[my+1…id…mx-1]，即：S[my+1…,id]与
S[id,…,mx-1]对称，而i和j关于id对称，因此
P[i]=P[j](P[j]是已知的)。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c82d6b054.png)


Manacher递推关系
 记i关于id的对称点为j(=2*id-i)，若此时满足条件mx-i
＜P[j]：
 记my为mx关于id的对称点(my=2*id-mx) ；
 由于以S[id]为中心的最大回文子串为
S[my+1…id…mx-1]，即：S[my+1…,id]与S[id…,mx-1]
对称，而i和j关于id对称，因此P[i]至少等于mx-i(图中
绿色框部分)。


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c83e2661d.png)


Manacher Code


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c8446c3ce.png)


原始算法的个人改进意见

P[j] > mx – i：P[i] = mx – i
 P[j] < mx – i：P[i] = P[j]
 P[j] = mx – i：P[i] ≥P[j]
 基本Manacher算法，红色的等号都是≥

Manacher改进版


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c853a161f.png)





# 附：完美洗牌算法


 长度为2n的数组{a 1 ,a 2 ,a 3 ,...,a n ,b 1 ,b 2 ,b 3 ,...,b n }，
经过整理后变成{a 1 ,b 1 ,a 2 ,b 2 ,a 3 ,b 3 ,…...,a n ,b n }，
要求时间复杂度O(n)，空间复杂度O(1) 。
 题目比较“数学”，当做阅读材料即可。


## 步步前移


 观察变换前后两个序列的特点，我们可做如下一系列操作：
 第①步确定b1的位置，即让b1跟它前面的a2，a3，a4交换：
 a1，b1，a2，a3，a4，b2，b3，b4
 第②步、接着确定b2的位置，即让b2跟它前面的a3，a4交换：
 a1，b1，a2，b2，a3，a4，b3，b4
 第③步、b3跟它前面的a4交换位置：
 a1，b1，a2，b2，a3，b3，a4，b4
 b4已在最后的位置，不需要再交换。如此，经过上述3个步骤
后，得到我们最后想要的序列。
 移动n-1次，第i次将n-i个元素后移。时间复杂度为O(N^2)。




## 中间交换


 每次让序列中最中间的元素进行交换。
 对于a1，a2，a3，a4，b1，b2，b3，b4
 第①步：交换最中间的两个元素a4，b1，序列变
成：
 a1，a2，a3，b1，a4，b2，b3，b4
 第②步，让最中间的两对元素各自交换：
 a1，a2，b1，a3，b2，a4，b3，b4
 第③步，交换最中间的三对元素，序列变成：
 a1，b1，a2，b2，a3，b3，a4，b4

中间交换


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c87e277a2.png)




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c8829a731.png)


玩乐中带来的算法思维


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c88f7ca89.png)





# 完美洗牌算法


 2004年，microsoft的Peiyush Jain在他发表一
篇名为：“A Simple In-Place Algorithm for In-
Shuffle”的论文中提出了完美洗牌算法。


## 位置变换


a1,a2,a3,...an,b1,b2,b3..bn → b1,a1,b2,a2,b3,a3...bn,an
 设定数组的下标范围是[1..2n]。考察元素的最终位置：
 以n=4为例，前n个元素中，
 第1个元素a1到了原第2个元素a2的位置，即1->2；
 第2个元素a2到了原第4个元素a4的位置，即2->4；
 第3个元素a3到了原第6个元素b2的位置，即3->6；
 第4个元素a4到了原第8个元素b4的位置，即4->8；
 前n个元素中，第i个元素的最终位置为(2 * i)。
 后n个元素，可以看出：
 第5个元素b1到了原第1个元素a1的位置，即5->1；
 第6个元素b2到了原第3个元素a3的位置，即6->3；
 第7个元素b3到了原第5个元素b1的位置，即7->5；
 第8个元素b4到了原第7个元素b3的位置，即8->7；
 后n个元素，第i个元素的最终位置为：(2*(i - n)) - 1 = 2*i - 2*n-1 =
(2*i) % (2*n+1)

两个圈

我们得到两个圈
 1 → 2 → 4 → 8 → 7 → 5 → 1
 3 → 6 → 3


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c96468ea8.png)





## K个圈


对于2*n =(3^k-1)这种长度的数组，恰好只有
k个圈，且每个圈的起始位置分别是
1,3,9，...3^(k-1)

若：2m可以写成3^k-1的形式


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c97660671.png)





## 任意长度数组的完美洗牌算法




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c97ef3a77.png)





## 循环移位


(AB)’=B’A’


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c98c9b794.png)





## 完美洗牌算法流程


 输入数组A[1..2 * n]
 step 1 找到 2*m=3^k-1，且3^k≤2*n<3^(k+1)
 step 2 把a[m+1…m+n]那部分循环右移m位
 step 3 对每个i = 0,1,2..k - 1，3^i是每个圈的
起始位置，做cycle_leader算法；
 注：因为子数组长度为m，所以对2*m+1取模
 step 4 对数组的剩余部分A[2*m+1.. 2*n]继续
使用本算法。

完美洗牌代码


![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c9a63fd4a.png)





## 依据


2是3的原根，2是9的原根
 {2^0,2^1}={1,2}
 {2^0,2^1,2^2,2^3,2^4,2^5,2^6,2^7,2^8}mod 9
 ={1,2,4,8,7,5}
 而φ(9) =6


## 附：算法原文




![](http://106.15.37.116/wp-content/uploads/2018/04/img_5ac4c9c12cbde.png)





## 进一步的思考


要求输出是a1,b1,a2,b2……an,bn，而完美洗牌算法输出是
b1,a1,b2,a2,……bn,an,怎么办？
 先把a部分和b部分交换，或者最后再交换相邻的两个位置——不够美观。
 原数组第一个和最后一个不变，中间的2*(n-1)项用原始的完美洗牌算法。
 逆完美洗牌问题：给定b1,a1,b2,a2,……bn,an，要求输出
a1,a2,a3,……an,b1,b2,b3,……bn。
 既然完美洗牌问题可以通过若干圈来解决，那么，逆完美洗牌问题仍然存
在是若干圈，并且2*n =(3^k-1)这种长度的数组恰好只有k个圈的结论仍然
成立。
 完美洗多付牌：给定a1,a2,……an, b1,b2,……bn, c1,c2,……cn，要求输
出是c1,b1,a1,c2,b2,a2,……cn,bn,an
 2付牌的结论：2是群(Z/3^k)*最小生成元，且(3^k-1)这种长度的数组，恰
好只有k个圈
 考察是否存在某数字p (如5、7、11、13等)，使得数字3是群(Z/p^k)*的最
小生成元，再验证p是否存在结论(p^k-1)这种长度的数组，恰好只有k个
圈。
 提示：3是7的原根，是49的原根，于是3是7^k的原根








# COMMENT：


**完美洗牌算法再总结下。**


# REF：






  1. 七月在线 算法
