### 6

#### 继承与面向对象设计

Inheritance and Object-Oriented Design

面向对象编程(OOP)几乎已经风靡两个年代了，所以关于继承、派生、virtual 函数等等，可能你已经有了一些经验。纵使你过去只以C编写程序，如今肯定也无 法逃脱OOP的笼罩。

尽管如此，C++的OOP有可能和你原本习惯的OOP稍有不同：“继承”可以 是单一继承或多重继承，每一个继承连接(link)可以是public, protected或private， 也可以是virtual或non-virtual。然后是成员函数的各个选项：virtual? non-virtual? pure virtual?以及成员函数和其他语言特性的交互影响：缺省参数值与virtual函数 有什么交互影响？继承如何影响C++的名称查找规则？设计选项有哪些？如果 class的行为需要修改，virtual函数是最佳选择吗？

本章对这些题目全面宣战。此外我也解释C++各种不同特性的真正意义，也 就是当你使用某个特定构件你真正想要表达的意思。例如“public继承”意味"is-a"， 如果你尝试让它带着其他意义，你会惹祸上身。同样道理，virtual函数意味“接口 必须被继承”，non-virtual函数意味“接口和实现都必须被继承”。如果不能区分 这些意义，会造成C++程序员大量的苦恼。

如果你了解C++各种特性的意义，你会发现，你对OOP的看法改变了。它不 再是一项用来划分语言特性的仪典，而是可以让你通过它说出你对软件系统的想 法。一旦你知道该通过它说些什么，移转至C++世界也就不再是可怕的高要求了。

Effective C++中文版，第三版

条款32:确定你的public继承塑模出is-a关系

Make sure public inheritance models "is-a."

在《SonjeAdwsf WflfchPVhiZe SowieMwsf SZeep》（W. H. Freeman and Company, 1974）这本书中，作者William Dement说了一个故事，谈到他曾经试图让学生记下 课程中最重要的一些教导。书上说,他告诉他的班级，一般英国学生对于发生在1066 年的黑斯廷斯（Hastings）战役所知不多。如果有学生记得多一些，Dement强调， 无非也只是记得1066这个数字而已。然后Dement继续其课程，其中只有少数重要 信息，包括“安眠药反而造成失眠症”这类有趣的事情。他一再要求学生，纵使忘 了课程中的其他每一件事，也要记住这些数量不多的重要事情。Dement在整个学 期中不断耳提面命这样的话。

课程结束后，期末考的最后一道题目是：“写下你从本课程获得的一件永生不 忘的事”。当Dement批改试卷，他目瞪口呆。几乎每一个人都写下"1066'

这就是为什么现在我要戒慎恐惧地对你声明，以C++进行面向对象编程，最 重要的一个规则是：public inheritance （公开继承）意味"is-a"（是一种）的关系。 把这个规则牢牢地烙印在你的心中吧！

如果你令class D （"Derived"）以public形式继承class B （"Base"）.你便是告 诉C++编译器（以及你的代码读者）说，每一个类型为D的对象同时也是一个类 型为B的对象，反之不成立。你的意思是B比D表现出更一般化的概念，而D比B 表现出更特殊化的概念。你主张“B对象可派上用场的任何地方，D对象一样可以 派上用场”（译注：此即所谓Liskov Substitution Principle）,因为每一个D对象都 是一种（是一个）B对象。反之如果你需要一个D对象，B对象无法效劳，因为虽 然每个D对象都是一个B对象，反之并不成立。

C++对于“public继承”严格奉行上述见解。考虑以下例子：

class Person { ... };

class Student: public Person { ... };

根据生活经验我们知道，每个学生都是人，但并非每个人都是学生。这便是这 个继承体系的主张。我们预期，对人可以成立的每一件事——例如每个人都有生 日——对学生也都成立。但我们并不预期对学生可成立的每一件事——例如他或她

Effective C++中文版，第三版

注册于某所学校——对人也成立。人的概念比学生更一般化，学生是人的一种特殊 形式。

于是，承上所述，在C++领域中，任何函数如果期望获得一个类型为Person (或 pointer-to-Person 或 reference-to-Person)的实参，都也愿意接受—Student

对象(或 pointer-to-Student 或 reference-to-Student):

void eat (const Persons p) ;    //任何人都会吃

void study (const Students s) ;    //只有学生才到校学习

Person p;    //p 是人

Student s;    //s 是学生

eat (p);    //没问题，p是人    '

eat(s);    //没问题，s是学生，而学生也是(is-a)人

study (s) ;    //没问题，s是个学生

study (p) ;    //错误！ p不是个学生

这个论点只对public继承才成立。只有当Student以public形式继承Person, C+十的行为才会如我所描述。private继承的意义与此完全不同(见条款39)，至于 protected继承，那是一种其意义至今仍然困惑我的东西。

public继承和is-a之间的等价关系听起来颇为简单，但有时候你的直觉可能会

误导你。举个例子，企鹅(penguin)是一种鸟，这是事实。鸟可以飞，这也是事实。

如果我们天真地以C++描述这层关系，结果如下：

class Bird { public:

virtual void fly {);    //鸟可以飞

}；

class Penguin: public Bird {    //企鹅是一种鸟

}；

突然间我们遇上了乱流，因为这个继承体系说企鹅可以飞，而我们知道那不是 真的。怎么回事？

在这个例子中，我们成了不严谨语言(英语)下的牺牲品。当我们说鸟会飞的 时候，我们真正的意思并不是说所有的鸟都会飞，我们要说的只是一般的鸟都有飞 行能力。如果谨慎一点，我们应该承认一个事实：有数种鸟不会飞。我们来到以下

Effective C++中文版，第三版

继承关系，它塑模出较佳的真实性： class Bird {

...    //没有声明fly函数

}；

class FlyingBird: public Bird { public:

virtual void fly{);

}；

class Penguin: public Bird {

...    //没有声明fly函数

};

这样的继承体系比原先的设计更能忠实反映我们真正的意思。

即便如此，此刻我们仍然未能完全处理好这些鸟事，因为对某些软件系统而言， 可能不需要区分会飞的鸟和不会飞的鸟。如果你的程序忙着处理鸟喙和鸟翅，完全 不在乎飞行，原先的“双classes继承体系”或许就相当令人满足了。这反映出一个 事实，世界上并不存在一个“适用于所有软件”的完美设计。所谓最佳设计，取决 于系统希望做什么事，包括现在与未来。如果你的程序对飞行一无所知，而且也不 打算未来对飞行“有所知”，那么不去区分会飞的鸟和不会飞的鸟，不失为一个完 美而有效的设计。实际上它可能比“对两者做出区隔”更受欢迎，因为这样的区隔 在你企图塑模的世界中并不存在。

另有一种思想派别处理我所谓"所有的鸟都会飞，企鹅是鸟，但是企鹅不会飞， 喔欧”的问题，就是为企鹅重新定义fly函数，令它产生一个运行期错误：

void error (const std:: strings msg);"定义于另夕卜某处

class Penguin: public Bird { public:

virtual void fly() { error("Attempt to make a penguin fly!n); }

}；

Effective C++中文版，第三版

很重要的是，你必须认知这里所说的某些东西可能和你所想的不同。这里并不 是说“企鹅不会飞”，而是说“企鹅会飞，但尝试那么做是一种错误”。

如何描述其间的差异？从错误被侦测出来的时间点观之，"企鹅不会飞”这一 限制可由编译期强制实施，但若违反“企鹅尝试飞行，是一种错误”这一条规则， 只有运行期才能检测出来。

为了表现“企鹅不会飞，就这样”的限制，你不可以为Penguin定义fly函数： class Bird {

...    //没有声明fly函数

};

class Penguin: public Bird {

...    //没有声明fly函数

};

现在，如果你试图让企鹅飞，编译器会对你的背信加以谴责：

Penguin p;

p.fly( );    //错误！

这和采取“令程序于运行期发生错误”的解法极为不同。若以那种做法，编译 器不会对P.fly调用式发出任何抱怨。条款18说过：好的接口可以防止无效的代 码通过编译，因此你应该宁可采取“在编译期拒绝企鹅飞行”的设计，而不是“只 在运行期才能侦测它们”的设计。

或许你承认你对鸟类缺乏直觉，但基础几何学得不错。喔，是吗？那么我请问， 正方形和矩形之间可能有多么复杂？

好，请回答这个简单的问题：class Square应该以public形式继承class Rectangle 吗？

Effective C++中文版，第三版

##### [www.linuxidc.com](http://www.linuxidc.com)

“咄！ ”你说，“当然应该如此！每个人都知道正方形是一种矩形，反之则不 一定”，这是真理，至少学校是这么教的。但是我不认为我们还在象牙塔内。

考虑这段代码：

class Rectangle { public:

virtual void setHeight(int newHeight); virtual void setwidth(int newWidth);

//返回当前值



//这个函数用以增加r的面积



//为r的宽度加10

//判断r的高度是否未曾改变



virtual int height( ) const; virtual int width() const;

}；

void makeBigger(Rectangles r)

{

int oldHeight = r.height(); r.setwidth(r.width。+ 10); assert(r.height( ) == oldHeight);

}

显然，上述的assert结果永远为真。因为makeBigger只改变r的宽度；r的 高度从未被更改。

现在考虑这段代码，其中使用public继承，允许正方形被视为一种矩形：

class Square: public Rectangle { ... };

Square s;

s.height ()) ;    //这对所有正方形一定为真。

"由于继承，s是一种(is-a)矩形, //所以我们可以增加其面积。

//对所有正方形应该仍然为真。



assert(s.width() makeBigger(s);

assert (s .width () == s.height ());

这也很明显，第二个assert结果也应该永远为真。因为根据定义，正方形的 宽度和其高度相同。

但现在我们遇上了一个问题。我们如何调解下面各个assert判断式：

■调用makeBigger之前，s的高度和宽度相同；

■在makeBigger函数内，s的宽度改变，但高度不变；

Effective C++中文版，第三版

■    makeBigger返回之后，s的高度再度和其宽度相同。（注意s是以reference 方式传给makeBigger,所以makeBigger修改的是s自身，不是s的副本。）

怎么样？

欢迎来到“public继承”的精彩世界。你在其他领域（包括数学）学习而得的 直觉，在这里恐怕无法如预期般地帮助你。本例的根本困难是，某些可施行于矩形 身上的事情（例如宽度可独立于其高度被外界修改）却不可施行于正方形身上（宽 度总是应该和高度一样）。但是public继承主张，能够施行于base class对象身上 的每件事情，每件事情唷，也可以施行于derived class对象身上。在正方形和矩形 例子中（另一个类似例子是条款38的sets和lists），那样的主张无法保持，所 以以public继承塑模它们之间的关系并不正确。编译器会让你通过，但是一如我们 所见，这并不保证程序的行为正确。就像每一位程序员一定学过的（某些人也许比 其他人更常学到）：代码通过编译并不表示就可以正确运作。

不要因为你发展经年的软件直觉在与面向对象观念打交道的过程中失去效用， 便心慌意乱起来。那些知识还是有价值的，但现在你已经为你的“设计”军械库加 上继承（inheritance）这门大炮，你也必须为你的直觉添加新的洞察力，以便引导 你适当运用“继承”这一支神兵利器。当有一天有人展示一个长达数页的函数给你 看，你终将回忆起“令Penguin继承Bird，或是令Square继承Rectangle”的概 念和趣味；这样的继承有可能接近事实真象，但也有可能不。

is-a并非是唯一存在于classes之间的关系。另两个常见的关系是has-a （有一 个）和is-implemented-in-terms*of （根据某物实现出）。这些关系将在条款38和 39讨论。将上述这些重要的相互关系中的任何一个误塑为is-a而造成的错误设计， 在C++中并不罕见，所以你应该确定你确实了解这些个“classes相互关系”之间 的差异，并知道如何在C++中最好地塑造它们。

请记住

■    “public继承”意味is-a。适用于base classes身上的每一件事情一定也适用于 derived classes身上，因为每一个derived class对象也都是一个base class对象。

Effective C++中文版，第三版

条款33：避免遮掩继承而来的名称

Avoid hiding inherited names.

关于“名称”，莎士比亚说过这样一句话：“名称是什么呢？”他问，“一朵 玫瑰叫任何名字还是一样芬芳。”吟游诗人也写过这样的话：“偷了我的好名字的 人呀……害我变得好可怜。”完全正确。这把我们引到了 C++“继承而来的名称”。

这个题材和继承其实无关，而是和作用域(scopes)有关。我们都知道在诸如 这般的代码中：

int x;

void someFunc()

{

double x; std::cin » x;

}



//global 变量

//local 变量

//读一个新值赋予local变量x

这个读取数据的语句指涉的是local变量x，而不是global变量x，因为内层作 用域的名称会遮掩(遮蔽)外围作用域的名称。我们可以这样看本例的作用域形势：

| Global scope |                   |
| ------------ | ----------------- |
| X            | SomeFunc's scopeX |

当编译器处于someFunc的作用域内并遭遇名称x时，它在local作用域内查找 是否有什么东西带着这个名称。如果找到就不再找其他作用域。本例的someFUnc 的x是double类型而global x > int类型，但那不要紧。C++的名称遮掩规则 (name-hiding rules)所做的唯一事情就是：遮掩名称。至于名称是否应和相同或不

同的类型，并不重要。本例中一个名为x的double遮掩了一个名为x的int。

现在导入继承。我们知道，当位于一个derived class成员函数内指涉(refer to) base class内的某物(也许是个成员函数、typedef、或成员变量)时，编译器可以找 出我们所指涉的东西，因为derived classes继承了声明于base classes内的所有东西。 实际运作方式是，derived class作用域被嵌套在base class作用域内，像这样：

Effective C++中文版，第三版

class Base { private:

int x; public:

Base的作用域

x(成员变量) mfl(l个函叙) mf20个函数) mf3(l个函数)



virtual void mfl(> = 0; virtual void mf2(); void mf3 ();

Derived的作用域

mfl(l个函数) mf4(l个函数)



}；

class Derived: public Base { public:

virtual void mfl(); void mf4 ();

}；

此例内含一组混合了public和private名称，以及一组成员变量和成员函数名称。 这些成员函数包括pure virtual, impure virtual和non-virtual三种，这是为了强调我们 谈的是名称，和其他无关。这个例子也可以加入各种名称类型，例如emims，nested classes和typedefs。整个讨论中唯一重要的是这些东西的名称，至于这些东西是什 么并不重要。本例使用单一继承，然而一旦了解单一继承下发生的事，很容易就可 以推想C++在多重继承下的行为。

假设derived class内的mf4的实现码部分像这样：

void Derived::mf4()

{

mf 2 ();

}

当编译器看到这里使用名称mf2,必须估算它指涉(refer to)什么东西。编译 器的做法是查找各作用域，看看有没有某个名为mf2的声明式。首先查找local作 用域(也就是mf4覆盖的作用域)，在那儿没找到任何东西名为mf2。于是查找其 外围作用域，也就是class Derived覆盖的作用域。还是没找到任何东西名为mf2, 于是再往外围移动，本例为base class。在那儿编译器找到一个名为mf2的东西了， 于是停止查找。如果Base内还是没有mf2,查找动作便继续下去，首先找内含Base 的那个namespace(s)的作用域(如果有的话)，最后往global作用域找去=

Effective C++中文版，第三版

刚才我描述的程序虽然精确，但范围不够广。我们的目标并不是为了知道撰写 编译器必须实践的名称查找规则，而是希望知道足够的信息，用以避免发生让人不 快的惊讶。对于后者，现在我们有了丰富的信息。

再次考虑前一个例子，这次让我们重载mfl和mf3,并且添加一个新版mf3到 Derived去。如条款36所说，这里发生的事情是：Derived重载了 mf3,那是一个 继承而来的non-virtual函数。这会使整个设计立刻显得疑云重重，但为了充分认识 继承体系内的“名称可视性”，我们暂时安之若素。

class Base { private:

Base的作用域

x(成员变量) mfl(2 个函 i) mf2(l个函数) mfi(2个函数5



int x; public:

Derived的作用域

mfl(l个函数) mf3(l个函数) mf4<l个函数)



virtual void mfl() = 0; virtual void mfl(int); virtual void mf2(); void mf3 ();

void mf3 (double);

}；

class Derived: public Base { public:

virtual void mfl(); void mf3 (); void mf4 ();

}；

这段代码带来的行为会让每一位第一次面对它的C++程序员大吃一惊。以作 用域为基础的“名称遮掩规则”并没有改变，因此base class内所有名为mfl和mf3 的函数都被derived class内的mfl和mf3函数遮掩掉了。从名称査找观点来看， Base:: mfl 和 Base: :mf 3 不再被 Derived 继承！

Derived d; int x;

d.mfl ();    //没问题，调用 Derived: :mfl

d.mfl (x);    //错误！因为 Derived::mfl 遮掩了 Base::mfl

d.mf2 ();    //没问题，调用 Base::mf2

d.mf3 ();    //没问题，调用 Derived::mf3

d.mf3 (x);    //错误！因为 Derived: :mf3 遮掩了 Base: :mf3

Effective C++中文版，第三版

如你所见，上述规则都适用，即使base classes和derived classes内的函数有不 同的参数类型也适用，而且不论函数是virtual或non-virtual—体适用。这和本条款 一开始展不的道理相同，当时函数someFunc内的double x遮掩了 global作用域内 的int X，如今Derived内的函数mf3遮掩了一个名为mf 3但类型不同的Base函数。

这些行为背后的基本理由是为了防止你在程序库或应用框架(application framework)内建立新的derived class时附带地从疏远的base classes继承重载函数。 不幸的是你通常会想继承重载函数、实际上如果你正在使用public继承而又不继承 那些重载函数，就是违反base和derived classes之间的is-a关系，而条款32说过 is-a是public继承的基石。因此你几乎总会想要推翻(override) C++对“继承而 来的名称”的缺省遮掩行为。

你可以使用using声明式达成目标：

class Base { private:

Base的作用域

x(成员变量) mfl (2个函蠢) mf2G个函数) mf3(2个函数)



int x; public:

Derived的作用域

mfl (2个函数) mf3(2个函数) mf4(l个函数)



virtual void mf1() =0; virtual void mfl(int); virtual void mf2(); void mf3 ();

void mf3 (double);

}；

class Derived: public Base { public:

using Base::mfl; //让 Base class 内名为 mfl 和 mf3 的所有东西 using Base::mf3;    //在 Derived作用域内都可见(并且public)

virtual void mfl ();

void mf3 (); void mf4{);

}；

现在，继承机制将一如往昔地运作：

Effective C++中文版，第三版

| Derived d; int x; |                                     |
| ----------------- | ----------------------------------- |
| d.mfl ();         | //仍然没问题，仍然调用Derived: :mfl |
| d.mfl (x);        | //现在没问题了，调用Base: :mfl      |
| d.mf2 ();         | //仍然没问题，仍然调用Base: :mf2    |
| d,mf3 (};         | //没问题，调用Derived: :mf 3        |
| d.mf3(x);         | //现在没问题了，调用;Base::mf3      |

这意味如果你继承base class并加上重载函数，而你又希望重新定义或覆写(推 翻)其中一部分，那么你必须为那些原本会被遮掩的每个名称引入一个using声明 式，否则某些你希望继承的名称会被遮掩。

有时候你并不想继承base classes的所有函数，这是可以理解的。在public继承 下，这绝对不可能发生，因为它违反了 public继承所暗示的“base和derived classes 之间的is«a关系”。(这也就是为什么上述using声明式被放在derived class的public 区域的原因:base class内的public名称在publicly derived class内也应该是public。) 然而在private继承之下(见条款39)它却可能是有意义的。例如假设Derived以 private形式继承Base，而Derived唯一想继承的mfl是那个无参数版本。using声 明式在这里派不上用场，因为using声明式会令继承而来的某给定名称之所有同名 函数在derived class中都可见。不，我们需要不同的技术，即一个简单的转交函数

(forwarding function):

class Base { public:

virtual void mfl() = 0; virtual void mfl(int);

...    //与前同

}；

class Derived: private Base { public:

virtual void mfl ()    //转交函数(forwarding fimction);

{ Base::mfl( ); }    //暗自成为 inline (见条款 30)

}；

Derived d; int x;

d.mfl ();    //很好，调用的是 Derived::mfl

d.rnfl (x) ;    //错误！ Base::mfl ()被遮掩了

Effective C++中文版，第三版

inline转交函数(forwarding function)的另一个用途是为那些不支持using声 明式(注：这并非正确行为)的老旧编译器另辟一条新路，将继承而得的名称汇入 derived class 作用域内。

这就是继承和名称遮掩的完整故事。但是当继承结合templates,我们又将面对 “继承名称被遮掩"的一个全然不同的形式。关于“以角括号定界”的所有东西， 详见条款43。

请记住

■ derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有 人希望如此。

■为了让被遮掩的名称再见天日，可使用using声明式或转交函数(forwarding functions)。

条款34:区分接□继承和实现继承

Differentiate between inheritance of interface and inheritance of implementation.

表面上直截了当的public继承概念，经过更严密的检查之后，发现它由两部分 组成：函数接口(function interfaces)继承和函数实现(function implementations) 继承。这两种继承的差异，很像本书导读所讨论的函数声明与函数定义之间的差异。

身为class设计者，有时候你会希望derived classes只继承成员函数的接口(也 就是声明)；有时候你又会希望derived classes同时继承函数的接口和实现，但又 希望能够覆写(override)它们所继承的实现；又有时候你希望derived classes同时 继承函数的接口和实现，并且不允许覆写任何东西。

为了更好地感觉上述选择之间的差异，让我们考虑一个展现绘图程序中各种几

何形状的class继承体系：

class Shape { public:

virtual void draw( ) const = 0;

virtual void error(const std::strings msg);

int objectID( ) const;

}；

class Rectangle: public Shape { ... }; class Ellipse: public Shape { ... };

Effective C++中文版,第三版

Shape是个抽象class;它的pure virtual函数draw使它成为一个抽象class。所 以客户不能够创建Shape class的实体，只能创建其derived classes的实体。尽管如 此，Shape还是强烈影响了所有以public形式继承它的derived classes，因为：

■成员函数的接口总是会被继承。一如条款32所说，public继承意味is-a (是一 种)，所以对base class为真的任何事情一定也对其derived classes为真。因此 如果某个函数可施行于某class身上，一定也可施行于其derived classes身上。

Shape class声明了三个函数。第一个是draw，于某个隐喻的视屏中画出当前对 象。第二个是error,准备让那些“需要报导某个错误”的成员函数调用。第三个 是objectID,返回当前对象的一个独一无二的整数识别码。每个函数的声明方式 都不相同：draw是个pure virtual函数；error是个简朴的(非纯)impure virtual 函数；objectID是个non-virtual函数。这些不同的声明带来什么样的暗示呢？

首先考虑pure virtual函数draw：

class Shape { public:

virtual void draw( ) const =0;

}；

pure virtual函数有两个最突出的特性：它们必须被任何“继承了它们”的具象 class重新声明，而且它们在抽象class中通常没有定义。把这两个性质摆在一起， 你就会明白：

■声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。

这对Shape: :draw函数是再合理不过的事了，因为所有Shape对象都应该是可 绘出的，这是合理的要求。但Shape class无法为此函数提供合理的缺省实现，毕竟 椭圆形绘法迥异于矩形绘法。Shape: :draw的声明式乃是对具象derived classes设 计者说，“你必须提供一个draw函数，但我不干涉你怎么实现它。”

令人意外的是，我们竟然可以为pure virtual函数提供定义。也就是说你可以为 Shape::draw供应一份实现代码,C++并不会发出怨言，但调用它的唯一途径是“调 用时明确指出其class名称”：

Effective C++中文版，第三版

Shape* ps = new Shape; Shape* psi = new Rectangle; psl~>draw();

Shape* ps2 = new Ellipse; ps2->draw (); psl->Shape::draw(); ps2->Shape::draw();

/ /错误！ Shape是抽象的 //没问题

//调用 Rectangle:: draw //没问题

//调用 Ellipse::draw //调用 Shape:: draw //调用 Shape:: draw



除了能够帮助你在鸡尾酒派对上留给大师级程序员一个深刻的印象，一般而言 这项性质用途有限，但是一如稍后你将看到，它可以实现一种机制，为简朴的（非 纯）impure virtual函数提供更平常更安全的缺省实现。

简朴的impure virtual函数背后的故事和pure virtual函数有点不同—如往常， derived classes继承其函数接口，但impure virtual函数会提供一份实现代码，derived classes可能覆写（override）它。稍加思索，你就会明白：

■声明简朴的（非纯）impure virtual函数的目的，是让derived classes继承该函数

的接口和缺省实现。

考虑Shape:: error这个例子：

class Shape { public:

virtual void error（const std::strings msg）;

}；

其接口表示，每个class都必须支持一个"当遇上错误时可调用”的函数，但 每个class可自由处理错误。如果某个class不想针对错误做出任何特殊行为，它可 以退回到Shape class提供的缺省错误处理行为。也就是说Shape::error的声明式 告诉derived classes的设计者，“你必须支持一^terror函数，但如果你不想自己 写一个，可以使用Shape class提供的缺省版本”。

但是，允许impure virtual函数同时指定函数声明和函数缺省行为，却有可能造 成危险，欲探讨原因，让我们考虑XYZ航空公司设计的飞机继承体系。该公司只 有A型和B型两种飞机，两者都以相同方式飞行。因此XYZ设计出这样的继承体 系：

Effective C++中文版，第三版

Linux公社（LinuxIDC.com）是包括Ubuntu，Fedora，SUSE技术，最新IT资讯等Linux专业类网站。



##### [www.linuxidc.com](http://www.linuxidc.com)

class Airport { ... };    //用以表现机场

class Airplane {

public:

virtual void fly(const Airports destination);

}；

void Airplane::fly(const Airports destination)

{

缺省代码，将飞机飞至指定的目的地

}

class ModelA: public Airplane { ... }; class ModeIB: public Airplane { ... };

为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的fly实 现”，Airplane:: fly被声明为virtual。然而为了避免在ModelA和ModelB中撰写 相同代码，缺省飞行行为由Airplane:: fly提供，它同时被ModelA和ModelB继承。

这是个典型的面向对象设计。两个classes共享一份相同性质(也就是它们实现 fly的方式)，所以共同性质被搬到base class中，然后被这两个classes继承。这 个设计突显出共同性质，避免代码重复，并提升未来的强化能力，减缓长期维护所 需的成本。所有这些都是面向对象技术如此受到欢迎的原因。XYZ航空公司应该感 到骄傲。

现在，假设XYZ盈余大增，决定购买一种新式C型飞机。C型和A型以及B 型有某些不同。更明确地说，它的飞行方式不同。

XYZ公司的程序员在继承体系中针对C型飞机添加了一个class,但由于他们 急着让新飞机上线服务，竟忘了重新定义其fly函数：

class ModelC: public Airplane {

...    //未声明fly函数

}；

然后代码中有一些诸如此类的动作

//PDX是我家附近的机场



Airport PDX(...)；

Airplane* pa = new ModelC;

pa->fly(PDX);



//调用 Airplane: :fly

Effective C++中文版，第三版

这将酿成大灾难；这个程序试图以ModelA或ModelB的飞行方式来飞ModelC。 这不是一个可以公开鼓舞旅游信心的行为。

问题不在Airplane:: fly有缺省行为，而在于ModelC在未明白说出“我要”

的情况下就继承了该缺省行为。幸运的是我们可以轻易做到“提供缺省实现给

derived classes,但除非它们明白要求否则免谈”。此间技俩在于切断“virtual函数

接口”和其“缺省实现”之间的连接。下面是一种做法：

class Airplane { public:

virtual void fly(const Airports destination) = 0;

protected:

void defaultFly(const Airports destination);

}；

void Airplane::defaultFly(const Airports destination)

{

缺省行为，将飞机飞至指定的目的地。

}

请注意，Airplane::fly己被改为一个pure virtual函数，只提供飞行接口。其 缺省行为也出现在Airplane class中，但此次系以独立函数defaultFly的姿态出 现。若想使用缺省实现(例如ModelA和ModelB)，可以在其fly函数中对defaultFly 做一个inline调用(但请注意条款30所言，inline函数和virtual函数之间的交互关 系)：

class ModelA: public Airplane { public:

virtual void fly(const Airports destination)

{ defaultFly(destination); }

}；

class ModelB: public Airplane { public:

virtual void fly{const Airports destination)

{ defaultFly(destination); }

}；

Effective C++中文版，第三版

##### [www.linuxidc.com](http://www.linuxidc.com)

现在ModelC class不可能意外继承不正确的fly实现代码了，因为Airplane 中的pure virtual函数迫使ModelC必须提供自己的fly版本：

class ModelC: public Airplane { public:

virtual void fly(const Airports destination);

}；

void ModelC::fly(const Airports destination)

{

将C型飞机飞至指定的目的地

}

这个方案并非安全无虞，程序员还是可能因为剪贴(copy-and-paste)代码而招 来麻烦，但它的确比原先的设计值得倚赖。至于Airplane: -.defaultFly,请注意 它现在成了 protected,因为它是Airplane及其derived classes的实现细目。乘客应 该只在意飞机能不能飞，不在意它们怎么飞。

Airplane: :defaultFly是个non-virtual函数，这一■点也很重要。因为没有任何 一个derived class应该重新定义此函数(见条款36)。如果default Fly是virtual 函数，就会出现一个循环问题：万一某些derived class忘记重新定义defaultFly， 会怎样？

有些人反对以不同的函数分别提供接口和缺省实现，像上述的fly和 defaultFly那样。他们关心因过度雷同的函数名称而引起的class命名空间污染问 题。但是他们也同意，接口和缺省实现应该分开。这个表面上看起来的矛盾该如何 解决？唔，我们可以利用“pure virtual函数必须在derived classes中重新声明，但 它们也可以拥有自己的实现”这一事实。下面便是Airplane继承体系如何给pure virtual函数一份定义：

class Airplane { public:

virtual void fly(const Airports destination) = 0;

}；

Effective C++中文版，第三版

void Airplane: : fly (const Airports destination) //pure virtual 函数实现 {

缺省行为，将飞机飞至指定的目的地

}

class Model A： public Airplane { public:

virtual void fly(const Airports destination)

{ Airplane::fly(destination); }

}；

class ModeIB: public Airplane { public:

virtual void fly(const Airports destination)

{ Airplane::fly(destination); }

}；

class Mode1C: public Airplane { public:

virtual void fly(const Airports destination);

}；

void ModelC::fly(const Airports destination)

{

将C型飞机飞至指定的目的地

}

这几乎和前一个设i"l"一'模一样，只不过pure virtual函数Airplane:: fly替换了 独立函数Airplane: :defaultFly。本质上，现在的fly被分割为两个基本要素： 其声明部分表现的是接口(那是derived classes必须使用的)，其定义部分则表现 出缺省行为(那是derived classes可能使用的，但只有在它们明确提出申请时才是)。 如果合并fly和defaultFly,就丧失了 “让两个函数享有不同保护级别”的机会: 习惯上被设为protected的函数(defaultFly)如今成了 public(因为它在fly之中)。

最后，让我们看看Shape的non-virtual函数objectID：

class Shape {

public:

• int objectID( ) const;

｝；

Effective C++中文版，第三版

如果成员函数是个non-virtual函数，意味是它并不打算在derived classes中有 不同的行为。实际上一个non-virtual成员函数所表现的不变性Cinvariant）凌驾其 特异性如《），因为它表示不论derived class变得多么特异化，它的行为 都不可以改变。就其自身而言：

■声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制 性实现。

你可以把Shape: :objectID的声明想做是：“每个Shape对象都有一个用来产

生对象识别码的函数；此识别码总是采用相同计算方法，该方法由

•*»

Shape: :objectlD的定义式决定，任何derived class都不应该尝试改变其行为”。 由于non-virtual函数代表的意义是不变性（invariant）凌驾特异性｛specialization）， 所以它绝不该在derived class中被重新定义。这也是条款36所讨论的一个重点。

pure virtual 函数、simple （impure） virtual 函数、non-virtual 函数之间的差异，使 你得以精确指定你想要derived classes继承的东西：只继承接口，或是继承接口和 一份缺省实现，或是继承接口和一份强制实现。由于这些不同类型的声明意味根本 意义并不相同的事情，当你声明你的成员函数时，必须谨慎选择。如果你确实履行， 应该能够避免经验不足的class设计者最常犯的两个错误。

第一个错误是将所有函数声明为non-virtualo这使得derived classes没有余裕空 间进行特化工作。non-virtual析构函数尤其会带来问题（见条款7）。当然啦，设 计一个并不想成为base class的class是绝对合理的，既然这样，将其所有成员函数 都声明为non-virtual也很适当。但这种声明如果不是忽略了 virtual和non-virtual函 '数之间的差异，就是过度担心virtual函数的效率成本。实际上任何class如果打算

被用来当做一个base class,都会拥有若干virtual函数（再次见条款7）。

如果你关心virtual函数的成本，请容许我介绍所谓的80-20法则（也可见条 款30）。这个法则说，一个典型的程序有80%的执行时间花费在20%的代码身上。 此一法则十分重要，因为它意味，平均而言你的函数调用中可以有80%是virtual 而不冲击程序的大体效率。所以当你担心是否有能力负担virtual函数的成本之前， 请先将心力放在那举足轻重的20%代码上头，它才是真正的关键。

Effective C++中文版，第三版

另一个常见错误是将所有成员函数声明为virtual。有时候这样做是正确的，例 如条款31的Interface classes。然而这也可能是class设计者缺乏坚定立场的前兆。 某些函数就是不该在derived class中被重新定义，果真如此你应该将那些函数声明 为non-virtual。没有人有权利妄称你的class适用于任何人任何事任何物而他们只需 花点时间重新定义你的函数就可以享受一切。如果你的不变性(invariant)凌驾特 异性Cspecialization')，别害怕说出来。

请记住

■接口继承和实现继承不同。在public继承之下，derived classes总是继承base class 的接口。

■    pure virtual函数只具体指定接口继承。

■简朴的(非纯)impure virtual函数具体指定接口继承及缺省实现继承。

■    non-virtual函数具体指定接口继承以及强制性实现继承。

条款35:考虑virtual函数以外的其他选择

Consider alternatives to virtual functions.

假设你正在写一个视频游戏软件，你打算为游戏内的人物设计一个继承体系。 你的游戏属于暴力砍杀类型，剧中人物被伤害或因其他因素而降低健康状态的情况 并不罕见。你因此决定提供一个成员函数healthValue,它会返回一个整数，表示 人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将 healthValue声明为virtual似乎是再明白不过的做法：

class GameCharacter { public:

virtual int healthValue () const;    //返回人物的健康指数；

...    //derived classes 可重新定义它。

}；

healthValue并未被声明为pure virtual,这暗示我们将会有个计算健康指数的 缺省算法(见条款34)。

Effective C++中文版，第三版

这的确是再明白不过的设计，但是从某个角度说却反而成了它的弱点。由于这 个设计如此明显，你可能因此没有认真考虑其他替代方案。为了帮助你跳脱面向对 象设计路上的常轨，让我们考虑其他一些解法。

藉由 Non-Virtual Interface 手法实现 Template Mefhod 模式

我们将从一个有趣的思想流派开始，这个流派主张virtual函数应该几乎总是

private。这个流派的拥护者建议，较好的设计是保留healthValue为public成员函

数，但让它成为non-virtual，并调用一个private virtual函数(例如doHealthValue)

进行实际工作：

class GameCharacter { public:

int    healthValue    {)    const    //derivedclasses 不重新定义它，

{    //见条款36。

...    //做一些事前工作，详下。

int    retVal    =    doHealthValue () ;    //做真正的工作。

...    //做一些事后工作，详下。

return retVal;

}

private:

virtual int doHealthValue () const    //derived classes 可重新定义它。

{

...    //缺省算法，计算健康指数。

}；

在这段(以及本条款其余的)代码中，我直接在class定义式内呈现成员函数 本体。一如条款30所言，那也就让它们全都暗自成了 inline。但其实我以这种方 式呈现代码只是为了让你比较容易阅读。我所描述的设计与inlining其实没有关联， 所以请不要认为成员函数在这里被定义于classes内有特殊用意。不，它没有。

这一基本设计,也就是“令客户通过public non-virtual成员函数间接调用private virtual 函数”，称为 non-virtual interface (NVI)手法。它是所谓 Template Method 设计模式(与C++templates并无关联)的一个独特表现形式。我把这个non-virtual 函数(healthValue)称为virtual函数的外覆器(wrapper)。

Effective C++中文版，第三版

NVI手法的一个优点隐身在上述代码注释“做一些事前工作”和“做一些事后 工作”之中。那些注释用来告诉你当时的代码保证在“virtual函数进行真正工作之 前和之后”被调用。这意味外覆器(wrapper)确保得以在一个virtual函数被调用 之前设定好适当场景，并在调用结束之后清理场景。“事前工作”可以包括锁定互 斥器(locking a mutex)、制造运转日志记录项(log entry)、验证class约束条件、 验证函数先决条件等等。“事后工作”可以包括互斥器解除锁定(unlocking a mutex)、 验证函数的事后条件、再次验证class约束条件等等。如果你让客户直接调用virtual 函数，就没有任何好办法可以做这些事。

有件事实或许会妨碍你跃跃欲试的心：NVI手法涉及在derived classes内重新 定义private virtual函数。啊，重新定义若干个derived classes并不调用的函数！这 里并不存在矛盾。“重新定义virtual函数”表示某些事“如何”被完成，“调用 virtual函数”则表示它“何时”被完成。这些事情都是各自独立互不相干的。NVI 手法允许derived classes重新定义virtual函数，从而赋予它们“如何实现机能”的 控制能力，但base class保留诉说“函数何时被调用”的权利。一开始这些听起来 似乎诡异，但C++的这种“derived classes可重新定义继承而来的private virtual函 数”的规则完全合情合理。

在NVI手法下其实没有必要让virtual函数一定得是private。某些class继承体 系要求derived class在virtual函数的实现内必须调用其base class的对应兄弟(例如 p.120的程序)，而为了让这样的调用合法，virtual函数必须是protected,不能是 private。有时候virtual函数甚至一定得是public (例如具备多态性质的base classes 的析构函数一见条款7),这么一来就不能实施NVI手法了。

藉由 Function Pointers 实现 Strategy 模式

NVI手法对public virtual函数而言是一个有趣的替代方案，但从某种设计角度 观之，它只比窗饰花样更强一些而已，毕竟我们还是使用virtual函数来计算每个人 物的健康指数。另一个更戏剧性的设计主张“人物健康指数的计算与人物类型无 关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的 构造函数接受一个指针，指向一个健康计算函数，而我们可以调用该函数进行实际 计算：

Effective C++中文版，第三版

class GameCharacter;    //前置声明(forwarddeclaration)

//以下函数是计算健康指数的缺省算法。 int defaultHealthCalc(const GameCharacter& gc); class GameCharacter { public:

typedef int (*HealthCalcFunc)(const GameCharacter&); explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)

:healthFunc(hcf)

{}

int healthValue() const

{ return healthFunc(*this); }

private:

HealthCalcFunc healthFunc;

}；

这个做法是常见的Strategy设计模式的简单应用。拿它和“植基于 GameCharacter继承体系内之virtual函数”的做法比较，它提供了某些有趣弹性：

■同一人物类型之不同实体可以有不同的健康计算函数。例如：

class EvilBadGuy: public GameCharacter { public:

explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc)

:GameCharacter(hcf)

}；

int loseHealthQuickly (const GameCharacterS) ; //健康指数计算函数 1 int loseHealthSlowly {const GameCharacterS);    //健康指数计算函数 2

EvilBadGuy ebgl (loseHealthQuickly);    //相同类型的人物搭配

EvilBadGuy ebg2 (loseHealthSlowly);    // 不同的健康计算方式

■某已知人物之健康指数计算函数可在运行期变更。例如GameCharacter可提供 一个成员函数setHealthCalculator,用来替换当前的健康指数计算函数。

换句话说,“健康指数计算函数不再是GameCharacter继承体系内的成员函数” 这一事实意味，这些计算函数并未特别访问“即将被计算健康指数”的那个对象的 内部成分。例如defaultHealthCalc并未访问EvilBadGuy的non-public成分。

Effective C++中文版，第三版

如果人物的健康可纯粹根据该人物public接口得来的信息加以计算，这就没有 问题，但如果需要non-public信息进行精确计算，就有问题了。实际上任何时候当 你将class内的某个机能（也许取道自某个成员函数）替换为class外部的某个等价 机能（也许取道自某个non-member non-friend函数或另一个class的non-friend成员 函数），这都是潜在争议点。这个争议将持续至本条款其余篇幅，因为我们即将考 虑的所有替代设计也都涉及使用GameCharacter继承体系外的函数。

一般而言，唯一能够解决“需要以non-member函数访问class的non-public成 分”的办法就是：弱化class的封装。例如class可声明那个non-member函数为 friends,或是为其实现的某一部分提供public访问函数（其他部分则宁可隐藏起 来）。运用函数指针替换virtual函数，其优点（像是“每个对象可各自拥有自己的 健康计算函数"和“可在运行期改变计算函数”）是否足以弥补缺点（例如可能必 须降低GameCharacter封装性），是你必须根据每个设计情况的不同而抉择的。 藉由 tri：function 完成 Strategy 模式

一旦习惯了 templates以及它们对隐式接口（见条款41）的使用，基于函数指 针的做法看起来便过分苛刻而死板了。为什么要求“健康指数之计算”必须是个函 数，而不能是某种“像函数的东西”（例如函数对象）呢？如果一定得是函数，为 什么不能够是个成员函数？为什么一定得返回int而不是任何可被转换为int的类 型呢？

如果我们不再使用函数指针（如前例的healthFunc）,而是改用一个类型为 tri: function的对象，这些约束就全都挥发不见了。就像条款54所说，这样的 对象可持有（保存）任何可调用物（callable entity,也就是函数指针、函数对象、 或成员函数指针），只要其签名式兼容于需求端。以下将刚才的设计改为使用 tri::function：

class GameCharacter;    //如前

int defaultHealthCalc （const GameCharacter & gc）;    "如前

class GameCharacter {

public:

//HealthCalcFunc可以是任何“可调用物”（callableentity）,可被调用并接受

//任何兼容于GameCharacter之物，返回任何兼容于int的东西。详下。

typedef std: : tri: : function<int （const GameCharacter&） > HealthCalcFunc;

Effective C++中文版，第三版

explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)

:healthFunc(hcf )

'{}

int healthValue() const { return healthFunc( * this); }

private:

HealthCalcFunc healthFunc;

}；

如你所见，HealthCalcFunc是个typedef，用来表现tri:: function的某个具 现体，意味该具现体的行为像一般的函数指针。现在我们靠近一点瞧瞧 HealthCalcFunc 是个什么样的 typedef：

std::tri::function<int (const GameCharacter&)>

这里我把 tri:: function 具现体(instantiation)的目标签名式(target signature)

以不同颜色强调出来，那个签名代表的函数是“接受一个reference指向const GameCharacter，并返回int”。这个tri:: function类型(也就是我们所定义的 HealthCalcFunc类型)产生的对象可以持有(保存)任何与此签名式兼容的可调 用物(callable entity)。所谓兼容，意思是这个可调用物的参数可被隐式转换为const GameCharacter &,而其返回类型可被隐式转换为into

和前一个设计(其GameCharacter持有的是函数指针)比较，这个设计几乎相 同。唯一不同的是如今GameCharacter持有一■个tri::function对象，相当于一' 个指向函数的泛化指针。这个改变如此细小，我总说它没有什么外显影响，除非客 户在“指定健康计算函数”这件事上需要更惊人的弹性：

short calcHealth (const GameCharacter&);    //健康计算函数；

"注意其返回类型为non-int

struct HealthCalculator {    //为计算健康而设计的函数对象

int operator()(const GameCharacter&) const { ... }

}；

class GameLevel { public:

float health (const GameCharacter&) const; //成员函数，用以计算健康; ,..    / /注意其non-int返回类型

}；

class EvilBadGuy: public GameCharacter {    "同前

}；

Effective C++中文版，第三版

class EyeCandyCharacter: public GameCharacter {    //另一个人物类型；

...    //假设其构造函数与

};    //EvilBadGuy 同

EvilBadGuy ebgl (calcHealth);    //人物 1，使用某个

//函数计算健康指数

EyeCandyCharacter eccl (HealthCalculator ()); "人物 2，使用某个

//函数对象计算健康指数

GameLevel currentLevel;

EvilBadGuy ebg2 (    //人物 3，使用某个

std:: tri: : bind (& GameLevel:: health,    // 成员函数计算健康指数

currentLevel,

_1)    //详见以下

)；

就我个人而言，当我发现tri: Junction允许我们做的事时，非常吃惊。它让 我浑身震颤。如果你没有这样的感觉，也许是你早已曾经惊叹tri: :bind所发生的 事情。请允许我稍加解释。

首先我要表明，为计算ebg2的健康指数，应该使用GameLevel class的成员函 数health。好，GameLevel: :health宣称它自己接受一个参数(那是个reference 指向GameCharacter),但它实际上接受两个参数，因为它也获得一个隐式参数 GameLevel,也就是this所指的那个。然而GameCharacters的健康计算函数只接 受单一参数：GameCharacter (这个对象将被计算出健康指数)。如果我们使用 GameLevel: :health作为ebg2的健康计算函数，我们必须以某种方式转换它，使 它不再接受两个参数(一个GameCharacter和一个GameLevel),转而接受单一参 数(一个GameCharacter)。在这个例子中我们必然会想要使用currentLevel作 为“ebg2的健康计算函数所需的那个GameLevel对象”，于是我们将currentLevel 绑定为GameLevel对象，让它在“每次GameLevel: :health被调用以计算ebg2的 健康”时被使用。那正是trl::bind的作为：它指出ebg2的健康计算函数应该总 是以 currentLevel 作为 GameLevel 对象。

我跳过了一大堆细节，像是为什么"_1"意味“当为ebg2调用 GameLevel: :health 时系以 currentLevel 作为 GameLevel 对象”。这样的细节不 难阐述，但它们会分散我要说的根本重点：若以tri: function替换函数指针，吾 人将因此允许客户在计算人物健康指数时使用任何兼容的可调用物(callable entity)。如果这还不酷，什么是酷？

Effective C++中文版，第三版

古典的Strategy模式

如果你对设计模式(design patterns)比对C++的酷劲更有兴趣，我告诉你， 传统(典型)的Sfrafegy做法会将健康计算函数做成一个分离的继承体系中的virtual 成员函数。设计结果看起来像这样：

如果你并未精通UML符号，别担心，这图只是告诉你GameCharacter是某个 继承体系的根类，体系中的EvilBadGuy和EyeCandyCharacter都是derived classes； HealthCa 1 cFunc是另一个继承体系的根类，体系中的SlowHealthLoser和 FastHealthLoser 都是 derived classes，每一个 GameCharacter 对象都内含一个指 针，指向一个来自HealthCalcFunc继承体系的对象。

下面是对应的代码骨干：

class GameCharacter;    //前置声明(forward declaration)

class HealthCalcFunc {

public:

virtual int calc(const GameCharacter& gc) const { ... }

}；

HealthCalcFunc defaultHealthCalc;

class GameCharacter { public:

explicit GameCharacter{HealthCalcFunc* phcf = &defaultHealthCalc) :pHealthCalc(phcf )

{}

int healthValue() const { return pHealthCalc->calc(*this); }

private:

HealthCalcFunc* pHealthCalc;

}；

Effective C++中文版,第三版

这个解法的吸引力在于，熟悉标准Strategy模式的人很容易辨认它，而且它还 提供“将一个既有的健康算法纳入使用”的可能性——只要为HealthCalcFunc继 承体系添加一个derived class即可。

摘要

本条款的根本忠告是，当你为解决问题而寻找某个设计方法时，不妨考虑virtual 函数的替代方案。下面快速重点复习我们验证过的几个替代方案：

■使用 non-virtual interface (NVI)手法，那是 remp/ate Metfiod 设计模式的一种 特殊形式。它以public non-virtual成员函数包裹较低访问性(private或protected) 的virtual函数。

■将virtual函数替换为“函数指针成员变量”，这是Sfrafegy设计模式的一种分 解表现形式。

■以tri::function成员变量替换virtual函数，因而允许使用任何可调用物 (callable entity)搭配一个兼容于需求的签名式。这也是Strategy设计模式的

某种形式。

■将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是 Strategy设计模式的传统实现手法。

以上并未彻底而详尽地列出virtual函数的所有替换方案，但应该足够让你知道 的确有不少替换方案。此外，它们各有其相对的优点和缺点，你应该把它们全部列 入考虑。

为避免陷入面向对象设计路上因常规而形成的凹洞中，偶而我们需要对着车轮 猛推一把。这个世界还有其他许多道路，值得我们花时间加以研究。

请记住

■    virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手 法自身是一个特殊形式的Template Method设计模式。

■将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访 问 class 的 non-public 成员。

■    tri: Junction对象的行为就像一般函数指针。这样的对象可接纳“与给定之 目标签名式(targetsignature)兼容”的所有可调用物(callableentities)。

Elective C++中文版，第三版

条款36:绝不重新定义继承而来的non-virtual函数

Never redefine an inherited non-virtual function.

假设我告诉你，class D系由class B以public形式派生而来，class B定义有一个 public成员函数mf。由于mf的参数和返回值都不重要，所以我假设两者皆为vid。 换句话说我的意思是：

class B { public:

void mf ();

}；

class D: public B { ... };

虽然我们对B，D和mf —无所知，但面对一个类型为D的对象x:

D x;    //X是一个类型为D的对象

如果以下行为：    、

B* pB = &x;    //获得一个指针指向x

pB->mf () ;    //经由该指针调用mf

异于以下行为：

D* pD = &x;    //获得一个指针指向x

pD->mf();    //经由该指针调用mf

你可能会相当惊讶。毕竟两者都通过对象x调用成员函gmf。由于两者所调用 的函数都相同，凭借的对象也相同，所以行为也应该相同，是吗？

是的，理应如此，但事实可能不是如此。更明确地说，如果mf是个non-virtual

函数而D定义有自己的mf版本，那就不是如此：

class D: public B { public:

void mf ();    //遮掩(hides) 了 B::mf；见条款33

};

pB->mf () ;    //调用 B: :mf

pD->mf {);    //调用 D::mf

造成此一两面行为的原因是，non-virtual函数如B::mf和D::mf都是静态绑定 (statically bound,见条款37)。这意思是，由于pB被声明为一个pointer-to-B，通

Effective C++中文版，第三版

过PB调用的non-virtual函数永远是B所定义的版本，即使pB指向一个类型为“B 派生之class”的对象，一如本例。

但另一方面，virtual函数却是动态绑定(dynamically bound,见条款37),所 以它们不受这个问题之苦。如果mf是个virtual函数，不论是通过pB或PD调用mf, 都会导致调用因为PB和PD真正指的都是一个类型为D的对象。

如果你正在编写class D并重新定义继承自class B的non-virtual函数mf，D对象 很可能展现出精神分裂的不一致行径。更明确地说，当mf被调用，任何一个D对 象都可能表现出B或D的行为；决定因素不在对象自身，而在于“指向该对象之指 针”当初的声明类型。References也会展现和指针一样难以理解的行径。

但那只是实务面上的讨论。我知道你真正想要的是理论层面的理由(关于“绝 不重新定义继承而来的non-virtual函数”这回事)。我很乐意为你服务。

条款32已经说过，所谓public继承意味is-a (是一种)的关系。条款34则描 述为什么在class内声明一个non-virtual函数会为该class建立起—不变性 (invariant),凌驾其特异性(specialization)。如果你将这两个观点施行于两个classes

B和D以及non-virtual成员函数B: :mf身上，那么：

■适用于B对象的每一件事，也适用于D对象，因为每个D对象都是一个B对象； ■ B的derived classes 一定会继承mf的接口和实现，因为mf是B的一个non-virtual

函数。

现在，如果g重新定义mf，你的设计便出现矛盾。如果D真有必要实现出与B 不同的mf,并且如果每一个B对象——不管多么特化一真的必须使用B所提供的 mf实现码，那么“每个D都是一个B”就不为真。既然如此D就不该以public形式 继承B。另一方面，如果D真的必须以public方式继承B,并且如果D真有需要实 现出与B不同的mf,那么mf就无法为B反映出“不变性凌驾特异性”的性质。既 然这样mf应该声明为Virtual函数。最后，如果每个D真的是一个B,并且如果mf 真的为B反映出“不变性凌驾特异性”的性质，那么D便不需要重新定义mf,而且 它也不应该尝试这样做。

不论哪一个观点，结论都相同：任何情况下都不该重新定义一个继承而来的 non-virtual 函数。

Effective C++中文版，第三版

如果此条款使你感到枯燥乏味，或许是因为你已经读过条款7,该条款解释为 什么多态性(polymorphic) base classes内的析构函数应该是virtual。如果你违反那 个准则(也就是说如果你在polymorphic base class内声明一个non-virtual析构函数)， 你也就违反了本条款，因为derived classes绝对不该重新定义一个继承而来的 non-virtual函数(此处指的是base class析构函数)。即使没有声明析构函数，此亦 为真，因为条款5说，析构函数是“如果你没有为自己声明一个，编译器会为你生 成一个”的数种成员函数之一。就本质而言，条款7只不过是本条款的一个特殊案 例，尽管它也足够重要到单独成为一个条款。

请记住

■绝对不要重新定义继承而来的non-virtual函数。

条款37:绝不重新定义继承而来的缺省参数值

Never redefine a function's inherited default parameter value.

让我们一开始就将讨论简化。你只能继承两种函数：virtual和non-virtual函数。 然而重新定义一个继承而来的non-virtual函数永远是错误的(见条款36)，所以我 们可以安全地将本条款的讨论局限于“继承一个带有缺省参数值的virtual函数”。

这种情况下，本条款成立的理由就非常直接而明确了： virtual函数系动态绑定 (dynamically bound),而缺省参数值却是静态绑定(statically bound)。

那是什么意思？你说你那负荷过重的脑袋早已忘记静态绑定和动态绑定之间 的差异？(为了正式记录在案，容我再说一次，静态绑定又名前期绑定，early binding-,动态绑定又名后期绑定，)现在让我们来一趟复习之旅吧！

对象的所谓静态类型(statictype),就是它在程序中被声明时所采用的类型。 考虑以下的class继承体系：

//一个用以描述几何形状的class

class Shape {

public:

enum ShapeColor { Red, Green, Blue };

//所有形状都必须提供一个函数，用来绘出自己

virtual void draw(ShapeColor color = Red) const = 0;

}；

Effective C++中文版，第三版

class Rectangle: public Shape {

public:

//注意，赋予不同的缺省参数值。这真糟糕！

virtual void draw(ShapeColor color = Green) const;

}；

class Circle: public Shape {

public:

virtual void draw(ShapeColor color) const;

//译注：请注意，以上这么写则当客户以对象调用此函数，一定要指定参数值。 //    因为静态绑定下这个函数并不从其base继承缺省参数值。

//    但若以指针(或reference)调用此函数，可以不指定参数值，

//    因为动态绑定下这个函数会从其base继承缺省参数值。

这个继承体系图示如下：

![img](09Effective C++082d87482c34809-10.png)



现在考虑这些指针：

"静态类型为Shape* "静态类型为Shape* "静态类型为Shape*



Shape* ps;

Shape* pc = new Circle; Shape* pr = new Rectangle;

本例中ps, pc和pr都被声明为pointer-to-Shape类型，所以它们都以它为静态 类型。注意，不论它们真正指向什么，它们的静态类型都是Shape*。

对象的所谓动态类型(dynamic type)则是指“目前所指对象的类型”。也就 是说，动态类型可以表现出一个对象将会有什么行为。以上例而言，pc的动态类型 是Circle*，pr的动态类型是Rectangle*。ps没有动态类型，因为它尚未指向任 何对象。

动态类型一如其名称所示，可在程序执行过程中改变(通常是经由赋值动作)：

ps = pc； ps = pr;



//ps的动态类型如今是Circle* //ps的动态类型如今是Rectangle*

Virtual函数系动态绑定而来，意思是调用一个virtual函数时，究竟调用哪一份 函数实现代码，取决于发出调用的那个对象的动态类型：

Effective C++中文版，第三版

pc->draw (Shape::Red);    //调用 Circle::draw (Shape::Red)

pr->draw (Shape:: Red);    "调用 Rectangle:: draw {Shape:: Red)

我知道这些都是老调重弹；是的，你当然已经了解virtual函数。但是当你考虑 带有缺省参数值的virtual函数，花样来了，因为就如我稍早所说，virtual函数是动 态绑定，而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于derived class内的virtual函数”的同时，却使用base class为它所指定的缺省参数值：

pr->draw{ );    //调用 Rectangle::draw (Shape::Red) !

此例之中，pr的动态类型是Rectangle*，所以调用的是Rectangle的virtual 函数，一如你所预期。Rectangle::draw函数的缺省参数值应该是GREEN，但由于 pr的静态类型是Shape*»所以此一调用的缺省参数值来自Shape class而非 Rectangle class!结局是这个函数调用有着奇怪并且几乎绝对没人预料得到的组 合，由Shape class和Rectangle class的draw声明式各出一半力。

以上事实不只局限于“ps，pc和pr都是指针”的情况;即使把指针换成references 问题仍然存在。重点在于draw是个virtual函数，而它有个缺省参数值在derived class 中被重新定义了。

为什么C++坚持以这种乖张的方式来运作呢？答案在于运行期效率。如果缺 省参数值是动态绑定，编译器就必须有某种办法在运行期为virtual函数决定适当的 参数缺省值。这比目前实行的“在编译期决定”的机制更慢而且更复杂。为了程序 的执行速度和编译器实现上的简易度，C++做了这样的取舍，其结果就是你如今所 享受的执行效率。但如果你没有注意本条款所揭示的忠告，很容易发生混淆。

这一切都很好，但如果你试着遵守这条规则，并且同时提供缺省参数值给base 和derived classes的用户，又会发生什么事呢？

class Shape { public:

enum ShapeColor { Red, Green, Blue };

virtual void draw(ShapeColor color = Red) const = 0;

}；

Effective C++中文版，第三版

class Rectangle: public Shape { public:

virtual void draw(ShapeColor color - Red) const;

}；

喔欧，代码重复。更糟的是，代码重复又带着相依性(with dependencies): 如果Shape内的缺省参数值改变了，所有“重复给定缺省参数值”的那些derived classes也必须改变，否则它们最终会导致“重复定义一个继承而来的缺省参数值”。 怎么办？

当你想令virtual函数表现出你所想要的行为但却遭遇麻烦，聪明的做法是考虑 替代设计。条款35列了不少virtual函数的替代设计，其中之一是NVI («o«-virtwa/ interface')手法：令 base class 内的一个 public non-virtual 函数调用 private virtual 函 数，后者可被derived classes重新定义。这里我们可以让non-virtual函数指定缺省 参数，而private virtual函数负责真正的工作：

class Shape { public:

enum ShapeColor { Red, Green, Blue };

void draw (ShapeColor color = Red) const    //如今它是 non-virtual

{

doDraw (color);    //调用一个 virtual

}

private:

virtual void doDraw (ShapeColor color) const = 0;"真正的工作 };    //在此处完成

class Rectangle: public Shape { public:

private:

virtual void doDraw (ShapeColor color) const;    //注意，

…    //缺省鎌值。

};

由于non-virtual函数应该绝对不被derived classes覆写(见条款36)，这个设 计很清楚地使得draw函数的color缺省参数值总是为Redo

请记住

■绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定， 而virtual函数——你唯一应该覆写的东西——却是动态绑定。

Effective C++中文版，第三版

184



##### [www.linuxidc.com](http://www.linuxidc.com)



6继承与面向对象设计



条款38:通过复合塑模出has-a或"根据某物实现出"

Model ”has-a’’ or "is-implemented-in-terms-of' through composition.

复合（composition）是类型之间的一种关系，当某种类型的对象内含它种类型 的对象，便是这种关系。例如：



class Address { ... }; class PhoneNumber {...

class Person { public:



//某人的住址



｝；



private:

std::string name;

Address address; PhoneNumber voiceNumber; PhoneNumber faxNumber;

}；



//合成成分物（composed object）

"同上

"同上

//同上



本例之中Person对象由string, Address, PhoneNumber构成。在程序员之间 复合（composition）这个术语有许多同义词，包括layering （分层），containment

（内含）aggregation （聚合）和 embedding （内嵌）。

条款32曾说，“public继承”带有is_a （是一种）的意义。复合也有它自己的 意义。实际上它有两个意义。复合意味has-a（有一个）或is-implemented-in-terms-of （根据某物实现出）。那是因为你正打算在你的软件中处理两个不同的领域

（domains）。程序中的对象其实相当于你所塑造的世界中的某些事物，例如人、 汽车、一张张视频画面等等。这样的对象属于应用域Capplication domain）部分。 其他对象则纯粹是实现细节上的人工制品，像是缓冲区（buffers）、互斥器（mutexes）、 查找树（search trees）等等。这些对象相当于你的软件的实现域（implementation domain）。当复合发生于应用域内的对象之间，表现出has-a的关系；当它发生于 '实现域内则是表现is-implemented-in-terms-of的关系。

上述的Person class示范has-a关系。Person有一个名称，—地址，以及语 音和传真两笔电话号码。你不会说“人是一个名称”或“人是一个地址”，你会说 “人有一个名称”和“人有一个地址”。大多数人接受此一区别毫无困难，所以很

少人会对is-a和has-a感到困惑。

比较麻烦的是区分is^a （是一种）和is-implemented-in-terms-of （根据某物实 现出）这两种对象关系。假设你需要一个template,希望制造出一组classes用来表 现由不重复对象组成的sets。由于复用（reuse）是件美妙无比的事情，你的第一个 Effective C++中文版，第三版

直觉是采用标准程序库提供的set template。是的，如果他人所写的template合乎 需求，我们何必另写一个呢？

不幸的是set的实现往往招致“每个元素耗用三个指针”的额外开销。因为sets 通常以平衡查找树(balanced search trees)实现而成，使它们在查找、安插、移除 元素时保证拥有对数时间(logarithmic-time)效率。当速度比空间重要，这是个通 情达理的设计，但如果你的程序却是空间比速度重要呢？那么标准程序库的set提 供给你的是个错误决定下的取舍。似乎你终究还得写个自己的template。

但是容我再说一次，复用(reuse)是件美好的事。如果你是一位数据结构专家， 你就会知道，实现sets的方法太多了，其中一种便是在底层采用linked lists。而你 又刚好知道，标准程序库有一个list template,于是你决定复用它。

更明确地说，你决定让你那个萌芽中的Set template继承std: :list«也就是 让Set<T>继承list<T>。毕竟在你的实现理念中Set对象其实是个list对象。你 于是声明Set template如下：

template<typename T>    //将 list 应用于 Set。错误做法。

class Set: public std::list<T> {    ;

每件事看起来都很好，但实际上有些东西完全错误。一如条款32所说，如果D 是一种B,对B为真的每一件事情对D也都应该为真。但list可以内含重复元素， 如果数值3051被安插到list<int>两次，那个list将内含两笔3051。Set不可以 内含重复元素，如果数值3051被安插到Set<int>两次，这个set只内含一笔3051。 因此“Set是一种list”并不为真，因为对list对象为真的某些事情对Set对象 并不为真。

由于这两个classes之间并非is-a的关系，所以public继承不适合用来塑模它

们。正确的做法是，你应当了解，Set对象可根据一个list对象实现出来：

template<class T>    //将 list 应用于 Set。正确做法。

class Set {

public:

bool member(const T& item) const; void insert(const T& item); void remove(const T& item); std::size_t size{) const;

private:

std:: list<T> rep;    //用Set 的数据

}；

Effective C++中文版，第三版

Set成员函数可大量倚赖list及标准程序库其他部分提供的机能来完成，所以 其实现很直观也很简单，只要你熟悉以STL编写程序：

template<typename T>

bool Set<T>::member(const T& item) const {

return std::find(rep.begin(), rep.end(), item) != rep.end();

}

tempiate<typename T>

void Set<T>::insert(const T& item)

{

if (!member(item)) rep.push_back(item);

} _

template<typename T>

void Set<T>::remove(const T& item)

{

typename std: :list<T>: : iterator it =    //见条款 42 对

std:: find (rep.begin (), rep. end () , item);    //"typename"的讨论

if (it != rep.end⑴ rep.erase(it);

}

template<typename T> std::size_t Set<T>::size( ) const { _

return rep.size();

}

这些函数如此简单，因此都适合成为inlining候选人。但请记住，在做出任何 与inlining有关的决定之前，应该先看看条款30。

也许有人主张，如果Set接口遵循STL容器的协议，就更符合条款18对设计 接口的警告：“让它容易被正确使用，不易被误用”。但是这儿如果要遵循那些协 议，需得为Set添加许多东西，那将模糊了它和list之间的关系。由于Set和list 之间的关系是本条款的重点，所以我们以教学清澈度交换STL兼容性。此外，Set 接口也不该造成“对Set而言无可置辩的权利”黯然失色，那个权利是指它和list 间的关系。这关系并非is-a (虽然最初似乎是)，而是is-implemented-in-terms-of。

[Linux](http://www.linuxidc.com)[公社(LinuxIDC+com)是包括Ubuntu,Fedora,SUSE技术，最新IT资讯等Linux专业类网站。](http://www.linuxidc.com)



请记住

■复合(composition)的意义和public继承完全不同。

■在应用域(application domain)，复合意味has-a (有一个)。在实现域

(implementation domain)，复合意味 is-implemented-in-terms-of (根据某物实

现出)。

Effective C++中文版，第三版

##### [www.linuxidc.com](http://www.linuxidc.com)

6条款39:明智而审慎地使用private继承



187



条款39:明智而审慎地使用private继承

f    ...

Use private inheritance judiciously.

条款32曾经论证过C++如何将public继承视为is-a关系。在那个例子中我们 有个继承体系，其中class Student以public形式继承class Person，于是编译器在 必要时刻（为了让函数调用成功）将Sttidents暗自转换为Persons。现在我再重复 该例的一部分，并以private继承替换public继承：

class Person { ... }; class Student: private Person { void eat(const Person& p); void study(const Students s);

};    "这次改用private继承

"任何人都会吃 //只有学生才在校学习

"P是人 //S是学生

"没问题，pMA.

//错误！吓，难道学生不是人?！



Person p;

Student s;

eat (p);

eat(s);

显然private继承并不意味is*a关系。那么它意味什么？

“哇喔！ ”你说，“在我们探讨其意义之前，可否先搞清楚其行为。到底private 继承的行为如何呢？ ”唔，统御private继承的首要规则你刚才已经见过了：如果 classes之间的继承关系是private,编译器不会自动将一个derived class对象（例如 Student）转换为一个base class对象（例如Person）。这和public继承的情况不 同。这也就是为什么通过s调用eat会失败的原因。第二条规则是，由private base class继承而来的所有成员，在derived class中都会变成private属性，级使它们在 base class 中原本是 protected 或 public 属性。

够了，现在让我们开始讨论其意义。Private继承意味implemented-in-terms-of （根据某物实现出）。如果你让class D以private形式继承class B,你的用意是为 了采用class B内已经备妥的某些特性，不是因为B对象和D对象存在有任何观念上 的关系。private继承纯粹只是一种实现技术（这就是为什么继承自一个private base class的每样东西在你的class内都是private:因为它们都只是实现枝节而已）。借

用条款34提出的术语，private继承意味只有实现部分被继承，接口部分应略去。 如果D以private形式继承B,意思是D对象根据B对象实现而得，再没有其他意涵 了。Private继承在软件“设计”层面上没有意义，其意义只及于软件实现层面。

Effective C++中文版，第三版

Private继承意味is-implemented-in-terms-of (根据某物实现出)，这个事实有 点令人不安，因为条款38才刚指出复合(composition)的意义也是这样。你如何 在两者之间取舍？答案很简单：尽可能使用复合，必要时才使用private继承。何时 才是必要？主要是当protected成员和/或virtual函数牵扯进来的时候。其实还有一 种激进情况，那是当空间方面的利害关系足以踢翻private继承的支柱时。稍后我们 再来操这个心，毕竟它只是一种激进情况。

假设我们的程序涉及Widgets,而我们决定应该较好地了解如何使用Widgets。 例如我们不只想要知道Widget成员函数多么频繁地被调用，也想知道经过一段时 间后调用比例如何变化。要知道，带有多个执行阶段(executionphases)的程序， 可能在不同阶段拥有不同的行为轮廓(behavioral profiles)。例如编译器在解析

(parsing)阶段所用的函数，大大不同于在最优化(optimization)和代码生成(code generation)阶段所使用的函数。

我们决定修改Widget Class,让它记录每个成员函数的被调用次数。运行期间 我们将周期性地审査那份信息，也许再加上每个Widget的值，以及我们需要评估 的任何其他数据。为完成这项工作，我们需要设定某种定时器，使我们知道收集统 计数据的时候是否到了。

我们宁可复用既有代码，尽量少写新代码，所以在自己的工具百宝箱中翻箱倒 柜，并且很开心地发现了这个class:

class Timer { public:

explicit Timer(int tickFrequency);

virtual void onTick () const;    //定时器每滴答一次，

...    //此函数就被自动调用一次。

这就是我们找到的东西。一个Timer对象，可调整为以我们需要的任何频率滴 答前进，每次滴答就调用某个virtual函数。我们可以重新定义那个virtual函数，让 后者取出Widget的当时状态。完美！

为了让Widget重新定义Timer内的virtual函数，Widget必须继承自Timer。 但public继承在此例并不适当，因为Widget并不是个Timer。是呀，Widget客户 总不该能够对着一个Widget调用onTick吧，因为观念上那并不是Widget接口的 一部分。如果允许那样的调用动作，很容易造成客户不正确地使用Widget接口，

Effective C++中文版，第三版

那会违反条款18的忠告：“让接口容易被正确使用，不易被误用”。在这里，public 继承不是个好策略。

我们必须以private形式继承Timer：

class Widget: private Timer { private:

//查看Widget的数据...等等。



virtual void onTick() const;

}；

藉由private继承，Timer的public onTick函数在Widget内变成private，而我 们重新声明(定义)时仍然把它留在那儿。再说一次，把onTick放进public接口 内会误导客户端以为他们可以调用它，那就违反了条款18。

这是个好设计，但不值几文钱，因为private继承并非绝对必要。如果我们决定

以复合(composition)取而代之，是可以的。只要在Widget内声明一个嵌套式private

class,后者以public形式继承Timer并重新定义onTick，然后放一个这种类型的

对象于Widget内。下面是这种解法的草样：

class Widget { private:

class WidgetTimer: public Timer {

public:

![img](09Effective C++082d87482c34809-11.png)



virtual void onTick() const;

｝；

WidgetTimer timer;



}；

这个设计比只使用private继承要复杂一些些，因为它同时涉及public继承和复 合，并导入一个新class (WidgetTimer)。坦白说我展示它主要是为了提醒你，解 决一个设计问题的方法不只一种，而训练自己思考多种做法是值得的(看看条款 35)。尽管如此，我可以想出两个理由，为什么你可能愿意(或说应该)选择这 样的public继承加复合，而不是选择原先的private继承设计。

首先，你或许会想设计Widget使它得以拥有derived classes，但同时你可能会 想阻止derived classes重新定义onTick。如果Widget继承自Timer,上面的想法就 不可能实现，即使是private继承也不可能。(还记得吗，条款35曾说derived classes 可以重新定义virtual函数，即使它们不得调用它。J但如果WidgetTimer是Widget

Effective C++中文版，第三版

内部的一个private成员并继承Timer，Widget的derived classes将无法取用 WidgetTimer,因此无法继承它或重新定义它的virtual函数。如果你曾经以Java或 C#编程并怀念“阻止derived classes重新定义virtual函数”的能力（也就是Java 的final和C#的sealed），现在你知道怎么在C++中模拟它了。

第二，你或许会想要将Widget的编译依存性降至最低。如果Widget继承 Timer，当Widget被编译时Timer的定义必须可见，所以定义Widget的那个文件 恐怕必须#:^<?111<16 Timer.h。但如果WidgetTimer移出Widget之外而Widget内含 指针指向一个WidgetTimer, Widget可以只带着一个简单的WidgetTimer声明式， 不再需任何与Timer有关的东西。对大型系统而言，如此的解耦

（decouplings）可能是重要的措施。关于编译依存性的最小化，详见条款31。

稍早我曾谈到，private继承主要用于“当一个意欲成为derived class者想访问 一个意欲成为base class者的protected成分，或为了重新定义一或多个virtual函数”。 但这时候两个classes之间的概念关系其实是is-implemented-in-terms-of （根据某物 实现出）而非is^a。然而我也说过，有一种激进情况涉及空间最优化，可能会促使 你选择“private继承”而不是“继承加复合”。

这个激进情况真是有够激进，只适用于你所处理的class不带任何数据时。这 样的classes没有non-static成员变量，没有virtual函数（因为这种函数的存在会为 每个对象带来一个vptr，见条款7）,也没有virtual base classes （因为这样的base classes也会招致体积上的额外开销，见条款40）。于是这种所谓的empty classes 对象不使用任何空间，因为没有任何隶属对象的数据需要存储。然而由于技术上的 理由，C-^裁定凡是独立（非附属）对象都必须有非零大小，所以如果你这样做：

class Empty { };    //没有数据，所以其对象应该不使用任何内存

class HoldsAnlnt {    //应该只需要一个int空间

private:

int x;

Empty e;    //应该不需要任何内存

}；

你会发现 sizeof （HoldsAnlnt） > sizeof （int）;喔欧，一个 En^»ty 成员变量竟 然要求内存。在大多数编译器中sizeof （Empty）获得1，因为面对“大小为零之独

Effective C++中文版，第三版

立（非附属）对象”，通常C++官方勒令默默安插一个char到空对象内。然而齐 位需求（alignment,见条款50）可能造成编译器为类似HoldsAnlnt这样的class 加上一些衬垫（padding）,所以有可能HoldsAnlnt对象不只获得一个char大小， 也许实际上被放大到足够又存放一个int。在我试过的所有编译器中，的确有这种 情况发生。

但或许你注意到了，我很小心地说“独立（非附属）”对象的大小一定不为零。 也就是说，这个约束不适用于derived class对象内的base class成分，因为它们并非 独立（非附属）。如果你继承Empty,而不是内含一个那种类型的对象；

class HoldsAnlnt: private Empty { private:

int x;

}；

几乎可以确定 sizeof （HoldsAnlnt） ==sizeof （int）。这是所谓的 EBO {empty base optimization,空白基类最优化），我试过的所有编译器都有这样的结果。如果 你是一个程序库开发人员，而你的客户非常在意空间，那么值得注意EBO。另外还 值得知道的是，EBO—般只在单一继承（而非多重继承）下才可行，统治C++对象 布局的那些规则通常表示EBO无法被施行于“拥有多个base”的derived classes身 上。

现实中的”empty1* classes并不真的是empty。虽然它们从未拥有non-static成员 变量，却往往内含typedefs, enums，static成员变量，或non-virtual函数。STL就有 许多技术用途的empty classes，其中内含有用的成员（通常是typedefs），包括base classes unary_functiori和binary_function，这些是“用户自定义之函数对象” 通常会继承的classes。感谢EBO的广泛实践，使这样的继承很少增加derived classes 的大小。

尽管如此，让我们回到根本。大多数classes并非empty,所以EBO很少成为 private继承的正当理由。更进一步说，大多数继承相当于is-a,这是指public继承， 不是private继承。复合和private继承都意味is-implemented-in-terms-of,但复合比 较容易理解，所以无论什么时候，只要可以，你还是应该选择复合。

当你面对“并不存在is-a关系”的两个classes,其中一个需要访问另一个的 protected成员，或需要重新定义其一或多个virtual函数，private继承极有可能成为 正统设计策略。即便如此你也已经看到，一个混合了 public继承和复合的设计，往 往能够释出你要的行为，尽管这样的设计有较大的复杂度。“明智而审慎地使用 Effective C++中文版，第三版

##### [www.linuxidc.com](http://www.linuxidc.com)

private继承”意味，在考虑过所有其他方案之后，如果仍然认为private继承是“表 现程序内两个classes之间的关系”的最佳办法，这才用它。

请记住

■ Private继承意味is-implemented-in-terms of (根据某物实现出)。它通常比复合

(composition)的级别低。但是当 derived class 需要访问 protected base class 的 成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。

■和复合(composition)不同，private继承可以造成empty base最优化。这对致 力于“对象尺寸最小化”的程序库开发者而言，可能很重要。

条款40:明智而审慎地使用多重继承

Use multiple inheritance judiciously.

—旦涉及多重继承(multiple inheritance； Ml)，C++社群便分为两个基本阵 营。其中之一认为如果单一继承(single inheritance； SI)是好的，多重继承一定更 好。另一派阵营则主张，单一继承是好的，但多重继承不值得拥有(或使用)。本 条款的主要目的是带领大家了解多重继承的两个观点。

最先需要认清的一件事是，当MI进入设计景框，程序有可能从一个以上的base classes继承相同名称(如函数、typedef等等)。那会导致较多的歧义(ambiguity) 机会。例如：

class BorrowableItem { public:

void checkout();

}；

class ElectronicGadget { private:

bool checkout{ ) const;

}；

class MP3Player:

public Borrowable工tem, public ElectronicGadget

{.♦.};

MP3Player mp;

mp.checkout{);



//图书馆允许你借某些东西

//离开时进行检査



//执行自我检测，返回是否测试成功



//注意这里的多重继承

// (某些图书馆愿意借出MP3播放器)

//这里，class的定义不是我们的关心重点

"歧义！调用的是哪个checkout?

Effective C++中文版，第三版

注意此例之中对checkout的调用是歧义（模棱两可）的，即使两个函数之中 只有~~■个可取用（BorrowableItem 内的 checkout public，ElectronicGadget 内的却是private）。这与C++用来解析（resolving）重载函数调用的规则相符：在 看到是否有个函数可取用之前，首先确认这个函数对此调用之言是最佳匹配。 找出最佳匹配函数后才检验其可取用性。本例的两个checkouts有相同的匹配程度 （译注:因此才造成歧义），没有所谓最佳匹配。因此ElectronicGadget:: checkout

的可取用性也就从未被编译器审查。

为了解决这个歧义，你必须明白指出你要调用哪一个base class内的函数： mp,Borrowahleltem: :checkout （ ）;    //哎呀，原来是这个 checkout. . •

你当然也可以尝试明确调用ElectronicGadget::checkout»但然后你会获得 一个“尝试调用private成员函数”的错误。

多重继承的意思是继承一个以上的base classes，但这些base classes并不常在 继承体系中又有更高级的base classes,因为那会导致要命的“钻石型多重继承”：

class File { ... };

}；

• };



![img](09Effective C++082d87482c34809-12.png)



class InputFile: public File {.

class OutputFile: public File {

class IOFile: public InputFile, public OutputFile

{...）；

任何时候如果你有一个继承体系而其中某个base class和某个derived class之间 有一条以上的相通路线（就像上述的File和lOFile之间有两条路径，分别穿越 Input File和OutputFile），你就必须面对这样一个问题：是否打算让base class 内的成员变量经由每一条路径被复制？假设File class有个成员变量fileName，那 么IOFile内该有多少笔这个名称的数据呢？从某个角度说，IOFile从其每一个 base class继承一份，所以其对象内应该有两份fileName成员变量。但从另一个角 度说，简单的逻辑告诉我们，IOFile对象只该有一个文件名称，所以它继承自两个 base classes而来的fileName不该重复o

C++在这场辩论中并没有倾斜立场;两个方案它都支持——虽然其缺省做法是 执行复制（也就是上一段所说的第一个做法）。如果那不是你要的，你必须令那个 带有此数据的class （也就是File）澈为—个virtual base class。为了这样做，你必

Effective C++中文版，第三版

##### [www.linuxidc.com](http://www.linuxidc.com)

须令所有直接继承自它的classes采用"virtual继承”：

class File { ... };

｝；

｝；



class InputFile: virtual public File { class OutputFile: virtual public File { class IOFile: public 工nputFile,

public OutputFile



｝；

C++标准程序库内含一个多重继承体系，其结构 就如右图那样，只不过其classes其实是class templates，名称分别是basic_ios， basic_istream, basic_ostream和 basic—iostream，而非这里的 File, InputFile, OutputFile和 IOFile。

从正确行为的观点看，public继承应该，总是virtual。如果这是唯一一个观点， 规则很简单：任何时候当你使用public继承，请改用virtual public继承。但是，啊 呀，正确性并不是唯一观点。为避免继承得来的成员变量重复，编译器必须提供若 干幕后戏法，而其后果是：使用virtual继承的那些classes所产生的对象往往比使 用non-virtual继承的兄弟们体积大，访问virtual base classes的成员变量时，也比访 问non-virtual base classes的成员变量速度慢。种种细节因编译器不同而异，但基本 重点很清楚：你得为virtual继承付出代价。

virtual继承的成本还包括其他方面。支配“virtual base classes初始化”的规则 比起non-virtual bases的情况远为复杂且不直观。virtual base的初始化责任是由继承 体系中的最低层（most derived） class负责，这暗示（1） classes若派生自virtual bases

而需要初始化，必须认知其virtual bases-不论那些bases距离多远，（2）当一个

新的derived class加入继承体系中，它必须承担其virtual bases （不论直接或间接） 的初始化责任。

我对virtual base classes （亦相当于对virtual继承）的忠告很简单。第一，非必 要不使用virtual bases。平常请使用non-virtual继承。第二，如果你必须使用virtual base classes,尽可能避免在其中放置数据。这么一来你就不需担心这些classes身上 的初始化（和赋值）所带来的诡异事情了。Java和.NET的Interfaces值得注意， 它在许多方面兼容于C++的virtual base classes,而且也不允许含有任何数据。

现在让我们看看下面这个用来塑模“人”的C++ Interface class （见条款31）:

Effective C++中文版，第三版

class IPerson { public:

virtual ~ I Per son ();

virtual std: -.string name() const = 0; virtual std::string birthDate() const = 0;

}；

I Person的客户必须以Iperson的pointers和references来编写程序，因为抽象 classes无法被实体化创建对象。为了创建一些可被当做IPerson来使用的对象，

I Person的客户使用factory functions (工厂函数，见条款31)将“派生自I Person 的具象classes”实体化：

//factory function (工厂函数)，根据一个独一无二的数据库ID创建一个Person对象。 "条款18告诉你为什么返回类型不是原始指针。

std::tri::shared_ptr<IPerson> makePerson(DatabaseID personldentifier);

//这个函数从使用者手上取得一个数据库ID

DatabaseID askUserForDatabaseID{);

DatabaselD id(askUserForDatabaseID());

std:: tri:: shared_jptr<IPerson> pp (makePerson (id));

//创建一个对象支持Iperson接口。 ...    //藉由Iperson成员函数处理*pp。

但是makePerson如何创建对象并返回一个指针指向它呢？无疑地一定有某些 派生自IPerson的具象class，在其中makePerson可以创建对象。

假设这个class名为CPerson。就像具象class —样，CPerson必须提供“继承 自IPerson”的pure virtual函数的实现代码。我们可以从无到有写出这些东西，但 更好的是利用既有组件，后者做了大部分或所有必要事情。例如，假设有个既有的 数据库相关class，名为Personlnfo，提供CPerson所需要的实质东西：

class Personlnfo { public:

explicit Personlnfo(DatabaselD pid); virtual -Personlnfo(); virtual const char* theName() const; virtual const char* theBirthDate( ) const;

private:

virtual const char* valueDelimOpen() const;    "详下

virtual const char* valueDelimClose() const;

}；

Effective C++中文版，第三版

你可以说这是个旧式class，因为其成员函数返回const char*而不是string 对象。尽管如此，如果鞋子合脚，干嘛不穿它？这个class的成员函数的名称己经 暗示我们其结果有可能很令人满意。

你会发现，Personlnfo被设计用来协助以各种格式打印数据库字段，每个字 段值的起始点和结束点以特殊字符串为界。缺省的头尾界限符号是方括号(中括 号)，所以(例如)字段值”Ring-tailed Lemur”将被格式化为：

[Ring-tailed Lemur]

但由于方括号并非放之四海人人喜爱的界限符号，所以两个virtual函数 valueDelimQpen 和 valueDelimClose 允许 derived classes 设定它们自己的头尾界限 符号。Personlnfo成员函数将调用这些virtual函数，把适当的界限符号添加到它 们的返回值上。以Personlnfo: :theNaine为例，代码看起来像这样：

const char* Personlnfo::valueDelimOpen() const {

return ” [”；    //缺省的起始符号

}

const char* Personlnfo::valueDelimClose() const {

return ” ;    / /缺省的结尾符号

}

const char* Personlnfo::theNameO const {

//保留缓冲区给返回值使用；由于缓冲区是static,因此会被自动初始化为“全部是0” static char value [Max__Formatted_Field__Value_Lerigth];

//写入起始符号

std::strcpy(value, valueDelimOpen());

现在，将value内的字符串添附到这个对象的name成员变量中 (小心，避免缓冲区超限)

//写入结尾符号

std::strcat(value, valueDelimClose{)); return value;

}

或许有人质疑Personlnfo:: theName的老旧设计(特别是它竟然使用固定大小 的static缓冲区，那将充斥超限问题和线程问题，见条款21)，但是不妨暂时把这 样的疑问放两旁，把以下焦点摆中间：theName调用valueDelimOpen产生字符串 起始符号，然后产生name值，然后调用valueDelimClose。由于valueDelimOpen

Effective C++中文版,第三版

和valueDelimClose都是virtual函数，theName返回的结果不仅取决于Personlnfo 也取决于从Personlnfo派生下去的classes。

身为CPerson实现者，这是个好消息，因为仔细阅读IPerson文档后，你发现 name和birthDate两函数必须返回未经装饰(不带起始符号和结尾符号)的值。也 就是说如果有人名为Homer,调用其name函数理应获得nHomer”而不是 "[Homer]%

CPerson和Personlnfo的关系是，Personlnfo刚好有若干函数可帮助CPerson 比较容易实现出来。就这样。它们的关系因此是is-implemented-in-terms-of (根据 某物实现出)，而我们知道这种关系可以两种技术实现：复合(见条款38)和private 继承(见条款39)。条款39指出复合通常是较受欢迎的做法，但如果需要重新定 义virtual函数，那么继承是必要的。本例之中CPerson需要重新定义 valueDelimQpen和valueDelimClose，所以单纯的复合无法应付。最直接的解法 就是令CPerson以private形式继承Personlnfo,虽然条款39也说过，只要多加一' 点工作，CPerson也可以结合“复合+继承”技术以求有效重新定义Personlnfo 的virtual函数。此处我将使用private继承。

但CPerson也必须实现IPerson接口，那需得以public继承才能完成。这导致 多重继承的一个通情达理的应用：将“public继承自某接口”和“private继承自某 实现”结合在一起：

class IPerson {    //这个class指出需实现的接口

public:

virtual -IPerson();

virtual std::string name() const = 0; virtual std::string birthDate() const = 0;

}；

class Database ID {.•.};    //稍后被使用；细节不重要。

class Personlnfo {    //这个class有若干有用函数，

public:    //可用以实现IPerson接口。

explicit Personlnfo(DatabaselD pid); virtual -Personlnfo(); virtual const char* theName() const; virtual const char* theBirthDate( ) const; virtual const char* valueDelimOpen() const; virtual const char* valueDelimClose() const;

}；

Effective C++中文版，第三版

class CPerson: public IPerson, private Personlnfo { //注意，多重辦承 public:    .

explicit CPerson(DatabaselD pid): Personlnfo(pid) { }

virtual std:: string name () const    //实现必要的 I Person 成员函数

{ return Personlnfo::theName(); }

"钢ft必要的I Person成员函数



virtual std::string birthDate() const { return Personlnfo::theBirthDate(); }

//重新定义 "继承而来的 // virtual //"界限函数"



private:

const char* valueDelimOpen() const { return n const char* valueDelimClose() const { return

};

在UML图中这个设计看起来像这样：

![img](09Effective C++082d87482c34809-14.png)



这个例子告诉我们，多重继承也有它的合理用途。

故事结束前，请容我说，多重继承只是面向对象工具箱里的一个工具而已。和 单一继承比较，它通常比较复杂，使用上也比较难以理解，所以如果你有个单一继 承的设计方案，而它大约等价于一个多重继承设计方案，那么单一继承设计方案几 乎一定比较受欢迎。如果你唯一能够提出的设计方案涉及多重继承，你应该更努力 想一想——几乎可以说一定会有某些方案让单一继承行得通。然而多重继承有时候 的确是完成任务之最简洁、最易维护、最合理的做法，果真如此就别害怕使用它。 只要确定，你的确是在明智而审慎的情况下使用它。

请记住

■多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。 ■ virtual继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果virtual

base classes不带任何数据，将是最具实用价值的情况。

■多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”

和“private继承某个协助实现的class”的两相组合。

Effective C++中文版，第三版

[Linux](http://www.linuxidc.com)[公社(LinuxIDC.com)是包括Ubuntu，Fedora，SUSE技术，最新IT资讯等Linux专业类网站。](http://www.linuxidc.com)
