


顶级畅销的程序设计教程和参考书籍 为新的C++11标准重新撰写

- 对 C++语言的介绍权威而又全面
- 能以一种现代、高效的方式使用它
- 强调一些现代C++编 程的最佳方法
- 展示了如何使用核心语言特性和标准库来编写 高效、易读、强大的代码。

- 介绍C++标准库相关内容，利用标准库功能和设施来帮助你编写有用的程序，而不要求你首先掌握每个语言细节。




- 学习如何使用新的C++11的语言特性和标准库来快速构建健壮的程序，并感受高级语言程序设计的轻松自如。<span style="color:red;">真的有那么轻松自如吗？有哪些特性？</span>
- 通过一些展示当前最佳编码 风格和程序设计技术的例子来学习。
- 理解“规则背后的原理”： 为什么C++11是这样的。<span style="color:red;">嗯，想知道为什么</span>
- 使用大量的交叉引用来帮助 你将有关联的概念和见解联系起来。<span style="color:red;">嗯，要注意一些交叉，连接</span>
- 得益于新式的学习辅助和强调关键点的课后练习，帮助你避免一些陷阱，促进你在实践中养成好的习惯，以及巩固你所学的知识。<span style="color:red;">嗯，看看有哪些陷阱。</span>



## 推荐序 1

C++ 一直直是我最为钟情的程序设计语言，我曾经在有些场合下提到 “C++正在成为一门完美的程序设计语言”。从C++标准1998年版本到2011年版本的变化，基本上印证了我的这一提法。原来版本中来不及引入的内容，以及语言机制中发现的一些缺陷，都在新版本中得以弥补和发展。比如新版标准中引入了无序容器，以弥补原版标准中对hash容器的缺漏<span style="color:red;">嗯，才知道hash在C++中对应的是无序容器。之前还以为是stl里面的，要看下无序容器是怎么使用的。</span>；新版标准支持移动构造函数和移动赋值运算符，以减小特定场景下对象拷贝的性能开销<span style="color:red;">什么是移动构造函数和移动赋值运算符？什么场景下使用的？</span>。新版标准不仅在语法上增加了大量特性，而且在标准库里也引入大量设施，使得标准库对于C++语言的重要性远超从前。<span style="color:red;">嗯，标准库现在很重要吗？一定要使用吗？</span>

“完美的程序设计语言”，听起来很好.但代价是语言变得越来越复杂。从一个完善的类型系统或者一门程序设计语言的角度来看，新版本的 C++ 标准是一个里程碑，但是，从 C++ 学习者和使用者角度来看这未必是好事。

- 语言的复杂性导致学习难度增加，学习周期变长；
- C++程序员写出好程序的门槛也相应提高。

这差不多正是C++语言这几年的现状。 我相信，随着计算机科学技术的发展，这种状况未来还会加剧。即便如此，我仍然乐于看到 C++ 语言走向完美。<span style="color:red;">现在仍在在走向完美吗？</span>


本书在讲解的时候，常常会提到"编译器会如何如何”，学习语言的一个境界是把自己想象成编译器，这种要求对于一般的程序设计语言可能太高了，但是对于学习 C 和 C++ 语言是最理想的方法。像编译器一样来思考和理解C++语言，如果暂时做不到，也不要紧，当有了一定的綰写程序经验以后，在 “揣摩” 编译器行为的过程中可逐渐掌握C++语法特性。<span style="color:red;">嗯。</span>因此，本书值得阅读多遍，每多读一遍，就会加深理解。<span style="color:red;">嗯。</span>可能是考虑到篇幅的原因，本书很多地方没有展开来透彻地讲解。我相信，作者们已经在深度和广度上做了较为理想的折中。<span style="color:red;">是这样吗？还有那些地方需要展开讲解的？</span>

本书的另一个特色是将C++的语法和标准库融为一体来介绍。 C++ 标准库本身就是 C++ 语法的最佳样例，其中包含不少 C++ 高级特性的指导性用法。在我的程序设计经历中，有些 C++ 语言特性（比如虚拟继承），我只在标准库中看到过实用做法。本书贯穿始终融合了 C++ 标准库的知识和用法，这符合新版本 C++ 标准的发展和变化，也符合现代软件开发现状。<span style="color:red;">嗯，对于C++标准库，书虽然买了，但是从来没看过，因为工作中基本用不到，不过看来，看还是要看的，主要学习里面是怎么使用 C++ 的一些特性的。</span>

C++ 语言正在走向完美，所以，C++ 语言值得学习（甚至研究），**这些知识可以成为一切编程的基础**<span style="color:red;">这个很重要</span>。然而，在实践中，不必全面地使用 C++语言的各种特性，而应根据工程项目的实际情况，适当取舍（譬如动态类型信息、虚拟继承、异常等特性的使用很值得商榷）<span style="color:red;">对呀，这些东西到底要不要使用？什么情况下使用？要明确下。</span>。通常只鼓励使用 C++ 语言的一个子集就够了， 一个值得学习和参考的例子是 Google 发布的 Google C++ Style Guide <span style="color:red;">嗯，一定要按照这个来，把这本书看完后，这个要总结下。</span>。**尽管在工程中只使 用 C++ 的子集，但全面地学习 C++ 语言仍然是必要的，毕竟 C++ 语言是一个整体，并且 C++ 标准库自身全面地使用了 C++ 语言的各种特性。** <span style="color:red;">嗯，是的。</span>我自己在过去多年的实践中就一直恪守着这种两面的做法，

## 推荐序 2

C++ 经历了这么多年的打磨与起伏，其在工业界的地位已经非常稳固，在很多领域里已经是不可取代也没必要被取代的统治者。新标准的出现能够大大提升 C++ 开发的效率和质量，因此贏得欢呼也是情理之中。在这种氛围之下，编译器实现的速度也令人惊喜。短短两年时间，从开源的GCC、LLVM到专有的Visual C++和Intel C++，对于新标准的追踪之快，覆盖之全，与 当年C++98标准颁布之后迟迟不能落地的窘境相比，可谓对比强烈。当年是热情的开发者反复敦促厂商实现完整标准而不得，为此沮丧无奈，那种心情，至今记忆犹新，时过境迁，今天是编译器实现远远冲在前面，开发者倒是大大地落在了后面。<span style="color:red;">嗯。</span>

时至今日，能够基本了解 C++11 标准的程序员恐怕不多，而能够以新的 C++ 风格开发实践的人更是凤毛麟角。因此，今天的 C++ 开发者面临的一个重要任务就是快速掌握新的 C++ 风格和工具。<span style="color:red;">嗯，工具有哪些？</span>

而说到教授“正宗的” C++11编程风格，《C++Primer（第5版）》如同它之前的版本一样，扮演着法定教科书的角色。

**一种优秀的编程语言，一定要对于计算这件事情实现一个完整和自洽的抽象。** <span style="color:red;">这个倒是第一次听</span>十几年来编程语言领域的竞争，除却实现质量之外，基本上是在比拼抽象的设汁。而 C 语言之所以四十年长盛不衰，根本在于它对于现代计算机提供了一个底层的高级抽象：凡是比它低的抽象都过于简陋，凡是比它高的抽象都可以用 C 语言构造出来<span style="color:red;">嗯。</span>。C++ 成功的根本原因，恰恰是因为它虽然试图提供一些高级的抽象机制，但是其根基与 C 在同一层面。正因为如此，每当你需要走下去直接与硬件对话时，C++ 成为 C 之外唯一有效率的选择。我的一个朋友在进行了多年的大型系统软件开发之后，不无感慨地说，C++ 最大的力量不在于其抽象，恰恰在于其不抽象。<span style="color:red;">这是什么意思？说的是厉害的地方都是 C 继承过来的吗？</span>

话虽然如此，但是 C++ 之所以脱离 C 而存在，毕竟还是因为其强大的抽象能力。Bjame Stroustmp 曾经总结说，C++ 同时支持4种不同的编程风格：C 风格、基于对象、面向对象和泛型 <span style="color:red;">一直没明白这个泛型是什么意思？而且这4种风格不同吗？</span>。事实上，把微软的 COM 也算进来的话，还可以加上一种 “基于组件” 的风格。 这么多的风格共存于一种语言，就是其强大抽象机制的证明。但是，在 C++11 以前，C++ 的抽象可以说存在若干缺陷，其中最严重的是缺少自动内存管理和对象级别的消息发送机制<span style="color:red;">现在有动态内存管理吗？有对象级别的消息发送机制吗？</span>。今天看来，C++98 只能说是特定历史条件造成的半成品，无论是从语言机制，还是标准库完备程度来说，可以说都存在明显的、不容忽略的缺陷。其直接后果，就是优雅性的缺失和效率的降低。我本人在十年前曾经与当时中国 C++ 社群中不少杰出的人物交流探讨，试图从 C++98 中剪裁出一个小巧、优雅的、自成一体的子集，希望至少在日常编程中，能够在这个子集之内可以写出与当时的 Java 和 C# 同样干净明晰的代码。为此我们尝试了各种古怪的模板技巧，并且到处寻找有启发的代码和经验来构造这个语言子集，结果并不理想，甚至可以说是令人非常失望。后来我在我的博客中发表过好几篇文章，探讨所谓的 C++ 风格问题，其实就是说，C++ 不支持简洁明快的面向对象风格，大家还不如回到基于对象甚至 C 语言的风格，最多加点模板，省一点代码量。非要面向对象的话，就必须依赖像 Qt 或者 MFC 那样的基础设施才可以。<span style="color:red;">这种情况在C++11 中有解决吗？</span>

C++11 出来之后，增强的语言机制和大为完善的标准库，为 C++ 语言的编程风格带来了革命性的变化。如果能够纯熟地运用 C++11 的新特征、新机制，那么就能够形成一种简洁优雅的C++编程风格<span style="color:red;">是这样吗？哪些特性可以使得开发简洁？</span>，以比以前更高的效率、更好的质量进行软件开发。对于这种新的风格，我认为“直觉、自然”是最佳的描述。也就是说，解决任何问题不必拘泥于什么笼盖一切的编程思想，也不再沉溺于各种古怪的模板技巧中无法自拔<span style="color:red;">模板一直不是特别清楚</span>，而是能够根据那个问题本身采用最自然、最符合直觉的方式。C++ 有自己的一套思维方式，比如容器、算法、作为概念抽象的对象等，很大程度上这套思维方式确实是合乎直觉的。只有到了 C++11 这一代，C++ 语言的高级抽象才基本完备，这样一种风格才可能真正落实。因此可以说 C++11 对于 C++98 而言，不是一次简单的升级，而是一次本质的跃升。<span style="color:red;">真的吗？到底是什么样的？</span>

学习新的 C++ 风格，并不是轻而易举的事情。即便对于以前已经精通 C++ 的人来说，熟练掌握 rvalue reference、move 语义，了解 unique_ptr、shared_ptr 和 weak_ptr 的完整用法，明智地使用 function/bind 和 lambda 机制，学习 C++ Concurrency 的新技术，都绝非一朝一夕之功。对于那些初学者来说，这件事情更不简单。<span style="color:red;">嗯，看来这些事必须掌握的。</span>

本书无论对于初学者还是提高者，都是最经典的教科全书。一直以来，它的特点就是完整而详细，基本上关于语言本身的问题，都可以在这本书里得到解决。<span style="color:red;">嗯。</span>而本书的另一个重要优点，就是其完全基于新的编程风格编写，所有的例子和讲解都遵循 C++11 标准所体现出来的思路和风格进行，如果能够踏下心来认真学习和练习，那么就能 “一次到位” 地掌握 C++11，尽管可能会比较慢 <span style="color:red;">嗯。</span>。有经验的 C++ 开发者阅读这本书当然不用从头到尾，选择自己关心的内容学习 C++11 的新特性就可以，是快速提升自身能力的捷径。

差不多十年前，我提出一个观点，**每一个具体的技术领域，只需要读四五本书就够了。** 以前的 C++ 是个例外，因为语言设计有缺陷，所以要读很多书才知道如何绕过缺陷。现在的C++11完全可以了，大家读四五本书就可以达到合格的水平，这恰恰是语言进步的体现。<span style="color:red;">嗯。这个道理倒是。</span>

- 本书是这四五本中的一本，而且是“教程+参考书”，扛梁之作，初学者的不二法门。
- 另一本是《C++标准程序库》，对于 C++ 熟手来说更为快捷。
- Scott Meyers的 《Effective C++ 》永远是学习 C++ 者必读的，只不过这本书的第4版不知道什么时候出来。
- Anthony Williams 的 《C++ Concurrency in Action》 是学习用标准C++开发并发程序的最佳选择。
- 国内的作品， 我则高度推荐陈硕的《Linux多线程服务端编程》。这本书的名字赶跑了不少潜在的读者，所以我要特别说明一下，这本书是C++开发的高水平作品，与其说是教你怎么用 C++ 写服务端开发，不如说是教你如何以服务端开发为例子提升 C++ 开发水平。前面几本书都是谈标准 C++ 自己的事情，碰到像 iostream 这样失败的标准组件也不得不硬着头皮介绍。而这本书是接地气的实践结晶，告诉你面对具体问题时应怎样权衡，C++里什么好用，什么不好用，为什么，等等。

<span style="color:red;">嗯，这几本书是一定要看的。</span>

今天的 C++ 学习者是非常幸运的，可以在 C++11 这个基础上大步向前，不必再因为那些语言的缺陷和过度的技巧而烦恼。大家静下心来认真读几本书，可以打下很好的基础。<span style="color:red;">嗯。</span>







## 本书介绍

新标准增加的一些特性是具有普适性的，例如用于类型推断的auto。这些新特性使本书中的代码更易于阅读和理解。程序（以及程序员！）可以忽略类型的细节，从而更容 易集中精力于程序逻辑上來。其他一些新特性，例如智能指针和允许移动的容器，允许我们编写更为复杂的类，而又不必与错综复杂的资源管理做斗争<span style="color:red;">智能指针到底要怎么使用？与普通的指针相比到底使用什么？之间的转化方式是什么？能通用吗？允许移动的容器是什么？</span>。因此，在本书中开始讲授如何编写自己的类，会比第 4 版简单得多。旧标准中阻挡在我们前进路上的很多细节，你我都不必再担心了。<span style="color:red;">哪些细节不用担心了？</span>

对于本书中涉及新标准定义的新特性的那些部分，我们都已用一个特殊的图标标记出来了。我们希望这些提示标记对那些己经熟悉 C++ 语言核心内容的读者是有帮助的，可以帮助他们决定将注意力投向哪里。对于那些可能尚不支持所有新特性的编译器，我们还希望这些图标能有助于解释这类编译器所给出的编译错误信息。这是因为虽然本书中几乎所有例子都己经用最新版本的 GNU 编译器编译通过，但我们知道一些读者可能尚未将编译器更新到最新版本。虽然新标准增加了大量新功能，但核心 C++ 语言并未变化，这构成了本书的大部分内容。读者可以借助这些图标来判断哪些功能可能还没有被自己的编译器所支持。<span style="color:red;">嗯。</span>

## 为什么选择这本书？

现代 C++ 语言可以看作是三部分组成的：

- 低级语言，大部分继承自 C 语言。
- 现代高级语言特性，允许我们定义自己的类型以及组织大规模程序和系统。
- 标准库，它利用高级特性来提供有用的数据结构和算法。

大多数 C++ 教材按照语言进化的顺序来组织其内容。首先讲授 C++ 的 C 子集，然后将 C++ 中更为抽象的一些特性作为高级话题在书的最后进行介绍。这种方式存在两个问题： 读者会陷入那些继承自低级程序设计的细节，从而由于挫折感而放弃；读者被强加学习一些坏习惯，随后又需要忘记这些内容。

我们采用一种相反的方法：从一开始就介绍一些语言特性，能让程序员忽略那些继承自低级程序设计的细节，例如，在介绍和使用内置的算术和数组类型时，我们还连同介绍和使用标准库中的类型 string 和 vector 。使用这些类型的程序更易写、易理解且更少出错。<span style="color:red;">嗯。OK</span>

太多时候，标准库被当作一种 “高级” 话题来讲授。很多教材不使用标准库，而是使用基于字符数组指针和动态内存管理的低级程序没计技术。让使用这种低级技术的程序确运行，要比编写相应的使用标准库的 C++ 代码难得多。<span style="color:red;">是的。</span>

贯穿全书，我们都在强调好的风格：我们想帮助读者直接养成好的惯，而不是在获得很多很复杂的知识后再去忘掉那些坏习惯。我们特别强调那些棘手的问题，并对常见的 错误想法和陷阱提出警告。<span style="color:red;">嗯。</span>

我们还注意解释规则背后的基本原理一使读者不仅知其然，还能知其所以然。我们相信，通过体会程序的工作原理，读者会更快地巩固对语言的理解。<span style="color:red;">是的，想知道这些工作原理</span>

虽然你不必为了学本书而掌握 C 语言，但我们还是假定你了解足够多的程序设计知识，了解至少一门现代分程序结构语言，知道如何用这门语言编写、编译以及运行程序。 特别是，我们假定你已经使用过变量，编写、调用过函数，也使用过编译器。

## 这一版变化的内容

这一版《C++ Primer》的新特点是用边栏图标来帮助引导读者。C++ 是一种庞大的编 程语言，它提供了一些为特定程序设计问题定制的功能。其中一些功能对大型项目团队有 很重耍的意义，但对于小型项目开发可能并无必耍。因此，并非每个程序员都需要了解每种语言特性的所有细节。我们加入这些边栏图标來帮助读者弄清哪些内容可以随后再学习，而哪些主题是更为重要的。

- 对于包含 C++ 语言基础内容的章节，我们用一个小人正在读书的图标加以标记。用这个图标标记的那些章节，涵盖了构成语言核心部分的中题。每个人都应该阅读并理解这个章节的内容。

- 对于那些涉及高级主题或特殊目的主题的章节，我们也进行了标记。在首次阅读时， 这些章节可以跳过或快速浏览。我们用一叠书的图标标记这些章节，指出在这些地方，你 可以放心地放下书本。快速浏览这些章节可能是一个好主意，这样你就可以知道有这些特性存在。但在真正需要在自己的程序中使用这些特性之前，没有必要花费时间仔细学习这些主题。<span style="color:red;">嗯。</span>

- 为了进一步引导读者的注意力，我们还用放大镜图标标记了特别复杂的概念。我们希望读者对有这种标记的章节能多花费一些时间彻底理解其中的内容。在这些章节中，至少有一些，其主题的重要性可能不是那么明显：但我们认为，你会发现这些章节涉及的主题对理解 C++ 语言原来至关重要。<span style="color:red;">嗯。</span>

交叉引用的广泛使用，是本书采用的另外一种阅读帮助。我们希望这些引用能帮助读者容易地翻阅书中的内容，同时还能在后面的例子涉及到前面的内容时容易地跳回到前面。

没有改变的是，《C++ Primer》仍是一本清晰、正确、全面的 C++ 入门教材。我们通过给出一系列复杂度逐步增加的例子来讲授这门语言，这些例子说明了语言特性，展示了 如何充分用好 C++ 语言。

## 本书的结构

我们首先在第 1 部分和第 2 部分中介绍了 C++语言和标准库的基础内容。这两部分包 含的内容足够你编写出有意义的程序，而不是只能3—些玩具程序。人部分程序员基本上 都需要掌握本书这两部分所包含的所有内容。

除了讲授 C++的基础内容，第 1 部分和第 2 部分还有另外一个重要目的：通过使用标准庠中定义的抽象设施，使你更加适应高级程序设计技术。标准库设施本身是一组抽象数据类型，通常用 C++ 编写。用来设计标准库的，就是任何C++程序员都可以使用的用来构造类的那些语言特性 <span style="color:red;">嗯。</span>。我们讲授 C++ 语言的一个经验是，在先学习了使用设计良好的抽象类型后，读者会发现理解如何构造自己的类型更容易了。<span style="color:red;">嗯。</span>

只有在经过全面的标准库使用训练，并编写了各种标准库所支持的抽象程序后，我们才真正进入到那些允许你编写自己的抽象类型的C++特性中去。本书的第 3 部分和第 4 部分介绍了如何编写类的形式的抽象类型。第 3 部分包含基础内容，第 4 部分介绍更专门的语言特性。

在第 3 部分中，我们将介绍拷贝控制问题，以及其他一些使类能像内置类型一样容易使用的技术。类是面向对象编程和泛型编程的基础，第 3 部分也会介绍这些内容。第 4 部分是《C++Primer》的结束部分，它介绍了一些在组织大型复杂系统时非常有用的语言特性 <span style="color:red;">大型复杂的系统中怎么使用？</span>。此外，我们将在附录 A 中总结标准库算法。

## 读者帮助


- 重耍的术语用黒体敁示，我们假定读者已经熟悉的重要术语用楷体显示。每个术语都会列在章末尾的术语表中。

- 贯穿全书，我们用灰底衬托的方式来提醒读者需要注意的重要部分，对常见的陷阱提出警吿，建议好的程序设计习惯，以及提供一般性的使用提示。

- 为了更好地理解语言特性间和概念问的联系，我们提供大量向前的和向后的交叉 引用。

- 对重要的概念和C++新程序员常常觉得困难的主题，我们提供边栏讨论。<span style="color:red;">嗯，这个要注意</span>


## 关于编译器的注意事项

我们使用最多的编译器是GNU编译器4.7.0。本书中只有一小部分特性在此编译器中尚未实现：继承构造函数、成员函数的引用限定符以及正则表达式库。
