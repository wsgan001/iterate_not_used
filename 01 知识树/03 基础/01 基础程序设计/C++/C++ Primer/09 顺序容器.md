### 第9章 顺序容器

<3^~1



内容

本章是第3章内容的扩展，完成本章的学习后，对标准库顺序容器知识的掌握就完榷 了。元素在顺序容器中的顺序与其加入容器吋的位置相对应。标准库还定义了几种关联容 器，关联容器中元素的位置由元素相关联的关键字值决定。我们将在第II章中介绍关联 容器特有的操作。

所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。这个公共接口使 容器的学习更加容易——我们基于某种容器所学习的内容也都适用于其他容器。每种容器 都提供了不同的性能和功能的权衡。

EJ26>    一个容器就是一些特定类型对象的集合。顺序容器(sequential container)为程序员提

供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器 时的位置相对应。与之相对的，我们将在第11章介绍的有序和无序关联容器，则根据关 键字的值来存储元素。

标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型 适配。我们将在本章末尾介绍适配器。

![img](C++  Primer 5-81.jpg)



本章的内容基于3.2节、3.3节和3.4节中已经介绍的有关容器的知识，我们假 定读者已经熟悉了这几节的内容

##### 沿9.1顺序容器概述

表9.1列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。 供是，这些容器在以下方面都有不同的性能折中：

•向容器添加或从容器中删除元素的代价 •非顺序访问容器中元素的代价

| 表9.1:顺序容器类型 |                                                              |
| ------------------ | ------------------------------------------------------------ |
| vector             | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元 素可能很慢 |
| deque              | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快      |
| list               | 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除 操作速度都很快 |
| forward_list       | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作 速度都很快 |
| array              | 固定大小数组。支持快速随机访问，不能添加或删除元素           |
| string             | 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部 插入/删除速度快 |

除了固定大小的array外，其他容器都提供高效、灵活的内存管理。我们可以添加 和删除元素，扩张和收缩容器的火小，容器保存元素的策略对容器操作的效率有着固有的， 有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作。

I 327> 例如，string和vector将元素保存在连续的内存空间中。由于元素是连续存储的， 由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元 素就会非常耗时：在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素， 来保持连续存储。而且，添加一个元素有时可能还需要分配额外的存储空间。在这种情况 下，每个元素都必须移动到新的存储空间中。

list和forward_list两个容器的设计目的是令容器任何位置的添加和删除操作 都很快速。作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能 遍历整个容器。而且，与vector、deque和array相比，这两个容器的额外内存开销 也很大。

deque是一个更为复杂的数据结构。与string和vector类似，deque支持快速

的随机访问。与string和vector 一在deque的中间位置添加或删除兀素的代价 （可能）很高。但是，在deque的两端添加或删除元素都是很快的，与list或 forward_list添加删除元素的速度相当。

forward_list和array是新C++标准增加的类型。与内置数组相比，array是一 pi? 种更安全、更長易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此， array不支持添加和删除元素以及改变容器大小的操作。forward_list的设计目称是 达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list没有size 操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其jtil容器而言，size 保证是_个快速的常量时间的操作。

![img](C++  Primer 5-82.jpg)



新标准库的容器比旧版本快得多，原因我们将在13.6节（第470页）解释.新 标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更 好现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置 数组。

确定使用哪种顺序容器

![img](C++  Primer 5-83.jpg)



通常，使用vector是最好的选择，除非你有很好的理由选择其他容器

以下是一些选择容器的基本原则：

•除非你有很好的理由选择其他容器，否则应使用vector。

•如果你的程序有很多小的元素，且空间的额外开销很重要，则不耍使用list或 forward_list。

•如果程序要求随机访问元素，应使用vector或deque。

•如果程序要求在容器的中间插入或删除元素，应使用list或forward_list。

•如果程序需要在头尾位置插入或刪除元素，供不会在中间位置进行插入或刪除操 作，则使用deque o

•如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元＜3?0 素，则

-首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据吋，通常 可以很容易地向vector追加数据，然后再调用标准库的sort函数（我们将 在10.2.3节介绍sort （第343页））来重排容器中的元素，从而避免在中间位 置添加元素。

-如果必须在中间位置插入元素，考虑在输入阶段使用list，. 一旦输入完成，将 list中的内容拷贝到一个vector中。

如果程序既需要随机访问元素，又需要在容器中间位置插入元素，那该怎么办？答案 取决于在list或forward_list中访问元素与vector或deque中插入/删除元素的 相对性能。一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入/删除更多）

决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。

如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list 公共的操作：使用迭代器，不使用下标操作，避免随机访问。..这样，在必要时 选择使用vector或list都很方便

###### 9.1节练习

练习9.1:对于下面的程序任务，vector、deque和list哪种容器最为遗合？解释 你的选择的理由。如果没有哪一种容器优于其他容器，也请解释理由。

（a）    读取固定数量的单词，将它们按字典序插入到容器中，我们将在下一章中看到, 关联容器更适合这个问题。

（b）    读取未知数量的单词，总是将新单词插入到末尾。删除操作在头部进行。

（c）    从一个文件读取未知数量的整数。将这些数排序，然后将它们打印到标准输出。

##### 浥9.2容器库概览

容器类型上的操作形成了一种层次：

•某些操作是所有容器类型都提供的（参见表9.2,第295页）。

•另外一些操作仅针对顺序容器（参见表9.3,第299页）、关联容器（参见表11.7, 第388页）或无序容器（参见表11.8,第395页）。

•还有一些操作只适用于一小部分容器。

□?9>在本节中，我们将介绍对所有容器都适用的操作。本章剩余部分将聚焦于仅适用于顺序容 器的操作。关联容器特有的操作将在第11章介绍。

一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即，deque定义 在头文件deque中，list定义在头文件list中，以此类推。容器均定义为模板类（参 见3.3节，第86页）。例如对vector,我们必须提供额外信息来生成特定的容器类型。 对大多数，佴不是所有容器，我们还需要额外提供元素类型信息：

list<Sales_data> // 保存 Sales_data 对象的 list deque<double>    // 保存 double 的 deque

对容器可以保存的元素类型的限制

顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的 类型是另一个容器。这种容器的定义与任何其他容器类型完全一样：在尖括号中指定元素 类型（此种情况下，是另一种容器类型）：

veetor<vector<string» Lines; // vector 的 vector ［甘j 此处lines是一■个vector，其元素类型是string的vector。

![img](C++  Primer 5-84.jpg)



较旧的编译器可能需要在两个尖括号之间键入空格， vector<vector<string> >.;

例如，



虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特 殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些 没有特殊耍求的容器操作了。

例如，顺序容器构造函数的一个版本接受容器大小参数（参见3.3.1节，第88页）， 它使用了元素类型的默认构造函数。但某些类没有默认构造函数。我们可以定义一个保存 这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：

//假定noDefault是一个没有默认构造函数的类型

vector<noDefault> vl （10, init） ;    // 正确：提供了 元素初始化器

vector<noDefault> v2 （10） ;    //错误：必须提供一个元素初始化器

当后面介绍容器操作时，我们还会注意到每个容器操作对元素类型的其他限制。

| 表9.2:容器操作                         |                                                             |
| -------------------------------------- | ----------------------------------------------------------- |
| 类型别名                               |                                                             |
| iterator                               | 此容器类型的迭代器类型                                      |
| const_iterator                         | 可以读取元素，但不能修改元素的迭代器类型                    |
| size_type                              | 无符号整数类型，足够保存此种容器类型最大可能容器的 大小     |
| difference_type                        | 带符号整数类型，足够保存两个迭代器之间的距离                |
| value_type                             | 元素类型                                                    |
| reference                              | 元素的左值类型；与value_type&含义相同                       |
| const_reference                        | 元素的const左值类型（即，const value_type& ）               |
| 构造函数                               |                                                             |
| C c;                                   | 默认构造函数，构造空容器（array,参见第301页）               |
| C cl(c2);                              | 构造c2的拷贝cl                                              |
| C c (b, e);                            | 构造c,将迭代器b和e指定的范围内的元素拷贝到c （array不支持） |
| Cc{a, b, c. . . };                     | 列表初始化C                                                 |
| 赋值与swap                             |                                                             |
| cl = c2                                | 将cl中的元素替换为c2中元素                                  |
| cl={a, b, c...}                        | 将cl中的元素替换为列表中元素（不适用于array）               |
| a.swap (b)                             | 交换a和b的元素                                              |
| swap(a, b)                             | 与a.swap (b)等价                                            |
| 大小                                   |                                                             |
| c.size ()                              | c中元素的数目（不支持forward_list）                         |
| c.max_size ()                          | c可保存的最大元素数目                                       |
| c.empty ()                             | 若c中存储了元素，返回false,否则返回true                     |
| 添加/删除元素（不适用于array）         |                                                             |
| 注：在不同容器中，这些操作的接口都不同 |                                                             |
| c.insert (args)                        | 将中的元素拷贝进c                                           |
| c.emplace (inits)                      | 使用zTi/权构造c中的一个元素                                 |
| c.erase (args)                         | 删除指定的元素                                              |
| c.clear ()                             | 删除c中的所有元素，返回void                                 |
| 关系运算符                             |                                                             |
| ==,!=                                  | 所有容器都支持相等（不等）运算符                            |
| <,,>,>=                                | 关系运算符（无序关联容器不支持）                            |
| 获取迭代器                             |                                                             |
| c.begin (), c.end ()                   | 返回指向C的首元素和尾元素之后位置的迭代器                   |
| c.cbegin (), c.cend ()                 | 返回 const iterator                                         |

<330~|

续表

| 反向容器的额外成员（不支持forward_list） |                                           |
| ---------------------------------------- | ----------------------------------------- |
| reverse」terator                         | 按逆序寻址元素的迭代器                    |
| const_reverse_iterator                   | 不能修改元素的逆序迭代器                  |
| c.rbegin (), c.rend ()                   | 返回指向C的尾元素和首元素之前位置的迭代器 |
| c.crbegin ()，c.crend ()                 | 返回 const reverse iterator               |

###### 9.2节练习

练习9.2:定义一个list对象，其元素类型是int的deque»

###### so 9.2.1迭代器

与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供 相同操作的迭代器对这个操作的实现方式都是相同的。例如，标准容器类型上的所有迭代 器都允许我们访问容器中的元素，而所有迭代器都是通过解引用运算符来实现这个操作 的。类似的，标准库容器的所有迭代器都定义了递增运算符，从当前元素移动到下一个元素。

表3.6 （第96页）列出了容器迭代器支持的所有操作，其中有一个例外不符合公共接 口特点一forward_list迭代器不支持递减运算符（一）。表3.7 （第99页）列出了迭 代器支持的算术运算，这些运算只能应用于string、vector、deque和array的迭代 器。我们不能将它们用于其他任何容器类型的迭代器。

迭代器范围

迭代器范围的概念是标准库的基础。

一个迭代器范围（iterator range）由一对迭代器表示，两个迭代器分别指向同一个容 器中的元素或者是尾元素之后的位置（one past the last element）„这两个迭代器通常被称 为begin和end,或者是first和last （可能有些误导），它们标记了容器中元素的一 个范围。

虽然第二个迭代器常常被称为last，但这种叫法有些误导，因为第二个迭代器从来 都不会指向范围中的最后一个元素，而是指向尾元素之后的位置。迭代器范围中的元素包含 first所表示的元素以及从first开始直至last （但不包含last）之间的所有元素。

这种元素范围被称为左闭合区间（left-inclusive interval）,其标准数学描述为

[begin, end）

表示范围自begin开始，于end之前结束。迭代器begin和end必须指向相同的容器。 end可以与begin指向相同的位置，但不能指向begin之前的位置。

对构成范隅的迭代器的要求

如果满足如下条件，两个迭代器begin和end构成一个迭代器范：

•它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置，且 •我们可以通过反复递增begin来到达end。换句话说，end不在begin之前。

/j\编译器不会强制这些要求确保程序符合这些约定是程序员的责任

WARNWG

使用左闭合范围蕴含的编程假定

标准库使用左闭合范围是因为这种范围有三种方便的性质。假定begin和end构成<33T] 一个合法的迭代器范围，则

•如果begin与end相等，则范围为空

•如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的 第一个元素

•我们可以对begin递增若干次，使得begin==end

这些性质意味着我们可以像下面的代码一样用一个循环来处理一个元素范围，而这是 安全的：

while (begin != end) {

★begin = val; //正确：范围非空，因此begin指向一^元素 ++begin;    //移动迭代器，获取下一个元素

}

给定构成一个合法范围的迭代器begin和end，若begin=end，则范围为空。在此情 况下，我们应该退出循环。如果范围不为空，begin指向此非空范围的一个元素。因此，

在while循环体中，可以安全地解引用begin，因为begin必然指向一个元素。最后，

由于每次循环对begin递增一次，我们确定循环最终会结朿。

###### 9.2.1节练习

练习9.3:构成迭代器范围的迭代器有何限制？

练习9.4:编写函数，接受一对指向vector<int>的迭代器和-个int值。在两个迭 代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。

练习9.5:重写上一题的函数，返回一个迭代器指向找到的元素。注意，程序必须处理 未找到给定值的情况。

练习9.6:下面程序有何错误？你应该如何修改它？ list<int> lstl;

list<int>::iterator iterl = lstl.begin(), iter2 = lstl.end();

while (iterl < iter2) /★ ... */

###### 9.2.2容器类型成员

每个容器都定义了多个类型，如表9.2所示(第295页)。我们已经使用过其中三种： size_type (参见 3.2.2 节，第 79 页)、iterator 和 const_iterator (参见 3.4.1 节，

第97页)。

除了已经使用过的迭代器类型，大多数容器还提供反向迭代器。简单地说，反向迭代<333] 器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。

例如，对一个反向迭代器执行++操作，会得到上一个元素。我们将在I0.4.3节(第363页)

介绍更多关于反向迭代器的内容。

剩下的就是类型别名了，通过类型别名，我们可以在不了解容器中元素类型的情况下 使用它。如果需要元素类型，可以使用容器的value_type。如果需要元素类型的一个引 用，可以使用reference或const_reference。这些元素相关的类型别名在泛型编程 中非常有用，我们将在16章中介绍6关内容。

为了使用这些类型，我们必须显式使用其类名：

// iter是通过list<string>定义的一^迭代器类型 list<string>::iterator iter;

// count 是通过 vectorcint〉定义的一个 difference_type 类型 vector<int>::difference_type count;

这些声明语句使用了作用域运算符（参见1.2节，第7页）来说明我们希望使用 list<string〉类的 iterator 成员及 vector<int〉类定义的 dif ference_type。

###### 9.2.2节练习

练习9.7:为了索引int的vector中的元素，应该使用什么类型？

练习9.8:为了读取string的list中的元素，应该使用什么类型？如果写入list, 又该使用什么类型？

勉 9.2.3 begin 和 end 成员

begin和end操作（参见3.4.1节，第95页）生成指向容器中第一个元素和尾元素 之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器 范围。

如表9.2 （第295页）所示，begin和end有多个版本：带r的版本返回反向迭代器 （我们将在10.4.3节（第363 K）中介绍相关内容）；以c开头的版本则返回const迭代 器：

list<string> auto itl = a auto it2 = a auto it3 = a auto it4 = a



a = {"Milton", "Shakespeare", "Austen"};

begin ();    // list<string>::iterator

rbegin (); // list<string>::reverse—iterator cbegin(); // list<string>::const_iterator crbegin();// list<string>::const_reverse_iterator

不以c开头的函数都是被重载过的。也就是说，实际上有两个名为begin的成员。一个 是const成员（参见7.1.2节，第231页），返回容器的const_iterator类型。另一 个是非常量成员，返回容器的iterator类型。rbegin, end和rend的情况类似。当 我们对一个非常量对象调用这些成员时，得到的是返回iterator的版本。只有在对一

I 334>个const对象调用这些函数时，才会得到-个const版本。与const指针和引用类似, 可以将一个普通的iterator转换为对应的const_iterator.但反之不行。

以c开头的版本是C++新标准引入的，用以支持auto （参见2.5.2节，第61页）与 [V] begin和end函数结合使用。过去，没有其他选择，只能显式声明希望使用哪种类型的

迭代器：

//显式指定类型

list<string>::iterator it5

a.begin();



list<string>::const_iterator it6 = a.begin（）;

//是iterator还是const_iterator依赖于a的类型

auto it7 = a.begin （） ; // 仅当 a 是 const 时，it7 是 const_iterator auto it8 = a. cbegin （） ; // it8 是 const_iterator

当auto与begin或end结合使用时，获得的迭代器类型依赖于容器类型，与我们 想要如何使用迭代器毫不相千。但以c开头的版本还是可以获得const_iterator的， 而不管容器的类型是什么。

•praetees    当不需要写访问时，应使用cbegin和cend。

9.2.3节练习    -

练习9.9: begin和cbegin两个函数有什么不同？

练习9.10:下面4个对象分别是什么类型？

vector<int> vl; const vector<int> v2;

auto itl = vl.begin(), it2 = v2.begin(); auto it3 = vl.cbegin(), it4 = v2.cbegin();

9.2.4容器定义和初始化

每个容器类型都定义了一个默认构造函数（参见7.1.4节，第236页）。除array之 外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大 小和元素初始值的参数。

| 表9.3:容器定义和初始化                                |                                                              |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| C c;                                                  | 默认构造函数。如果C是一个array,则c中元素按默认方式初始化； 否则c为空 |
| C cl(c2)C cl=c2                                       | cl初始化为c2的拷贝。cl和c2必须是相同类型（即，它们必须是 相同的容器类型，且保存的是相同的元素类型；对于array类型，两 者还必须具有相同大小） |
| C c{a,b,c... }C c={a,br c... }                        | c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与C的 元素类型相容。对于array类型，列表中元素数目必须等于或小于 array的大小，任何遗漏的元素都进行值初始化（参见3.3.1节，第 88页） |
| C c (b, e)                                            | C初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类 型必须与C的元素类型相容（array不适用） |
| 只有顺序容器（不包括array）的构造函数才能接受大小参数 |                                                              |
| C seq(n)                                              | seq包含n个元素，这些元素进行了值初始化；此构造函数是 explicit 的（参见 7.5.4 节，第 265 页）。（string 不适用） |
| C seq(n,t)                                            | seq包含n个初始化为值t的元素                                  |

将一个容器初始化为另一个容器的拷贝

将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者

(array除外)拷贝由一个迭代器对指定的元素范围。

为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不 过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器 和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换(参见4.11节，第141页) 为要初始化的容器的元素类型即可。

E235>    //每个容器有三个元素，用给定的初始化器进行初始化

list<string> authors = {"Milton", "Shakespeare", "Austen"}; vector<const char*> articles = {"a", "an", "the"};

list<string> list2 (authors) ;    // 正确：类型匹配

deque<string> authList (authors) ; // 错误：容器类型不匹配 vector<string> words (articles) ;    // 错误：容器类型必须匹配

//正确：可以将const char*元素转换为string

forward_list<string> words(articles.begin(), articles.end());

![img](C++  Primer 5-85.jpg)



当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型 都必须相同

接受两个迭代器参数的构造函数用这两个迭代器表示我们想要拷贝的一个元素范围。 与以往一样，两个迭代器分别标记想要拷贝的第一个元素和尾元素之后的位置。新容器的 大小与范围中元素的数目相同。新容器中的每个元素都用范围中对应元素的值进行初始 化。

由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序 列。例如，假定迭代器it表示authors中的一个元素，我们可以编写如下代码

//拷贝元素，直到(但不包括)it指向的元素 deque<string> authList(authors.begin(), it);

列表初始化

[^7)    在新标准中，我们可以对一个容器进行列表初始化(参见3.3.1节，第88页)

//每个容器有三个元素，用给定的初始化器进行初始化

list<string> authors = {"Milton", "Shakespeare", "Austen"}; vector<const char*〉articles = {'’a", "an", "the"};

当这样做时，我们就显式地指定了容器中每个元素的值。对于除array之外的容器类型, 初始化列表还隐含地指定了容器的大小：容器将包含与初始值一样多的元素。

与顺序容器大小相关的构造函数

除了与关联容器相同的构造函数外，顺序容器(array除外)还提供另一个构造函数, 它接受一个容器大小和一个(可选的)元素初始值。如果我们不提供元素初始值，则标准 库会创建一个值初始化器(参见3.3.1节，第88页)：

vector<int> ivec(10, -1); list<string> svec (10, "hi!*1); forward_list<int> ivec(10); deque<string> svec(10);



// 10个int元素，每个都初始化为-1 // 10个strings;每个都初始化为"hi // 10个元素，每个都初始化为0 // 10个元素，每个都是空string



如果元素类型是内置类型或者是具有默认构造函数（参见9.2节，第294页）的类类 型，可以只为构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，除了大 小参数外，还必须指定一个显式的元素初始值。

![img](C++  Primer 5-86.jpg)



标准库array具有固定大小

与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时， 除了指定元素类型，还要指定容器大小：

array<intz 42>    //类型为：保存42个int的数组

array<string, 10〉    //类型为：保存10个string的数组

为了使用array类型，我们必须同时指定元素类型和大小:

array<int, 10>::size_type i; array<int>::size_type j;



//数组类型包括元素类型和大小 //错误：array<int〉不是一个类型

由于大小是array类型的一部分，array不支持普通的容器构造函数。这些构造函数都 会确定容器的大小，要么隐式地，要么显式地。而允许用户向一个array构造函数传递 大小参数，最好情况下也是多余的，而且容易出错。

array大小固定的特性也影响了它所定义的构造函数的行为。与其他容器不同，一个 默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始<337： 化（参见2.2.1节，第40页），就像一个内置数组（参见3.5.1节，第102页）中的元素那 样。如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小。

如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩 余元素都会进行值初始化（参见3.3.1节，第88页）。在这两种情况下，如果元素类型是 一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行：

array<int, 10> ial;    // 10 个默认初始化的 int

array<int, 10〉ia2 = {0,1,2, 3, 4,5, 6, 7, 8, 9}; // 列表初始化 array<int, 10> ia3 = {42};    // ia3[0]为 42，剩余元素为 0

值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作（参见3.5.1 节，第102页），但array并无此限制：

int digs[10] = { 0,1,2,3,4,5,6,7,8,9};

int cpy[10] = digs;    II错误：内置数组不支持拷贝或賊值

array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9}; array<int, 10〉copy = digits; //正确：只要数组类型匹配即合法

与其他容器一样,array也要求初始值的类型必须与要创建的容器类型相同。此外,array 还要求元素类型和大小也都一样，因为大小是array类型的一部分。

###### 9.2.4节练习

练习9.11:对6种创建和初始化vector对象的方法，每一种都给出一个实例。解释每 个vector包含什么值。

练习9.12:对于接受一个容器创建其拷贝的构造函数，和接受两个迭代器创建拷贝的构 造函数，解释它们的不同。

练习 9.13:如何从一个 list<int〉初始化一个 vector<double〉？从一个 vector<int> 又该如何创建？编写代码验证你的答案。

#### 9.2.5赋值和swap

表9.4中列出的与赋值相关的运算符可用于所有容器。赋值运算符将其左边容器中的 全部元素替换为右边容器中元素的拷贝：

cl = c2;    //将cl的内容替换为c2中元素的拷贝

cl = {a,b, c}; II賦值后，cl大小为3

第一个赋值运算后，左边容器将与右边容器相等。如果两个容器原来大小不同，赋值运算 后两者的大小都与右边容器的原大小相同。第二个赋值运算后，cl的size变为3,即花 括号列表中值的数目。

ri38>    与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具

有相同的类型：

array<int, 10〉 al = {0,1,2,3,4,5,6,7,8,9}; array<int, 10> a2 = {0}; // 所有元素值均为 0 al = a2;    //替换al中的元素

a2 = {0}; //错误：不能将一个花括号列表賦予数组

由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持assign, 也不允许用花括号包围的值列表进行赋值。

表9.4:容器赋值运算

cl=c2



c= {a, b, c . . . }

swap(cl,c2) cl.swap (c2)



将cl中的元素替换为c2 ;元素的拷贝。cl和c2必须具有相同的

类型

将cl中元素替换为初始化列表中元素的拷贝（array不适用）

交换cl和c2中的元素。cl和c2必须具有相同的类型。swap通常 比从c2向cl拷贝元素快得多

assign操作不适用于关联容器和array

seq.assign （b,e）    将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代

器b和e不能指向seq中的元素

seq.assign （il）    将seq中的元素替换为初始化列表il中的元素

seq.assign (n, t)



将seq中的元素替换为n个值为t的元素



WARNING



賦值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而 swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效 （容器类塑为array和string的情况除外）。

使用assign （仅顺序容器）

赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元 素拷贝到左边运算对象中。顺序容器（array除外）还定义了一个名为assign的成员， 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用 参数所指定的元素（的拷贝）替换左边容器中的所有元素。例如，我们可以用assgin实 现将一个vector中的一段char *值赋予一个list中的string：

list<string> names;

vectorCconst char*> oldstyle;

names = oldstyle; //错误：容器类型不匹配

//正确：可以将const char★转换为string

names.assign(oldstyle.cbegin(), oldstyle.cend());

这段代码中对assign的调用将names中的元素替换为迭代器指定的范围中的元素的拷<339] 贝。assign的参数决定了容器中将有多少个元素以及它们的值都是什么。

WARNING



由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的 容器。

assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定 值的元素替换容器中原有的元素：

// 等价于 slistl. clear ();

// 后跟 slistl. insert (slistl.begin () , 10, "Hiya ! n); list<string> slistl (1) ;    // 1 个元素，为空 string

slistl .assign (10, "Hiya!");    // 10 个元素，每个都是 “Hiya!”

使用swap

swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会 交换：

vector<string> svecl (10) ; // 10 个元素的 vector vector<string> svec2 (24) ; // 24 个元素的 vector swap(svecl, svec2);

调用swap后，svecl将包含24个string元素，svec2将包含10个string。除array 外，交换两个容器内容的操作保证会很快——元素本身并未交换，swap只是交换了两个 容器的内部数据结构。

![img](C++  Primer 5-89.jpg)



除array外，swap不对任何元素进行拷贝、删除■或插入操作，因此可以保证 在常数时间内完成d

元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在 swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap 之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svecl [3] 的string，那么在swap之后它指向svec2 [3]的元素。与其他容器不同，对一个string 调用swap会导致迭代器、引用和指针失效。

与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array 所需的时间与array中元素的数目成正比。

因此，对于array,在swap操作之后，指针、引用和迭代器所绑定的元素保持不变， 但元素值已经与另一个array中对应元素的值进行了交换。

在新标准库中，容器既提供成员函数版本的 swap,也提供非成员版本的swap。而 早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常 重要的。统一使用非成员版本的swap是一个好习惯。

###### EM＞ j 9.2.5节练习

练习9.14:编写程序，将一个list中的char *指针（指向C风格字符串）元素赋值 给一个 vector 中的 string。

###### 50 9.2.6容器大小操作

除了一个例外，每个容器类型都有三个与大小相关的操作。成员函数size（参见3.2.2 节，第78页）返回容器中元素的数目；empty当size为0时返回布尔值true，否则 返回false； max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。 forward_list支持max_size和empty,但不支持size，原因我们将在下一节解释。

###### 9.2.7关系运算符

每个容器类型都支持相等运算符（==和!=）;除了无序关联容器外的所有容器都支持 关系运算符（＞、＞=、＜、＜=），关系运算符左右两边的运算对象必须是相同类型的容器， 且必须保存相同类型的元素。即，我们只能将一个另一个vector＜int＞ 进行比较，而不能将一个 vector＜int＞与一个 list＜int＞3）＜,一个 vector＜double＞J4 行比较。

比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关 系运算（参见3.2.2节，第79页）类似：

•如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则 两个容器不等。

•如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则 较小容器小于较大容器。

•如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不 相等的元素的比较结果。

下面的例子展示了这些关系运算符是如何工作的：

vector<int> vector<int> vector<int> vector<int> vl < v2 // vl < v3 // vl == v4 // vl == v2 //



vl = { 1, v2 = { 1, v3 = { 1, v4 = { 1,

true； vl和v2在元素[2]处不同：vl [2]小于等于v2 [2] false;所有元素都相等，但v3中元素数目更少 true；每个元素都相等，且vl和v4大小相同 false; v2元素数目比vl少

SE＞容器的关系运算符使用元素的关系运算符完成比较

![img](C++  Primer 5-90.jpg)



只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符 来比较两个容器、

容器的相等运算符实际上是使用元素的=运算符实现比较的，而其他关系运算符是使 用元素的＜运算符。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使 用相应的关系运算。例如，我们在第7章中定义的Sales_data类型并未定义=和＜运算。 因此，就不能比较两个保存Sales data元素的容器：

vector<Sales_data> storeA, storeB;

if (storeA < storeB) // 错误：Sales_data 没有〈运算符

练习9.15:编写程序，判定两个vector<int〉是否相等。

练习9.16：重写上一题的程序，比较一个1131:<:1111:>中的元素和一个vector<int〉 中的元素。

练习9.17:假定cl和c2是两个容器，下面的比较操作有何限制(如果有的话)？ if (cl < c2)

##### 9.3顺序容器操作

顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到 了元素如何存储、访问、添加以及删除。上一节介绍了所有容器都支持的操作(罗列于表

9.2 (第295页))。本章剩余部分将介绍顺序容器所特有的操作。

###### 9.3.1向顺序容器添加元素    S

除array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删 除元素来改变容器大小。表9.5列出了向顺序容器(非array)添加元素的操作。

表9.5:向顺序容器添加元素的操作

这些操作会改变容器的大小；array不支持这些操作,

forward_list有自己专有版本的insert和emplace;参见9.3.4节(第312页)， forward_list 不支持 push_back 和 emplace_back,? vector 和 string 不支持 push_front 和 emplace_f rontc-

c.push_back(t)    在c的尾部创建一个值为t或由fl/识创建的元素。返回void

c.emplace_back (args)

c.push_front (t) c.emplace_f ront (args) c.insert (p, t) c.emplace (p, args)



c.insert (p, n, t)

c.insert (p, b, e)



在c的头部创建一个值为t或由flAgs创建的元素。返回void

在迭代器p指向的元素之前创建一个值为t或由flzx*创建的元 素。返回指向新添加的元素的迭代器

在迭代器p指向的元素之前插入n个值为t的元素。返回指向 新添加的第一个元素的迭代器；若n为0,则返回p 将迭代器b和e指定的范围内的元素插入到迭代器p指向的元 素之前。b和e不能指向c中的元素。返回指向新添加的第一 个元素的迭代器：若范围为空，则返回p

c.insert (p, il)    il是一个花括号包围的元素值列表。将这些给定值插入到迭代

器p指向的元素之前。返回指向新添加的第一个元素的迭代器; 若列表为空，则返回p

A

WARNING



向一个vector、string或deque插入元素会使所有指向容器的迭代器、 引用和指针失效3

当我们使用这残操作时，必须记得不同容器使用不同的策略来分配兀素空间，而这些 策略直接影响性能。在一个vector或string的尾部之外的任何位置，或是一个deque 的首尾之外的任何位置添加元素，都需要移动元素。而且，向一个vector或string添

E^D>加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新 的内存，并将元素从旧的空间移动到新的空间中。

使用 push_back

在3.3.2节(第90页)中，我们看到push_back将一个元素追加到一个vector的 尾部。除array和forward_list之外，每个顺序容器(包括string类型)都支持 push_backo

例如，下面的循环每次读取一个string到word中，然后追加到容器尾部：

//从标准输入读取数据，将每个单词放到容器末尾

string word;

while (cin >> word)

container,push_back(word);

对push_back的调用在container尾部创建了一个新的元素，将container的size 增大了 1。该元素的值为word的一个拷贝。container的类型可以是list、vector 或 deque。

由于string是一个字符容器，我们也可以用push_back在string末尾添加字符:

void pluralize(size_t cnt, string Sword)

{

if (cnt > 1)

word.push_back (* sr ) ; // 等价于 word += 1 sr

}

父键概念：矜器元素坫拷贝

当我们用一个对象來初始化容器时，或将一•个对象插入到容器中时，实际上放入到 容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参 数(参见3.2.2节，第79页)一样，容器屮的元素与提供值的对象之间没有任何关联。 随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。

使用 push_front

除了 push_back, list、forward_list 和 deque 容器还支持名为 push_front 的类似操作。£操作将元素插入到容器头胃b，

list<int> ilist;

//将元素添加到ilist开头

for (size_t ix = 0; ix != 4; ++ix)

ilist.push_front(ix);

此循环将元素0、1、2、3添加到ilist头部。每个元素都插入到list的新的开始位 1 343 >置(new beginning)。即，当我们插入1时，它会被放置在0之前，2被放置在1之前，

依此类推。因此，在循环中以这种方式将元素添加到容器中，最终会形成逆序。在循环执 行完毕后，ilist保存序列3、2、1、0。

注意，deque像vector 一样提供了随机访问元素的能力，但它提供了 vector所

不支持的push_fronto deque保证在容器首尾进行插入和删除元素的操作都只花费常 数时间。与vector—样，在deque首尾之外的位置插入元素会很耗时。

在容器中的特定位置添加元素

push_back和push_f ront操作提供了一种方便地在顺序容器尾部或头部插入单个 元素的方insert成i提供了更一般的添加功能，它允许我们在容器中任意位置插入 0 个或多个元素。vector、deque、list 和 string 都支持 insert 成员。forward_list 提供了特殊版本的insert成员，我们将在9.3.4节(第312页)中介绍。

每个insert函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么 位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭＜M] 代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用 的功能，所以insert函数将元素插入到迭代器所指定的位置之前。例如，下面的语句

slist. insert (iter, ’’Hello!"); // 将’’Hello !"添加到 iter 之前的位置

将一个值为"Hello"的string插入到iter指向的元素之前的位置。

虽然某些容器不支持push_front操作，但它们对于insert操作并无类似的限制 (插入开始位置)。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持 push_front：

vector<string> svec;

list<string> slist;

// 等价于调用 slist .push_front ("Hello !"); slist.insert(slist.begin(), "Hello!");

// vector不支持push_front,但我们可以插入到begin ()之前 //警告：插入到vector末尾之外的任何位置都可能很慢 svec.insert(svec.begin() , "Hello!");

WARNING



将元素插入到vector、deque和string中的任何位置都是合法的，然而， 这样做可能很耗时。

插入范围内元素

除了第一个迭代器参数之外，insert函数还可以接受更多的参数，这与容器构造函 数类似。其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置 之前，这些元素都按给定值初始化：

svec.insert(svec.end(), 10, "Anna”)；

这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为string "Anna，，。

接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定 位置之前：

vector<string> v = {"quasi", "simba", "frollo", "scarH}; //将v的最后两个元素添加到slist的开始位置 slist.insert (slist.begin(), v.end() - 2, v.end()); slist.insert(slist.end(), {"these", "words", "will",

"go", "at", "the", "end"});

//运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器 slist.insert(slist.begin(), slist.begin(), slist.end());

如果我们传递给insert —对迭代器，它们不能指向添加元素的目标容器。

在新标准下，接受元素个数或范围的insert版本返回指向第一个新加入元素的迭代 器。(在旧版本的标准库中，这些操作返回void。)如果范围为空，不插入任何元素，insert 操作会将第一个参数返回。

1 345〉使用insert的返回值

通过使用insert的返回值，可以在容器中一个特定位置反复插入元素:

list<string> 1st;

auto iter = 1st.begin();

while (cin » word)

iter = 1st • insert (iter, word) ; // 等价于调用 push_front

![img](C++  Primer 5-91.jpg)



理解这个循环是如何工作的非常重要，特别是理解这个循环为什么等价于调用 push_front尤为重要。

在循环之前，我们将iter初始化为lst.begin()。第一次调用insert会将我们刚刚 读入的string插入到iter所指向的元素之前的位置。insert返回的迭代器恰好指向 这个新元素。我们将此迭代器赋予iter并重复循环，读取下一个单词。只要继续有单词 读入，每步while循环就会将一个新元素插入到iter之前，并将iter改变为新加入 元素的位置。此元素为(新的)首元素。因此，每步循环将一个新元素插入到list首元 素之前的位置。

使用emplace操作

rc++1    新标准引入了三个新成员-emplace_front、emplace 和 emplace一back，这

些操作构造而不是拷贝元素。这些操作分别对应push_f ront、insert和push_back， 允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。

当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象 被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型 的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。例如， 假定c保存Sales_data (参见7.1.4节，第237页)元素：

//在c的末尾构造一个Sales_data对象

//使用三个参数的Sales_data构造函数 c.emplace_back("978-0590353403", 25, 15.99);

//错误：没有接受三个参数的push_back版本 c.push_back("978-0590353403", 25， 15.99);

//正确：创建一临时的Sales_data对象传递给push_back c.push_back(Sales_data("978-0590353403", 25, 15.99));

其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对 象。在调用ernplace_back时，会在容器管理的内存空间中直接创建对象。而调用 push_back则会创建一个局部临时对象，并将其压入容器中。

emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配: I 346〉    // iter指向c中一个元素，其中保存了 Sales data元素

c. emplace_back () ; // 使用 Sales_data 的默认构造函数

c.emplace(iter, n999-999999999°); // 使用 Sales_data(string)

//使用Sales_data的接受一个ISBN、一个count和一个price的构造函数 c.emplace_front ("978-0590353403**, 25, 15.99);

emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元 素类型的构造函数相匹配.，

###### 9.3.1节练习

练习9.18:编写程序，从标准输入读取string序列，存入一个deque中。编写一个 循环，用迭代器打印deque中的元素。

练习9.19:重写上题的程序，用list替代deque。列出程序要做出哪些改变。

练习9.20:编写程序，从一个list<int4#贝元素到两个deque中。值为偶数的所 有元素都拷贝到一个deque中，而奇数值元素都拷贝到另一个deque中。

练习9.21：如果我们将第308页中使用insert返回值将元素添加到list中的循环 程序改写为将元素插入到vector中，分析循环将如何工作。

练习9.22：假定iv是一个int的vector,下面的程序存在什么错误？你将如何修改？

vector<int>::iterator iter = iv.begin(),

mid = iv.begin() + iv.size()/2;

while (iter != mid)

if (*iter == some_val)

iv.insert (iter, 2 * some val);

###### 9.3.2访问元素    50

表9.6列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访 问操作的结果是未定义的。

包括array在内的每个顺序容器都有一个front成员函数，而除forward_list 之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引 用：

//在解引用一个迭代器或调用front或back之前检查是否有元素 if (!c.empty())    {

// val和val2是c中第一个元素值的拷贝 auto val = *c.begin(), val2 = c.front();

// val3和val4是c中最后一个元素值的拷贝 auto last = c.end();

auto val3 = * (--last) ; // 不能递减 forward_list 迭代器 auto val4 = c.back () ;    // forv/ard_list 不支持

}

此程序用两种不同方式来获取c中的首元素和尾元素的引用。直接的方法是调用front <34f1 和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通 过递减然后解引用end返回的迭代器來获得尾元素的引用。

这个程序有两点值得注意：迭代器end指向的是容器尾元素之后的(不存在的)元

素。为了获取尾元素，必须首先递减此迭代器。另一个重要之处是，在调用front和back （或解引用begin和end返回的迭代器）之前，要确保c非空。如果容器为空，if中操 作的行为将是未定义的。

表9.6:在顺序容器中访问元素的操作

at和下标操作只适用于string、vector、deque和array。 back 不适用于 forward_listo



c.back () c.f ront () c[n]



c.at (n)



返回c中尾元素的引用。若c为空，函数行为未定义 返回c中首元素的引用。若c为空，函数行为未定义 返回c中下标为n的元素的引用，n是一个无符号整数。若n>=C.siZe （>， 则函数行为未定义

返回下标为n的元素的引用。如果下标越界，则抛出一out_Of_range 异常



A

WARNING



对一个空容器调用front和back,就像使用一个越界的下标一样，是一 种严重的程序设计错谋。



访问成员函数返回的是引用

在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。 如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则 返回值是普通引用，我们可以用来改变元素的值：

if （!c.empty（）） {

| c.front () | =42;      | //将42赋予c中的第一个元素                      |
| ---------- | --------- | ---------------------------------------------- |
| auto &v =  | c.back(); | //获得指向最后一个元素的引用                   |
| v = 1024;  |           | //改变c中的元素                                |
| auto v2 =  | c.back(); | / / v2不是一个引用，它是c .back （）的一个拷贝 |
| v2 = 0;    |           | //未改变c中的元素                              |

与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来 改变元素的值，必须记得将变量定义为引用类型。

下标操作和安全的随机访问

提供快速随机访问的容器（string、vector、deque和array）也都提供下标运 C^L>算符（参见3.3.3节，第91页）。就像我们已经看到的那样，下标运算符接受一个下标参 数，返冋容器中该位置的元素的引用。给定下标必须“在范围内”（即，大于等于0,且小 于容器的大小）。保证下标有效是程序员的责任，下标运算符并不检查下标是否在合法范

围内。使用越界的下标是一种严重的程序设计错误，而且编译器并不检查这种错误。

如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算 符，但如果下标越界，at会抛出一个out_of_range异常（参见5.6节，第173页）：

vector<string> svec;    // 空 vector

cout « svec [0] ;    //运行时错误：svec中没有元素！

cout « svec.at （0） ;    // 抛出一个 out of range 异常

###### 9.3.2节练习

练习9.23：在本节第一个程序（第309页）中，若c.size（）为1，则val、val2, val3 和val4的值会是什么？

练习9.24:编写程序，分别使用at、下标运算符、front和begin提取一个vector 中的第一个元素。在一个空vector上测试你的程序。

###### 9.3.3删除元素    啦

与添加元素的多种方式类似，（非array）容器也有多种删除元素的方式。表9.7列 出了这些成员函数。

表9.7:顺序容器的删除操作

这些操作会改变容器的大小，所以不适用于array， forward_list有特殊版本的erase,参见9.3.4节（第312瓦）。 forward_list 不支持 pop_back; vector 和 string 不支持 pop_f ronto



c.pop_back () c.pop_f ront () c.erase (p)



c.erase (b, e



z.clear ()



A

WARNING



删除c屮尾元素。若c为空,则函数行为未定义。函数返回void 删除C中首元素。若C为空，则函数行为未定义。函数返回void 删除迭代器P所指定的元素，返回一个指向被删元素之后元素的迭代 器，若P指向尾元素，则返回尾后（off-the-end）迭代器。若p是尾后 迭代器，则函数行为未定义

删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删 元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾 后迭代器

删除c中的所有元素。返回void

删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用和指针 失效。指向vector或string中删除点之后位置的迭代器、引用和指针 都会失效。



WARNING



删除元素的成贾函数并不检查其参数。在删除元素之前，程序员必须确保它 （们）是存在的。

pop_front 和 pop_back 成员函数

pop_front和pop_back成员函数分别删除首元素和尾元素。与vector和string 不支持push_front 一样，这些类型也不支持pop_front。类似的，forward_list 不支持pop_back。与元素访问成员函数类似，不能一个空容器执行弹出操作。_

这些操作返回void。如果你需要弹出的元素的值，就必须在执行弹出操作之前保存 它：

while (!ilist.empty())    {

process (ilist.front () ) ; // 对 ilist 的首元素进行一些处理 ilist .pop_f ront () ;    //完成处理后删除首元素

从容器内部删除一个元素

成员函数erase从容器中指定位置删除元素。我们可以删除由一个迭代器指定的单 个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的erase都返回 指向删除的(最后一个)元素之后位置的迭代器。即，若j是i之后的元素，那么erase (i) 将返回指向j的迭代器。

例如，下面的循环删除一个list中的所有奇数元素：

list<int> 1st = {0,1,2,3,4,5,6,7,8,9}; auto it = 1st.begin(); while (it != 1st.end())

if (*it % 2)    //若元素为奇数

it = 1st. erase (it) ;    // 删除此元素

else

++it;

每个循环步中，首先检查当前元素是否是奇数。如果是，就删除该元素，并将it设置为 我们所删除的元素之后的元素。如果*it为偶数，我们将it递增，从而在下一步循环检 查下一个元素。

删除多个元素

接受一对迭代器的erase版本允许我们删除一个范围内的元素：

//删除两个迭代器表示的范围内的元素

//返回指向最后一个被删元素之后位置的迭代器

eleml = slist.erase (eleml, elem2) ; // 调用后，eleml == elem2

迭代器eleml指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之 后的位置。

S>    为了删除一个容器中的所有元素，我们既可以调用clear,也可以用begin和end

获得的迭代器作为参数调用erase：

slist.clear () ; //删除容器中所有元素

slist. erase (slist .begin () , slist .end 0 ) ; // 等价调用

###### 9.3.3节练习

练习9.25：对于第312页中删除一个范围内的元素的程序，如果eleml与elem2相等 会发生什么？如果elem2是尾后迭代器，或者eleml和elem2皆为尾后迭代器，又 会发生什么？

练习9.26：使用下面代码定义的ia,将ia拷贝到一个vector和一个list中。使 用单迭代器版本的erase从list中删除奇数元素，从vector中删除偶数元素。 int ia[l = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 89 };

###### 9.3.4 特殊的 forward Jist 操作

为了理解forward Jist为什么有特殊版本的添加和删除操作，考虑当我们从一个单向 链表中删除一个元素时7会发生什么。如图9.1所示，删除一个元素会改变序列中的链接。 在此情况下，删除e/ew3会改变e/e/w2，原来指向e/ew3，但删除e/ezw3后，指向 了 elem4o

eleni\



| elemo |      | eletn:i |      | elertu |
| ----- | ---- | ------- | ---- | ------ |
|       |      |         |      |        |



删除e/w3会改变elem2的值

elcnii



eleni2 -elcm^



图9.1: forward_list的特殊操作

当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生改变。为 了添加或删除一个元素，我们需要访问其前驱，以便改变前驱的链接。但是， forward_list是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前 驱。出于这个原因，在一个forward_list中添加或删除元素的操作是通过改变给定元 素之后的元素来完成的。这样，我们£是可以访问到被添加或删除操作所影响的元素。

由于这些操作与其他容器上的操作的实现方式不同，forward_list并未定义 insert、emplace 和 erase，而是定义了名为 insert_after、emplace_after 和 erase_after的操作（参见表9.8）。例如，在我们的例子中，为了删除elem3,应该用 指向e/ezw2的迭代器调用erase_after。为了支持这些操作，forward_list也定义了 <351 | before_begin，它返回一个首前（off-the-beginning）迭代器。这个迭代器允许我们在链 表首元之前并不存在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除 元素）。

表9.8:在forwardjist中插入或删除元素的操作



lst.before_begin () lst.cbefore_begin ()

lst.insert_after (p, t) lst.insert_af ter (p, n, t) lst.insert_after (p, b, e) lst.insert_after (p, il)

emplace_after (p,args)

lst.erase_after (p) lst.erase_after (b, e)



返回指向链表首元素之前不存在的元素的迭代器。此迭代器不 能解弓I用。cbef ore_begin （）返回一个 const_iterator 在迭代器P之后的位置插入元素。t是一个对象，n是数量， b和e是表示范围的一对迭代器（b和e不能指向1st内）， il是一个花括号列表。返回一个指向最后一个插入元素的迭 代器。如果范围为空，则返回p。若p为尾后迭代器，则函数 行为未定义

使用a邸在P指定的位置之后创建一个元素。返回一个指向 这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义 删除P指向的位置之后的元素，或删除从b之后直到（但不 包含）e之间的元素。返回一个指向被删元素之后元素的迭代 器，若不存在这样的元素，则返回尾后迭代器。如果p指向 1st的尾元素或者是一个尾后迭代器，则函数行为未定义

当在forward_list中添加或删除元素时，我们必须关注两个迭代器--个指向

我们要处理的元素，另一个指向其前驱。例如，可以改写第312页中从list中删除奇数 元素的循环程序，将其改为从forward_list中删除元素：

forward_list<int> fist = {0,1,2,3,4,5,6,7,8, auto prev = f1st,before_begin(); // auto curr = fist.begin(); // while (curr != flst.endf)) { //



9};

表示fist的“首前元素” 表示fist中的第一个元素 仍有元素要处理



if (*curr % 2)



//若元素为奇数



curr = fist. erase_after (prev) ;    // 删除它并移动 curr



else {



prev



curr;



//移动迭代器curr,指向下一个元素，prev指向



++curr;    // curr之前的元素

}

此例中，curr表示我们要处理的元素，prev表示curr的前驱。调用begin来初始化 curr,这样第一步循环就会检查第一个元素是否是奇数。我们用before_begin来初始 化prev,它返回指向curr之前不存在的元素的迭代器。

当找到奇数元素后，我们将prev传递给erase_after。此调用将prev之后的元 I 352 >素删除，BP，删除curr指向的元素。然后我们将curr重置为erase_after的返回值， 使得curr指向序列中下一个元素，prev保持不变，仍指向(新)curr之前的元素。如

果curr指向的元素不是奇数，在else中我们将两个迭代器都向前移动。

###### 9.3.4节练习

练习9.27:编写程序，查找并删除的奇数元素。

练习9.28：编写函数，接受一个forward_list<string〉和两个string共三个参 数。函数应在链表中查找第一个string,并将第二个string插入到紧接着第一个 string之后的位置。若第一个string未在链表中，则将第二个string插入到链表 末尾。

9.3.5改变容器大小

如表9.9所描述，我们可以用resize来増大或缩小容器，与往常一样，array不支 持resize。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小 小于新大小，会将新元素添加到容器后部：

list<int> ilist (10, 42); // ilist.resize (15); // ilist.resize (25, -1); // ilist.resize (5); //



10个int：每个的值都是42

将5个值为0的元素添加到ilist的末尾 将10个值为-1的元素添加到ilist的末尾 从ilist末尾删除20个元素

resize操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。如果调用者 未提供此参数，新元素进行值初始化(参见3.3.1节，第88页)。如果容器保存的是类类 型元素，且resize向容器添加新元素，则我们必须提供初始值，或者元素类型必须提供 一个默认构造函数。

表9.9:顺序容器大小操作

resize不适用于array

c.resize (n)    调整c的大小为n个元素。gn<c.size()，则多出的元素被丢

弃。若必须添加新元素，对新元素进行值初始化

c. resize (n, t)    调整c的大小为n个元素。任何新添加的元素都初始化为值t

WARNING



如果resize缩小容器，则指向被删除元素的迭代器、引用和指针都会失 效；对vector、string或deque进行resize可能导致迭代器、指针 和引用失效。

###### 9.3.5节练习

练习9.29:假定vec包含25个元素，那么vec.resize（lOO）会做什么？如果接下来 调用vec.resize （10）会做什么？

练习9.30:接受单个参数的resize版本对元素类型有什么限制（如果有的话）？

###### 9.3.6容器操作可能使迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或 迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引 用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题（参 见2.3.2节，第49页）

在向容器添加元素后：

•如果容器是vector或string,且存储空间被重新分配，则指向容器的迭代器、 指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代 器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。

•对于deque,插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失 效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不 会失效。

•对于list和forward_list,指向容器的迭代器（包括尾后迭代器和首前迭代 器）、指针和引用仍有效。

当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这 应该不会令人惊讶。毕竟，这些元素都已经被销毁了。当我们删除一个元素后：

•对于list和forward_list,指向容器其他位置的迭代器（包括尾后迭代器和 首前迭代器）、引用和指针仍有效。

•对于deque,如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他 元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代 器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不 会受影响。

•对于vector和string,指向被刪元素之前元素的迭代器、引用和指针仍有效。 注意：当我们删除元素时，尾后迭代器总是会失效。

WARNING



使用失效的迭代器、指针或引用是严重的运行时错误„



进议：锌理迭代器

当你使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效 的程序片段是一个好的方法。

由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此.必须 保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对vector 、string 和deque尤为重要。

编写改变容器的循环程序

添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指 针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中 调用的是insert或erase,那么更新迭代器很容易。这些操作都返回迭代器，我们可 以用来更新：

//傻瓜循环，删除偶数元素，复制每个奇数元素 vector<int> vi = {0,1,2,3,4,5,6,7,8,91;

auto iter = vi .begin (); //调用begin而不是cbegin，因为我们要改变vi while (iter != vi.end()) {

if (*iter % 2)    {

iter = vi . insert (iter, *iter) ; // 复制当前元素

iter += 2; //向前移动迭代器，跳过当前元素以及插入到它之前的元素

} else

iter = vi.erase (iter) ;    // 删除偶数元素

//不应向前移动迭代器，iter指向我们删除的元素之后的元素

}

此程序删除vector中的偶数值元素，并复制每个奇数值元素。我们在调用insert和 erase后都更新迭代器，因为两者都会使迭代器失效。

在调用erase后，不必递增迭代器，因为erase返回的迭代器已经指向序列中下一 个元素。调用insert后，需要递增迭代器两次。记住，insert在给定位置之前插入新 元素，然后返回指向新插入元素的迭代器。因此，在调用insert后，iter指向新插入 元素，位于我们正在处理的元素之前。我们将迭代器递增两次，恰好越过了新添加的元素 和正在处理的元素，指向下一个未处理的元素。

(§不要保存end返回的迭代器

当我们添加/删除vector或string的元素后，或在deque中首元素之外任何位置 添加/删除元素后，原来end返回的迭代器总是会失效。因此，添加或删除元素的循环程 序必须反复调用end,而不能在循环之前保存end返回的迭代器，一直当作容器末尾使 用。通常C++标准库的实现中end()操作都很快，部分就是因为这个原因。

例如，考虑这样一个循环，它处理容器中的每个元素，在其后添加一个新元素。我们 [355>希望循环能跳过新添加的元素，只处理原有元素。在每步循环之后，我们将定位迭代器，

使其指向下一个原有元素。如果我们试图“优化”这个循环，在循环之前保存end ()返回 的迭代器，一直用作容器末尾，就会导致一场灾难：

//灾难：此循环的行为是未定义的 auto begin = v.begin(),

end = v.end() ; //保存尾迭代器的值是一个坏主意 while (begin != end) {

//做一些处理

//插入新值，对begin重新赋值，否则的话它就会失效 ++begin; //向前移动begin，因为我们想在此元素之后插入元素 begin = v. insert (begin, 42); // 插入新值

++begin; //向前移动begin跳过我们刚刚加入的元素

}

此代码的行为是未定义的。在很多标准库实现上，此代码会导致无限循环。问题在于我们 将end操作返回的迭代器保存在一个名为end的局部变量中。在循环体中，我们向容器

中添加了一个元素，这个操作使保存在end中的迭代器失效了。这个迭代器不再指向v 中任何元素，或是v中尾元素之后的位置。

![img](C++  Primer 5-95.jpg)



如果在一个猸环中插入/删除deque、string或vector中的元素，不要缓 存end返回的迭代器。

必须在每次插入操作后重新调用end(),而不能在循环开始前保存它返回的迭代器:

//更安全的方法：在每个循环步添加/删除元素后都重新计算end while (begin != v.end())    {

//做一些处理

++begin; //向前移动begin,因为我们想在此元素之后插入元素 begin = v. insert (begin, 42); // 插入新值 ++begin; //向前移动begin，跳过我们刚刚加入的元素

###### 9.3.6节练习

练习9.31:第316页中删除偶数值元素井复制奇数值元素的程序不能用于list或 forward_listo为什么？修改程序，使之也能用于这些类型。

练习9.32:在第316页的程序中，向下面语句这样调用insert是否合法？如果不合法， 为什么？

iter = vi.insert(iter, *iter++);

练习9.33：在本节最后一个例子中，如果不将insert的结果赋予begin,将会发生 什么？编写程序，去掉此赋值语句，验证你的答案。

练习9.34:假定vi是一个保存int的容器，其中有偶数值也有奇数值，分析下面循环 的行为，然后编写程序验证你的分析是否正确。

iter = vi.begin(); while (iter != vi.end())

if (*iter % 2)

iter = vi.insert(iter, *iter);

++iter;

##### 9.4 vector对象是如何增长的    啦

为了支持快速随机访问，vector将元素连续存储——每个元素紧挨着前一个元素存 储。通常情况下，我们不必关心一个标准库类型是如何实现的，而只需关心它如何使用。

然而，对于vector和string,其部分实现渗透到了接口中。

假定容器中兀素是连续存储的，且容器的大小是可变的，考虑向vector或string 中添加元素会发生什么：如果没有空间容纳新元素，容器不可能简单地将它添加到内存中 其他位置——因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元 素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。如果我们 每添加一个新元素，vector就执行一次这样的内存分配和释放操作，性能会慢到不可 接受。

为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配次数的策略。当＜356^

不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大 的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素=这样，就不需要每 次添加新元素都重新分配容器的内存空间了。

这种分配策略比每次添加新元素时都重新分配容器内存空间的策略要高效得多。其实 际性能也表现得足够好——虽然vector在每次重新分配内存空间时都要移动所有元素， 但使用此策略后，其扩张操作通常比list和deque还要快。

管理容量的成员函数

如表9.10所示，vector和string类型提供了一些成员函数，允许我们与它的实现 中内存分配部分互动。capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳 多少个元素。reserve操作允许我们通知容器它应该准备保存多少个元素。

| 表9.10:容器大小管理操作                                      |
| ------------------------------------------------------------ |
| shrink to fit 只适用于 vector、string 和 deque。 capacity 和 reserve 只适用于 vector 和 string。c.shrink_to_f it ()    请将 capacity ()减少为与 size ()相同大小c.capacity ()    不重新分配内存空间的话，c可以保存多少元素c.reserve (n)    分配至少能容纳n个元素的内存空间 |

![img](C++  Primer 5-96.jpg)



reserve并不改变容器中元素的数量，它仅影响vector频先分配多大的内 存空间

[J57>    只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。

如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间(可能更大)。

如果需求大小小于或等于当前容量，reserve什么也不做。特别是，当需求大小小 于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，capacity将会 大于或等于传递给reserve的参数。

这样，调用reserve永远也不会减少容器占用的内存空间。类似的，resize成员 函数(参见9.3.5节，第314页)只改变容器中元素的数目，而不是容器的容量。我们同 样不能使用resize来减少容器预留的内存空间。

fc++l    在新标准库中，我们可以调用shrink_to_fit来要求deque、vector或string

退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实 现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。

capacity 和 size

理解capacity和size的区别非常重要。容器的size是指它已经保存的元素的数 目；而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。

下面的代码展示了 size和capacity之间的相互作用： vector<int> ivec;

// size庭该为0; capacity的值依赖于具体实现 cout « ’’ ivec: size: " « ivec. size ()

<< "capacity: "    « ivec.capacity() « endl;

//向ivec添加24个元素

for (vector<int>::size_type ix = 0; ix != 24; ++ix) ivec.push_back(ix);

// size应该为24; capacity应该大于等于24，具体值依赖于标准库实现 cout « "ivec: size: *' « ivec.size ()

<< "capacity: "    << ivec. capacity () « endl

当在我们的系统上运行时，这段程序得到如下输出：

ivec: size: 0 capacity: 0 ivec: size: 24 capacity: 32

我们知道一个空vector的size为0，显然在我们的标准库实现中一个空vector的< 358 I capacity也为0。当向vector中添加元素时，我们知道size与添加的元素数目相等。

而capacity至少与size 一样大，具体会分配多少额外空间则视标准库具体实现而定。

在我们的标准库实现中，每次添加1个元素，共添加24个元素，会使capacity变为32。

可以想象ivec的当前状态如下图所示：

| 0 1  | 2 ... | 23   | 保留空间 |
| ---- | ----- | ---- | -------- |
|      |       |      |          |

ivec.size() ivec.capacity()

现在可以预分配一些额外空间：

ivec. reserve (50) ; //将capacity至少设定为50，可能会更大 // size应该为24; capacity应该大于等于50,具体值依赖于标准库实现 cout « "ivec: size: ’• « ivec.size ()

<< •’ capacity: " « ivec. capacity () « endl;

程序的输出表明reserve严格按照我们需求的大小分配了新的空间：

ivec: size: 24 capacity: 50

接下来可以用光这些预留空间：

//添加元素用光多余容量

while (ivec.size()    != ivec.capacity())

ivec.push_back(0);

// capacity应该未改变，size和capacity不相等 cout « "ivec: size: " << ivec.size(}

« " capacity: "    << ivec.capacity() « endl;

程序输出表明此时我们确实用光了预留空间，size和capacity相等：

ivec: size: 50 capacity: 50

由于我们只使用了预留空间，因此没有必要为vector分配新的空间。实际上，只要没有 操作需求超出vector的容量，vector就不能重新分配内存空间。

如果我们现在再添加一个新元素，vector就不得不重新分配空间：

ivec .push_back (42) ; // 再添加一个元素

// size应该为51; capacity应该大于等于51，具体值依赖于标准库实现 cout « "ivec: size: " « ivec.size()

« " capacity: ’’    « ivec • capacity () « endl;

这段程序的输出为

I 359〉



I 360〉



ivec: size: 51 capacity: 100

这表明vector的实现采用的策略似乎是在每次需要分配新内存空间时将当前容量翻倍。

可以调用shrink_to_f it来要求vector将超出当前大小的多余内存退回给系统:

ivec. shrink_to_f it () ; // 要求归还内存 // size应该未改变；capacity的值依赖于具体实现 cout « "ivec: size: " << ivec.size()

« " capacity: "    « ivec.capacity() « endl;

调用Shririk_tO_fit只是一个请求，标准库并不保证退还内存。

![img](C++  Primer 5-97.jpg)



每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则 是：只有当迫不得已时才可以分配新的内存空间。

只有在执行insert操作时size与capacity相等，或者调用resize或reserve 时给定的大小超过当前capacity，vector才可能重新分配内存空间。会分配多少超过 给定容量的额外空间，取决于具体实现。

虽然不同的实现可以采用不同的分配策略，但所有实现都应遵循一个原则：确保用 push_back向vector添加元素的操作有高效率。从技术角度说，就是通过在一个初始 为空的vector上调用w次push_back来创建一个《个元素的vector,所花费的时间 不能超过《的常数倍。

###### 9.4节练习

练习9.35：解释一个vector的capacity和size有何区别。

练习9.36： 一个容器的capacity可能小于它的size吗？

练习9.37：为什么list或array没有capacity成员函数？

练习9.38:编写程序，探究在你的标准库实现中，vector是如何增长的。

练习9.39:解释下面程序片段做了什么：

vector<string> svec; svec.reserve(1024); string word; while (cin » word)

svec.push_back(word); svec.resize(svec.size()+svec.size()/2);

练习9.40：如果上一题中的程序读入了 256个词，在resize之后容器的capacity 可能是多少？如果读入了 512个、1000个或1048个词呢？

##### 9.5额外的string操作

除了顺序容器共同的操作之外，string类型还提供了一些额外的操作。这些操作中 的大部分要么是提供string类和C风格字符数组之间的相互转换,要么是增加了允许我 们用下标代替迭代器的版本，

标准库string类型定义了大量函数。幸运的是，这些函数使用了重复的模式。由于 函数过多，本节初次阅读可能令人心烦，因此读者可能希望快速浏览本节。当你了解 string支持哪些类型的操作后，就可以在需要使用一个特定操作时回过头来仔细阅读。

###### 9.5.1构造string的其他方法

除了我们在3.2.1节（第76页）己经介绍过的构造函数，以及与其他顺序容器相同的 构造函数（参见表9.3,第299页）外，string类型还支持另外三个构造函数，如表9.11 所示。

| 表9.11:构造string的其他方法 |                                                              |
| --------------------------- | ------------------------------------------------------------ |
| n、len2和pos2都是无符号值   |                                                              |
| string s (cp, n)            | s是cp指向的数组中前n个字符的拷贝。此数组至少应该 包含n个字符 |
| string s (s2,pos2)          | s是string s2从下标pos2幵始的字符的拷贝。若 pos2>s2.size（）,构造函数的行为未定义 |
| string s (s2, pos2, len2)   | s是string s2从下标pos2开始len2个字符的拷贝。若pos2>s2.size （）,构造函数的行为未定义。不管len2 的值是多少，构造函数至多拷贝s2.SiZe（）-pOS2个字符 |

这些构造函数接受一个string或一个const char*参数，还接受（可选的）指定 拷贝多少个字符的参数。当我们传递给它们的是一个string时，还可以给定一个下标来 指出从哪里开始拷贝：

const char *cp = "Hello World!!!"; // 以空字符结束的数组 char noNull[] = {'H', 'i'};    // 不是以空字符结束

string

string

string

string

string

string

string

string



sl（cp）; //拷贝cp中的字符直到遇到空字符；si

"Hello World!



s2(noNull,2); s3(noNull); s4 (cp + 6, 5); s5(si, 6, 5); s6(si, 6); s7(si,6,20); s8 (s 1, 16);



//从noNull拷贝两个字符；s2 == "Hi"

//未定义：noNull不是以空字符结束 //从cp [ 6]开始拷贝5个字符；s4 == "World"

//从si [6]开始拷贝5个字符；s5 == "World"

//从si [6]开始拷贝，直至si末尾；s6 == "World! //正确，只拷贝到si末尾；s7 == "World!!!"

//抛出一个out of range异常

通常当我们从一个const char*创建string时，指针指向的数组必须以空字符结 尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以 空字符结尾。如果我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组 大小，则构造函数的行为是未定义的。

当从一个string拷贝字符时，我们可以提供一个可选的开始位置和一个计数值。开 始位置必须小于或等于给定的string的大小。如果位置大于size,则构造函数抛出一 个out_Of_range异常（参见5.6节，第173页）。如果我们传递了一个计数值，则从给 定位置开始拷贝这么多个字符。不管我们要求拷贝多少个字符，标准库最多拷贝到string 结尾，不会更多。

substr操作

substr操作（参见表9.12）返回一个string,它是原始string的一部分或全部 的拷贝。可以传递给substr 一个可选的开始位置和计数值：

| string | s(*  | ’hello world"); |       |      |                          |        |
| ------ | ---- | --------------- | ----- | ---- | ------------------------ | ------ |
| string | s2   | =s.substr(0,    | 5);   | //   | s2                       | =hello |
| string | s3   | =s.substr(6);   |       | //   | s3                       | =world |
| string | s4   | =s.substr(6,    | 11)； | //   | s3                       | =world |
| string | s5   | =s . substr(12) | ；    | //   | 抛出一个out of range异常 |        |

如果开始位置超过了 string的大小，则substr函数抛出一个out_of_range异常(参 见5.6节，第173页)。如果开始位置加上计数值大于string的大小，则substr会调 整计数值，只拷贝到string的末尾。

表9.12:子字符串操作

s.substr (pos, n)    返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默

认值为0。n的默认值为s.size ()-pos，即拷贝从pos开始的所有字符

###### 9.5.1节练习

练习9.41:编写程序，从一个vector<char>初始化一个string。

练习9.42：假定你希望每次读取一个字符存入一个string中，而且知道最少需要读取 100个字符，应该如何提高程序的性能？

#### 驗9.5.2改变string的其他方法

string类型支持顺序容器的赋值运算符以及assign、insert和erase操作(参 见9.2.5节，第302页；9.3.1节，第306页；9.3.3节，第311页)。除此之外，它还定义 了额外的insert和erase版本。

除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。 下标指出了开始删除的位置，或是insert到给定值之前的位置：

s . insert (s . size () , 5,    // 在 s 末尾插入 5 个感叹号

s . erase (s . size () - 5, 5);    // 从 s 删除最后 5 个字符

r362> 标准库string类型还提供了接受C风格字符数组的insert和assign版本。例 如，我们可以将以空字符结尾的字符数组insert到或assign给一个string：

const char *cp = "Stately, plump Buck";

s.assign(cpz 7);    // s == "Stately"

s.insert(s.size (), cp + 7);    // s == "Stately, plump Buck"

此处我们首先通过调用assign替换s的内容。我们赋予s的是从cp指向的地址开始的 7个字符。要求赋值的字符数必须小于或等于cp指向的数组中的字符数(不包括结尾的 空字符)。

接下来在s上调用insert,我们的意图是将字符插入到s [size ()]处(不存在的) 元素之前的位置。在此例中，我们将cp开始的7个字符(至多到结尾空字符之前)拷贝 到s中。

我们也可以指定将来自其他string或子字符串的字符插入到当前string中或赋予 当前 string：

string s = "some string", s2 = "some other string"; s.insert (0, s2) ; //在s中位置0之前插入s2的拷贝

II在s[0]之前插入s2中s2[0]开始的s2.size()个字符 s.insert (0, s2, 0, s2.size ());

append 和 replace 函数

string类定义了两个额外的成员函数：append和replace，这两个函数可以改变 string的内容。表9.13描述了这两个函数的功能。append操作是在string末尾进行 插入操作的一种简写形式：

string s ("C++ Primer"), s2 = s; // 将 s 和 s2 初始化为"C++ Primer*' s.insert(s.size(), " 4th Ed."); // s == "C++ Primer 4th Ed." s2. append (" 4 th Ed.");    // 等价方法：将"4 th Ed.”追加到 s2; s == s2

replace操作是调用erase和insert的一种简写形式：

//将"4thn替换为"5thn的等价方法

s.erase (11, 3);    // s == "C++ Primer Ed."

s.insert(11, "5th");    // s == "C++ Primer 5th Ed."

//从位置11开始，删除3个字符并插入"5th"

s2 . replace (11, 3, ”5th");    // 等价方法：s == s2

此例中调用replace时，插入的文本恰好与删除的文本一样长。这不是必须的，可以插 入一个更长或更短的string：

s. replace (11, 3, '•Fifth1') ;    // s == "C++ Primer Fifth Ed."

在此调用中，删除了 3个字符，但在其位置插入了 5个新字符。

| 表9.13:修改string的操作                                      |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| s.insert (pos.args)                                          | 在pos之前插入tnys指定的字符。pos可以是一个下标或一个迭 代器。接受下标的版本返回一个指向s的引用；接受迭代器的版 本返回指向第一个插入字符的迭代器 |
| s.erase (pos’len)                                            | 删除从位置POS开始的len个字符。如果len被省略，则删除 从pos开始直至s末尾的所有字符。返回一个指向s的引用 |
| s.assign (args)                                              | 将s中的字符替换为指定的字符。返回一个指向s的引用             |
| s.append (args)                                              | 将叩追加到S。返回一个指向S的引用                             |
| s.replace (range,args)    删除s中范围range内的字符，替换为args指定的字符。range或者是一个下标和一个长度，或者是一对指向s的迭代器。返回 ——个指向s的引用 |                                                              |
| 可以是下列形式之一；append和assign可以使用所有形式。         |                                                              |
| str不能与s相同，                                             | 迭代器b和e不能指向s。                                        |
| str                                                          | 字符串str                                                    |
| str, pos, len                                                | str中从pos开始最多len个字                                    |
| cp，len                                                      | 从cp指向的字符数组的前(最多)len个字符                        |
| cp                                                           | cp指向的以空字符结尾的字符数组                               |
| n,c                                                          | n个字符c                                                     |
| b,e                                                          | 迭代器b和e指定的范围内的字符                                 |
| 初始化列表                                                   | 花括号包围的，以逗号分隔的字符列表                           |

<363 |

续表

replace和insert所允许的形式依赖于和po.v是如何指定的

| replace          | replace    | insert      | insert | args可以是  |
| ---------------- | ---------- | ----------- | ------ | ----------- |
| (pos, len,az玄5) | (b,efargs) | (pos fargs) | (iter, |             |
| 是               | 是         | 是          | 否     | str         |
| 是               | 否         | 是          | 否     | str,pos,len |
| 是               | 是         | 是          | 否     | cp,len      |
| 是               | 是         | 否          | 否     | cp          |
| 是               | 是         | 是          | 是     | n,c         |
| 否               | 是         | 否          | 是     | b2，e2      |
| 否               | 是         | 否          | 是     | 初始化列表  |

改变string的多种重载函数

表9.13列出的append、assign、insert和replace函数有多个重载版本。根据 我们如何指定要添加的字符和string中被替换的部分，这些函数的参数有不同版本。幸 运的是，这些函数有共同的接口。

assign和append函数无须指定要替换string中哪个部分：assign总是智换 string中的所有内容，append总是将新字符追加到string末尾。

replace函数提供了两种指定删除元素范围的方式。可以通过一个位置和一个长度 ES＞来指定范围，也可以通过一个迭代器范围来指定。insert函数允许我们用两种方式指定 插入点：用一个下标或一个迭代器。在两种情况下，新元素都会插入到给定下标（或迭代

器）之前的位置。

可以用好几种方式来指定要添加到string中的字符。新字符可以来自于另一个 string,来自于一个字符指针（指向的字符数组），来自于一个花括号包围的字符列表， 或者是一个字符和一个计数值。当字符来自于一个string或一个字符指针时，我们可以 传递一个额外的参数来控制是拷贝部分还是全部字符。

并不是每个函数都支持所有形式的参数。例如，insert就不支持下标和初始化列表 参数。类似的，如果我们希望用迭代器指定插入点，就不能用字符指针指定新字符的来源。

###### 9.5.2节练习

练习9.43:编写—函数，接受三个string参数s、oldVal和newVal。使用迭代 器及insert和erase函数将s中所有oldVal替换为newVal。测试你的程序，用 它替换通用的简写形式，如，将”tho"替换为"though”，将"thru"替换为"through”。

练习9.44:重写上一题的函数，这次使用一个下标和replace，

练习9.45：编写一个函数，接受一个表示名字的string参数和两个分别表示前缀（如 "Mr."或"Ms."）和后缀（如"Jr.”或"III"）的字符串。使用迭代器及insert和append 函数将前缀和后缀添加到给定的名字中，将生成的新string返回。

题的函数,这次使用位置和长度来管理string,并只使用insert。

###### 9.5.3 string搜索操作

string类提供了 6个不同的搜索函数，每个函数都有4个重载版本。表9.14描述了 这些搜索成员函数及其参数。每个搜索操作都返回一个string::size_type值，表示匹 配发生位置的下标。如果搜索失败，则返回一个名为stringr.npos的static成员(参 见7.6节，第268页)。标准库将npos定义为一个const string::size_type类型，

并初始化为值-1。由于npos是一个unsigned类型，此初始值意味着npos等于任何 string最大的可能大小(参见2.1.2节，第32页)。

string搜索函数返回string:: size_type值，该类型是一个unsigned Z!\类型。因此，用一个int或其他带符号类型来保存这些函数的返回值不是一 WARNING个好主意(参见2.1.2节，第33页)0

find函数完成最简单的搜索。它查找参数指定的字符串，若找到，则返回第一个匹 配位置的下标，否则返回npos:

string name("AnnaBelle");

auto posl = name.find("Anna"); // posl == 0    < 365 |

这段程序返回0,即子字符串”Arma"在"AnnaBelle"中第一次出现的下标。

搜索(以及其他string操作)是大小写敏感的。当在string中查找子字符串时，

要注意大小写：

string lowercase("annabelle");

posl = lowercase.find("Anna"); // posl == npos

这段代码会将posl置为npos,因为Anna与anna不匹配。

一个更复杂一些的问题是查找与给定字符串中任何一个字符匹配的位置。例如，下面 代码定位name中的第一个数字：

string numbers("0123456789"), name(”r2d2");

//返回1,即，name中第一个数字的下标 auto pos = name.find_first_of(numbers);

如果是要搜索第一个不在参数中的字符，我们应该调用find_first_not_of □例如，为 了搜索一个string中第一个非数字字符，可以这样做：

string dept("03714p3");

//返回5——字符fp'的下标

auto pos = dept.find_first_not_of(numbers);

表9.14: string搜索操作



搜索操作返回指定字符出现的下标，

s.f ind (args)

s.rf ind (args)

s.f ind_f irst_of (args)

s.find_last_of (args)

s.find_f irst_not_of (args)

s.f ind last not of (args)



如果未找到则返回npos。

査找s中args第一次出现的位置 查找s中最后一次出现的位置 在s中查找args中任何一个字符第一次出现的位置。 在s中查找中任何一个字符最后一次出现的位置 在s中查找第一个不在args中的字符 在s中查找最后一个不在azgx中的字符

续表

args必须是以下形式之一

c, pos    从s中位置pos开始查找字符c。pos默认为0

s2,pos    从s中位置pos开始查找字符串s2。pos默认为0

cp, pos    从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。

pos默认为0

cp,posz n    从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n

无默认值

指定在哪里开始搜索

我们可以传递给find操作一个可选的开始位置。这个可选的参数指出从哪个位置开 始进行搜索。默认情况下，此位置被置为0。一种常见的程序设计模式是用这个可选参数 在字符串中循环地搜索子字符串出现的所有位置：

I 366〉    string: :size_type pos = 0;

//每步循环查找name中下一个数

while ( (pos = name.find_first_of(numbers, pos))

!= string::npos) {

cout << Hfound number at index: " « pos

« " element is " « name[pos] << endl;

++pos; //移动到下一个字符

}

while的循环条件将pos重置为从pos开始遇到的第一个数字的下标。只要 find_first_of返回一个合法下标，我们就打印当前结果并递增pos。

如果我们忽略了递增pos，循环就永远也不会终止。为了搞清楚原因，考虑如果不做 递增运算会发生什么。在第二步循环中，我们从pos指向的字符开始搜索。这个字符是 一个数字，因此find_first_of会(重复地)返回pos!

逆向搜索

到现在为止，我们已经用过的find操作都是由左至右搜索。标准库还提供了类似的， 但由右至左搜索的操作。rfind成员函数搜索最后一个匹配，即子字符串最靠右的出现位 置：

string river ("Mississippi*');

auto first_pos = river. find ("is") ; // 返回 1

auto last_pos = river. rfind ("is"} ; // 返回 4

find返回下标1，表示第一个"is”的位置，而rfind返回下标4，表示最后一个"is"的 位置。

类似的，find_last函数的功能与find_first函数相似，只是它们返回最后一个 而不是第一个匹配：

•    find_last_of搜索与给定string中任何一个字符匹配的最后一个字符。

•    find_last_not_of搜索最后一个不出现在给定string中的字符。

每个操作都接受一个可选的第二参数，可用来指出从什么位置开始搜索。

###### 9.5.3节练习

练习9.47:编写程序，首先查找string "ab2c3d7R4E6"中的每个数字字符，然后查 找其中每个字母字符。编写两个版本的程序，第一个要使用find_first_of,第二个 要使用 find_first_not_of。

练习9.48：假定name和numbers的定义如325页所示，numbers.find (name)返冋 什么？

练习9.49:如果一个字母延伸到中线之上，如d或f，则称其有上出头部分(ascender)。 如果一个字母延伸到中线之下，如p或g，则称其有下出头部分(descender)。编写程 序，读入一个单词文件，输出最长的既不包含上出头部分，也不包含下出头部分的单词。

9.5.4 compare 函数    O

除了关系运算符外(参见3.2.2节，第79页)，标准库string类型还提供了一组 compare函数，这些函数与C标准库的strcmp函数(参见3.5.4节，第109页)很相似。

类似strcmp，根据s是等于、大于还是小于参数指定的字符串，s.compare返回0、正 数或负数。

如表9.15所示，compare有6个版本。根据我们是要比较两个string还是一个〈3Q7 1 string与一个字符数组，参数各有不同。在这两种情况下，都可以比较整个或一部分字 符串。

表9.15: s.compare的几种参数形式

s2    比较s和s2

posl, nl, S2    将s中从posl开始的nl个字符与s2进行比较

posl, nl, s2, pos2, n2    将s中从posl开始的nl个字符与s2中从pos2开始的

n2个字符进行比较

cp    比较s与cp指向的以空字符结尾的字符数组

posl, nl, cp    将s中从posl开始的nl个字符与cp指向的以空字符结尾

的字符数组进行比较

posl, nl, cp, n2    将s中从posl开始的nl个字符与指针cp指向的地址开始

的n2个字符进行比较

9.5.5数值转换    6

字符串中常常包含表示数值的字符。例如，我们用两个字符的string表示数值15 一字符'1'后跟字符'5，。一般情况，一个数的字符表示不同于其数值。数值15如果保 存为16位的short类型，则其二进制位模式为0000000000001111，而字符串"15。

存为两个Latin-1编码的char,二进制位模式为0011000100110101。第一个字节表示

字符'1',其八进制值为061,第二个字节表示，5,，其Latin-1编码为八进制值065。

新标准引入了多个函数，可以实现数值数据与标准库string之间的转换： int i = 42;

string s = to_string (i) ; //将整数i转换为字符表示形式 double d = stod(s);    //将字符串s转换为浮点数

r368＞此例中我们调用to_string将42转换为其对应的string表示，然后调用stod将此 string转换为浮点值。

要转换为数值的string中第一个非空白符必须是数值中可能出现的字符： string s2 = "pi = 3.14";

//梓换s中以数字开始的第一个子串，结果d = 3.14 d = stod （s2 . substr （s2 . f ind_f irst_of （*'+-. 0123456789n）））;

在这个stod调用中，我们调用了 find_first_of （参见9.5.3节，第325页）來获得s 中第一个可能是数值的一部分的字符的位置《我们将s中从此位置开始的子串传递给 stodo stod函数读取此参数，处理其中的字符，直至遇到不可能是数值的一部分的字符。 然后它就将找到的这个数值的字符串表示形式转换为对应的双精度浮点值。

string参数中第一个非空白符必须是符号（+或-）或数字。它可以以Ox或0X 开头來表示十六进制数。对那些将字符串转换为浮点值的函数，string参数也可以以小 数点（.）开头，并可以包含e或E来表示指数部分。对于那些将字符串转换为整型值的 函数，根裾基数不同，string参数可以包含字母字符，对应大于数字9的数。

如果string不能转换为一个数值，这些函数抛出一个invalid_argument 卜异常（参见5.6节，第173页），如果转换得到的数值无法用任何类型来表示， 、 贝抛出一个out_of_range异常o :

| 表9.16: string和数值之间的转换   |                                                              |
| -------------------------------- | ------------------------------------------------------------ |
| to_string(val)                   | 一组重载函数，返回数值val的string表示。val可以是任何算 术类型（参见2.1.1节，第30页）。对每个浮点类型和int或更大 的整型，都有相应版本的tO_string。与往常一样，小整型会被提 升（参见4.11.1节，第142页） |
| stoi (s, p, b)                   | 返回s的起始子串（表示整数内容）的数值，返回值类型分别是int、 |
| stol (s, p, b)                   | long、unsigned long、long long、unsigned long long。b        |
| stoul (s, p, b)                  | 表示转换所用的基数，默认值为10。p是siZe_t指针，用来保存      |
| stoll (s, p, b) stoull (s, p, b) | s中第一个非数值字符的下标，P默认为0,即，函数不保存下标       |
| stof (s, p)                      | 返回S的起始子串（表示浮点数内容）的数值，返回值类型分别是    |
| stod(s, p)                       | float、double或long double。参数p的作用与整数转换困数        |
| stold(s, p)                      | 中一样                                                       |

###### 9.5.5节练习

练习9.50：编写程序处理一个vectorcstring〉，其元素都表示整型值。计算vector 中所有元素之和。修改程序，使之计算表示浮点值的string之和。

练习9.51:设计一个类，它有三个unsigned成员，分别表示年、月和日。为其编写 构造函数，接受一个表示日期的string参数。你的构造函数应该能处理不同数据格式,

如 January 1, 1900、1/1/1990、Jan 丨 1900 等，

##### 9.6容器适配器

除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和 priority_queue。适配器(adaptor)是标准库中的一个通用概念。容器、迭代器和函数< 369 I 都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事 物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。

例如，stack适配器接受一个顺序容器(除array或forward_list外).并使其操作 起來像-•个stack—样。表9.17列出了所有容器适配器都支持的操作和类型。

| 表9.17:所有容器适配器都支持的操作和类型 |                                                              |
| --------------------------------------- | ------------------------------------------------------------ |
| size_type                               | 一种类型，足以保存当前类型的最大对象的大小                   |
| value_type                              | 元素类型                                                     |
| container_type                          | 实现适配器的底层容器类型                                     |
| A a;                                    | 创建一个名为a的空适配器                                      |
| A a (c);                                | 创建一个名为a的适配器，带有容器c的一个拷贝                   |
| 关系运算符                              | 每个适配器都支持所有关系运算符：==、！=、<、<=、>和>=这些运算符返回底层容器的比较结果 |
| a.empty ()                              | 若a包含任何元素，返回false,否则返回true                      |
| a.size ()                               | 返回a中的元素数目                                            |
| swap (a,b)                              | 交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必     |
| a.swap (b)                              | 须相同                                                       |

定义一个适配器

每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构 造函数拷贝该容器来初始化适配器。例如，假定deq是一个deque<int>，我们可以用 deq来初始化一个新的stack,如下所示：

stack<int> stk(deq); // 从 deq 拷贝元素到 stk

默认情况下，stack和queue是基于deque实现的，priority_queue是在vector 之上实现的。我们可以在创建一个适配器时将-个命名的顺序容器作为第二个类型参数， 来重载默认容器类型。

//在vector上实现的空栈

stack<string, vector<string>> str_stk;

// str_stk2在vector上实现，初始化时保存svec的拷贝 stack<string, vector<string» str_stk2(svec);

对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配器都要求容器具有添加 和删除元素的能力。因此，适配器不能构造在array之上。类似的，我们也不能用 forward_list来构造适配器，因为所有适配器都要求容器具有添加、删除以及访问尾 元素的能力。stack只要求push_back、pop_back和back操作，因此可以使用除array 和forward_list之外的任何容器类型来构造stack。queue适配器要求back、 push_back、front和push_front，因此它可以构造于list或deque之上，但不能 基于 vector 构造。priority_queue 除了 front、push_back 和 pop_back 操作之 外还要求随机访问能力，因此它可以构造p vector或deque之上，但不能基于list 构造。

栈适配器

stack类型定义在stack头文件中。表9.18列出了 stack所支持的操作。下面的 程序展示了如何使用stack：

stack<int> intStack; // 空栈 //填满栈

for (size_t ix = 0; ix != 10; ++ix)

intStack.push (ix) ;    // intStack 保存 0 到 9 十个数

while (! intStack. empty () ) {    // intStack 中有值就继续循环

int value = intStack.top();

//使用栈顶值的代码

intStack.pop () ; //弹出栈顶元素，继续循环

}

其中，声明语句

stack<int> intStack; // 空栈

定义了一个保存整型元素的栈intStack,初始时为空。for循环将10个元素添加到桟 中，这些元素被初始化为从0开始连续的整数。while循环遍历整个stack.，获取top 值，将其从栈中弹出，直至桟空。

| 表9.18:表9.17未列出的栈操作                                  |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 栈默认基于deque实现， s.pop ()s.push(item)s. emplace (urgs)s.top () | 也可以在list或vector之上实现，删除栈顶元素，担不返回该元素值创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者 由args构造返回栈顶元素，但不将元素弹出栈 |

每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用 适配器操作，而不能使用底层容器类型的操作。例如，

intStack.push (ix) ; // intStack 保存 0 到 9 十个数

此语句试图在intStack的底层deque对象上调用push_back。虽然stack是基于 deque实现的，但我们不能直接使用deque操作。不能在一个stack上调用push_back, 而必须使用stack自己的操作-push。

队列适配器

queue和priority_queue适配器定义在queue头文件中。表9.19列出了它们所 支持的操作。

表 9.19:表 9.17 未列出的 queue 和 priority_queue 操作

queue默认基于deque实现，priority_queue默认基于vector实现； queue也可以用list或vector实现，prior it y_queue也可以用deque实现o q.pop ()    返回queue的首元素或priority_queue的最高优先级的元素，

但不删除此元素

q.frontO    返回首元素或尾元素，但不删除此元素

q.back ()    只适用于 queue

续表

| q.top ()         | 返回最高优先级元素，但不删除该元素 只适用于 priority queue |
| ---------------- | ---------------------------------------------------------- |
| q.push (item)    | 在queue末尾或priority_queue中恰当的位置创建一个元素，      |
| q.emplace (args) | 其值为item，或者由crrgy构造                                |

标准库queue使用一种先进先出（first-in, first-out, FIFO）的存储和访问策略。进 入队列的对象被放置到队尾，而离开队列的对象则从队首删除。饭店按客人到达的顺序来 为他们安排座位，就是一个先进先出队列的例子。

priority_queue允许我们为队列中的元素建立优先级。新加入的元素会排在所有 优先级比它低的已有元素之前。饭店按照客人预定时间而不是到来时间的早晚来为他们安 排座位，就是一个优先队列的例子。默认情况下，标准库在元素类型上使用＜运算符来确 定相对优先级。我们将在11.2.2节（第378页）学习如何重载这个默认设置。

###### 9.6节练习

练习9.52:使用stack处理括号化的表达式。当你看到一个左括号，将其记录下来。 当你在一个左括号之后看到一个右括号，从stack中pop对象，直至遇到左括号，将 左括号也一起弹出栈。然后将一个值（括号内的运算结果）push到栈中，表示一个括 号化的（子）表达式已经处理完毕，被其运算结果所替代。

[~372> 小结_

标准库審器是模板类型,用來倮存给定类型的对象.在-•个顺序容器中,元素是按顺 序存放的，通过位置來访顺序容器有公共的标准接口：如果两个顺序容器都提供•个 特定的操作，那么这个操作在两个容器中具有相M的接口和含义。

所甸容器（除array外）都提供卨效的动态内存管理。我们町以向容器中添加元素， 而不必把心元素存储在哪里。容器负责管理自身的存储.vector和string都提供更细 致的內存管理控制，这是通过它们的reserve和capacity成员函数來实现的。

很人稈度L,容器只定义了极少的操作。每个容器都定义了构造函数、添加和删除元 素的操作、f角定容器大小的操作以及返围指向特定元素的迭代器的操作.其他-，有用的 操作.如排序或搜索，并不是由容器类甩定义的，而是由标准库算法实现的，我们将在第 10孕介绍这邱内容。

，我们使用添加和删除元素的容器操作时，必须注意这些操作吋能使指向容器中元紊 的迭代器、指针或引用失效=很多会使迭代器失效的操作，如insert和erase，都会 返M 个新的迭代器，來帮助程序员维护容器中的位置。如果循环稃汴中使用了改变容器 人小的操作，就要尤其小心其中迭代器、指针和引用的使用=

##### 术语农

适配器（adaptor） I小准叩类型、函数或 迭代器，它们接受•个类甩、函数或迭代 器.使策:行为像男外--个爨®、函数或迭 代器，。杯准阼提供了 :种顺序容器适 PjllSS： stack,queue >F（1 priority_queueo 毎个诂配器都在其底层顺序容器型之上 定义了 -个新的接口。



数组（array）固定人小的顺序容器。为了 定义-个array,除了元桌类型之外还必 颁给定人小.array中的元索町以周其位 置卜7+來WM。array支抒快速的随机访 I'nJ.

begin容器操作，返回•个指向容器首元 素的迭代器，如果容器为空，则返冋尾后 迭代器。足否返I«1 const迭代器依赖于容 器的类慮.。

cbegin容器操作，返冋_ •个指向容器首兀 裝的const_iterator.如果容雅为申， 则返M尾后迭代器，

cend容器操作，返问•个指叫容器尾元素 之（不存在的）的 const_iterator.



容器（container）保存-组给定类型对象 的类型。毎个标准即容器类型都是个模 板类®。为T定义•个容器.我们必须指 定保存仵容器屮的元素的类型。除了 array之外，标准库容器都是大小可变的.

deque顺序容器。deque中的元素可以通 f373>HRl 7标來访问.支持快速的随机访

deque 各 Z/rfll 都 ^vector 类似，唯•的 差别是，deque支持在容器头尾位置的快 速插入和刪除，而吐在两端插入或刪除元 素都不会导致車新分配窄间。

end容器操作，返回个指向容器尾元翥 之后（不存在的）元紊的迭代器。是否返 冋const迭代器依赖十容器的类型。

forwardJist顺序容器，表¥ —个单向链 表。forward_list中的元素只能顺H■:讲 问。从' '个给定元素开始，为了 w问另-个元索，我们只能遍历两者之间的所有元 素。forward_list上的迭代器不i持递 减运算（--）。forward_list i持任， 位置的快速插入（或删除）操作。~其他 容器不同，插入和删除发生在个给定的



迭代器之后的位置。因此，除了通常的尾 后迭代器之外，forWard_list还有一个 “首前”迭代器。在添加新元素后，原有的 指向forward_list的迭代器仍有效。在 刪除元素后，只有原来指向被删元素的迭 代器才会失效。

迭代器范围(iteratorrange)由一对迭代

器指定的元素范围。第一个迭代器表示序 列中第一个元素，第二个迭代器指向最后 一个元素之后的位置。如果范围为空，则 两个迭代器是相等的(反之亦然，如果两 个迭代器不等，则它们表示一个非空范 围)。如果范围非空，则必须保证，通过反 复递增第一个迭代器，可以到达第二个迭 代器。通过递增迭代器，序列中每个元素 都能被访问到。

左闭合区间(left-inclusive interval)值范

围，包含首元素，但不包含尾元素。通常 表示为［i, j),表示序列从i开始(包含) 直至j结束(不包含\

list顺序容器，表示一-个双向链表。list 中的元素只能顺序访问，从一个给定元素 开始，为了访问另一个元素，我们只能遍 历两者之间的所有元素，list上的迭代器 既支持递增运算(++),也支持递减运算 (―)。list支持任意位置的快速插入(或 删除)操作。当加入新元素后，迭代器仍 然有效。当删除元素后，只有原来指向被 删除元素的迭代器才会失效。



(不存在的)元素的迭代器。是 forward_list 的成员困数 bef ore_begin的返回值。与end ()迭代 器类似，~不能被解引用，

尾后迭代器(off-the-end iterator)表乐范

围中尾元素之后位置的迭代器。通常被称 为“末尾迭代器”(end iterator)»

priority_queue顺序容器适配器，生成一

个队列，插入其中的元素不放在末尾，而 是根据特定的优先级排列。默认情况下， 优先级用元素类型上的小于运算符确定。

queue顺序容器适配器，生成一个类型， 使我们能将新元素添加到末尾，从头部删 除元素，

顺序容器(sequentialcontainer)保存相

同类型对象有序集合的类型。顺序容器中 的元素通过位置来访问。

stack顺序容器适配器，生成一个类型， 使我们只能在其一端添加和删除元素。

vector顺序容器。vector中的元素可以 通过位置下标访问。支持快速的随机访问。 我们只能在vector末尾实现高效的元素 添加/删除。向vector添加元素可能导致 内存空间的重新分配，从而使所有指向 vector的迭代器失效■■在vector内部 添加(或删除)元素会使所有指問插入(删 除)点之后元素的迭代器失效。



首前迭代器(off-the-beginning iterator)

表示一个forward list开始位置之前
