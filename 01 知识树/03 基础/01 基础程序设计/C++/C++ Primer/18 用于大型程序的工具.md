

第18章

### 用于大型程序的工具



<jzE



内容

C++语言能解决的问题规模千变万化，有的小到一个程序员几小时就能完成，有的则 是含有几千几万行代码的庞大系统，需要几百个程序员协同工作好几年。本书之前介绍的 内容对各种规模的编程问题都适用。

除此之外，C++语言还包含其他一些特征，当我们编写比较复杂的、小组和个人难以 管理的系统时，这些特征最为有用。本章的主题即是向读者介紹这些特征，它们包括异常 处理、命名空间和多重继承。

E^?>    与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更

高。大规模应用程序的特殊要求包括：

•在独立开发的子系统之间协同处理错误的能力。

•使用各种库（可能包含独立开发的库）进行协同开发的能力。

•对比较复杂的应用概念建模的能力。

本章介绍的三种C++语言特性正好能满足上述要求，它们是：异常处理、命名空间和 多重继承。

##### 18.1异常处理

异常处理（exception handling）机制允许程序中独立开发的部分能够在运行时就出现 的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开 来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。 检测环节无须知道闷题处理模块的所有细节，反之亦然。

在5.6节（第173页）我们曾介绍过一些有关异常处理的基本概念和机理，本节将继 续扩展这些知识。对于程序员来说，要想有效地使用异常处理，必须首先了解当抛出异常 吋发生了什么，捕获异常时发生了什么，以及用来传递错误的对象的意义。

###### 18.1.1抛出异常

在C++语言中，我们通过抛出（throwing） —条表达式来引发（raised） —个异常。被 抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码（handler）将被用来处理 该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中， 根据抛出对象的类型和内容，程序的异常抛出部分将会告知异常处理部分到底发生了什么 错误。

当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权 从throw转移到与之匹配的catch模块。该catch可能是同一个函数中的局部catch， 也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一 处，这有两个重要的含义：

•沿着调用链的函数可能会提早退出。

• 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。

因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return 语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。

栈展开

当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的 catch子句。当throw出现在一个try语句块（try block）内时，检查与该try块关联 的catch子句。如果找到了匹配的catch,就使用该catch处理异常。如果这一步没找 到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的 catch子句。如果还是找不到匹配的catch,则退出当前的函数，在调用当前函数的外 层函数中继续寻找。

如果对抛出异常的函数的调用语句位于一个try语句块内，则检查与该try块关联

的catch子句。如果找到了匹配的catch,就使用该catch处理异常。否则，如果该 try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果仍然没 有找到匹配的catch,则退出当前这个主调函数，继续在调用了刚刚退出的这个函数的其 他函数中寻找，以此类推。

上述过程被称为栈展开(stack unwinding)过程。栈展开过程沿着嵌套函数的调用链 不断查找，直到找到了与异常匹配的catch子句为lh:或者也可能一直没找到匹配的 catch,则退出主函数后查找过程终止。

假设找到了一•个匹配的catch子句，则程序进入该子句并执行其中的代码。当执行 完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里 继续执行。

如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常 执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch 时，程序将调用标准库函数terminate,顾名思义，terminate负责终止程序的执行 过程。

![img](C++  Primer 5-179.jpg)



一个异常如果没有被捕获，则它将终止当前的程序



栈展开过程中对象被自动销毀

在桟展开过程中，位于调用链上的语句块可能会提前退出。通常情况下，程序在这些 块中创建了一些局部对象，我们已经知道，块退出后它的局部对象也将随之销毁，这条规 则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这 个块中创建的对象能被正确地销毁。如果某个局部对象的类型是类类型，则该对象的析构 函数将被自动调用。与往常一样，编译器在销毁内置类型的对象时不需要做任何事情，

如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始 化了，而另外一些成员在异常发生前也许还没有初始化，即使某个对象只构造了一部分， 我们也要确保已构造的成员能被正确地销毁。

类似的，异常也可能发生在数组或标准库容器的元素初始化过程中。与之前类似，如 果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确地销毁。

析构函数与异常

析构函数总是会被执行的，但是函数中负责释放资源的代码却可能被跳过，这一特点 对于我们如何组织程序结构有重要影响。如我们在12.1.4节(第415页)介绍过的，如果 -个块分配了资源，并且在负责释放这些资源的代码前面发生了异常，则释放资源的代码 将不会被执行。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我 们使用类来控制资源的分配.就能确保无论函数止常结朿还是遭遇异常，资源都能被正确

地释放。

析构函数在栈展开的过程中执行，这一事实影响着我们编写析构函数的方式。在栈展 开的过程中，已经引发了异常但是我们还没有处理它。如果异常抛出后没有被正确捕获， 则系统将调用terminate函数。因此，出于栈展开可能使用析构函数的考虑，析构函数 不应该抛出不能被它自身处理的异常。换句话说，如果析构函数需要执行某个可能抛出异 常的操作，则该操作应该被放置在一个try语句块当中，并ft在析构函数内部得到处理。

在实际的编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。所 有标准库类型都能确保它们的析构函数不会引发异常。

在栈展开的过程中，运行类类型的局部对象的析构函数..因为这些析构函数是 自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出 WARNING 了异常，并且析构函数自身没能捕获到该异常，则程序将被终止,：

异常对象

异常对象(exception object)是一种特殊的对象，编译器使用异常抛出表达式来对异 常对象进行拷贝初始化(参见13.1.1节，第441页)。因此，throw语句中的表达式必须 拥有完全类型(参见7.3.3节，第250页)。而且如果该表达式是类类型的话，则相应的类 必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数 组类型或函数类型，则表达式将被转换成与之对应的指针类型。

异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子 句都能访问该空间。当异常处理完毕后，异常对象被销毁。

如我们所知，当一个异常被抛出时，沿着调用链的块将依次退出直至找到与异常匹配 的处理代码。如果退出了某个块，则同时释放块中局部对象使用的内存。因此.抛出一个 指向局部对象的指针几乎肯定是一种错误的行为。出于同样的原因，从函数中返回指向局 部对象的指针也是错误的(参见6.3.2节，第202页)。如果指针所指的对象位于某个块中， 而该块在catch语句之前就已经退出了，则意味着在执行catch语句之前局部对象已经 被销毁了。

当我们抛出一条表达式时，该表达式的静态编译时类型(参见15.2.3节，第534页) 决定了异常对象的类型。读者必须牢记这一点，因为很多情况下程序抛出的表达式类型来 自于某个继承体系。如果一条throw表达式解引用一个基类指针，而该指针实际指向的 是派生类对象，则抛出的对象将被切掉一部分(参见15.2.3节，第535页)，只有基类部 分被抛出，

WARNING



抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在

###### 18.1.1节练习

练习18.1：在下列throw语句中异常对象的类型是什么？

(a)range_error r("error") ;    (b)exception *p = &r;

throw r;    ,    throw *p;

如果将(b)巾的throw语句写成了 throwp将发生什么情况？

练习18.2:当在指定的位置发生了异常时将出现什么情况？

void exercise(int *b, int *e)

{

vector<int> v(b, e);

int *p = new int[v.size()];

if stream in (" ints’’)；

//此处发生异常

}

练习18.3:要想让上面的代码在发生异常时能正常工作，有两种解决方案。请描述这两 种方法并实现它们。

###### 18.1.2捕获异常

catch子句（catch clause）中的异常声明（exception declaration）看起来像是只包含

一个形参的函数形参列表，像在形参列表中一样，如果catch无须访问抛出的表达式的 话，则我们可以忽略捕获形参的名字。

声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型（参见 7.3.3节，第250页），它可以是左值引用，但不能是右值引用（参见13.6.1节，第471页）。

当进入一个catch语句后，通过异常对象初始化异常声明中的参数。和函数的参数 类似，如果catch的参数类型是非引用类型，则该参数是异常对象的一个副本，在catch 语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类 型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异 常对象。

catch的参数还有一个特性也与函数的参数非常类似：如果catch的参数是基类类 型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果catch的参 数是非引用类型，则异常对象将被切掉一部分（参见15.2.3节，第535页），这与将派生＜MI 类对象以值传递的方式传给一个普通函数差不多。另一方面，如果catch的参数是基类 的引用，则该参数将以常规方式绑定到异常对象上。

最后一点需要注意的是，异常声明的静态类型将决定catch语句所能执行的操作。

如果catch的参数是基类类型，则catch无法使用派生类特有的任何成员。

卩^^ 通常情况下，如果:caitch接受的异常与某个继承体系有关，则最好将该catch 的参数定义成引用类禮酸通' S，

查找匹配的处理代码

在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反， 挑选出來的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置 于整个catch列表的前端。

因为catch语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关 系的多个异常时必须对catch语句的顺序进行组织和管理，使得派生类异常的处理代码 出现在基类异常的处理代码之前。

与实参和形参的匹配规则相比，异常和catch异常声明的匹配规则受到更多限制。 此吋，绝大多数类型转换都不被允许，除了一些极细小的差別之外，耍求异常的类型和 catch声明的类型是精确匹配的：

•允许从非常量向常量的类型转换，也就是说，•条非常量对象的throw语句可以 匹配一个接受常量引用的catch语句。

•允许从派生类向基类的类型转换。

•数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针。 除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配

catch的过程中使用。

如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最 /^o(^\底埔的类(most derived type )放在前面，而将继承链最顶端的类(least derived

type)放在后面a

重新抛出

有吋，一个单独的catch语句不能完整地处理某个异常。在执行了某些校正操作之 后，当前的catch可能会决定由调用链更上一层的函数接着处理异常。一条catch语句 通过重新抛出(rethrowing)的操作将异常传递给另外一个catch语句。这里的重新抛出 仍然是一条throw语句，只不过不包含任何表达式：

throw;

\JE＞空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如 果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate.

一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上 传递。

很多时候，catch语句会改变其参数的内容。如果在改变了参数的内容后catch语 句重新抛出异常，则只有当catch异常声明是引用类型时我们对参数所做的改变才会被 保留并继续传播：

catch (my_error &eObj ) {    // 引用类型

eObj.status = errCodes: : severeErr; // 修改了异常对象

throw;    //异常对象的status成员是severeErr

} catch (other_error eObj )    {    // 非引用类型

eObj. status = errCodes: : badErr;    //只修改了异常对象的局部副本

throw;    //异常对象的status成员没有改变

捕获所有异常的处理代码

有时我们希望不论抛出的异常是什么类型，程序都能统一捕获它们。要想捕获所有可 能的异常是比较有难度的，毕竟有些情况下我们也不知道异常的类型到底是什么。即使我 们知道所有的异常类型，也很难为所有类型提供唯一一个catch语句。为了一次性捕获 所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常(catch-all) 的处理代码，形如catch (...)« 一条捕获所有异常的语句可以与任意类型的异常匹配，

catch (...)通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工 作，随后重新抛出异常：

void manip() { try {

//这里的操作将引发并拋出一个异常

}

catch (...)    {

//处理异常的某些特殊操作

throw；

catch (...)既能单独出现，也能与其他几个catch语句一起出现。

j    如果catch (...)与其他几个catch语句一起出现，则catch (...)必须在

1"叫最后的位置出现在捕获所有异常语句后面的catch语句将永远不会被匹配

###### 18.1.2节练习    ~~

练习18.4：查看图18.1 (第693页)所示的继承体系，说明下面的try块有何错误并 修改它， try {

//使用C++标准库 } catch(exception) {

"…

} catch(const runtime_error &re) {

// •••

} catch (overflow—error eobj) { /* ... */ }

练习18.5:修改下面的main函数，使其能捕获图18.1 (第693页)所示的任何异常类 型：

int main() {

//使用C++标准库

}

处理代码应该首先打印异常相关的错误信息，然后调用abort (定义在cstdlib头文 件中)终止main函数。

练习18.6:已知下面的异常类型和catch语句，书写一个throw表达式使其创建的异 常对象能被这些catch语句捕获：

(a)    class exceptionType { }; catch(exceptionType *pet) { }

(b)    catch (...)    { }

(c)    typedef int EXCPTYPE; catch(EXCPTYPE) { }

###### 18.1.3函数try语句块与构造函数

通常情况下，程序执行的任何时刻都可能发生异常，特别是异常可能发生在处理构造 函数初始值的过程中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值＜ZZS3 列表抛出异常时构造函数体内的try语句块还未生效，所以构造函数体内的catch语句 无法处理构造函数初始值列表抛出的异常。

要想处理构造函数初始值抛出的异常，我们必须将构造函数写成函数try语句块(也 称为函数测试块，function try block)的形式。函数try语句块使得一组catch语句既能 处理构造函数体(或析构函数体)，也能处理构造函数的初始化过程(或析构函数的析构 过程)。举个例子，我们可以把Biol□的构造函数(参见16.1.2节，第586页)置于一个 函数try语句块中：

template <typename T>

Blob<T>::Blob(std::initializer_list<T> il) try :

data(std::make_shared<std::vector<T»(il))    {

/*空函数体*/

} catch(const std::bad_alloc &e)    { handle_out_of_memory(e); }

注意：关键字try出现在表示构造函数初始值列表的冒号以及表示构造函数体(此例为 空)的花括号之前。与这个try关联的catch既能处理构造函数体抛出的异常，也能处 理成员初始化列表抛出的异常。

还有一种情况值得读者注意，在初始化构造函数的参数时也可能发生异常，这样的异 常不属于函数try语句块的•部分。函数try语句块只能处理构造函数开始执行后发生 的异常。和其他函数调用•样，如果在参数初始化的过程中发生了异常，则该异常属于调 用表达式的一部分，并将在调用者所在的上下文中处理，

处理构造函数初始值异常的唯一方法是将构造函数写成函数1；]^语句块-

###### 18.1.3节练习

练习18.7：根据第I6章的介绍定义你自己的Blob和BlobPtr,注意将构造函数写成 函数try语句块。

###### 18.1.4 noexcept 异常说明

对丁•用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道 函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异 常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码，

C++11新标准中，我们可以通过提供noexcept说明(noexcept specification)指 [CTTI定某个函数不会抛出异常。其形式是关键字noexcept紧跟在函数的参数列表后面，用

11以标识该函数不会抛出异常：

void recoup (int) noexcept;    // 不会抛出异常

void alloc (int) ;    //可能抛出异常

这两条声明语句抱出recoup将不会抛出任何异常，而alloc可能抛出异常。我们说 recoup 做了不抛出说明(nonthrowing specification)。

对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句 中，要么一次也不出现。该说明应该在函数的尾置返回类型(参见6.3.3节，第206页) 之前。我们也可以在函数指针的声明和定义中指定noexcept。在typedef或类型别名 中则不能出现noexcept。在成员函数中，noexcept说明符需要跟在const及引用限 定符之后，而在final、override或虚函数的=0之前。

违反异常说明

读者需要清楚的一个事实是编译器并不会在编译时检查noexcept说明。实际上， 如果 '个函数在说明了 noexcept的同时又含有throw语句或者调用了可能抛出异常的 其他函数，编译器将顺利编译通过，并不会因为这种违反异常说明的情况而报错(不排除 个別编译器会对这种用法提出警告)：

[~780>



//尽管该函数明显违反了异常说明，但它仍然可以顺利编译通过 void f () noexcept    //承诺不会抛出异常

throw exception ();    // 违反了异常说明

}

因此可能出现这样一种情况：尽管函数声明了它不会抛出异常，但实际上还是抛出了。 一旦一个noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时 抛出异常的承诺。上述过程对是否执行栈展开未作约定，因此noexcept可以用在两种 情况下：一是我们确认函数不会抛出异常，二是我们根本不知道该如何处理异常。

指明某个函数不会抛出异常可以令该函数的调用者不必再考虑如何处理异常。无论是 函数确实不抛出异常，还是程序被终止，调用者都无须为此负责。

通常情况下

WARNING



编译器不能也不必在编译时验证异常说明



向后兼容：异常说明

早期的C++版本设计了一套更加详细的异常说明方案，该方案使得我们可以指定某 个函数可能抛出的异常类型D :函数可以指定一个关键字throw,在后面跟上括号•括起来 的异常类型列表。throw说明符所在的位置与新版本C++中noexcept所在的位置相同。

上述使用throw的异常说明方案在C++11新版本中已经被取消了。然而尽管如此, 它还有一个重要的用处。如果函数被设计为是throw。的，则意味着该函数将不会抛 出异常：

void recoup (int) noexcept;    // recoup 不会抛出异常

void recoup (infc) throw() ;    // 等价的声明

上面的两条声明语句是等价的，它们都承诺recoup不会抛出异常。

异常说明的实参

noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型：如果实参 是true，则函数不会抛出异常；如果实参是false,则函数可能抛出异常：

void recoup (int) noexcept (true) ;    // recoup 不会抛出异常

void alloc (int) noexcept (false) ;    // alloc 可能抛出异常

noexcept运算符

noexcept说明符的实参常常与noexcept运算符(noexcept operator)混合使用。Cc+TI noexcept运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，

用于表示给定的表达式是否会抛出异常。和sizeof (参见4.9节，第139页)类似，＜M] noexcept也不会求其运算对象的值。

例如，因为我们声明recoup时使用了 noexcept说明符，所以下面的表达式的返 回值为true：

noexcept (recoup (i) )    //如果recoup不抛出异常则结果为true;否则结果为false

更普通的形式是：

noexcept(e)

当e调用的所有函数都做了不抛出说明且e本身不含有throw语句时，上述表达式为 true；否贝1J noexcept (e)返回 false。

我们可以使用noexcept运算符得到如下的异常说明：

void f() noexcept (noexcept (g ())) ; // f 和 g 的异常说明一致

如果函数g承诺了不会抛出异常，则f也不会抛出异常：如果g没有异常说明符，或者g 虽然有异常说明符但是允许抛，出异常，则f也可能抛出异常。

![img](C++  Primer 5-182.jpg)



noexcept有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作 为noexcept异常说明的bool实参出现时，它是一个运算符。

异常说明与指针、虚函数和拷贝控制

尽管noexcept说明符不属于函数类型的一部分，但是函数的异常说明仍然会影响 函数的使用。

函数指针及该指针所指的函数必须具有一致的异常说明。也就是说，如果我们为某个 指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显 式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出 异常的函数也可以：

// recoup和pfl都承诺不会拋出异常 void (*pfl)(int) noexcept = recoup;

II正确：recoup不会拋出异常，pf2可能抛出昇常，二者之间互不干扰 void (*pf2) (int) = recoup;

pfl = alloc;    //错误：alloc可能拋出异常，但是pfl已经说明了它不会抛出异常

pf2 = alloc;    //正确：pf2和alloc都可能抛出异常

如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的 承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出 异常，也可以不允许抛出异常：

1~782>



class Base {

public:

virtual double f1(double)



virtual



virtual



noexcept;

int f2() noexcept(false); void f3();



//不会抛出异常 //可能抛出异常 //可能抛出异常



}；

class Derived : public Base { public:

double f1(double);

int f2() noexcept(false);

void f3() noexcept;



//错误：Base :: fl承诺不会抛出异常 //正确：与Base : : f 2的异常说明一致 //正确：Derived的f3做了更严格的限定， //这是允许的



当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的 所有操作都承话了不会抛出异常，则合成的成员是noexcept的。如果合成成员调用的 任意一个函数可能抛出异常，则合成的成员是noexcept (false)。而且，如果我们定义 了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将与 假设由编译器为类合成析构函数时所得的异常说明一致。

###### 18丄4节练习

练习18.8:回顾你之前编写的各个类，为它们的构造函数和析构函数添加正确的异常说 明。如果你认为某个析构函数可能抛出异常，尝试修改代码使得该析构函数不会抛出异 常。

###### 18.1.5异常类层次

标准库异常类（参见5.6.3节，第176页）构成了图18.1所示的继承体系（参见第15章）。

类型exception仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一 个名为what的虚成员。其中what函数返回一个const char*,该指针指向一个以unll 结尾的字符数组，并且确保不会抛出任何异常。

类exception、bad_cast和bad_alloc定义了默认构造函数。类 runtime_error和logic_error没有默认构造函数，但是有一个可以接受C风格字 符串或者标准库string类实参的构造函数，这些实参负责提供关于错误的更多信息。

在这些类中，„hat负责返回用于初始化异常对象的信息。因为what是虚函数，所以当 我们捕获基类的引用时，对what函数的调用将执行与异常对象动态类型对应的版本。

书店应用程序的异常类

实际的应用程序通常会自定义exception （或者exception的标准库派生类）的 派生类以扩展其继承体系。这些面向应用的异常类表示了与应用相关的异常条件。

如果我们构建的是一个真实的书店应用程序，则其中的类将比本书之前所示的复杂得＜783] 多。复杂性的一个方面就是如何处理异常。实际上，我们很可能需要建立一个自己的异常 类体系，用它来表示与应用相关的各种问题。我们设计的异常类可能如下所示：

//为某个书店应用程序设定的异常类

class out_of_stock: public std::runtime_error { public:

explicit out_of_stock(const std::string &s):

std::runtime_error(s)    { }

}；

class isbn_mismatch: public std::logic_error { public:

explicit isbn_mismatch(const std::string &s):

std::logic_error(s)    { }

isbn_mismatch(const std::string &s,

const std::string &lhs, const std::string &rhs): std::logic—error(s), left(lhs), right(rhs) { }

const std::string left, right;

}；

由上可知，我们的面向应用的异常类继承自标准异常类。和其他继承体系一样，异常类也 可以看作按照层次关系组织的。层次越低，表示的异常情况就越特殊，例如，在异常类继 承体系中位于最顶层的通常是exception, exception表示的含义是某处出错了，至 于错误的细节则未作描述。

继承体系的第二层将exception划分为两个大的类别：运行时错误和逻辑错误。运 行吋错误表示的是只有在程序运行时才能检测到的错误；而逻辑错误一般指的是我们可以 在枵序代码中发现的错误。

我们的书店应用程序进一步细分上述异常类别。名为out_of_stock的类表示在运 行时可能发生的错误，比如某些顺序无法满足：名为isbn_mismatch的类表示 logic_error的一个特例，程序可以通过比较对象的isbn ()结果来阻止或处理这一 错误。_

使用我们自己的异常类型

我们使用自定义异常类的方式与使用标准异常类的方式完全一样。程序在某处抛出异 常类型的对象，在另外的地方捕获并处理这些出现的问题。举个例子，我们可以为 SaleS_data类定义一个复合加法运算符，当检测到参与加法的两个ISBN编号不一致时 抛出名为isbn_mismatch的异常：

//如果参与加法的两个对象并非同一书籍，则抛出一个异常

Sales_data&

Sales_data::operator+=(const Sales_data& rhs)

{

if (isbn ()    != rhs.isbn())

throw isbn_mismatch("wrong isbns”，isbn (), rhs.isbn ()); units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;

}

使用了复合加法运算符的代码将能检测到这一错误，进而输出一条相应的错误信息并继续 完成其他任务：

//使用之前设定的书店程序异常类

Sales_data iteml, item2, sum;

while (cin » iteml » item2) {    // 读取两条交易信息

try {

sum = iteml + item2;    //计算它们的和

//此处使用sum

} catch (const isbn_mismatch &e)    {

cerr « e . what () << *': left isbn(" « e. left

« ") right isbn (" « e. right «    « endl;

}

###### 18.1.5节练习

<785~|



练习18.9:定义本节描述的书店程序异常类，然后为SaleS_data类重新编写一个复 合赋值运算符并令其抛出一个异常。

练习18.10：編写程序令其对两个ISBN编号不相同的对象执行Sales_data的加法运 算。为该程序编写两个不同的版本：一个处理异常，另一个不处理异常。观察并比较这 两个程序的行为，用心体会当出现了一个未被捕获的异常时程序会发生什么情况。

练习18.11:为什么what函数不应该抛出异常？

##### 18.2命名空间

大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函 数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲 突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染(namespace pollution )o

传统上，程序员通过将其定义的全局实体名字设得很长来避免命名空间污染问题，这 样的名字中通常包含表示名字所属库的前缀部分：

class cplusplus_primer_Query { ... };

string cplusplus_primer_make_plural(size_t, strings);

这种解决方案足然不太理想：对于程序员来说，书写和阅读这么长的名字费时费力且过予 烦琐。

命名空间(namespace)为防止名字冲突提供了更加可控的机制。命名空间分割了全 局命名空间，其中每个命名空间是_ •个作用域。通过在某个命名空间中定义库的名字，库 的作者(以及用户)可以避免全局名字固有的限制。

###### 18.2.1命名空间定义

一个命名空间的定义包含两部分：首先是关键字namespace,随后是命名空间的名 字。在命名空间名字后面是一系列由花括号括起來的声明和定义。只要能出现在全局作用 域中的声明就能置于命名空间内，主要包括：类、变量(及其初始化操作)、函数(及其 定义)、模板和其他命名空间：

namespace cplusplus_primer { class Sales data { /*

Sales_data operator^(const Sales_data&, const Sales_data&);

class Query { /*.••*/ }; class Query_base { /* . ..*/}；

} //命名空间结束S无须分号，这一点与块类似

[786＞上面的代码定义了一个名为cplusplus_primer的命名空间，该命名空间包含四个成 员：三个类和一个重载的+运算符。

和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间既可 以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部=

命名空间作用域后面无须分号。

每个命名空间都是一个作用域

和其他作用域类似，命名空间中的每个名字都必须表示该空间内的唯一实体。因为不 同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。

定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这 些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须明确指出所用的 名字属于哪个命名空间：

cplusplus_primer::Query q =

cplusplus_primer::Query("hello");

如果其他命名空间(比如说AddisonWesley)也提供了一个名为Query的类，并 且我们希望使用这个类替代cpluSpluS_primer中定义的同名类，则可以按照如下方式 修改代码：

AddisonWesley: :Query q = AddisonWesley: :Query (’’hello");

命名空间可以是不连续的

如我们在16.5节(第626页)介绍过的，命名空间可以定义在几个不同的部分，这一 点与其他作用域不太一样。编写如下的命名空间定义：

namespace nsp {

//相关声明

}

可能是定义了一个名为nsp的新命名空间，也可能是为已经存在的命名空间添加一些新 成员。如果之前没有名为nsp的命名空间定义，则上述代码创建一个新的命名空间：否 贝IJ,上述代码打开己经存在的命名空间定义并为其添加一些新成员的声明。

命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成 一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式：

•命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这 些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。

•命名空间成员的定义部分则置于另外的源文件中。

在程序中某些实体只能定义一次：如非内联函数、静态数据成员、变量等，命名空间中定 义的名字也需要满足这一要求，我们可以通过上面的方式组织命名空间并达到目的。这种 接口和实现分离的机制确保我们所需的函数和其他名字只定义一次，而只要是用到这些实

体的地方都能看到对于实体名字的声明。

B«t    定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型(或关

卩 roetiew

联类型构成的集合)。

定义本书的命名空间

通过使用上述接口与实现分离的机制，我们可以将cplusplus_primer库定义在几 个不同的文件中。Sales_data类的声明及其函数将置于Sales_data.h头文件中，第 15章介绍的Query类将1于Query.h头文件中，以此类推。对7应的实现文件将分别是 Sales_data.cc 和 Query.cc：

// -一-Sales_data.h ----

// #include应该出现在打开命名空间的操作之前

\#include <string> namespace cplusplus_primer {

class Sales_data { /*

Sales_data operator+(const Sales_data&, const Sales_data&);

// Sales_data的其他接口函数的声明

}

/ / —Sales_data. cc —

//确保#include出现在打开命名空间的操作之前

\#include "Sales_data.hn

namespace cplusplus_primer {

// Sales_data成贾及重载运算符的定义

}

程序如果想使用我们定义的库，必须包含必耍的头文件，这些头文件中的名字定义在 命名空间 cplusplus_primer 内：

// —user. cc —

// Sales_data.h头文件的名字位于命名空间cplusplus_primer中

\# include '’Sales_data. h" int main()

{

using cplusplus_primer::Sales_data;

Sales_data transl, trans2;

II ...

return 0;

}

这种程序的组织方式提供了开发者和库用户所需的模块性。毎个类仍组织在自己的接口和 实现文件中，一个类的用户不必编译与其他类相关的名字。我们对用户隐藏了实现细节， 同时允许文件Sales_data. cc和user . cc被编译并链接成一个程序而不会产生任何编 译吋错误或链接时错误。库的开发者可以分别实现每一个类，相互之间没有干扰。

有一点需要注意，在通常情况下，我们不放在命名空间内部。如果我们 这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。例如，如果 Sales_data.h在包含string头文件前就已经打开了命名空间cplusplus_primer. 则程序将出错，因为这么做意味着我们试图将命名空间std嵌套在名空间 cplusplus primer 中。

定义命名空间成员

假定作用域中存在合适的声明语句，则命名空间中的代码可以使用同一命名空间定义 的名字的简写形式：

\#include "Sales_data.hH

namespace cplusplus_primer {    // 重新打开命名2间 cplusplus_primer

//命名空间中定义的成员可以直接使用名字，此时无须前缀 std::istream&

operator>>(std::istreamS in, Sales_data& s) { /*...*/}

}

也可以在命名空间定义的外部定义该命名空间的成员。命名空间对于名字的声明必须 在作用域内，同时该名字的定义需要明确指出其所属的命名空间：

//命名空间之外定义的成员必须使用含有前缀的名字 cplusplus_primer::Sales_data

cplusplus_primer::operator+(const Sales_data& lhs, const Sales_data& rhs)

{

Sales_data ret(lhs);

// ••丁

}

和定义在类外部的类成员一样，一旦看到含有完整前缀的名字，我们就可以确定该名字位 于命名空间的作用域内。在命名空间cplusplus_primer内部，我们可以直接使用该命 名空间的其他成员，比如在上面的代码中，可以直接使用Sales_data定义函数的形参。

尽管命名空间的成员可以定义在命名空间外部，但是这样的定义必须出现在所属命名 空间的外层空间中。换句话说，我们可以在cplusplus_primer或全局作用域中定义 Sales_data operator+，但是不能在一个不相关的作用域中定义这个运算符。

模板特例化

模板特例化必须定义在原始模板所属的命名空间中(参见16.5节，第626页)。和其 □§?>他命名空间名字类似,只要我们在命名空间中声明了特例化,就能在命名空间外部定义它了：

//我们必须将模板特例化声明成std的成员 namespace std {

template <> struct hash<Sales_data>;

}

//在std中添加了模板特例化的声明后，就可以在命名空间std的外部定义它了 template <> struct std::hash<Sales_data>

{

size_t operator()(const Sales_data& s) const { return hash<string>()(s.bookNo) A

hash<unsigned>()(s.units_sold)八 hash<double>() (s.revenue); }

//其他成员与之前的版本一致

}；

全局命名空间

全局作用域中定义的名字(即在所有类、函数及命名空间之外定义的名字)也就是定 义在全局命名空间(global namespace)中。全局命名空间以隐式的方式声明，并且在所有

程序中都存在=全局作用域中定义的名字被隐式地添加到全局命名空间中。

作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并 没有名字=下面的形式

::member_name

表示全局命名空问中的一个成员。

嵌套的命名空间

嵌套的命名空间是指定义在其他命名空间中的命名空间：

namespace cplusplus_primer {

//第一个嵌套的命S空间：定义了库的Query部分 namespace QueryLib {

class Query { /* …*/ };

Query operators(const Query&, const Query&);

"…

}

//第二个嵌套的命名空间：定义了库的Sales_data部分 namespace Bookstore {

class Quote { /*...*/ };

class Disc_quote : public Quote { /*...*/ };

"…

}

}

上面的代码将命名空间cplusplus_primer分割为两个嵌套的命名空间，分别是 QueryLib 和 Bookstore。

嵌套的命名空间同时是一个嵌套的作用域，它嵌套在外层命名空间的作用域中。嵌套 的命名空间中的名字遵循的规则与往常类似：内层命名空间声明的名字将隐藏外层命名空 间声明的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名 空间中的代码要想访问它必须在名字前添加限定符。例如，在嵌套的命名空间QueryLib 中声明的类名是

cplusplus_primer::QueryLib::Query

内联命名空间

C++11新标准引入了一种新的嵌套命名空间，称为内联命名空间(inline namespace)。 和普通的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。也就 是说，我们无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间 的名字就可以直接访问它。

定义内联命名空间的方式是在关键字namespace前添加关键字inline：

inline namespace FifthEd {

//该命名空间表示本书第5版的代码

}

namespace FifthEd {    // P急式内联

class Query_base { /*

//其他与Query有关的声明

关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以 写inline,也可以不写。

当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名 空间。例如，我们可以把本书当前版本的所有代码都放在一个内联命名空间中，而之前版 本的代码都放在一个非内联命名空间中：

namespace FourthEd {

class Item_base ( /* class Query_base { /*

//本书第4版_用到的其他代码

}

命名空间cplusplus_primer将同时使用这两个命名空间。例如，假定每个命名空间都 定义在同名的头文件中，则我们可以把命名空间cplusplus_primer定义成如下形式：

namespace cplusplus_primer {

\#include HFifthEd.hn

\#include nFourthEd.h’’

}

CISC5,因为FifthEd是内联的，所以形如cplusplus_primer ::的代码可以直接获得 FifthEd的成员。如果我们想使用早期版本的代码，_则必须像其他嵌套的命名空间一样 加上完整的外层命名空间名字，比如cplusplus_primer: :FourthEd: :Query_base。

未命名的命名空间

未命名的命名空间(unnamed namespace)是指关键字namespace后紧跟花括号括起 来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次 使用前创建，并且直到程序结束才销毁。

一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每 个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个 空间互相无关。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的 是不冋实体。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在 每个包含了该头文件的文件中对应不同实体。

![img](C++  Primer 5-184.jpg)



和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范 围不会横跨多个不同的文件.。

定义在未命名的命名空间中的名字可以直接使用，毕竟我们找不到什么命名空间的名 字来限定它们；同样的，我们也不能对未命名的命名空间的成员使用作用域运算符。

未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。如果未命 名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域 中的名字有所区别：

int i;    // i的全局声明

namespace {

int i;

}

//二义性：i的定义既出现在全局作用域中，又出现在未嵌套的未命名的命名空间中 i = 10;

其他情况下，未命名的命名空间中的成员都属于正确的程序实体。和所有命名空间类似， 一个未命名的命名空间也能嵌套在其他命名空间当中。此时，未命名的命名空间中的成员 可以通过外层命名空间的名字来访问：

namespace local { namespace {

int i;

}

}

//正确：定义在嵌套的未命名的命名空间中的i与全局作用域中的i不同 local::i = 42;

未命名的命名空间取代文件中的静态声明

<791]



在标准C++引入命名空间的概念之前，程序需要将名字声明成static的以使得其 对于整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言 中.声明为static的全局实体在其所在的文件外不可见。

/f\在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命 WARNMG名的命名2间。.

###### 18.2.1节练习

练习18.12:将你为之前各章练习编写的程序放置在各自的命名空间中。也就是说，命 名空间chapterl5包含Query程序的代码，命名空间chapterlO包含TextQuery 的代码；使用这种结构重新编译Query代码示例。

练习18.13:什么时候应该使用未命名的命名空间？

练习18.14:假设下面的operator*声明的是嵌套的命名空间mathLib: :MatrixLib 的一个成员：

namespace mathLib {

namespace MatrixLib {

class matrix { /* ... */ }; matrix operator*

(const matrix &, const matrix &);

"…

}

}

请问你应该如何在全局作用域中声明该运算符？

###### 18.2.2使用命名空间成员

像namespace_name : : member_name这样使用命名空间的成员显然非常烦琐，特 别是当命名空间的名字很长时尤其如£。幸运的是，我们可以通过一些其他更简便的方法 使用命名空间的成员。之前的程序已经使用过其中一种方法，即using声明(参见3.1 节，第74页)。本节还将介绍另外几种方法，如命名空间的别名以及using指示等。

命名空间的别名

命名空间的别名(namespace alias)使得我们可以为命名空间的名字设定一个短得多 的同义词。例如，一个很长的命名空间的名字形如

namespace cplusplus_primer { /*••.*/ }; 我们可以为其设定一个短得多的同义词：

namespace primer = cplusplus_primer;

Cl93＞命名空间的别名声明以关键字namespace开始，后面是别名所用的名字、=符号、命名 空间原来的名字以及一个分号。不能在命名空间还没有定义前就声明别名，否则将产生 错误。

命名空间的别名也可以指向一个嵌套的命名空间：

namespace Qlib = cplusplus_primer::QueryLib; Qlib::Query q;

一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字

using声明：扼要概述

一条using声明(using declaration)语句一次只引入命名空间的一个成员。它使得 我们可以清楚地知道程序中所用的到底是哪个名字。

using声明引入的名字遵守与过去一样的作用域规则：它的有效范围从using声明 的地方开始，一直到using声明所在的作用域结束为止。在此过程中，外层作用域的同 名实体将被隐藏=未加限定的名字只能在using声明所在的作用域以及其内层作用域中 使用。在有效作用域结束后，我们就必须使用完整的经过限定的名字了。

一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类 的作用域中。在类的作用域中，这样的声明语句只能指向基类成员(参见15.5节，第546页)。 using指示

using指示(using directive)和using声明类似的地方是，我们可以使用命名空间 名字的简写形式；和using声明不同的地方是，我们无法控制哪些名字是可见的，因为 所有名字都是可见的。

using指示以关键字using开始，后面是关键字namespace以及命名空间的名字。 如果这里所用的名字不是一个已经定义好的命名空间的名字，则程序将发生错误。using 指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用 域中。

using指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们 添加任何前缀限定符了。简写的名字从using指示开始，一直到using指示所在的作用 域结朿都能使用。

如果我们提供了 一个对std等命名空间的using指示而未做任何特殊控制的 话，将重新引入由于使用了多个库而造成的名字冲突问题

using指示与作用域

using指示引入的名字的作用域远比using声明引入的名字的作用域复杂。如我们 所知，using声明的名字的作用域与using声明语句本身的作用域一致，从效果上看就 好像using声明语句为命名空间的成员在当前作用域内创建了一个别名一样。

using指示所做的绝非声明别名这么简单。相反，它具有将命名空间成员提升到包含 命名空间本身和using指示的最近作用域的能力。

using声明和using指示在作用域上的区别直接决定了它们工作方式的不同。对于 using声明来说，我们只是简单地令名字在局部作用域内有效。相反，using指示是令 整个命名空间的所有内容变得有效，通常情况下，命名空间中会含有一些不能出现在局部 作用域中的定义，因此，using指示一般被看作是出现在最近的外层作用域中。

在最简单的情况下，假定我们有一个命名空间A和一个函数f，它们都定义在全局作 用域中。如果f含有一个对A的using指示，则在f看来，A中的名字仿佛是出现在全 局作用域中f之前的位置一样：

II命名空间A和函数f定义在全局作用域中 namespace A {

int i, j;

}

void f()

{

using namespace A;    //把A中的名字注入到全局作用域中

cout << i * j « endl;    //使用命名空间A中的i和j

"…

}







using指示示例

让我们看一个简单的示例:

namespace blip {

int i = 16, j = 15, k = 23; //其他声明

int j = 0;    //正确：blip的j隐藏在命名空间中

void manip()

{

// using指示，blip中的名字被“添加”到全局作用域中

using namespace blip; //如果使用了 j,则将在：：j和blip: : j之间产生冲突

++i；

++j;

::j;

++blip::j; int k = 97; ++k;



//将blip:: i设定为17

//二义性错误：是全局的j还是blip:: //正确：将全局的j设定为1 //正确：将blip: : j设定为16 //当前局部的k隐藏了 blip: :k //将当前局部的k设定为98

manip的using指示使得程序可以直接访问blip的所有名字，也就是说，manip 的代码可以使用blip中名字的简写形式。

blip的成员看起来好像是定义在blip和manip所在的作用域一样。假定manip <7951

定义在全局作用域中，则blip的成员也好像是定义在全局作用域中一样。

当命名空间被注入到它的外层作用域之后，很有可能该命名空间中定义的名字会与其 外层作用域中的成员冲突。例如在manip中，blip的成员j就与全局作用域中的j产 生了冲突。这种冲突是允许存在的，但是要想使用冲突的名字，我们就必须明确指出名字 的版本。manip中所有未加限定的j都会产生二义性错误。

为了使用像j这样的名字，我们必须使用作用域运算符来明确指出所需的版本。我们 使用：：j来表示定义在全局作用域中的j，而使用blip: : j来表示定义在blip中的j。

因为manip的作用域和命名空间的作用域不同，所以manip内部的声明可以隐藏命 名空间中的某些成员名字。例如，局部变量k隐藏了命名空间的成员blip: : k»在manip 内使用k不存在二义性，它指的就是局部变量k。

头文件与using声明或指示

头文件如果在其顶层作用域中含有using指示或using声明，则会将名字注入到所 有包含了该头文件的文件中。通常情况下，头文件应该只负责定义接口部分的名字，而不 定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用using指示 或using声明（参见3.1节，第75页）。

提示：避免using指示

using指示一次性注入某个命名空间的所有名字，这种用法看似简单实则充满了风 险：只使用一条语句就突然将命名空间中所有成员的名字变得可见了。如果应用程序使 用了多个不同的库，而这些库中的名字通过using指示变得可见，则全局命名空间污 染的问题将重新出现。

而且，当引入库的新版本后，正在工作的程序很可能会编译失败。如果新版本引入 了一个与应用程序正在使用的名字冲突的名字，就会出现这个问题。

另一个风险是由using指示引发的二义性错误只有在使用了冲突名字的地方才能 被发现。这种延后的检测意味着可能在特定库引入很久之后才爆发冲突。直到程序开始 使用该库的新部分后，之前一直未被检测到的错误才会出现。

相比于使用using指示，在程序中对命名空间的每个成员分别使用using声明效 果更好，这么做可以减少注入到命名空间中的名字数量。using声明引起的二义性问题 在声明处就能发现，无须等到使用名字的地方，这显然对检测并修改错误大有益处。

![img](C++  Primer 5-185.jpg)



using指示也并非一无是处，例如在命名空间本身的实现文件中就可以使用 using指示。

r?96>



###### 18.2.2节练习

练习18.15：说明using指示与using声明的区别。

练习18.16:假定在下面的代码中标记为“位置I”的地方是对于命名空间Exercise 中所有成员的using声明，请解释代码的含义。如果这些using声明出现在“位置2” 又会怎样呢？将using声明变为using指示，重新回答之前的问题。

namespace Exercise { int ivar = 0; double dvar = 0;

const int limit = 1000;

}

int ivar = 0;

//位置1 void manip()    {

//位置2

double dvar = 3.1416; int iobj = limit + 1;

++ivar;

++::ivar;

}

练习18.17:实际编写代码检验你对上一题的回答是否正确。

###### 18.2.3类.命名空间与作用域

对命名空间内部名字的查找遵循常规的查找规则：即由内向外依次查找每个外层作用 域。外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过 程终止。只有位于开放的块中且在使用点之前声明的名字才被考虑：

namespace A { int i;

namespace B {

int i;    // 在 B 中隐藏了 A: : i

int j ; int fl ()

{

int j;    // j是fl的局部变量，隐藏了

return i;    // 返回 B::i

}

} //命名空间B结束，此后B中定义的名字不再可见 int f2()    {

return j;    //错误：j没有被定义

}

int j = i;    //用A:: i进行初始化

对于位于命名空间中的类来说，常规的查找规则仍然适用：当成员函数使用某个名字＜J9L] 时，首先在该成员中进行查找，然后在类中查找(包括基类)，接着在外层作用域中查找，

这时一个或几个外层作用域可能就是命名空间：

namespace A { int i; int k; class Cl { public:

CIO : i(0), j(0) { }    //    正确：初始化 Cl: :i    和 Cl: : j

int f 1 ()    { return k;    }    //    返回 A::k

int f2()    { return h;    }    //    错误：h 未定义

int f3 ();

private:

//在Cl中隐藏了 A:



int i;

int j;

}；

int h = i;    //用A: :i进行初始化

}

//成员f3定义在Cl和命名空间A的外部

int A: :C1: : f3 () { return h; }    // 正确：返回 A: :h

除了类内部出现的成员函数定义之外(参见7.4.1节，第254页)，总是向上查找作用 域。名字必须先声明后使用，因此f2的return语句无法通过编译。该语句试图使用命 名空间A的名字h,但此时h尚未定义。如果h在A中定义的位置位于C1的定义之前， 则上述语句将合法。类似的，因为f3的定义位于A: :h之后，所以f3对于h的使用是 合法的。

可以从函数的限定名推断出查找名字时检查作用域的次序，限定名以相反次序 \^Z指出被查找的作用域。

限定符A: :Cl: :f3指出了查找类作用域和命名空间作用域的相反次序。首先查找函 数f3的作用域，然后查找外层类C1的作用域，最后检查命名空间A的作用域以及包含 着f3定义的作用域。

(g实参相关的查找与类类型形参

考虑下面这个简单的程序：

std::string s; std::cin » s;

如我们所知，该调用等价于(参见14.1节，第491页)： operator〉〉(std::cin, s);

I 798＞ operator〉〉函数定义在标准库string中，string又定义在命名空间std中。但是我 们不用std::限定符和using声明就可以调用operator〉〉。

对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以直接访问输 出运算符。这个例外是，当我们给函数传递一个类类型的对象时，除了在常规的作用域查 找外还会查找实参类所属的命名空间。这一例外对于传递类的引用或指针的调用同样 有效。

在此例中，当编译器发现对operator〉〉的调用时，首先在当前作用域中寻找合适的 函数，接着查找输出语句的外层作用域。随后，因为＞＞表达式的形参是类类型的，所以编 译器还会查找cin和s的类所属的命名空间。也就是说，对于这个调用来说，编译器会 查找定义了 istream和string的命名空间std。当在std中查找时，编译器找到了 string的输出运算符函数。

查找规则的这个例外允许概念上作为类接口一部分的非成员函数无须单独的using 声明就能被程序使用。假如该例外不存在，则我们将不得不为输出运算符专门提供一个 using声明：

using std: :operator〉〉；    //要想使用cin » s就必须有该using声明

或者使用函数调用的形式以把命名空间的信息包含进来：

std::operator»(std::cin, s);

//正确：显式地使用std: :»



在没有使用运算符语法的情况下，上述两种声明都显得比较笨拙且无形中增加了使用1O 标准库的难度。

查找与 std::move 和 std:forward

很多甚至是绝大多数C杆程序员从来都没有考虑过与实参相关的查找问题。通常情况 下，如果在应用程序中定义了一个标准库中已有的名字，则将出现以下两种情况中的一种：

要么根据一般的重载规则确定某次调用应该执行函数的哪个版本；要么应用程序根本就不 会执行函数的标准库版本。

接下来考虑标准库move和forward函数。这两个都是模板函数，在标准库的定义 中它们都接受一个右值引用的函数形参。如我们所知，在函数模板中，右值引用形参可以 匹配任何类型(参见16.2.6节，第611页)。如果我们的应用程序也定义了一个接受单一 形参的move函数，则不管该形参是什么类型，应用程序的move函数都将与标准库的版 本冲突。forward函数也是如此。

因此，move (以及forward)的名字冲突要比其他标准库函数的冲突频繁得多。而 且，因为move和forward执行的是非常特殊的类型操作，所以应用程序专门修改函数 原有行为的概率非常小。

对于move和forward来说，冲突很多但是大多数是无意的，这一特点解释了为什I 么我们建议最好使用它们的带限定语的完整版本的原因(参见12.1.5节，第417页)。通 过书写std: :move而非move,我们就能明确地知道想要使用的是函数的标准库版本。

友元声明与实参相关的查找

回顾我们曾经讨论过的，当类声明了一个友元时，该友元声明并没有使得友元本身可 见(参见7.2.1节，第242页)。然而，一个另外的未声明的类或函数如果第一次出现在友 元声明中，则我们认为它是最近的外层命名空间的成员。这条规则与实参相关的查找规则 结合在一起将产生意想不到的效果：

namespace A { class C {

//两个友元，在友元声明之外没有其他的声明 //这些函数隐式地成为命名空间A的成员

friend void f2 () ;    //除非另有声明，否则不会被找到

friend void f (const C&) ; //根据实参相关的查找规则可以被找到

}；

}

此时，f和f2都是命名空间A的成员。即使f不存在其他声明，我们也能通过实参相关 的查找规则调用f:

int main()

{

A::C cobj;

f(cobj);    //正确：通过在A: :C中的友元声明找到A: :f

f2() ;    //错误：A::f2没有被声明

}

因为f接受一个类类型的实参，而且f在C所属的命名空间进行了隐式的声明，所以f 能被找到。相反，因为f2没有形参，所以它无法被找到。

###### 18.2.3节练习

练习18.18:已知有下面的swap的典型定义(参见13.3节，第457页)，当meml是 一个string时程序使用swap的哪个版本？如果meml是int呢？说明在这两种情况 下名字查找的过程。

void swap(T vl, T v2)

{

using std::swap; swap(vl.meml, v2.meml);

//交换类型T的其他成员

}

练习18.19:如果对swap的调用形如std: :swap (vl .meml, v2 .meml)将发生什么情况？

□qo> 18.2.4重载与命名空间

命名空间对函数的匹配过程有两方面的影响(参见6.4节，第209页)。其中一个影响 非常明显：using声明或using指示能将某些函数添加到候选函数集。另外一个影响则 比较微妙。

(g与实参相关的查找与重载

在上一节中我们了解到，对于接受类类型实参的函数来说，其名字查找将在实参类所 属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。我们将在每 个实参类(以及实参类的基类)所属的命名空间中搜寻候选函数。在这些命名空间中所有 与被调用函数同名的函数都将被添加到候选集当中，即使其中某些函数在调用语句处不可 见也是如此：

namespace NS {

class Quote { /* …*/ };

void display(const Quotes) { /*...*/ }

}

// Bulk_item的基类声明在命名空间NS中

class Bulk_item : public NS::Quote { /* …*/ };

int main()    {

Bulk_item bookl; display(bookl); return 0;

}

我们传递给display的实参属于类类型Bulk_item,因此该调用语句的候选函数不仅 应该在调用语句所在的作用域中查找，而且也应'^在Bulk_item及其基类Quote所属 的命名空间中查找。命名空间NS中声明的函数display (const Quotes >也将被添加 到候选函数集当中。

重载与using声明

要想理解using声明与重载之间的交互关系，必须首先明确一条：using声明语句 声明的是一个名字，而非一个特定的函数(参见15.6节，第551页)：

using NS::print(int); using NS::print;



//错误：不能指定形参列表 //正确：using声明只声明一个名字

当我们为函数书写using声明时，该函数的所有版本都被引入到当前作用域中。

一个using声明囊括了重载函数的所有版本以确保不违反命名空间的接口。库的作 者为某项任务提供了好几个不同的函数，允许用户选择性地忽略重载函数中的一部分但不 是全部有可能导致意想不到的程序行为。

一个using声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。 如果using声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。如 果using声明所在的作用域中已经有一个函数与新引入的函数同名且形参列表相同，则 该using声明将引发错误。除此之外，using声明将为引入的名字添加额外的重载实例， 并最终扩充候选函数集的规模。

<8QE



重载与using指示

using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命 名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中：

namespace libs_R_us {

extern void print (int); extern void print(double);

}

//普通的声明

void print(const std::string &);

//这个using指示把名字添加到print调用的候选函数集 using namespace libs_R_us;

// print调用此时的候选函数包括：

// libs_R_us 的 print (int)

// libs_R_us 的 print (double)

// 显式声明的 print (const std: : string &) void fooBar(int ival)

{

print (''Value: n);    // 调用全局函数 print (const string &)

print (ival) ;    // 调用 libs_R_us : :print (int)

与using声明不同的是，对于using指示来说，引入一个与已有函数形参列表完全相同 的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前作 用域的版本即可。

跨越多个using指示的重载

如果存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分:

namespace AW {

int print(int);

}

namespace Primer {

double print(double);

}

// using指示从不同的命名空间中创建了 一个重载函数集合

using namespace AW;

using namespace Primer;

long double print(long double);

int main()    {

print (1);    "调用 AW: :print (int)

print (3.1);    // 调用 Primer: :print (double)

return 0;

}

在全局作用域中，函数print的重载集合包括print (int)、print (double)和 print (long double),尽管它们的声明位于不同作用域中，但它们都属于main函数 中print调用的候选函数集。

###### 18.2.4节练习

练习18.20：在下面的代码中，确定哪个函数与compute调用匹配。列出所有候选函 数和可行函数，对于每个可行函数的实参与形参的匹配过程来说，发生了哪种类型转 换？

namespace primerLib { void compute(); void compute(const void *);

}

using primerLib::compute; void compute(int);

void compute(double, double = 3.4); void compute(char*, char* = 0); void f()

{

compute(0);

}

如果将using声明置于main函数中compute的调用点之前将发生什么情况？重新回 答之前的那些问题。

##### 18.3多重继承与虚继承

多重继承(multiple inheritance)是指从多个直接基类(参见15.2.2节，第533页)中 产生派生类的能力。多重继承的派生类继承了所有父类的属性，尽管概念上非常简单，但 是多个基类相互交织产生的细节可能会带来错综复杂的设计问题与实现问题。

为了探讨有关多重继承的问题，我们将以动物园中动物的层次关系作为教学实例。动 物园中的动物存在于不同的抽象级别上。有个体的动物，如Ling-Ling、Mowgli和Balou 等，它们以名字进行区分；每个动物属于一个物种，例如Ling-Ling是一只大熊猫；物种 又是科的成员，大熊猫是熊科的成员；每个科是动物界的成员，在这个例子中动物界是指 一个动物园中所有动物的总和。

我们将定义一个抽象类ZooAnimal,用它来保存动物园中动物共有的信息并提供公 共接口。类Bear将存放Bear科特有的信息，以此类推。

除了类ZooAnimal之外，我们的应用程序还包含其他一些辅助类，这些类负责封装 不同的抽象，如濒临灭绝的动物，以类Panda的实现为例，Panda是由Bear和 Endangered共同派生而來的。

###### 18.3.1多重继承

在派生类的派生列表中可以包含多个基类： class Bear : public ZooAnimal {

class Panda : public Bear, public Endangered { /*•..*/ };

每个基类包含一个可选的访问说明符（参见15.5节，第543页）。一如往常，如果访问说 明符被忽略掉了，则关键字class对应的默认访问说明符是private,关键字struct 对应的是public （参见15.5节，第546页）。

和只有一个基类的继承一样，多重继承的派生列表也只能包含己经被定义过的类，而 且这些类不能是final的（参见15.2.2节，第533页）。对于派生类能够继承的基类个数， C++没有进行特殊规定；但是在某个给定的派生列表中，同-个基类只能出现一次。

多重继承的派生类从每个基类中继承状态

在多重继承关系中，派生类的对象包含有每个基类的子对象（参见15.2.2节，第530 页）。如图18.2所示，在Panda对象中含有一个Bear部分（其中又含有一个ZooAnimal 部分）、-个Endangered部分以及在Panda中声明的非静态数据成员。

Panda

对象

| Bear             |                | ZooAnimal成员 |
| ---------------- | -------------- | ------------- |
| 子部分           |                | Bear成员      |
| Endangered子部分 | Endangered成员 |               |
|                  |                | Panda成员     |

图18.2: Panda对象的概念结构

派生类构造函数初始化所有基类

< 804 I



构造一个派生类的对象将网时构造并初始化它的所有基类子对象。与从一个基类进行 的派生一样（参见15.2.2节，第531页），多重继承的派牛.类的构造函数初始值也只能初 始化它的直接基类：

//显式地初始化所有基类

Panda::Panda（std::string name, bool onExhibit）

:Bear（name, onExhibit, "Panda"）,

Endangered（Endangered::critical） { }

//隐式地使用Bear的默认构造函数初始化Bear子对象

Panda::Panda（）

:Endangered（Endangered::critical） { }

派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派 生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。 一个Panda对象按照如下次序进行初始化：

• ZooAnimal是整个继承体系的最终基类，Bear是Panda的直接基类， ZooAnimal是Bear的基类，所以首先初始化ZooAnimal。

•接下来初始化Panda的第一个直接基类Bear。

•然后初始化Panda的第二个直接基类Endangered。

•最后初始化Pandao

继承的构造函数与多重继承

[^Fl 在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数（参见15.7.4 节，第557页）。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同）， 则程序将产生错误：

struct Basel {

Basel () = default;

Basel(const std::strings);

Basel(std::shared_ptr<int>);

}；

struct Base2 {

Base2() = default;

Base2(const std::strings);

Base2(int);

}；

//错误：DI试图从两个基类中都继承■ DI:: DI (const strings) struct DI: public Basel, public Base2 {

using Basel: :Basel;    // 从 Basel 继承构造函数

using Base2 : :Base2;    // 从 Base2 继承构造函数

}；

如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它 自己的版本：

I 805〉    struct D2: public Basel, public Base2 {

using Basel: : Basel;    // 从 Basel 继承构造函数

using Base2 : :Base2;    // 从 Base2 继承构造函数

// D2必须自定义一个接受string的构造函数

D2(const string &s) : Basel (s), Base2(s) { }

D2() = default;    // 一旦D2定义了它自己的构造函数，则必须出现

析构函数与多重继承

和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及 基类都是自动销毁的。合成的析构函数体为空。

析构函数的调用顺序正好与构造函数相反，在我们的例子中，析构函数的调用顺序是 'Panda、 'Endangered、 'Bear和'ZooAnimalo

多重继承的派生类的拷贝与移动操作

与只有一个基类的继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数 和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作（参见15.7.2节，第553 页）。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部 分执行这些操作。在合成的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完 成构造、赋值或销毁等工作。

例如，假设Panda使用了合成版本的成员ling_ling的初始化过程: Panda ying yang（"ying yang"）;

Panda ling_ling = ying_yang;    // 使用拷贝构造A数

将调用Bear的拷贝构造函数，后者又在执行自己的拷贝任务之前先调用ZooAnimal的 拷贝构造函数。一旦ling_ling的Bear部分构造完成，接着就会调用Endangered 的拷贝构造函数来创建对象la应的部分。最后，执行Panda的拷贝构造函数。合成的移 动构造函数的工作机理与之类似。

合成的拷贝赋值运算符的行为与拷贝构造函数很相似。它首先赋值Bear部分(并且 通过Bear赋值ZooAnimal部分)，然后赋值Endangered部分，最后是Panda部分。 移动赋值运算符的工作机理与之类似。

###### 18.3.1节练习

练习18.21:解释下列声明的含义，在它们当中存在错误吗？如果有，请指出来并说明 错误的原因。

(a)    class CADVehicle : public CAD, Vehicle { ... };

(b)    class DblList: public List, public List { ... };

(c)    class iostream: public istream, public ostream { ... };

练习18.22：已知存在如下所示的类的继承体系，其中每个类都定义了一个默认构造函 数：

class A class B class C class X class Y



{•••};

:public A { ... }; :public B { ... }; {•••};

{..•};

class Z : public X, public Y { class MI : public C, public Z {

![img](C++  Primer 5-186.jpg)



对于下面的定义来说，构造函数的执行顺序是怎样的？

MI mi;

###### 18.3.2类型转换与多个基类

在只有一个基类的情况下，派生类的指针或引用能自动转换成一个可访问基类的指针 或引用(参见15.2.2节，第530页；参见15.5节，第544页)。多个基类的情况与之类似。

我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。例如，一个＜S ZooAnimal、Bear或Endangered类型的指针或引用可以绑定到Panda对象上：

//接受Panda的基类引用的一系列操作

void print(const Bear&);

void highlight(const EndangeredS);

ostream& operator«(ostreamS, const ZooAnimal&);

Panda ying_yang("ying_yang");

print (ying_yang) ;    //把一个Panda对象传递给一个Bear的引用

highlight (ying_yang) ;    // 把一个 Panda 对象传递给一个 Endangered 的引用

cout « ying_yang « endl; // 把一个 Panda 对象传递给一个 ZooAnimal 的引用

编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意 一种基类都一样好。例如，如果存在如下所示的print重载形式：

void print(const Bear&); void print(const Endangered&);

则通过Panda对象对不带前缀限定符的print函数进行调用将产生编译错误:

Panda ying_yang("ying_yangn);

print (ying_yang) ;    // 二义性错误

基于指针类型或引用类型的查找

与只有一个基类的继承一样，对象、指针和引用的静态类型决定了我们能够使用哪些 1~807＞成员(参见15.6节，第547页)。如果我们使用一个ZooAnimal指针，则只有定义在 ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered 特有的部分都不可见。类似的，一个Bear类型的指针或引用只能访问Bear及

ZooAnimal的成员，一个Endangered的指针或引用只能访问Endangered的成员。 举个例子，已知我们的类已经定义了表18.1列出的虚函数，考虑下面的这些函数调用：

| Bear *pb = new Panda (’’ying | yang"); |
| ---------------------------- | ------- |
| pb->print();                 | //正确  |
| pb->cuddle();                | //错误  |
| pb->highlight ();            | //错误  |
| delete pb;                   | //正确  |

Panda::print() 不属于Bear的接口 不属于Bear的接口 Panda::~Panda()

当我们通过Endangered的指针或引用访问一个Panda对象时，Panda接口中 Panda特有的部分以及属于Bear的部分都是不可见的：

Endangered *pe = new Panda ( ymg yang );



pe->print(); // pe->toes (); // pe->cuddle(); // pe->highlight(); // delete pe; II



正确：Panda: : print ()

错误：不属于Endangered的接口 错误：不属于Endangered的接口 正确：Panda: :highlight () 正确：Panda: : ~Panda ()



| 表18.1:在ZooAnimal/Endangered中定义的虚函数 |                                    |                                                              |
| ------------------------------------------- | ---------------------------------- | ------------------------------------------------------------ |
| 函数                                        |                                    | 含有自定义版本的类                                           |
| print                                       |                                    | ZooAnimal::ZooAnimalBear::BearEndangered::EndangeredPanda::Panda |
| highlight                                   | Endangered::EndangeredPanda::Panda |                                                              |
| toes                                        |                                    | Bear::BearPanda::Panda                                       |
| cuddle                                      |                                    | Panda::Panda                                                 |
| 析构函数                                    |                                    | ZooAnimal::ZooAnimalEndangered::Endangered                   |

###### 18.3.2节练习

练习18.23:使用练习18.22的继承体系以及下面定义的类D,同时假定每个类都定义 了默认构造函数，请问下面的哪些类型转换是不被允许的？

class D : public X, public C { ... };

D *pd = new D;

(a) X *px = pd;    (b) A *pa = pd;

(c) B *pb = pd;    (d) C *pc = pd;

练习18.24:在第714页，我们使用一个指向Panda对象的Bear指针进行了一系列调 用，假设我们使用的是一个指向Panda对象的ZooAnimal指针将发生什么情况，请 对这些调用语句逐一进行说明。

练习18.25:假设我们有两个基类Basel和Base2，它们各自定义了一^^名为print 的虚成员和一个虚析构函数。从这两个基类中我们派生出下面的类，它们都重新定义了 print函数：

class D1 : public Basel { /* ...*/ }; class D2 : public Base2 { /* . . .    ;

class MI : public DI, public D2 { /*...*/ };

通过下面的指针，指出在每个调用中分别使用了哪个困数：

Basel *pbl = new Base2 *pb2 = new Dl *pdl = new MI D2 *pd2 = new MI

(a) pbl->print ();

(d)delete pb2;



MI;

MI;



(b) pdl_〉print ();

(e) delete pdl;



(c) pd2->print (); (f) delete pd2;



###### 18.3.3多重继承下的类作用域

在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中 (参见15.6节，第547页)。查找过程沿着继承体系自底向上进行，直到找到所需的名字。 派生类的名字将隐藏基类的同名成员。

在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个 基类中都被找到，则对该名字的使用将具有二义性。

在我们的例子中，如果我们通过Panda的对象、指针或引用使用了某个名字，则程 序会并行地在Endangered和Bear/ZooAnimal这两棵子树中查找该名字。如果名字 在超过一棵子树中被找到，则该名字的使用具有二义性。对于一个派生类来说，从它的几 个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时必须明确指出 它的版本。

<808 |



/j\    当•一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名

成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性,，

例如，如果ZooAnimal和Endangered都定义了名为max_weight的成员，并且 Panda没有定义该成员，则下面的调用是错误的：

double d = ying_yang.max_weight();

Panda在派生的过程中拥有了两个名为max_weiglit的成员，这是完全合法的。派生仅 仅是产生了潜在的二义性，只要Panda对象不调用max_weight函数就能避免二义性错 误。另外，如果每次调用max_weight时都指出所调用的版本

< 809 1



(ZooAnimal: :max_weight 或者 Endangered: :max_weight),也不会发生二义性。 只有当要调用哪个函is(含糊不清时程序才会出错。

在上面的例子中，派生类继承的两个max_weight会产生二义性，这一点显而易见。 一种更复杂的情况是，有时即使派生类继承的&个函数形参列表不同也可能发生错误。此 外，即使maX_weight在一个类中是私有的，而在另一个类中是公有的或受保护的同样 也可能发生错误。最后一种情况，假如max_weight定义在Bear中而非ZooAnimal 中，上面的程序仍然是错误的。

和往常一样，先查找名字后进行类型检查(参见6.4.1节，第210页)。当编译器在两 个作用域中同时发现了 max_weight时，将直接报告一个调用二义性的错误。

要想避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本。例如， 我们可以为Panda定义一个max_weight函数从而解决二义性问题：

double Panda::max_weight() const

{

return std::max(ZooAnimal::max_weight(),

Endangered::max_weight());

}

###### 18.3.3节练习

struct Basel {

void print (int) const;    //默认情况下是公有的

protected:

int ival; double dval; char cval; private:

int *id;

}；

struct Base2 {

void print (double) const;    //默认情况下是公有的

protected:

double fval; private:

double dval;

}；

struct Derived : public Basel {

void print (std: :string) const; // 默认情况下是公有的

protected:

std::string sval; double dval;

}；

struct MI : public Derived, public Base2 {

void print (std: : vector<double>) ; // 默认情况下是公有的

protected:

int *ival;

std::vector<double> dvec;

}；

练习18.26：已知如上所示的继承体系，下面对print的调用为什么是错误的？适当修 改MI,令其对print的调用可以编译通过并正确执行。

MI mi;

mi.print(42);

练习18.27:已知如上所示的继承体系，同时假定为MI添加了一个名为foo的函数：

int ival; double dval;

void MI::foo(double cval)

{

int dval;

//练习中的问题发生在此处

}

(a)    列出在MI: : foo中可见的所有名字。

(b)    是否存在某个可见的名字是继承自多个基类的？

(c)    将Basel的dval成员与Derived的dval成员求和后赋给dval的局部实例。

(d)    将MI: : dvec的最后一个元素的值赋给Base2 : : fval。

(e)    将从Basel继承的cval赋给从Derived继承的sval的第一个字符。

###### 18.3.4虚继承

< 810 1



尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个 类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基 类，然后通过另一个基类再一次间接继承该类。

举个例子，10标准库的istream和ostream分别继承了一个共同的名为base_ios 的抽象基类。该抽象基类负责保存流的缓冲内容并管理流的条件状态。iostreami另外 一个类，它从istream和ostream直接继承而来，可以同时读写流的内容。因为istream 和ostream都继承自base_ios,所以iostream继承了 base_ios两次，一次是通 过istream.另一次是通过ostream,,

在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程 中出现了多次，则派生类中将包含该类的多个子对象。

这种默认的情况对某些形如iostream的类显然是行不通的。一个iostream对象 肯定希望在同一个缓冲区中进行读写操作，也会要求条件状态能同时反映输入和输出操作 的情况。假如在iostream对象中真的包含了 base_ios的两份拷贝，则上述的共享行 为就无法实现了。

在C++语言中我们通过虚继承(virtual inheritance)的机制解决上述问题。虚继承的 目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类 (virtual base class)。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中 都只包含唯一一个共享的虚基类子对象。

另一个Panda类

在过去，科学界对于大熊猫属于Raccoon科还是Bear科争论不休。为了如实地反映 这种争论，我们可以对Panda类进行修改，令其同时继承Bear和Raccoon。此时，为 了避免赋予Panda两份ZooAnimal的子对象，我们将Bear和Raccoon继承

ZooAnimal的方式定义为虚继承。图18.3描述了新的继承体系。

![img](C++  Primer 5-187.jpg)



观察这个新的继承体系，我们将发现虚继承的一个不太直观的特征：必须在虚派生的 ft实需求出现前就已经完成虚派生的操作。例如在我们的类中，当我们定义Panda时才 出现了对虚派生的需求，但是如果Bear和Raccoon不是从ZooAnimal虚派生得到的， 那么Panda的设计者就显得不太幸运了。

在实际的编程过程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么 问题。通常情况下，使用虚继承的类层次是由一个人或一个项目组一次性设计完成的。对 于一个独立开发的类来说，很少需要基类中的某一个是虚基类，况且新基类的开发者也无 法改变已存在的类体系。

![img](C++  Primer 5-188.jpg)



虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生 类本身3

使用虚基类

我们指定虚基类的方式是在派生列表中添加关键字virtual:

//关键字public和virtual的顺序随意

class Raccoon : public virtual ZooAnimal { /* …*/ }; class Bear : virtual public ZooAnimal { /* ...★/ };

通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类。

virtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。 至于什么样的类能够作为虚基类并没有特殊规定。

如果某个类指定了虚基类，则该类的派生仍按常规方式进行：

class Panda : public Bear,

public Raccoon, public Endangered {

}；

Panda 通过 Raccoon 和 Bear 继承了 ZooAnimal,因为 Raccoon 和 Bear 继承 ZooAnimal的方式都是虚继承，所以在Panda中只有一个ZooAnimal基类部分。

支持向基类的常规类型转换

不论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。例如，下 面这些从Panda向基类的类型转换都是合法的：

void dance(const Bears); void rummage(const Raccoons);

ostream& operator«(ostreamS, const ZooAnimal&);

Panda ying_yang;

dance (ying_yang) ;    //正确：把一个Panda对象当成Bear传递

rummage (ying_yang) ;    // 正确：把一个 Panda 对象当成 Raccoon 传递

cout << ying yang;    // 正确：把■个 Panda 对象当成 ZooAnimal 传递

虚基类成员的可见性

因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直 接访问，并且不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们 仍然可以直接访问这个被覆盖的成员。但是如果成员被多余一个基类覆盖，则一般情况下 派生类必须为该成员自定义一个新的版本。

例如，假定类B定义了一个名为x的成员，D1和D2都是从B虚继承得到的，D继 承了 D1和D2,则在D的作用域中，x通过D的两个基类都是可见的。如果我们通过D 的对象使用x,有三种可能性：

•如果在D1和D2中都没有x的定义，则X将被解析为B的成员，此时不存在二义 性，一个D的对象只含有x的一个实例。

•如果x是B的成员，同时是D1和D2中某一个的成员，则同样没有二义性，派生 类的x比共享虚基类B的x优先级更高。

•如果在D1和D2中都有x的定义，则直接访问x将产生二义性问题。

与非虚的多重继承体系一样，解决这种二义性问题最好的方法是在派生类中为成员自定义 新的实例。

###### 18.3.4节练习

练习18.28:已知存在如下的继承体系，在VMI类的内部哪些继承而来的成员无须前缀 限定符就能直接访问？哪些必须有限定符才能访问？说明你的原因。 struct Base {

void bar (int) ;    //默认情况下是公有的

protected:

int ival;

}；

struct Derivedl : virtual public Base {

void bar (char) ;    //默认情况下是公有的

void foo (char);

protected:

char cval;

}；

struct Derived2 : virtual public Base {

void foo (int) ;    //默认情况下是公有的

protected:

int ival;

| char cval;    |                                   |      |
| ------------- | --------------------------------- | ---- |
| ｝；class VMI | :public Derivedl, public Derived2 | }；  |

###### 18.3.5构造函数与虚继承

在虚派生中，虚基类是由最低层的派生类初始化的。以我们的程序为例，当创建Panda 对象时，由Panda的构造函数独自控制ZooAnimal的初始化过程。

为了理解这一规则，我们不妨假设当以普通规则处理初始化任务时会发生什么情况。 在此例中，虚基类将会在多条继承路径上被重复初始化。以ZooAnimal为例，如果应用 普通规则，则Raccoon和Bear都会试图初始化Panda对象的ZooAnimal部分。

当然，继承体系中的每个类都可能在某个时刻成为“最低层的派生类”。只耍我们能 创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。例如在我们的 继承体系中，当创建一个Bear (或Raccoon)的对象时，它已经位于派生的最低层，因 此Bear (或Raccoon)的构造函数将直接初始化其ZooAnimal基类部分：

Bear::Bear(std::string name, bool onExhibit):

ZooAnimal(name, onExhibit, "Bear") { }

Raccoon::Raccoon(std::string name, bool onExhibit)

:ZooAnimal (name, onExhibit, ’’Raccoon") { }

而当创建一个Panda对象时，Panda位于派生的最低层并由它负责初始化共享的 ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数 也可以初始化ZooAnimal：

Panda::Panda(std::string name, bool onExhibit)

:ZooAnimal(name, onExhibit, "Panda"),

Bear(name, onExhibit),

Raccoon(name, onExhibit),

Endangered(Endangered::critical), sleeping_flag(false) { }

虚继承的对象的构造方式

含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类 构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现 的次序依次对其进行初始化。

例如，当我们创建一个Panda对象时：

•首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal 部分。

•接下来构造Bear部分。

•然后构造Raccoon部分。

•然后构造第三个直接基类Endangered。

•最后构造Panda部分。

如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被 调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。

![img](C++  Primer 5-189.jpg)



虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。

构造函数与析构函数的次序

一个类可以有多个虚基类。此吋，这些虚的子对象按照它们在派生列表中出现的顺序 从左向右依次构造。例如，在下面这个稍显杂乱的TeddyBear派生关系中有两个虚基类：＜M] ToyAnimal是直接虚基类，ZooAnimal是Bear的虚基类：

class Character { /*...*/ };

class BookCharacter : public Character { /* ...*/ };

class ToyAnimal { /★ . ..★/ };

class TeddyBear : public BookCharacter,

public Bear, public virtual ToyAnimal { /★...*/};

编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如 果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。因此，要想创建一 个TeddyBear对象，需要按照如下次序调用这些构造函数：

ZooAnimal();



ToyAnimal (}; Character(); BookCharacter(); Bear ();

TeddyBear();



// Bear的虚基类

//直接虚基类

//第一个非虚基类的间接基类 //第一个直接非虚基类 //第二个直接非虚基类 //最低层的派生类

合成的拷贝和移动构造函数按照完全相同的顺序执行，合成的赋值运算符中的成员也 按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反，首先销毁 TeddyBear部分，最后销毁ZooAnimal部分。

###### 18.3.5节练习

| 练习18.29: | 已知有如下所示的类继承关系： |                               |        |
| ---------- | ---------------------------- | ----------------------------- | ------ |
| class      | Class                        | {•••};                        |        |
| class      | Base                         | :public Class { ... };        |        |
| class      | D1 :                         | virtual public Base { ... };  |        |
| class      | D2 :                         | virtual public Base { ... };  |        |
| class      | MI :                         | public DI, public D2 { ... }; |        |
| class      | Final                        | :public MI, public Class {    | .• }； |

(a)    当作用于一个Final对象时，构造函数和析构函数的执行次序分别是什么？

(b)    在一个Final对象中有几个Base部分？几个Class部分？

(c＞下面的哪些赋值运算将造成编译错误？

Base *pb;    Class *pc;    MI *pmi;    D2 *pd2 ;

(a) pb = new Class;    (b) pc = new Final;

(c)    pmi = pb;    (d) pd2 = pmi;

练习18.30：在Base中定义一个默认构造函数、一个拷贝构造函数和一个接受int形 参的构造函数。在每个派生类中分别定义这三种构造函数，每个构造函数应该使用它的 实参初始化其Base部分。

1~816> 小结

C++语以用r解决各种类型的问题，既有儿个小吋就可以解决的小问题，也有一 个人团队工作数年才能解决的超火规模问题。C++的某些特性特別适合r处理超大规模问 题，这些特性包括：异常处现、命名空间以及多s继承或虚继承，

异常处坤.使得我们||了以将程序的错误检测部分与错误处理部分分隔开來。当枵序抛出 •个洋常时，3前止在执行的函数暂时中lb汗始查找最邻近的与异常匹配的catch语 句.作为异常处琍的•-部分,如果査找catch语句的过程中退出了某些函数,则函数中

定义的局部变8:也随之销毁。

命名空间是-种管理人规模复杂应用程序的机制，这桦应用可能是由多个独立的供应 商分别编写的代码组合而成的。一个命名空间是，个作用域，我们可以在其中定义对象、 类型、函数、模板以及其他命名空间。标准库定义在名为std的命名空间中。

从概念上來说，多重继承非常简单：一个派生类可以从多个直接基类继承而來。在派 屮类对象中既包含派生类部分，也包含毎个基类对应的基类部分。虽然看起来很简单， W实际上多《继承的细节非常复杂。特别是对多个基类的继承nJ■能会引入新的名字冲突， 丼造成來自P基类部分的名字的.义性问题。

如果-个类是从多个萆类直接继承而來的，那么有可能这些基类本身又共亨r另•个 荜类。在这种情况下，中间类可以选择使用虚继承.从而声明愿意与层次中虚继承-基 类的其他类共享虚基类。用这种方法，后代派生类中将只有-个共享虚基类的副本。



##### 术语表

捕获所有异常(catch-all)异常声明形如(...) 的catch子句。一条捕获所有异常的子句 可以捕获任意类型的异常。常用于捕获局 部检测的异常，该异常将K新抛出到程序 的其他部分并最终解决问题。

catch子句(catch clause)祥序屮负责处

理异常的部分。catch子'nJ包含关键字 catch,后面是异常声明以及-个i&句块。 catch户句的代码负责处理异常声明中定 义的异常。

构造函数顺序(constructor order)在非虚

继承中，基类的构造顺序~其在派生列表 中出现的顺序•-致。在虚继承中，首先构 造虚幕类。虚基类的构造顺序与其在派生 类的派牛.列表中出现的觀序一致。只有最 低U的派生类才能初始化虛蓽类。虚基类 的初始值如果出现在中间基类中，则这些 初始值将被忽略。

异常声明(exceptiondeclaration) catch 子句中指定其能够处理的异常类型的部 分。异常声明的行为与形参列表类似，其 中的唯--个形参通过异常对象进行初始 面1＞化。如果异常说明符是非引用类型，则异 常对象将被拷贝给catch。

异常处理(exception handling)管现运打

时异常的语S级支持。代码中—个独立开 发的部分町以检测并引发异常，由程序的 另- '个独立开发的部分处理该异常。也就 是说，程序的错误检测部分负责抛出异常， 而错误处珲部分在try语句块的catch 子句中处理异常。

异常对象(exception object)用干在异常

的throw和catch之间进行通信的对象。 在抛出点创建该对象，该对象是被抛出的 表达式的副本。在该异常的最后一段处理 代码完成之前异常对象都-•直存在。异常 对象的类型是被抛出的表达式的静态类型。



文件中的静态声明(file static)使用关键

字static声明的仅对当前文件有效的名 字。在C语言和之前的C++版本中，文件 中的静态声明用于声明只能在当前文件中 使用的名字。该特性在逬前的C++版本中 已经被未命名的命名空间替换了。

函数try语句块(function try block)用于

捕获构造函数初始化过程发生的异常。关 键字try出现在表示构造函数初始值列表 开始的冒号之前(或者当初始值列表为空 时出现在函数体的左侧花括号之前)，并以 函数体右侧花括号之后的一个或几个 catch子句作为结束。

全局命名空间(global namespace)是每

个程序的隐式命名空间，用于存放全局定 义。

处理代弭(handler)是“catch子句” 的同义词。.

内联的命名空间(inline namespace)内

联命名空间中的名字可以看成是外层命名 空间的成员。

多重继承(multiple inheritance)有多个直

接基类的类，派生类继承所有基类的成员。 可以为每个基类分别设定访问说明符。

命名空间(namespace)将库或者其他程

序集定义的名字放在同一个作用域中的机 制。和C++的其他作用域不同，命名空闾 作用域可以定义成几个部分。我们可以打 开并关闭命名空间，然后在程序的另一个 地方重新打开并关闭该命名空间。

命名空间的别名(namespace alias)为某

个给定的命名空间定义同义词的机制：

namespace Nl = N；

将N1定义成命名空间N的另一个名字。 命名空间可以含有多个别名，命名空间的 原名和别名是等价的。

命名空间污染(namespace pollution)当

所有类和函数的名字都放置于全局命名空 间时将造成命名空间污染。如果来自于多 个独立供应商的代码都含有全局名字，则 使用这些代码的大型程序很可能会面临命

名空间污染的问题。

noexcept 运算符(noexcept operator)该

运算符返回一个bool值，用于表示给定 的表达式是否会抛出异常。该表达式不会 被求值，运算的结果是一个常最表达式。 当提供的表达式不含throw并且只调用了 做出不抛出说明的函数时，结果为true； 否则结果为false。

noexcept 说明(noexcept specification)表

示函数是否会抛出异常的关键字。当 noexcept跟在函数的形参列表之后时， 它可以连接一个括号括起来的常暈表达 式，前提是该表达式可以转换成bool值。 如果忽略了该表达式，或者表达式的值为 true,则函数不会抛出异常。如果表达式 的值是false或荇函数没有异常声明，则 其可能抛出异常。

不抛出说明(nonthrowing specification)该

异常说明用于承诺某个函数不会抛出异 常。如果一个做了不抛出说明的函数实际 抛出了异常，将调用terminateo不抛出 说明符是不含实参或者含有-个值为 true 的实参的 noexcept-

引发(raise)常常作为抛出的同义词。C++ 程序员认为抛出异常和引发异常基本上是 等价的。

重新抛出(rethrow)不指定表达式的

throw。重新抛出只有在catch '.f•句内部 或者被catch直接或间接调用了的函数内 时才有效。它的效果是将其接受的异常重 新抛出。

找展开(stack unwinding)在搜寻 catch 时依次退出函数的过程。异常发生前构造 的局部对象将在进入相应的catch前被销 毁。

terminate是--个标准庠函数，当异常未被 捕获或者在处理异常的过程中发生了另一 个异常时，terminate负责结束程序的执 行。

throw e该表达式将中断当前的执行路径， throw语句将控制权传递给最近的能够处

< 818 I



现该异常的catch子句。表达式e将被拷 贝给异常对象。

try语句块(try block)含有关键字try以

及--个或多个catch _f•句的语句块。如果 try语句块中的代码引发了一个异常，并 R某个catch可以匹配该异常，则异常将 波这个catch处理。否则，异常被传递到 try语句块之外并继续沿着调用链寻找与 之匹配的catch。

未命名的命名空间(unnamed namespace)

定义时未指定名字的命名空间。对于定义 在未命名的命名空间中的名字，我们可以 不用作用域运算符就直接访问它们。毎个 文件有一个独有的未命名的命名空间，其 中的名字在文件外不可见。

using 声明(using declaration)是一-种将

命名空间中的某个名字注入当前作用域的 机制：

using std：:cout；

上述语句使得命名空间std中的名字 cout在当前作用域可见-之后，我们就町 以直接使用cout而无须前缀std: : 了。

using指示(using directive)是具有如下

形式的声明： using NS;

上述语句使得命名空间NS的所有名字在 using指示所在的作用域以及NS所在的 作用域都变得可见。

虚基类(virtual base class)在派生列表中

使用了关键字virtual的基类。在派屯类 对象中，虚基类部分只有--份，即使该虚 基类在继承体系中出现了多次也是如此。 对于非虚继承而言，构造函数只能初始化 它的直接基类。但是对于虚继承来说，虚 基类将被最低S的派生类初始化，因此最 低层的派生类应该含有它的所有虚基类的 初始值。

虚继承(virtual inheritance)足多S继承

的一种形式，基类被继承了多次，何是派 屯类共享该基类的唯一-份副本。

作用域运算符(:：operator)用于访|'«J命

名空间或类中的名字，
