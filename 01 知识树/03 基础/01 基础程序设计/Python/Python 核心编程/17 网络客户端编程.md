网络客户端编程

![img](07Python38c3160b-2373.jpg)



本章主题

*引言

•文件传输

•文件传输协议(FTP)

•网络新闻、Usenet,和新闻组 •网络新闻传输协议(NNTP)

•电子邮件

•简单邮件传输协议(SMTP)

•邮局协议3(POP3)

•相关模块

![img](07Python38c3160b-2374.jpg)



![img](07Python38c3160b-2375.jpg)



![img](07Python38c3160b-2376.jpg)



![img](07Python38c3160b-2377.jpg)



![img](07Python38c3160b-2378.jpg)



![img](07Python38c3160b-2379.jpg)



![img](07Python38c3160b-2380.jpg)



![img](07Python38c3160b-2381.png)



在之前的章节中，我们已经大致了解了那些使用套接字的低级别的网络通讯协议。这种网络互 连是当今互联网中大部分客户端/服务器协议的核心。这些网络协议包括文件传输(FTP, SCP等)，

阅读Usenet新闻组(NNTP)，e-mail发送(SMTP)，从服务器上下载e-mail(POP3，I撤P)等等。这些 协议的工作方式与之前在套接字编程中介绍的客户端/服务器的例子很像。唯一的不同在于，我们

已经使用过TCP/IP等低级别的协议，并基于此创建了新的，更具体的协议来实现我们刚刚描述的 瞥服务。    H

### 17.1什么是因特网客户端？

在着手研究这些协议之前，我们要先问一个问题：“因特网客户端到底是什么”？要回答这个问

题，我们把因特网简化成一个数据交换中心，数据交换的参与者是一个服务提供者和一个服务的使

用者。有的人把它称为“生产者－消费者”(虽然这个词一般只用在讲解操作系统相关信息时)。服

务器就是生产者，它提供服务，一般只有一个服务器(进程或主机等)，和多个消费者，就像我们之

前看的客户端/服务器模型那样。虽然现在我们不再使用底级别的套接字来创建因特网客户端，但

模型是完全相同的。

这里，我们将详细了解三个因特网协议——FTP，NNTP和POP3，并写出它们的客户端程序。通 过这些程序，你将会发现这些协议的API是多么的相似——由于保持接口的一致性有很大的好处， 所以，这些相似性在设计之初就考虑到了——更重要的是，你还能学会如何写出这些协议与其它协 议实用的客户端程序来。虽然我们只着重说了这三个协议。在看完这些协议后，你就能有足够的信 心和能力写出任何因特网协议的客户端程序了。

![img](07Python38c3160b-2382.jpg)



17.2 文件传输

17.2.1 文件传输因特网协议

因特网中最流行的事情就是文件的交换。文件交换无处不在。有很多协议可以供因特网上传输

文件使用。最流行的有文件传输协议（FTP） Unix-to-Unix复制协议（UUCP）以及网页的超文本传输 协议（HTTP）。另外，还有（Unix下的）远程文件复制指令rcp （以及更安全，更灵活的scp和rsync）。

迄今为止，HTTP，FTP和scp/rsync还是非常流行的。HTTP主要用于网页文件的下载和访问Web 服务上。它一般不要求用户输入登录的用户名密码就可以访问服务器上的文件和服务。HTTP文件传 输请求主要是用于获取网页（文件下载）。

相对的，scp和rsync要求用户登录到服务器，否则不能上传或下载文件。至于FTP，跟scp/rsync 一样，可以上传或下载文件，还采用了 Unix的多用户的概念，用户一定要输入有效的用户名和密码 才能使用。不过，FTP也允许匿名登录。接下来，我们先仔细看看FTP。

17.2.2文件传输协议（FTP）

文件传输协议由已故的Jon Postel和Joyce Reynolds开发，记录在RFC（Request for — Comment）959号文档中，于1985年10月发布。它主要用于匿名下载公共文件。也可以用于在两台 电脑之间传输文件，尤其是在使用Unix系统做为文件存储系统，使用其它机器来工作的情况。早

在网络流行之前，FTP就是在因特网上文件传输，软件和源代码下载的主要手段之一。

FTP要求输入用户名和密码才能访问远程的FTP服务器，但它也允许没有帐号的用户以匿名用户 登录。不过，管理员要先设置FTP服务器允许匿名用户登录。这时，匿名用户的用户名是“anonymous”

密码一般是用户的e-mail地址。与特定的用户拥有特定的帐户不同，这有点像是把FTP公开出来让 大家访问。匿名用户通过FTP协议可以使用的命令与一般的用户相比来说，限制更多。

图17-1展示了这个协议，其工作流程如下：

\1.    客户端连接远程的FTP服务器

\2.    客户端输入用户名和密码（或“anonymous”和e-mail地址）

\3.    客户端做各种文件传输和信息查询操作

\4.    客户端登出远程FTP服务器，结束通讯

当然，这只是很泛的一个流程。有时，由于网络两边电脑的崩溃或是网络的问题，会导致整个

事务在完成之前被中断。一般，在客户端超过15分钟（900秒）不活动之后，连接就会被关闭。

在底层上，FTP只使用TCP （见前面网络编程相关章节）一一它不使用UDP。而且，FTP是客户 端／服务器编程中很“与众不同”的例子。客户端和服务器都使用两个套接字来通讯：一个是控制 和命令端口（21号端口），另一个是数据端口（有时是20号端口）。

图17-1因特网上的FTP客户端和服务器。客户端和服务器使用指令和控制端口发送FTP协议， 而数据通过数据端口传输。

我们说“有时”是因为FTP有两种模式：主动和被动。只有在主动模式服务器才使用数据端口。 在服务器把20号端口设置为数据端口后，它“主动”连接客户端的数据端口。而被动模式中，服务 器只是告诉客户端它的随机端口的号码，客户端必须主动建立数据连接。在这种模式下，你会看到， FTP服务器在建立数据连接时是“被动”的。最后，现在已经有了一种扩展被动模式来支持第6版本 的因特网协议（IPv6）地址——见RFC 2428。

Python已经支持了包括FTP在内的大多数据因特网协议。支持各个协议的客户端模块可以在 [http://docs.python.org/lib/internet.html找到。现在看看用Python创建一个因特网客户端程](http://docs.python.org/lib/internet.html%e6%89%be%e5%88%b0%e3%80%82%e7%8e%b0%e5%9c%a8%e7%9c%8b%e7%9c%8b%e7%94%a8Python%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%9b%a0%e7%89%b9%e7%bd%91%e5%ae%a2%e6%88%b7%e7%ab%af%e7%a8%8b) 序有多简单。

### 17.2.3 Python 和 FTP

那么，我们怎么用Python写FTP客户端程序呢？其实，我们之前已经提到过一些了。现在还要 再加上相应的Python模块导入和调用的操作。现在再来回顾一下流程：

\1.    连接到服务器

\2.    登录

\3.    发出服务请求 （有可能有返回信息）

\4.    退出

在使用Python的FTP支持时，你所需要做的就是导入ftplib模块，并实例化一个ftplib.FTP 类对象。所有的FTP操作（如登录，传输文件和登出等）都要使用这个对象来完成。下面是一段Python 的伪代码：

from ftplib import FTP

f = FTP('ftp.python.org') f.login('anonymous'， 'guess@who.org')



f.quit()

在看真实的例子之前，我们要先熟悉一下ftplib.FTP类的方法，这些方法将在代码中用到。

### 17.2.4 ftplib.FTP 类方法

在表17.1中列出了最常用的方法，这个表并不全面——想查看所有的方法，请参阅模块源代码 ——但这里列出的方法组成了我们在Python中FTP客户端编程的“API”。

也就是说，你不一定要使用其它的方法，因为它们或者是辅助函数，或者是管理函数，或者是 被API调用的。

表17.1 FTP对象的方法

方法

login(user='anonymous'， passwd=''， acct='') pwd()

cwd(path)

dir([path[，...[，cb]])

nlst([path[，...])

retrlines(cmd [， cb])



retrbinary(cmd， cb[， bs=8192[， ra]])

storlines(cmd， f)



storbinary(cmd， f[， bs=8192])

rename(old， new)

delete(path)

mkd(directory)



描述

登录到FTP服务器，所有的参数都是可选的    H

得到当前工作目录 把当前工作目录设置为path

显示path目录里的内容，可选的参数cb是一个回调函数，它 会被传给retrlinesO方法

与dir（）类似，但返回一个文件名的列表，而不是显示这些文 件名

给定FTP命令（如“RETR filename”），用于下载文本文件。

可选的回调函数cb用于处理文件的每一行

与retrlinesO类似，只是这个指令处理二进制文件。回调函 数cb用于处理每一块（块大小默认为8K）下载的数据。

给定FTP命令（如“STOR filename”），以上传文本文件。要 给定一个文件对象f

与storlinesO类似，只是这个指令处理二进制文件。要给定 一个文件对象f，上传块大小bs默认为8Kbs=8192］）

把远程文件old改名为new

删除位于path的远程文件

创建远程目录

![img](07Python38c3160b-2389.jpg)



![img](07Python38c3160b-2390.jpg)



rmd(directory)    删除远程目录

quit()    关闭连接并退出

在一般的 FTP 通讯中，要使用到的指令有 login(), cwd(), dir(), pwd(), stor*(), retr*() 和quit()。有一些没有列出的FTP对象方法也是很有用的。请参阅Python的文档以得到更多关于 FTP对象的信息：

<http://python.org/docs/current/lib/ftp-objects.html>

### 17.2.5交互式FTP示例

在Python中使用FTP非常的简单，你甚至可以不用写脚本，直接在交互式解释器中实时地看到

交互与输出。下面这个例子是在几年前，python.org还支持ftp服务的时候做的：

»> from ftplib import FTP »> f = FTP( 1 ftp.python.org')

»> f . login ( 1 anonymous 1 ,    ' -helpGpython. org 1 )

1230 Guest login okf access restrictions apply.1 >>> f.dir()

total 36

![img](07Python38c3160b-2391.jpg)



| drwxrwxr-K | 10   | 1075  | 4127  | 512  | May  | 17   | 2000   |      |           |
| ---------- | ---- | ----- | ----- | ---- | ---- | ---- | ------ | ---- | --------- |
| drwxrwxr-x | 10   | 107 5 | 4127  | 512  | May  | 17   | 2000   |      |           |
| drwxr-xr-x | 3    | root  | wheel | 512  | May  | 19   | 1998   | bin  |           |
| drwxr-sr-K | 3    | root  | 1400  | 512  | Jun  | 9    | 1997   | dev  |           |
| drwxr-xr-K | 3    | root  | wheel | 512  | May  | 19   | 1998   | etc  |           |
| Irwxrwxrwx | 丄   | root  | bin   | 7    | Jun  | 29   | 19 9 9 | lib  | > usr/lib |
| -r——r--r-- | 丄   | guido | 4127  | 52   | Mar  | 24:  | 2000   | motd |           |
| drwcrwsr-x | 9    | 1122  | 4127  | 512  | May  | 17   | 2000   | pub  |           |
| drwxr-Kr-K | 5    | root  | wheel | 512  | May  | 19   | 1998   | usr  |           |

\>>> f.rstrlines('RETR motd1)

Sun Microsystems Inc. SunOS 5.6    Generic August 1997

'226 Transfer coniplGte .

»> f . quit ()

'221 Goodbye.'



![img](07Python38c3160b-2392.jpg)



### 17.2.6客户端FTP程序举例

之前我们说过，你可以不写脚本，在交互环境中使用FTP。不过，下面我们还是要写一段脚本， 假设你要从Mozilla的网站下载最新的Bugzilla的代码。例17.1就是用来完成这个工作的。我们 在试着写一个应用程序，不过，你也可以交互式地运行这段代码。我们的程序使用FTP库来下载文 件，也做了一些错误检测。

不过，程序并不完全自动。你要自己决定什么时候要去下载。如果你在使用类Unix系统，你可 以设定一个“cron”任务来自动下载。另一个问题是，如果文件的文件名或目录名改了的话，程序 就不能正常工作了。

![img](07Python38c3160b-2393.jpg)



![img](07Python38c3160b-2394.jpg)



例 17.1 FTP 下载示例(getLatest[FTP.py](ftp://FTP.py))

这个程序用于下载网站中最新版本的文件。你可以修改这个程序让它下载你喜欢的程序。

1    #!/usr/bin/env python

2

3    import ftplib

4    import os

5    import socket

6

7    HOST = 'ftp.mozilla.org'

8    DIRN = 'pub/mozilla.org/webtools'

9    FILE = 'bugzilla-LATEST.tar.gz'

10

11    def main():

12    try:

13    f = ftplib.FTP(HOST)

14    except (socket.error, socket.gaierror), e:

![img](07Python38c3160b-2395.jpg)



15    print 'ERROR: cannot reach "%s"' % HOST

16    return

17    print '*** Connected to host "%s"' % HOST 18

19    try:

20    f.login()

21    except ftplib.error_perm:

22    print 'ERROR: cannot login anonymously'

23    f.quit()

24    return

25    print '*** Logged in as "anonymous"'

26

27    try:

28    f.cwd(DIRN)

29    except ftplib.error_perm:

30    print 'ERROR: cannot CD to "%s"' % DIRN

31    f.quit()

32    return

33    print '*** Changed to "%s" folder' % DIRN

34

35    try:

![img](07Python38c3160b-2396.jpg)



![img](07Python38c3160b-2397.jpg)



36    f.retrbinary('RETR %s' % FILE，

37    open(FILE， 'wb').write)

38    except ftplib.error_perm:

39    print 'ERROR: cannot read file "%s"' % FILE

40    os.unlink(FILE)

41    else:

42    print '*** Downloaded "%s" to CWD' % FILE

43    f.quit()

44    return

45

46    if __name__ == '__main__':

47    main()

如果运行脚本时没有出错，则会得到如下输出：

$ getLatest[FTP.py](ftp://FTP.py)

*** Connected to host "[ftp.mozilla.org](ftp://ftp.mozilla.org)"

*** Logged in as "anonymous"

*** Changed to "pub/mozilla.org/webtools" folder *** Downloaded "bugzilla-LATEST.tar.gz" to CWD $

![img](07Python38c3160b-2398.jpg)



逐行解释

#### 1-9行

代码前几行导入要用的模块和设置一些常量

#### 11-44行

main（）函数分为以下几步：创建一个FTP对象，尝试连接到FTP服务器（12-17行）然后返回。 在有任何错误发生的时候退出。我们尝试用“anonymous”登录，如果不行就结束（19-25行）。下一 步就是转到发布目录（27-33行），最后，下载文件（35-44行）。

在35-36行，我们传了一个回调函数给retrbinaryO，它在每接收到一块二进制数据的时候都 会被调用。这个函数就是我们创建的本地文件对应文件对象的write方法。在传输结束的时候，Python 解释器会自动关闭这个文件对象，而不会丢失数据。虽然这样方便，但最好还是不要这样做，做为 一个程序员，要尽量做到在资源不再被使用的时候就直接释放，而不是依赖其它代码来做释放操作。 在这里，我们应该把文件对象保存到一个变量中，如变量loc，然后把loc.write传给 ftp.retrbinary（）方法。

在代码中，如果由于某些原因我们无法保存这个文件，那要把存在的空文件给删掉，以防搞乱



文件系统（40行）。最后，我们使用了 try-except-else子句（35-42行），而不是写两遍关闭FTP 连接然后返回的代码。



#### 46-47行

这是运行独立脚本的惯用方法。

### 17.2.7 FTP的其它方面

Python同时支持主动和被动模式。注意，在Python2.0及以前版本中，被动模式支持默认是关 闭的，在Python2.1及以后版本中，默认是打开的。

以下是一些典型的FTP客户端类型：

•命令行客户端程序：你可以使用一些FTP文件传输工具如/bin/ftp或NcFTP，它们允许用户 在命令行交互式的参与到FTP通讯中来。

• GUI客户端程序：与命令行客户端程序相似，只是它是一个GUI程序。如WsFTP和Fetch等。

•网页浏览器：在使用HTTP之外，大多数网页浏览器（也是一个客户端）可以进行FTP通讯。

![img](07Python38c3160b-2401.jpg)



URL/URI的第一部分就用来表示所使用的协议，如“http://blahblah.”这就告诉浏览器要 使用HTTP做为与给定网站进行通讯的协议。修改协议部分，就可以发使用FTP的请求，如 “ftp://blahblah.”这跟使用HTTP的网页的URL很像。（当然，“ftp://”后面的“blahblah”

可以展开为“host/path?attributes”）。如果要登录，用户可以把登录信息（以明文方式）一 放在 URL 里，如：“ftp://user:passwd@host/path?attr1=val1&attr2=val2...”.

•定制程序：你自己写的用于FTP文件传输的程序。由于程序用于特殊目的，一般这种程序都 不允许用户与服务器接触。

这四种客户端类型都可以用Python来写。上面，我们用ftplib来创建了一个自己的定制程序， 你也可以自己做一个命令行的应用程序。在命令行的基础上，你可以使用一些界面工具包，如 Tk， wxWidgets，GTK+，Qt，MFC，甚至Swing （要导入相应的Python［或Jython］的接口模块）来创建一 个完整的GUI程序。最后，你可以使用Python的urllib模块来解析FTP的URL并进行FTP传输。 在urllib的内部也导入并使用了 ftplib，urllib也是ftplib的客户端。

FTP不仅可以用在下载应用程序上，还可以用在系统之间文件的转移上。比如，如果你是一个工 程师或是系统管理员，你需要传输文件。在跨网络的时候，很明显可以使用scp或rsync命令，或 者把文件放到一个外部能访问的服务器上。不过，在一个安全网络的内部机器之间移动大量的日志 或数据库文件，这种方法的开销就太大了，要注意安全性，加密，压缩，解压缩等。如果你想要做 的只是写一个FTP程序来帮助你在下班后自动移动文件，那用Python是一个非常好的主意。

从FTP协议定义/规范（RFC 959）中，你可以得到更多关于FTP的信息：

<ftp://ftp.isi.edu/in-notes/rfc959.txt> 以及网页

[http://www.networksorcery.com/enp/protocol/ftp.htm。其它相关的](http://www.networksorcery.com/enp/protocol/ftp.htm%e3%80%82%e5%85%b6%e5%ae%83%e7%9b%b8%e5%85%b3%e7%9a%84) RFC 有 2228，2389,



2428，2577，2640和4217。想了解更多Python对FTP的支持，可以从这里开始: <http://python.org/docs/current/lib/module-ftplib.html>.

### 17.3 网络新闻

### 17.3.1 Usenet与新闻组

Usenet新闻系统是一个全球存档的“电子公告板”。各种主题的新闻组一应俱全，从诗歌到政治，

从自然语言学到计算机语言，软件到硬件，种植到烹饪，招工，应聘，音乐，魔术，分手，求爱等。

新闻组可以是面向全球泛泛而谈，也可以是只面向某个地理区域。

整个系统是一个由大量计算机组成的一个庞大的全球网络，计算机之间共享Usenet上的帖子.如 果某一个用户发了一个帖子到本地的Usenet计算机上，这个帖子会被传播到其它相连的计算机上， 并再由这些计算机传到与它们相连的计算机上，直到这个帖子传播到了全世界，每个人都收到这个帖 子为止.

每个系统都有一个它已经“订阅”的新闻组的列表，它只接收它感兴趣的新闻组里的帖子—— 而不是服务器上所有新闻组的帖子。Usenet新闻组服务内容取决于服务提供者，很多都是可供公众

访问的，也有一些只允许特定的用户使用，例如付费用户，特定大学的学生等。如果Usenet系统 |變一管理员设置了的话，有可能会要求输入用户名和密码。管理员也可以设置是否只允许上传或只允许

下载。

### 17.3.2网络新闻传输协议（NNTP）

供用户在新闻组中下载或发表帖子的方法叫网络新闻传输协议（NNTP）。它由Brain Kantor （加 利福尼亚大学圣地亚哥分校）和Phil Lapsley （加利福尼亚大学伯克利分校）创建并记录在RFC 977 中，于1986年2月公布。其后的更新记录在RFC 2980，于2000年10月公布。

作为客户端/服务器架构的另一个例子，NNTP与FTP的操作方式很像，而且简单得多。FTP需 要不同的端口来做登录，数据传输和控制，而NNTP只使用一个标准端口 119来做通讯。你给服务器 一个请求，它做相应的反馈，见图17-2。

![img](07Python38c3160b-2405.jpg)



![img](07Python38c3160b-2406.jpg)



![img](07Python38c3160b-2407.jpg)



![img](07Python38c3160b-2408.jpg)



![img](07Python38c3160b-2409.jpg)



图17-2因特网上的NNTP客户端和服务器。客户端主要阅读新闻，有时也发帖子。文章会在服 务器之间做同步。

### 17.3.3 Python 和 NNTP

![img](07Python38c3160b-2411.jpg)



由于之前已经有了 Python和FTP的经验，你也许可以猜到，一定有一个库nntplib和一个类 nntplib.NNTP，你要实例化这个类。你猜对了。用FTP —样，我们所要做的就是导入那个Python 模块，然后调用相应的方法。我们先大致看一下这个协议：

![img](07Python38c3160b-2412.jpg)



![img](07Python38c3160b-2413.jpg)



\1.    连接到服务器

\2.    登录（如果需要的话）

\3.    发送请求

\4.    退出

是不是有点熟悉？是的，这几乎就是完全复制了 FTP协议。唯一的不同就是根据NNTP服务器的 配置不一样，登录这一步是可选的。

下面是一段Python的伪代码：

from nntplib import NNTP n = NNTP('your.nntp.server') r,c,f,l,g = n.group('comp.lang.python')

n.quit()

![img](07Python38c3160b-2414.jpg)



一般来说，在你登录完成后，你要调用groupO方法来选择一个感兴趣的新闻组。方法返回服务 器的返回信息，文章的数量，第一个和最后一个文章的ID，以及组的名字。在有了这些信息后，你 会做一些其它的操作，如从头到尾看文章，下载整个帖子（文章的标题和内容），或者发表一篇文章 等。



在看真实的例子之前，我们要先介绍一下nntplib.NNTP类的一些常用的方法。

### 17.3.4 nntplib.NNTP 类方法

跟前一节列出ftplib.FTP类的方法时一样，我们不会列出nntplib.NNTP的所有方法，只列出 你创建NNTP客户端程序时可能用得着的方法。

表17.2 NNTP对象的方法



方法

group(name)



![img](07Python38c3160b-2416.jpg)



xhdr(hdr， artrg， [ofile])

body(id[，

ofile])



head(id)

article(id)

stat(id)

next()

last()



描述

选择一个组的名字，返回一个元组（rsp，ct，fst，lst，group）: 服务器的返回信息，文章的数量，第一个和最后一个文章的号 码以及组名，所有数据都是字符串。（返回的group与我们传 进去的name应该是相同的）

返回文章范围artrg（'头-尾’的格式）内文章hdr头的列表，或 输出到文件ofile中

给定文章的id，id可以是消息的ID （放在尖括号里），或一 个文章号（是一个字符串），返回一个元组（rsp，anum，mid， data）: 服务器的返回信息，文章号（是一个字符串），消息 的ID （放在尖括号里），和文章所有行的列表或把数据输出到 文件ofile中。

与body（）相似，只是返回的元组中那个行的列表中只包含了 文章的标题。

也跟body（）—样，只是返回的元组中那个行的列表中包含了 文章的标题和内容。

让文章的“指针”指向id （同上，是一个消息的ID或是文章 的号码）。返回一个跟body —样的元组（rsp，anum，mid）， 但不包含文章的数据。

用法和stat（）类似，把文章指针移到下一篇文章，返回与 stat（）相似的元组

用法和stat（）类似，把文章指针移到最后一篇文章，返回与 stat（）相似的元组



![img](07Python38c3160b-2417.jpg)



![img](07Python38c3160b-2418.jpg)



post(ufile)    上传ufile文件对象里的内容(使用ufile.readlineO)，并

在当前新闻组发表。

quit()    关闭连接，然后退出



跟上一节的FTP对象表一样，还有一些NNTP对象的方法没有提及。为了避免混乱，我们只列出 了你可能用得到的。其余的，我们再次建议你参考Python手册。

### 17.3.5交互式NNTP举例

接下来，是一个如何使用Python中NNTP库的交互式的例子。它看上去跟交互式的FTP的例子 差不多。(出于保密的原因，e-mail地址都做了修改)。

在调用表17.2中所列的groupO方法连接到一个组的时候，你会得到一个长度为5的元组。

\>>> from nntplib import NNTP

\>>> n = NNTP('your.nntp.server')

\>>> rsp, ct, fst, lst, grp = n.group('comp.lang.python')

\>>> rsp, anum, mid, data = n.article('110457')

\>>> for eachLine in data:

![img](07Python38c3160b-2420.jpg)



... print eachLine

From: "Alex Martelli" <alex@...> Subject: Re: Rounding Question Date: Wed, 21 Feb 2001 17:05:36 +0100 "Remco Gerlich" <remco@...> wrote:

\>    Jacob Kaplan-Moss <jacob@...> wrote in comp.lang.python:

\>> So I've got a number between 40 and 130 that I want to round up to >> the nearest 10. That is:

\>>

\>> 40 --> 40, 41 --> 50, ..., 49 --> 50, 50 --> 50, 51 --> 60 >> Rounding like this is the same as adding 5 to the number and then

\>    rounding down. Rounding down is substracting the remainder if you were

\>    to divide by 10, for which we use the % operator in Python.

This will work if you use +9 in each case rather than +5 (note that he doesn't really want rounding -- he wants 41 to 'round' to 50, for ex).

Alex

\>>> n.quit()

'205 closing connection - goodbye! >>>



![img](07Python38c3160b-2422.jpg)



![img](07Python38c3160b-2423.jpg)



![img](07Python38c3160b-2424.jpg)



![img](07Python38c3160b-2425.jpg)



![img](07Python38c3160b-2426.jpg)



### 17.3.6客户端程序NNTP举例

在NNTP客户端例子中，我们来点更复杂的。在之前的FTP客户端例子中，我们是下载最新的文 件，这一次，我们要下载Python语言新闻组com.lang.python里的最后一篇文章。

下载完成后，我们会显示文章的前20行，而且是前20行有意义的内容。有意义的内容是指那 些不是被引用的文本（引用以“〉”或“|”开头），也不是像这样的文本“In article <...>, soAndSo@some.domain wrote:”。

最后，我们要智能的处理空行。在文章中出现了一行空行，那我们就显示一行空行，但如果有

多行连续的空行，那只显示一行空行。只有有数据的行才算在“前20行”之中。所以，最多可能显

示39行输出，20行实际数据间隔了19行空行。

如果脚本的运行正常的话，我们可能会看到这样的输出：

$ getLatestNNTP.py

![img](07Python38c3160b-2427.jpg)



*** Connected to host "your.nntp.server" *** Found newsgroup "comp.lang.python" *** Found last article (#471526):

![img](07Python38c3160b-2428.jpg)



From: "Gerard Flanagan" <grflanagan@...>

Subject: Re: Generate a sequence of random numbers that sum up to 1? Date: Sat Apr 22 10:48:20 CEST 2006

*** First (<= 20) meaningful lines: def partition(N=5):

vals = sorted( random.random() for _ in range(2*N) ) vals = [0] + vals + [1] for j in range(2*N+1): yield vals[j:j+2]

deltas = [ x[1]-x[0] for x in partition() ] print deltas print sum(deltas)

[0.10271966686994982, 0.13826576491042208, 0.064146913555132801, 0.11906452454467387, 0.10501198456091299, 0.011732423830768779, 0.11785369256442912, 0.065927165520102249, 0.098351305878176198, 0.077786747076205365, 0.099139810689226726]

1.0

$

![img](07Python38c3160b-2429.jpg)



![img](07Python38c3160b-2430.jpg)



![img](07Python38c3160b-2431.jpg)



![img](07Python38c3160b-2432.jpg)



![img](07Python38c3160b-2433.jpg)



![img](07Python38c3160b-2434.jpg)



例 17.2 NNTP 下载示例(getFirstNNTP.py)

这个脚本下载并显示Python新闻组comp.lang.python最后一篇文章的前20个“有意义的”行。

1    #!/usr/bin/env python

2

3    import nntplib

4    import socket

5

6    HOST = 'your.nntp.server'

7    GRNM = 'comp.lang.python'

8    USER = 'wesley'

9    PASS = "you'llNeverGuess"

10

11    def main():

12

13 try:

14    n = nntplib.NNTP(HOST)

![img](07Python38c3160b-2435.jpg)



15    #, user=USER, password=PASS)

16    except socket.gaierror, e:

17    print 'ERROR: cannot reach host "%s"' % HOST

18    print ' ("%s")' % eval(str(e))[1]

19    return

20    except nntplib.NNTPPermanentError, e:

21    print 'ERROR: access denied on "%s"' % HOST

22    print ' ("%s")' % str(e)

23    return

24    print '*** Connected to host "%s"' % HOST

25

26    try:

27    rsp, ct, fst, lst, grp = n.group(GRNM)

28    except nntplib.NNTPTemporaryError, e:

29    print 'ERROR: cannot load group "%s"' % GRNM

30    print ' ("%s")' % str(e)

31    print ' Server may require authentication'

32    print ' Uncomment/edit login line above'

33    n.quit()

34    return

35    except nntplib.NNTPTemporaryError, e:



36    print ’ERROR: group "%s" unavailable’ % GRNM

37    print ’ ("%s")’ % str(e)

38    n.quit()



![img](07Python38c3160b-2438.jpg)



39    return

40    print ’*** Found newsgroup "%s"’ % GRNM

41

42    rng = ’%s-%s’ % (lst， lst)

43    rsp， frm = n.xhdr(’from’， rng)

44    rsp， sub = n.xhdr(’subject’， rng)

45    rsp， dat = n.xhdr(’date’， rng)

46    print ’’’*** Found last article (#%s):

47

48    From: %s

49    Subject: %s

50    Date: %s

51    ’’’% (lst， frm[0][1]， sub[0][1]， dat[0][1])

52

53 rsp， anum， mid， data = n.body(lst)

![img](07Python38c3160b-2439.jpg)



54    displayFirst20(data)

![img](07Python38c3160b-2440.jpg)



55    n.quit()

56

57 def displayFirst20(data):

58    print ’*** First (<= 20) meaningful lines:\n

59    count = 0

60    lines = (line.rstrip() for line in data)

61    lastBlank = True

62    for line in lines:

63    if line:

64    lower = line.lower()

65    if (lower.startswith(’>’) and not \

66    lower.startswith(’>>>’)) or \

67    lower.startswith(’|’) or \

68    lower.startswith(’in article’) or \

69    lower.endswith(’writes:’) or \

70    lower.endswith(’wrote:’):

71    continue

72    if not lastBlank or (lastBlank and line):

73    print ’ %s’ % line

74    if line:

75    count += 1

![img](07Python38c3160b-2441.jpg)



76    lastBlank = False

77    else:

78    lastBlank = True

79    if count == 20:

80    break

81

82    if __name__ == '__main__':

83    main()

这个输出显示了新闻组帖子的原始内容，如下：

From: "Gerard Flanagan" <grflanagan@...>

Subject: Re: Generate a sequence of random numbers that sum up to 1? Date: Sat Apr 22 10:48:20 CEST 2006

Groups: comp.lang.python

Gerard Flanagan wrote:

\>    Anthony Liu wrote:

![img](07Python38c3160b-2443.jpg)



\>    > I am at my wit's end.

![img](07Python38c3160b-2444.jpg)



\>    > I want to generate a certain number of random numbers.

\>    > This is easy, I can repeatedly do uniform(0, 1) for > > example.

\>    > But, I want the random numbers just generated sum up

\>    > to 1 .

\> > I am not sure how to do this. Any idea? Thanks.

\> -----------------------------------------------------------

\>    import random

\>    def partition(start=0,stop=1,eps=5):

\>    d = stop - start

\>    vals = [ start + d * random.random() for _ in range(2*eps) ]

\>    vals = [start] + vals + [stop]

\>    vals.sort()

\>    return vals

\> P = partition()



![img](07Python38c3160b-2446.jpg)



\>    intervals = [ P[i:i+2] for i in range(len(P)-1) ]

\>    deltas = [ x[1] - x[0] for x in intervals ]

\>    print deltas

\>    print sum(deltas)

\>    --------------------------------------------------

def partition(N=5):

vals = sorted( random.random() for _ in range(2*N) ) vals = [0] + vals + [1] for j in range(2*N+1): yield vals[j:j+2]

deltas = [ x[1]-x[0] for x in partition() ]

![img](07Python38c3160b-2447.jpg)



print deltas

print sum(deltas)



![img](07Python38c3160b-2448.jpg)



![img](07Python38c3160b-2449.jpg)



[0.10271966686994982, 0.13826576491042208, 0.064146913555132801 0.11906452454467387, 0.10501198456091299, 0.011732423830768779, 0.11785369256442912, 0.065927165520102249, 0.098351305878176198 0.077786747076205365, 0.099139810689226726]

1.0

当然，由于新文章不断的出现，输出经常会不一样。只要你的服务器里一有文章更新，输出就

会不一样了。

逐行解释

#### I-    9行

程序开始是一些导入语句和常量定义，跟FTP客户端差不多。

#### II-    40行

在第一部分，我们尝试连接到NNTP服务器，如果失败就退出（13-24行）。第15行故意注释掉 了，如果需要输入用户名和密码进行认证的话，可以打开这一行，并修改第14行。后面是尝试读取 指定的新闻组。同样，如果新闻组不存在，服务器没有保存这个新闻组，或是需要认证的话，退出

26-40行）。

#### 42-55行

下面这一部分，我们读一些头信息，并显示出来（42-51行）。最有用处的头信息包括作者，主 题和日期。这些数据会被读取并显示给用户。在每一次调用xhdr（）方法时，都要给定想要提取信息 头的文章的范围。我们只想取一条信息，所以范围就是“X-X”，其中，X是最后一条信息的号码。

xhdr（）方法返回一个长度为2的元组，包含了服务器的返回信息（rsp）和我们指定范围的信息 头的列表。由于我们只指定了一个消息（最后一个），我们只取列表的第一个元素（hdr[0]）。数据 元素是一个长度为2的元组，包含文章号和数据字符串。由于我们已经知道了文章号（我们在请求 中给出了），我们只关心第二个元素，数据字符串（hdr[0][1]）。

最后一部分是下载文章的内容（53-55行）。先调用body（）方法，然后显示前20个有意义的行， 最后登出服务器，完成执行。

#### 57-80行

主要的处理任务由displayFirst20（）函数完成（57-80行）。它接受文章的所有行做为参数，并 做一些预处理，如把计数器清0，创建一个生成器表达式对文章内容的所有行做一些处理，然后“假 装”我们刚碰到并显示了一行空行（59-61行，稍后细说）。由于前导空格可能是Python代码的一

部分，所以在我们去掉字符串中的空格的时候，只删除字符串右边的空格（rstripO）。

我们要做的是，我们不要显示引用的文本和引用文本指示行。这就是65-71行（也包含64行） 的那个大if语句所要做的事。如果这一行不是空行的时候，才做这个检查（63行）。检查的时候， 会把字符串转成小写，这样就能做到比较的时候大小写无关（64行）。

如果一行以“>”或“|”开头，说明这一般是一个引用。不过，我们认为“>>>”是一个例外，

因为这有可能是交互命令行的提示，虽然这样可能有问题，因为它也可能是一段被引用了三次的消

息（1段文本到第4个回复的帖子时被引用了3次）却被显示了。

现在来处理空行。我们想让程序聪明一些，它应该能显示文章中的空行，但对空行的处理要做

到智能。如果有多个连续的空行，则只显示第一个，这样用户不用看那么多行信息，导致有用的信

息却在屏幕之外。我们也不能把空行计算到20行有意义的行之中。所有这些要求都在72-78行内实

现。

72行的if语句表示只有在上一行不为空，或者上一行为空但当前行不为空的时候才显示。也就 是说，如果显示了当前行的话，就说明要么当前行不为空，要么当前行为空但上一行不为空。这是 另一个比较有技巧的地方:如果我们碰到了一个非空行，计数器加1,并设置lastBlank标志为False， 以表示这一行非空（74-76行）。否则，表示我们碰到了空行，把标志设为True。

现在回到第61行，我们设lastBlank标志为True，是因为，如果内容的第一行实际数据（不是

前导数据或是引用数据）是一个空行，我们不会显示它。因为我们想要看第一行实际数据！

最后，如果我们已经显示了20行非空行，则退出，放弃其余的行（79-80行）。否则，我们应该

已经遍历了所有行，循环也正常结束了。

### 17.3.7 NNTP的其它方面

从NNTP协议定义/规范（RFC 977）中，你可以得到更多关于NNTP的信息： <ftp://ftp.isi.edu/in-notes/rfc977.txt> 以及网页

[http://www.networksorcery.com/enp/protocol/nntp.htm。其它相关的](http://www.networksorcery.com/enp/protocol/nntp.htm%e3%80%82%e5%85%b6%e5%ae%83%e7%9b%b8%e5%85%b3%e7%9a%84) RFC 有 1036，2980。 想了解更多Python对NNTP的支持，可以从这里开始： <http://python.org/docs/current/lib/module-nntplib.html>.

### 17.4 电子邮件

电子邮件既古老又现代。对于我们这些从很早就开始用因特网的人来说，e-mail看上去是如此 的“古老”尤其是相对于基于网页的在线聊天，即时聊天（頂），和数字电话即VOIPCVoice Over Internet Protocol）等更新更快的通讯方式来说更是如此。下一节中，我们将从宏观上介绍一下

— e-mail是如何工作的。如果你已经对此相当了解，只想看如何用Python做e-mail相关的开发，你 一 可以跳到后续章节。

在看e-mail的底层的结构之前，你有没有问过自己，e-mail的确切定义到底是什么？根据RFC 2822,“消息由头域（合起来叫消息头）以及后面可选的消息体组成”。对于一般用户来说，一说起 e-mail就会让我们想到它的内容，不管它是一封真的邮件还是一封不请自来的商业广告（即spam， 垃圾邮件），都应该有内容。不过，RFC规定，邮件体是可选的，只有邮件头是必要的。这一点要特

别注意。

### 17.4.1 E-mail系统组件和协议

不管你是怎么样想的，电子邮件（e-mail）实际上在现代的因特网出现之前就已经出现了。它一 开始用于mainframe的用户之间简单的交换信息。注意，由于他们都在使用同一台电脑，所以，这 里甚至都没有涉及到网络。后来，当网络成为现实的时候，用户就可以在不同的主机之间交换信息。 当然，由于用户使用着不同的电脑，电脑之间使用着不同的协议，信息交换成了一个很复杂的概念。

直到20世纪80年代，因特网上用e-mail进行信息交换才有了一个事实上的统一的标准。

在深入细节之前，我们先问问自己，e-mail是怎么工作的？ 一条消息是如何从发件人那通过浩 瀚的因特网，到达收件人的？简单点来说，有一台发送电脑（发件人的消息从这里发送出去），和一

台目的电脑（收件人的信件服务器）。最好的解决方案是发送电脑知道如何连接到接收电脑，这样一

来，它就可以直接把消息发送过去。不过，实际上一般并不这么顺利。

发送电脑要查询到某一台中间主机，这台中间主机能到达最后的收件主机。然后这台中间主机

要找一台离目的主机更近一些的主机。所以，在发送主机和目的主机之间，可能会有多台叫做“跳

板”的主机。如果你仔细看看你收到的e-mail的邮件头，你会看到一个“passport”标记，其中记

录了邮件寄给你这一路上都到过了哪些地方。

为了让描述清楚一些，让我们先看看e-mail系统的各个组件。最主要的组件是消息传输代理 （MTA）。这是一个在邮件交换主机上运行的一个服务器程序，它负责邮件的路由，队列和发送工作。

它们就是邮件从源主机到目的主机所要经过的跳板。所以也被称为是“信息传输”的“代理”。

要让所有这些工作起来，MTA要知道两件事情：1）如何找到消息应该去的下一台MTA 2）如何 与另一台MTA通讯。第一件事由域名服务（DNS）来查找目的域名的MX （邮件交换Mail eXchange） 来完成。这对于最后的收件人是不必要的，但对其它的跳板来说，则是必要的。对于第二件事，MTA 怎么把消息转给其它的MTA呢？

### 17.4.2 发送 E-mail

要能发送e-mail，你的邮件客户端一定要连接到一个MTA，它们靠某种协议进行通讯。MTA之一 间通讯所使用的协议叫消息传输系统（MTS）。只有两个MTA都使用这个协议时，才能进行通讯。在

本节开始时就说过，由于以前存在很多不同的计算机系统，每个系统都使用不同的网络软件，这种

通讯很危险，具有不可预知性。更复杂的是，有的电脑使用互连的网络，而有的电脑使用调制解调

器拨号，消息的发送时间也是不可预知的。事实上，笔者曾经有一封邮件在发送9个月后才收到！

互连网的速度怎么会这么慢？出于对这些复杂度的考虑，现代e-mail的基础之一，简单邮件传输协 议（SMTP）于1982年出现了。

#### SMTP

SMTP由已故的Jonathan Postel（加利福尼亚大学信息学院）创建，记录在RFC 821中，于 1982年8月公布。其后的修改记录在RFC 2821中，于2001年4月公布。一些已经实现了 SMTP 的著名MTA包括：

开源MTA

參 Sendmail

參 Postfix

•    Exim

•    qmail （免费发布，但不开源）

商业MTA

參 Microsoft Exchange

• Lotus Notes Domino Mail Server



注意，虽然它们都实现了 RFC 2821中定义的最小化SMTP协议，它们中的大多数，尤其是一些 商业MTA，都在服务器中加入了协议定义之外的特有的功能。

SMTP是在因特网上MTA之间用于消息交换的最常用的MTS。它被MTA用来把e-mail从一台主机 传送到另一台主机。在你发e-mail的时候，你必须要连接到一个外部的SMTP服务器，这时，你的 邮件程序是一个SMTP客户端。你的SMTP服务器也因此成为了你的消息的第一个跳板。

### 17.4.3 Python 和 SMTP

是的，也存在一个smtplib模块和一个smtplib.SMTP类要实例化。再来看看这个已经熟悉的过 程吧：

\1. 连接到服务器

\2.    登录(如果需要的话)

\3.    发出服务请求

![img](07Python38c3160b-2458.jpg)



\4.    退出

像NNTP —样，登录是可选的，只有在服务器打开了 SMTP认证(SMTP-AUTH)时才要登录。SMTP-AUTH 在RFC 2554中定义。还是跟NNTP—样，SMTP通讯时，只要一个端口 25。

下面是一些Python的伪代码：

from smtplib import SMTP n = SMTP('smtp.yourdomain.com')

n.quit()

在看真实的例子之前，我们要先介绍一下smtplib.SMTP类的一些常用的方法。

### 17.4.4 smtplib.SMTP 类方法

跟之前一样，我们会列出smtplib.SMTP类的方法，但不会列出所有的方法，只列出你创建SMTP 客户端程序所需要的方法。对大多数e-mail发送程序来说，只有两个方法是必须的：sendmailO和 quit()。

![img](07Python38c3160b-2459.jpg)



sendmailO的所有参数都要遵循RFC 2822，即e-mail地址必须要有正确的格式，消息体要有正 确的前导头，前导头后面是两个回车和换行（\r\n）对。



注意，实际的消息体不是必要的。根据RFC 2822“唯一要求的头信息只有发送日期和发送地址” 即 “Date:” 和 “From:” （MAIL FROM, RCPT TO, DATA）

还有一些方法没有被提到，不过，一般来说，它们不是发送 e-mail 所必须的。请参考 Python 文档以获取SMTP对象的所有方法的信息。

表17.3 SMTP对象的方法

方法

Sendmail

(from, to, msg[, mopts, ropts])

quit()

login(user, passwd)a



描述



把msg从from发送给to （列表或元组）。ESMTP设置（mopts）和收 件人设置（ropts）为可选。

关闭连接，然后退出

使用user用户和passwd密码登录到SMTP服务器

![img](07Python38c3160b-2461.jpg)



a.只在有SMTP-AUTH时使用。

### 17.4.5交互式SMTP示例



![img](07Python38c3160b-2462.jpg)



![img](07Python38c3160b-2463.jpg)



同样地，我们先给一个交互式的例子：

\>>> from smtplib import SMTP as smtp

\>>> s = smtp('smtp.python.is.cool')

\>>> s.set_debuglevel(1)

\>>> s.sendmail('wesley@python.is.cool', ('wesley@python.is.cool', 'chun@python.is.cool'), ''' From: wesley@python.is.cool\r\nTo: wesley@python.is.cool, chun@python.is.cool\r\nSubject: test msg\r\n\r\nxxx\r\n.''')

send: 'ehlo myMac.local\r\n'

reply: '250-python.is.cool\r\n'

reply: '250-7BIT\r\n'

reply: '250-8BITMIME\r\n'

reply: '250-AUTH CRAM-MD5 LOGIN PLAIN\r\n'

reply: '250-DSN\r\n'

reply: '250-EXPN\r\n'

![img](07Python38c3160b-2464.jpg)



![img](07Python38c3160b-2465.jpg)



reply: '250-HELP\r\n'

reply: '250-NOOP\r\n'

reply: '250-PIPELINING\r\n'

reply: '250-SIZE 15728640\r\n'

reply: '250-STARTTLS\r\n'

reply: '250-VERS V05.00c++\r\n'

reply: '250 XMVP 2\r\n'

reply: retcode (250); Msg: python.is.cool

7BIT

8BITMIME

AUTH CRAM-MD5 LOGIN PLAIN

DSN

EXPN

HELP

NOOP

PIPELINING

SIZE 15728640

STARTTLS

![img](07Python38c3160b-2466.jpg)



VERS V05.00c++

![img](07Python38c3160b-2467.jpg)



XMVP 2

send: 'mail FROM:<wesley@python.is.cool> size=108\r\n' reply: '250 ok\r\n' reply: retcode (250); Msg: ok send: 'rcpt TO:<wesley@python.is.cool>\r\n' reply: '250 ok\r\n' reply: retcode (250); Msg: ok send: 'data\r\n' reply: '354 ok\r\n' reply: retcode (354); Msg: ok data: (354, 'ok')

send: 'From: wesley@python.is.cool\r\nTo:

wesley@python.is.cool\r\nSubject: test

msg\r\n\r\nxxx\r\n..\r\n.\r\n'

reply: '250 ok ; id=2005122623583701300or7hhe\r\n' reply: retcode (250); Msg: ok ; id=2005122623583701300or7hhe data: (250, 'ok ; id=2005122623583701300or7hhe')

{}

\>>> s.quit()

send: 'quit\r\n'

reply: '221 python.is.cool\r\n'

![img](07Python38c3160b-2468.jpg)



reply: retcode (221); Msg: python.is.cool

### 17.4.6    SMTP的其它方面

从SMTP协议定义/规范（RFC 2821）中，你可以得到更多关于SMTP的信息： <ftp://ftp.isi.edu/in-notes/rfc2821.txt> 以及网页 [http://www.networksorcery.com/enp/protocol/smtp.htm。](http://www.networksorcery.com/enp/protocol/smtp.htm%e3%80%82)

想了解更多Python对SMTP的支持，可以从这里开始： <http://python.org/docs/current/lib/module-smtplib.html>.

我们还没有讨论的e-mail的一个很重要的方面是怎么正确的设定因特网地址的格式和e-mail 消息。这些信息详细记录在因特网信息格式RFC 2822中。可以在

<ftp://ftp.isi.edu/in-notes/rfc2822.txt> 下载。

### 17.4.7    接收 E-mail

在以前，在因特网上用e-mail通讯的只有大学学生，研宄人员和工商企业的雇员。桌面电脑还 都是类Unix操作系统。家庭用户只是拨号到PC上，并不真的使用e-mail。在20世纪90年代中期

一因特网大爆炸的时候，e-mail进入了千家万户。

对于家族用户来说，在家里放一个工作站来运行SMTP是不现实的。必须要设计一种新的系统， 能够周期性地把信件下载到本地计算机，以供离线时使用。这样的系统就要有一套新的协议和新的 应用程序来与邮件服务器通讯。

在家用电脑中运行的应用程序叫邮件用户代理（MUA）。MUA从服务器上下载邮件，在这个过程中 可能会自动删除它们（也可能不删除，留在服务器上，让用户手动删除）。不过，MUA也必须要能发 送邮件。也就是说，在发送邮件的时候，它要能直接与MTA用SMTP进行通讯。在前面讲SMTP的章 节中，我们已经看过这种客户端了。那下载邮件的呢？

### 17.4.8    POP 和 IMAP

用于下载邮件的第一个协议叫邮局协议，记录在RFC 918中，于1984年10月公布。“邮局协议 （POP）的目的是让用户的工作站可以访问邮箱服务器里的邮件。邮件要能从工作站通过简单邮件传

输协议（SMTP）发送到邮件服务器”。POP协议的最新版本是第3版，也叫POP3。

POP3在RFC 1939中定义，至今为止仍在被广泛地使用，也是我们下面的客户端例子的主要内容。

在POP之后几年，出现了另一个协议，叫交互式邮件访问协议（IMAP）。第一个版本是实验性的，

直到第2版时，其RFC 1064才在1988年被公布。现在被使用的IMAP版本是IMAP4rev1，它也被广 泛地使用。事实上，当今世界上占有邮件服务器大多数市场的Microsoft Exchange就使用IMAP作 为其下载机制。IMAP4rev1协议定义在RFC 3501，于2003年3月公布。IMAP的目的是要提供一个更 全面的解决方案。不过，它比POP更为复杂。对IMAP的进一步讨论超出了本章剩余部分的范围。我 们建议感兴趣的用户参考上述RFC文档。图17-3展示的复杂系统就是我们所认为的简单的e-mail。



Mail

client

filtering

device

MUA

S@nd@r (or recipient)

MTA

SMTP (send)

Internet

POP3/IMAP4

(receive)

Mail

client

Recipient (or sender)

bRMv & vi ins

图17-3因特网上的E-Mail发件人和收件人。客户端通过他们的MUA和相应的MTA进行通讯，

来下载和发送邮件。E-Mail从一个MTA “跳”到另一个MTA，直到到达目的地为止。



### 17.4.9 Python 和 POP3

毫不奇怪，我们要做的是：导入poplib，实例化poplib.POP3类。 标准的做法如下：

\1.    连接到服务器

\2.    登录

\3.    发出服务请求

\4.    退出

Python的伪代码如下：

from poplib import POP3 p = POP3('pop.python.is.cool') p.user(...) p.pass_(...)

p.quit()

在看真实的例子之前，我们要先看一个交互式的例子以及介绍一下poplib.POP3类的一些基本 的方法。



![img](07Python38c3160b-2474.jpg)

 17.4.10交互式POP3举例

下面是使用Python poplib模块的交互式的例子:

\>>> from poplib import POP3

\>>> p = POP3('pop.python.is.cool')

\>>> p.user('techNstuff4U')

'+OK'

\>>> p.pass_('notMyPasswd')

Traceback (most recent call last):

File "<stdin>", line 1, in ?

File "/usr/local/lib/python2.4/poplib.py", line 202, in pass_

return self._shortcmd('PASS %s' % pswd)

File "/usr/local/lib/python2.4/poplib.py", line 165, in _shortcmd

return self._getresp()

File "/usr/local/lib/python2.4/poplib.py", line 141, in _getresp

![img](07Python38c3160b-2475.jpg)



raise error_proto(resp)

poplib.error_proto: -ERR directory status: BAD PASSWORD >>> p.user('techNstuff4U')

'+OK'

\>>> p.pass_('youllNeverGuess')

'+OK ready'

\>>> p.stat()

(102, 2023455)

\>>> rsp, msg, siz = p.retr(102)

\>>> rsp, siz

('+OK', 480)

\>>> for eachLine in msg:

... print eachLine

Date: Mon, 26 Dec 2005 23:58:38 +0000 (GMT) Received: from c-42-32-25-43.smtp.python.is.cool by python.is.cool (scmrch31) with ESMTP id <2005122623583701300or7hhe>; Mon, 26 Dec 2005 23:58:37 +0000

![img](07Python38c3160b-2476.jpg)



![img](07Python38c3160b-2477.jpg)



From: wesley@python.is.cool To: wesley@python.is.cool Subject: test msg



xxx



\>>> p.quit()

'+OK python.is.cool'

### 17.4.10 poplib.POP3 类方法

POP3类有无数的方法来帮助你下载和离线管理你的邮箱。最常用的列在表17.4中。



表17.4 POP3对象的常用方法



方法

user(login)

pass_(passwd)



stat()



list([msgnum])



retr(msgnum)



dele(msgnum)

quit()



描述

发送用户名login到服务器，并等候服务器的正在等待用户密码的返回信息 发送密码passwd (在使用user()登录之后使用)。如果登录失败，引发一 个异常

返回邮件的状态，一个长度为2的元组(msg_ct, mbox_siz):消息的数

量和消息的总大小也即字节数

stat()的扩展，从服务器返回长度为3的元组的消息列表(rsp, msg_list, rsp_siz):服务器的返回信息，消息的列表，返回信息的大小。如果给 了 msgnum的话，只返回指定消息的数据。

从服务器中得到消息msgnum，并设置其“已读”标志。返回一个长度为 3的元组(rsp, msglines, msgsiz):服务器的返回信息，消息msgnum 的所有行，消息的字节数

把消息msgnum标记为删除，大多数服务器在调用quit()后执行删除操作。 登出，保存修改(如，执行“已读”和“删除”标记等)，解锁邮箱，

结束连接，然后退出



在登录时，user()方法不仅向服务器发送了用户名，也要等待服务器正在等待用户密码的返回信 息。如果pass_()方法认证失败，会引发一个poplib.error_proto的异常。

如果成功，会得到一个以'+'号开头的返回信息，如“+OK ready”然后服务器上的该邮箱就被



锁定了，直到调用了 quitO方法为止。



调用 list()方法时，msg_list 的格式为：［‘msgnum msgsiz',…］，其中，msgnum 和 msgsiz 分别是每个消息的编号和消息的大小。

还有一些方法未被列出，想要了解更多信息，请参考Python手册里poplib的文档。

### 17.4.12客户端程序SMTP和POP3举例

下面的例子演示了如何使用SMTP和POP3来创建一个既能接收和下载e-mail也能上传和发送 e-mail的客户端。我们将要先用SMTP发一封e-mail给自己(或其它测试帐户)，等待一段时间—— 我们随便选了一个时间，10秒钟一一然后使用POP3下载这封e-mail，下载下来的内容跟发送的内 容应该是完全一样的。如果程序悄无声息地结束，没有输出也没有异常，那就说明我们的操作都成 功了。

例 17.3 SMTP 和 POP3 示例(myMail.py)

![img](07Python38c3160b-2481.jpg)



这个脚本(通过SMTP邮件服务器)发送一封测试e-mail到目的地址，并马上(通过POP)把 e-mail从服务器上收回来。要让程序能正常工作，你需要修改服务器的名字和e-mail的地址。

![img](07Python38c3160b-2482.jpg)



1 #!/usr/bin/env python 2

3    from smtplib import SMTP

4    from poplib import POP3

5    from time import sleep

6

7    SMTPSVR = 'smtp.python.is.cool'

8    POP3SVR = 'pop.python.is.cool'

9

10    origHdrs = ['From: wesley@python.is.cool',

11    'To: wesley@python.is.cool',

12    'Subject: test msg']

13    origBody = ['xxx', 'yyy', 'zzz']

14    origMsg = '\r\n\r\n'.join(['\r\n'.join(origHdrs),

'\r\n'.join(origBody)])

15

16    sendSvr = SMTP(SMTPSVR)

17    errs = sendSvr.sendmail('wesley@python.is.cool',

18    ('wesley@python.is.cool',), origMsg)

![img](07Python38c3160b-2483.jpg)



19    sendSvr.quit()

20    assert len(errs) == 0, errs

21    sleep(10) # wait for mail to be delivered

22

23    recvSvr = POP3(POP3SVR)

24    recvSvr.user('wesley')

25    recvSvr.pass_('youllNeverGuess')

26    rsp, msg, siz = recvSvr.retr(recvSvr.stat()[0])

27    # strip headers and compare to orig msg

28    sep = msg.index('')

29    recvBody = msg[sep+1:]

30    assert origBody == recvBody # assert identical



逐行解释

#### 1-8行

跟本章前面的例子一样，程序一开始是一些导入语句和常量的定义。常量分别是发送邮件和接

收邮件的服务器。

#### 10-14行

![img](07Python38c3160b-2485.jpg)



这几行是消息内容的准备工作。这里，我们放了三行消息头然后是消息体。From和To两个头 分别表示消息的发件人和收件人。14行把消息头和消息体放在一起组成一个可以发送的消息，按 RFC 2822的要求，这两部分用空行隔开。

#### 16-21行

我们连接到发送(SMTP)服务器来发送我们的消息。这里还有一对From和To的地址，这些地 址是“真实”的e-mail地址，或者说是信封格式(envlelope)的地址。收件人参数应该是一个可迭 代的对象，如果传的是一个字符串，就会被转成一个只有一个元素的列表。不请自来的垃圾邮件中， 消息头和信封头总是不一致的。

sendmailO的第三个参数是e-mail信息本身。这个函数返回之后，我们就登出SMTP服务器， 并判断是否有错误发生过。我们要等待一段时间，等待服务器完成消息的发送与接收。

#### 23-30行

程序的最后一部分是下载刚刚发送的消息，并断言发送的和接收的消息是完全一样的。先给出 用户名和密码，连接到POP3服务器，在登录成功后，调用stat()方法得到有效的消息的列表。我们 先选第一条消息([0])，然后调用retr()下载这个消息。

我们用空行来分隔头和信息，去掉头部分，比较原始信息体和收到的信息体。如果它们相同，

什么都不显示，程序正常退出，否则，会出现一个断言失败的错误。



![img](07Python38c3160b-2487.jpg)



由于错误的类型太多，我们在这个脚本里不做错误检查，这样的好处是你可以直接看到出现了

什么错误。在本章末尾有一个习题就是做错误检查的。

现在，你对如何发送和接收e-mail有了一个很全面的了解。如果你想深入了解这一方面的编程， 请参阅下一章里介绍的e-mail相关的模块，它们在程序开发方面有相当大的帮助。

### 17.5 相关模块

Python 最好的一个方面就是它在标准库中提供了相当的全面的网络支持。尤其在因特网协议和 客户端开发方面的支持更为全面。下面列出了一些相关模块，首先是电子邮件相关的，随后是一般 用途的因特网协议相关的。

17.5.1 E-mail

Python自带了很多e-mail模块和包可以帮助你创建应用程序。表17.5中列出了一部分。

表17.5 E-Mail相关模块

| 模块/包    | 描述                                                |
| ---------- | --------------------------------------------------- |
| email      | e-mail处理的包（也支持MIME）                        |
| rfc822     | RFC2822邮件头解析器                                 |
| smtpd      | SMTP服务器                                          |
| base64     | Base 16，32，和 64 数据编码（RFC 3548）             |
| mhlib      | 处理MH文件夹和信息的类                              |
| mailbox    | 支持mailbox文件格式解析的类                         |
| mailcap    | “mailcap” 文件的处理模块                            |
| mimetools  | （不建议使用）M頂E信息解析工具（使用上面的email）   |
| mimetypes  | 在文件名或URL到相关的MIME类型之间转换的模块         |
| MimeWriter | （不建议使用）M頂E信息处理模块（使用上面的email）   |
| mimify     | （不建议使用）信息的M頂E处理工具（使用上面的email） |
| binascii   | 二进制和ASCII转换                                   |
| binhex     | Binhex4编码和解码支持                               |



![img](07Python38c3160b-2488.jpg)



### 17.5.2 其他网络协议

表17.6 因特网协议相关的模块

![img](07Python38c3160b-2489.jpg)



| 模块      | 描述                  |
| --------- | --------------------- |
| ftplib    | FTP协议客户端         |
| gopherlib | Gopher协议客户端      |
| httplib   | HTTP和HTTPS协议客户端 |
| imaplib   | IMAP4协议客户端       |
| nntplib   | NNTP protocol client  |
| nntplib   | NNTP协议客户端        |
| poplib    | POP3协议客户端        |
| smtplib   | SMTP协议客户端        |
| telnetlib | Telnet协议客户端类    |

### 17.6 练习

#### FTP

17-1.简单FTP客户端。参考本章的FTP例子，写一个小的FTP客户端程序，能够去你喜欢的 网站下载你使用的软件的最新版本。这个脚本应该每几个月就运行一次，以确保你在用的软件是“最 新和最好的”。你应该把FTP地址，登录信息放在一个表里，省得每次都要修改。

17-2.简单FTP客户端和模式匹配。在上一个练习的基础上创建一个新的FTP客户端程序。 它可以上传和下载指定模式的文件。比方说，如果想把一些Python的文件和PDF文件从一台电脑 传到另一台电脑上，那用户可以输入“*.py”或“doc*.pdf”，程序会只传这些文件名匹配的文件。

17-3.智能FTP命令行客户端程序。创建一个跟Unix下/bin/ftp类似的命令行下的FTP程序， 不过，这个FTP客户端要更好一些，能提供更有用的功能。你可以看看http://ncftp.com的ncFTP 做为样板。它有以下功能：历史记录，书签(可以保存FTP地址和登录信息)，下载进度显示等。你 可以使用readline来记录历史命令，用curses来控制屏幕。

17-4. FTP和多线程。创建一个能使用Python的线程库下载文件的FTP客户端程序。你可以通 过修改上一个练习的程序或者重写一个简单的客户端来下载文件。你可以在命令行参数里指定要下 载的文件，也可以做一个GUI，在界面中让用户选择要下载的文件。附加题：要能支持模式，如*^义6。 要使用不同的线程来下载每个文件。

17-5. FTP和GUI。在你上面写的FTP客户端程序中加入GUI，让你的程序成为一个完整的FTP 应用程序。你可以使用Python的任何GUI工具包。

17-6.子类化。从ftplib.FTP派生出一个类FTP2,在这个类中，你不用像之前那4个retr*() 和stor*()方法中那样要给定“STOR filename”或“RETR filename”这样的命令。只要传文件名 就好了。你可以重写已有的方法也可以在方法后加一个2,如retrlines2()。

Python发布包中有一个Tools/scripts/ftpmirror.py脚本，它使用ftplib模块，可以对整个 FTP站点或FTP站点的一部分做镜像。它可以做为ftplib模块应用的扩展例子来使用。解答下面5 个问题时，可以参考这个脚本。你可以直接使用ftpmirror.py里的代码，也可以以这个脚本为样板，

自己重新写一个。

17-7.递归。ftpmirror.py脚本递归的复制一个远程的目录。写一个与ftpmirror.py相似的 脚本，它的默认行为是不递归的。只有在传入了 “-r”参数的时候，才递归的把文件复制到本地目 录。

17-8.模式匹配。ftpmirror.py脚本支持“-s”参数让用户指定能匹配模式的文件不下载，如 “*.exe”。重新写一个简单的FTP客户端程序或修改之前的程序，实现让用户指定通配符，程序只 下载能匹配模式的文件。可以在你之前练习的答案基础上实现。

17-9.递归和模式匹配。写一个FTP客户端程序，把上面两个练习的脚本集成在一起。

17-10.递归和ZIP文件。这个练习与上面的第一个递归练习有些相似，只是不再直接把文件 下载到本地文件系统，而是文件下载后压缩到一个ZIP （或TGZ，或BZ2）文件中。同样，你可以在 之前脚本的基础上改，也可以重写一个。使用“-z”参数让用户可以自动地备份一个FTP站点。

17-11.集成。实现一个最终的，全功能的FTP应用程序，包含上面几个练习的所有功能。即， 支持“-r” “-s”和“-z”参数。

#### NNTP

17-12. NNTP介绍。修改例17.2（getLatestNNTP.py）让它显示第一封（而不是最后一封）有 效文章的有意义的内容。

17-13.代码改进。修正getLatestNNTP.py的会输出3次引用问题，这是因为我们想输出Python 交互解释的内容，而不是被3次引用的文本。用检查“〉>>”后的代码是否为合法Python代码的方 式来解决这个问题。如果合法，那就显示这一行数据，如果不合法，认为是引用文本，不显示。附 加题：你的解决方案再解决这样一个小问题：我们没有去掉前导的空格，因为它可能是

Python代码的缩进。如果真的是代码的缩进，就显示它，否则，认为它是一般的文本，先对字 符串用lstripO方法处理后再显示。

17-14.查找文章。写一个NNTP客户端程序，让用户能选择并登录感兴趣的新闻组。在登录成 功后，提示用户输入一些关键字，使用这些关键字来查找文章的标题。把符合要求的文章列出来显 示给用户。用户可以在列表中选择某一篇文章进行阅读，这时要能显示选定文章的内容。程序还要 有简单的导航功能，如分页等。如果没有给出搜索关键字，则显示所有的文章。

17-15. 搜索内容。修改上一题你的脚本，让脚本同时搜索主题和文章内容。允许关键字的“与



(AND)和“或”(OR)的操作。也要允许指定在标题和文章内容的“与”(AND)和“或”(OR)即， 关键字要只在标题里出现，只在内容里出现或两者里面都要出现。

17-16. 线索化的新闻阅读工具。把不同的回帖组织到一个“文章线索”中。也就是说，把相 关的文章放在一起，与文章什么时候发的没有关系。同一个线索中的文章按时间顺序排列。

用户可以：

(a)    选择某一篇文章进行阅读，然后可以选择回到文章列表，顺序阅读当前线索的

前一篇文章或是后一篇文章。

(b)    允许回复线索，可以选择复制并引用之前文章，用跟贴的方式回复到整个新闻组。附加题： 也允许私下用e-mail进行回复。

(c)    永久地删除线索，即后续的相关文章不会在文章列表中显示。要实现这个功能，你应该把 要删除的文章的列表暂时记录下来。一个线索在几个月之后还没有人回复的话，你可以认为这个线 索已经死了。

17-17.⑶I新闻阅读工具。跟上面的FTP练习差不多，选择一个GUI工具包来实现一个完整的， 独立的GUI新闻阅读工具。

![img](07Python38c3160b-2495.jpg)



17-18. 重构。跟FTP的ftpmirror.py —样。NNTP也有一个示例脚本： Demo/scripts/newslist.py。运行它。这个脚本在很久之前就写好了，你可以做一些翻新工作。做 为练习，你要用Python新版本的一些特性和你的Python开发技巧来重构这个脚本。让这个脚本运 行得更快。你可以使用列表解析和生成器表达式，用更智能的字符串连接而不是调用不必要的函数 等。

![img](07Python38c3160b-2496.jpg)



17-19.缓冲。如其作者所说，newslist.py的另一个问题是，“我应该把要忽略的空的新闻组 的列表保存下来，在每次运行的时候检查一下是否有新的文章，但我真的抽不出时间”。你来实现这 个功能。你可以直接修改它，也可以修改你之前的脚本。

#### E-MAIL

17-20.标识符。POP3的pass_()方法用于在调用login()方法传了用户名之后，传递密码。你 能不能说出，为什么这个方法命名时要在后面加一个下划线，即“pass_0”而不是“passO”？

17-21. IMAP。现在，你已经熟悉了 POP是怎么工作的。这方面的经验对你写一个IMAP客户端 程序也是有帮助的。研宄一下IMAP协议的RFC文档，使用Python的imaplib模块来实现一个IMAP 客户端程序。

下面的练习题跟本章(例17.3)中的myMail.py程序有关。

17-22. e-mail头。在myMail.py的最后几行，比较了发送的信息体与接收到的e-mail的信息



体。写一段相似的代码，比较信息头。注意，要忽略新加入的头。



17-23.错误检查。加入SMTP和POP3的错误检查。

17-24. SMTP和IMAP。在简单的myMail.py中，加入IMAP的支持。附加题：支持两种邮件下 载协议，让用户选择要使用哪一种协议。

17-25.撰写e-mail。再次扩展你之前的程序，允许用户撰写和发送e-mail。

17-26. e-mail应用程序。再次扩展你的e-mail应用程序，在其中加入更有用的邮箱管理功能。 你的程序要能读出当前所有e-mail的信息，并显示其主题。用户可以选择想要看的邮件。附加题: 要能支持用外部程序查看附件。

17-27.⑶I.给你的脚本加入GUI的功能，让它成为一个实用的完整的e-mail应用程序。

17-28.垃圾邮件的特点。不请自来的垃圾邮件(spam)是当今的一大问题。所幸，针对这个 问题有不少好的解决方案。我们不用你来重新发明轮子，我们想让你了解一些垃圾邮件的特点。

(a)    “mbox”格式。在开始之前，我们要把你想处理的e-mail信息转为一个公共的格式。比 如〃mbox"格式。(如果你愿意，你也可以使用别的格式。)如果你已经有了一些mbox格式的消息， 把它们合并到一个文件中。

![img](07Python38c3160b-2499.jpg)



(b)    头。很多e-mail的头上就看出有垃圾邮件的线索。(你可以用email包或自己解析头)。 写一段代码来回答以下问题：

-发送这个消息的e-mail客户端软件是什么？(检查X-Mailer头)

-报文ID(Message-ID头)的格式是否合法？

-From, Received和Return-Path头的域名是否不匹配？域名和IP地址是否不匹配？有没有 X-Authentication-Warning头？如果有的话，内容是什么？

(c)    信息服务器。一些服务器如WHOIS, SenderBase.org等可以根据IP地址或域名帮助你找 到e-mail来自何方。找到一些这样的服务，写一些代码来得到来源地的国别，城市，网络所有者的 名字，联系方法等。

(d)    关键字。垃圾邮件中，有一些字经常出现。你之前一定见过，它们是单个的字母，开头大 写的随机字母等。把你常见的一些大量在垃圾邮件中出现的词汇放在一个列表中。把出现了这些词 汇的邮件做为疑似垃圾邮件隔离。附加题：设计一种算法或加入一些关键字的变形来找出这些邮件。

(e)钓鱼。这些垃圾邮件总是想把他们伪装成来自大银行或某个知名的网站的合法的e-mail。 里面包含某种链接，引诱用户输入自己私密的或是敏感的信息，如登录用户名，密码和信用卡的卡 号等。这些骗子往往做得足以以假乱真。不过，他们还是免不了要让用户登录到与他们声称的并不 相符的网站。这里，就可能会透露出很多信息，如，看上去很乱七八糟的域名，只用了 IP地址，或 是32位整数形式而不是字节形式的IP地址等。写一段代码来判断一封看上去像正式交流的e-mail 是真的还是假的。

![img](07Python38c3160b-2500.jpg)



其它



可以在

[http://www.networksorcery.com/enp/topic/ipsuite.htm#Application%20layer%20protocol](http://www.networksorcery.com/enp/topic/ipsuite.htm%23Application%20layer%20protocol)

找到包含本章中所列的那些协议在内的各种因特网协议的列表。Python （当前）所支持的因特 网协议列表可以在 <http://docs.python.org/lib/internet.html> 找到。

17-29.开发其它因特网客户端程序。现在，你已经看到了 4个Python开发因特网客户端程序 的例子。选一种Python标准库中支持的其它协议，开发一个对应的客户端程序。

17-30. *开发一种新的因特网客户端程序。这个难度比较大：找到一个不常用的，或是还未成 型的Python尚未支持的协议，实现它。如果做得好的话，你可以考虑提交一个PEP，把你的实现加 入到以后版本Python的标准库中发布。

![img](07Python38c3160b-2502.jpg)



![img](07Python38c3160b-2503.jpg)



![img](07Python38c3160b-2504.jpg)
