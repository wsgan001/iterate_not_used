数字

![img](07Python38c3160b-314.jpg)



本章主题

•数的简介 •整型 •布尔型 •标准的整型 •长整型 •浮点型实数 •复数 •操作符 •内建函数 •其它数字类型 •相关模块

![img](07Python38c3160b-315.jpg)



![img](07Python38c3160b-316.jpg)



![img](07Python38c3160b-317.jpg)



![img](07Python38c3160b-318.png)



本章的主题是Python中的数字。我们会详细介绍每一种数字类型，它们适用的各种运算 符，以及用于处理数字的内建函数。在本章的末尾，我们简单介绍了几个标准库中用于处理

t数字的模块。

### 5.1数字类型

数字提供了标量贮存和直接访问。它是不可更改类型，也就是说变更数字的值会生成新的

对象。当然，这个过程无论对程序员还是对用户都是透明的，并不会影响软件的开发方式。

Python支持多种数字类型：整型、长整型、布尔型、双精度浮点型、十进制浮点型和复数。

如何创建数值对象并用其赋值

（数字对象）

创建数值对象和给变量赋值一样同样简单：

anInt = 1

aLong = -9999999999999999L

aFloat = 3.1415926535897932384626433832795



如何更新数字对象

通过给数字对象（重新）赋值， 您可以“更新”一个数值对象。我们之所以给更新这两个 字加上引号， 是因为实际上你并没有更新该对象的原始数值。这是因为数值对象是不可改变对 象。Python的对象模型与常规对象模型有些不同。你所认为的更新实际上是生成了一个新的数 值对象，并得到它的引用。

在学习编程的过程中， 我们一直接受这样的教育， 变量就像一个盒子， 里面装着变量的

值。在Python中，变量更像一个指针指向装变量值的盒子。对不可改变类型来说，你无法 改变盒子的内容， 但你可以将指针指向一个新盒子。每次将另外的数字赋给变量的时候，实际 上创建了一个新的对象并把它赋给变量.（不仅仅是数字，对于所有的不可变类型，都是这么回 事）

anInt += 1 aFloat = 2.718281828

#### 如何删除数字对象

按照Python的法则，你无法真正删除一个数值对象，你仅仅是不再使用它而已。如果你 实际上想删除一个数值对象的引用， 使用 del 语句（参见3.5.6小节）。 删除对象的引用之 后， 你就不能再使用这个引用（变量名）， 除非你给它赋一个新值。如果试图使用一个已经被 删除的对象引用，会引发NameError异常。

del anInt

del aLong, aFloat, aComplex

好了，既然你已经了解如何创建和更新数值对象，那么来看下Python的四种主要数字类 型。

### 5.2整型

Python有几种整数类型。布尔类型是只有两个值的整型。常规整型是绝大多数现代系统都 能识别的整型。Python也有长整数类型。然而，它表示的数值大小远超过C语言的长整数。 下面我们先来了解一下这些类型，然后再来研宄那些用于Python整数类型的运算符和内建函数。

### 5.2.1 布尔型

Python从版本2.3开始支持布尔类型。该类型的取值范围只有两个值，也就是布尔值True 和布尔值False。我们会在本章的末尾一节5.7.1详细讲解布尔对象。

### 5.2.2    标准整数类型

Python的标准整数类型是最通用的数字类型。在大多数32位机器上，标准整数类型的取 值范围是-231 到231-1，也就是-2,147,483,648到 2,147,483,647。如果在 64 位机器上使 用64位编译器编译Python，那么在这个系统上的整数将是64位。下面是一些Python标准整 数类型对象的例子：

#### 0101 84 -237    0x80 017 -680    -0X92

Python标准整数类型等价于C的（有符号）长整型。整数一般以十进制表示，但是Python 也支持八进制或十六进制来表示整数。如果八进制整数以数字“0”开始， 十六进制整数则以

“0x”或“OX”开始。

### 5.2.3    长整型

关于Python长整数类型我们必须要提的是，请不要将它和C或其它编译型语言的长整数 类型混淆。那些语言的长整数典型的取值范围是32位或64位。Python的长整数类型能表达的 数值仅仅与你的机器支持的（虚拟）内存大小有关，换句话说，Python能轻松表达很大很大很 大的整数。

长整数类型是标准整数类型的超集， 当你的程序需要使用比标准整数类型更大的整数时， 长整数类型就有用武之地了。在一个整数值后面加个L （大写或小写都可以），表示这个整数是 长整数。这个整数可以是十进制，八进制， 或十六进制。下面是一些长整数的例子：

#### 16384L -0x4E8L 017L -2147483648l 052144364L 299792458l 0xDECADEDEADBEEFBADFEEDDEAL -5432101234L

![img](07Python38c3160b-324.jpg)



尽管Python也支持用小写字母L标记的长整型，但是我们郑重推荐您仅使用大写的“L” 这样能有效避免数字1和小写L的混淆。Python在显示长整数类型数值的时候总是用大写“L ” 目前整型和长整型正在逐渐缓慢的统一，您只有在对长整数调用repr()函数时才有机会看到 “L”，如果对长整数对象调用str()函数就看不到L。举例如下：

\>>> aLong = 999999999l

\>>> aLong

999999999L

\>>> print aLong

999999999

### 5.2.4 整型和长整型的统

这两种整数类型正在逐渐统一为一种。在Python 2.2以前，标准整数类型对象超出取值范 围会溢出(比如上面提到的大于232的数)，但是从Python2.2以后就再也没有这样的错误了。

![img](07Python38c3160b-325.jpg)



![img](07Python38c3160b-326.jpg)



#### Python 2.1

\>>> 9999 ** 8

Traceback (most recent call last): File "<stdin>"， line 1， in ? OverflowError: integer exponentiation

#### Python 2.2

\>>> 9999 ** 8

99920027994400699944002799920001L

移除这个错误是第一步。 下一步修改位移位； 左移比特导致出界(导致0值)在过去是 经常可能发生的事;

\>>> 2 << 32 0



![img](07Python38c3160b-328.jpg)



#### Python 2.3

\>>> 2 << 32

__main__:1: FutureWarning: x<<y losing bits or changing sign will return a long in Python 2.4

and up 0

#### Python 2.4

\>>> 2 << 32 8589934592L

不远的将来，至少普通用户会几乎感觉不到长整型的存在。必要时整型会悄悄自动转换为 长整型。当然，那些要调用C的人仍然可以继续使用这两种整数类型，因为C代码必须区分不 同的整数类型。如果你想详细了解标准整型与长整型整合的信息，请阅读PEP237.

![img](07Python38c3160b-329.jpg)



### 5.3 双精度浮点数

Python中的浮点数类似C语言中的double类型，是双精度浮点数，可以用直接的十进制 或科学计数法表示。每个浮点数占8个字节（64比特），完全遵守IEEE754号规范（52M/11E/1S）， 其中52个比特用于表示底，11个比特用于表示指数（可表示的范围大约是正负10的308.25 次方，， 剩下的一个比特表示符号。这看上去相当完美，然而，实际精度依赖于机器架构和创 建Python解释器的编译器。

浮点数值通常都有一个小数点和一个可选的后缀e（大写或小写，表示科学计数法）。在e 和指数之间可以用正（+，或负（-，表示指数的正负（正数的话可以省略符号，。下面是一些典 型的浮点数值的例子：

0.0

4.3e25

3.1416



-777.

9.384e-23

4.2E-10



1.6

-2.172818

-90.



-5.555567119

float(12)

6.022e23



96e3 * 1.0

1.000000001

-1.609E-19



![img](07Python38c3160b-330.jpg)



### 5.4 复数

在很久以前，数学家们被下面这样的等式困扰。

x2 = -1

这是因为任何实数（无论正数还是负数）乘以自己总是会得到一个非负数。一个数怎么可 以乘以自己却得到一个负数？没有这样的实数存在。就这样， 直到18世纪， 数学家们发明了 一个虚拟的数i （或者叫j,看你读的是哪本教科书了）

j=-

基于这个特殊的数（或者称之为概念），数学从此有了一个新的分支。现在虚数已经广泛应 用于数值和科学计算应用程序中。一个实数和一个虚数的组合构成一个复数。一个复数是一对 有序浮点数（x, y）。表示为x + yj，其中x是实数部分，y是虚数部分。

渐渐的复数在日常运算,机械,电子等行业获得了广泛的应用。由于一些研究人员不断的重 复制造用于复数运算的工具，在很久以前的Python1.4版本里，复数终于成为一个真正的 Python数据类型。

下面是Python语言中有关复数的几个概念：

•虚数不能单独存在，它们总是和一个值为0.0的实数部分一起来构成一个复数。

•复数由实数部分和虚数部分构成 •表示虚数的语法：real+imagj •实数部分和虚数部分都是浮点数 •虚数部分必须有后缀j或J。

下面是一些复数的例子：

64.375+1j    4.23-8.5j    0.23-8.55j    1.23e-045+6.7e+089j

6.23+1.5j    -1.23-875J    0+1j    9.80665-8.31441J    -.0224+0j

### 5.4.1 复数的内建属性

复数对象拥有数据属性（参见4.1.1节）， 分别为该复数的实部和虚部。复数还拥有 conjugate方法，调用它可以返回该复数的共轭复数对象。（两头牛背上的架子称为轭，轭使

| 表 5.1 复数属性 属性 num.realnum num.imag num.conjugate()    | 描述该复数的实部该复数的虚部返回该复数的共轭复数 |
| ------------------------------------------------------------ | ------------------------------------------------ |
| >>> aComplex = -8.333-1.47j >>> aComplex (-8.333-1.47j)>>> aComplex.real -8.333>>> aComplex.imag -1.47>>> aComplex.conjugate()(-8.333+1.47j) |                                                  |

表5.1描述了复数的所有属性

### 5.5 运算符

数值类型可进行多种运算。从标准运算符到数值运算符，甚至还有专门的整数运算符。

### 5.5.1 混合模式运算符

也许你还记得， 过去将两个数相加时， 你必须努力保证操作数是合适的类型。自然而然的， 加法总是使用 + 号， 然而在计算机语言看来这件事没那么简单，因为数字又有很多不同的类

型。

当两个整数相加时， + 号表示整数加法， 当两个浮点数相加时， + 表示浮点数加法， 依

此类推。在Python中，甚至非数字类型也可以使用+运算符。举例来说，字符串A +字符 串B并不表示加法操作，它表示的是把这两个字符串连接起来，生成一个新的字符串。关键 之处在于支持+运算符的每种数据类型，必须告诉Python，+运算符应该如何去工作。这

也体现了重载概念的具体应用。

虽然我们不能让一个数字和一个字符串相加，但Python确实支持不同的数字类型相加。 当一个整数和一个浮点数相加时， 系统会决定使用整数加法还是浮点数加法（实际上并不存在 混合运算）。Python使用数字类型强制转换的方法来解决数字类型不一致的问题，也就是说它 会强制将一个操作数转换为同另一个操作数相同的数据类型。这种操作不是随意进行的， 它遵 循以下基本规则。

首先，如果两个操作数都是同一种数据类型，没有必要进行类型转换。仅当两个操作数类 型不一致时，Python才会去检查一个操作数是否可以转换为另一类型的操作数。如果可以， 转换它并返回转换结果。由于某些转换是不可能的，比如果将一个复数转换为非复数类型， 将 一个浮点数转换为整数等等，因此转换过程必须遵守几个规则。

要将一个整数转换为浮点数，只要在整数后面加个 .0 就可以了。 要将一个非复数转换为 复数，则只需要要加上一个 “0j” 的虚数部分。这些类型转换的基本原则是： 整数转换为浮 点数，非复数转换为复数。在Python语言参考中这样描述coerce（）方法：

•    如果有一个操作数是复数，另一个操作数被转换为复数。

•    否则，如果有一个操作数是浮点数，另一个操作数被转换为浮点数。

•    否则，如果有一个操作数是长整数，则另一个操作数被转换为长整数；

•    否则，两者必然都是普通整数，无须类型转换。（参见下文中的示意图）

图5－1的流程图阐释了强制转换的规则。数字类型之间的转换是自动进行的，程序员无须 自己编码处理类型转换。不过在确实需要明确指定对某种数据类型进行特殊类型转换的场合， Python提供了 coerce（）内建函数来帮助你实现这种转换。（见5.6.2小节）

![img](07Python38c3160b-337.jpg)



![img](07Python38c3160b-338.jpg)



图 5-1 数值类型转换



![img](07Python38c3160b-340.jpg)



下面演示一下Python的自动数据类型转换。为了让一个整数和一个浮点数相加，必须使 二者转换为同一类型。因为浮点数是超集，所以在运算开始之前， 整数必须强制转换为一个浮 点数，运算结果也是浮点数：

\>>> 1 + 4.5 5.5

![img](07Python38c3160b-341.jpg)



![img](07Python38c3160b-342.jpg)



### 5.5.2 标准类型运算符

第四章中讲到的标准运算符都可以用于数值类型。上文中提到的混合模式运算问题， 也就 是不同数据类型之间的运算，在运算之前，Python内部会将两个操作数转换为同一数据类型。

下面是一些数字标准运算的例子：

\>>> 5.2 == 5.2 True

\>>> -719 >= 833 False

\>>> 5+4e >= 2-3e True

\>>> 2 < 5 < 9 # same as ( 2 < 5 ) and ( 5 < 9 )

True

\>>> 77 > 66 == 66 # same as ( 77 > 66 ) and ( 66 == 66 )

True

\>>> 0. < -90.4 < 55.3e2 != 3 < 181 False

\>>> (-1 < 1) or (1 < -1)

![img](07Python38c3160b-343.jpg)



True

### 5.5.3 算术运算符

Python支持单目运算符正号(+ )和负号(一)，双目运算符，+，_，*，/，％，还有#， 分别表示加法，减法，乘法，除法，取余，和幂运算。从Python2.2起，还增加了一种新 的整除运算符 // 。

#### 除法

拥有C背景的程序员一定熟悉传统除法一一也就是说，对整数操作数，会执行“地板除” (floor，取比商小的最大整数。例如5除以2等于2.5,其中“2”就称为商的“地板”，即“地 板除”的结果。本书中使用“地板除”的说法是为了沿用原作者的风格，译者注)。对浮点操作

数会执行真正的除法。然而，对第一次学编程的人或者那些依赖精确计算的人来说，可能就需

要多次调整代码才能得到自己想要的结果。

在未来的Python版本中，Python开发小组已经决定改变/运算符的行为。/的行为将变 更为真正的除法，会增加一种新的运算来表示地板除。下面我们总结一下Python现在的除法 规则， 以及未来的除法规则：

![img](07Python38c3160b-344.jpg)



![img](07Python38c3160b-345.jpg)



#### 传统除法

如果是整数除法， 传统除法会舍去小数部分，返回一个整数(地板除，。如果操作数之一 是浮点数，则执行真正的除法。包括Python语言在内的很多语言都是这种行为。看下面的例子：

\>>> 1 / 2 # perform integer result (floor) # 地板除

0

\>>> 10/ 2.0 林 returns actual quotient#真正除法

0.5

#### 真正的除法

除法运算总是返回真实的商， 不管操作数是整数还是浮点数。在未来版本的 Python 中， 这将是除法运算的标准行为。现阶段通过执行 from __future__ import division 指令， 也 可以做到这一点。

\>>> from __future__ import division >>>

![img](07Python38c3160b-346.jpg)



\>>> 1 / 2 # returns real quotient

0.5

\>>> 1.0 / 2.0    # returns real quotient

0.5

#### 地板除

从Python 2.2开始，一个新的运算符//已经被增加进来，以执行地板除：//除法不 管操作数何种数值类型，总是舍去小数部分，返回数字序列中比真正的商小的最接近的数字。

\>>> 1 // 2 # floors result， returns integer    # 地板除， 返回整数

0

\>>> 1.0 // 2.0 # floors result， returns float # 地板除， 返回浮点数

0.0

\>>> -1 // 2 # move left on number line# 返回比-0. 5小的整数，也就是一1 -1

![img](07Python38c3160b-347.jpg)



关于除法运算的变更， 支持的人和反对的人几乎一样多。有些人认为这种变化是错误的， 有些人则不想修改自己的现有代码，而剩下的人则想要真正的除法。

之所以会有这种变化是因为Python的核心开发团队认为Python的除法运算从一开始就设 计失误。特别是，随着Python的逐渐发展，它已经成为那些从未接触过地板除的人们的首选 学习语言。Python语言的发明人范•罗萨姆在他的《Python 2.2新增功能》一文中讲到：

def velocity(distance, totalTime): rate = distance / totalTime

你可能会说， 只要有一个参数为浮点数这个函数就能正常工作。像上面提到的那样，要确 保它能正常工作需要强制将参数转换为浮点类型，也就是 rate = float(distance) / float(totalTime)。将来除法将变更为真正的除法，上面的代码可以无需更改正常工作。需要 地板除的地方只需要改变为两个连续的 除号。

是的，代码会受到一些影响，Python团队已经创作了一系列脚本帮助你转换旧代码，

以确保它能适应新的除法行为。而且对那些强烈需要某种除法行为的人来说，Python解释器 1 提供了 Qdivision_style启动参数。一Qnew执行新的除法行为，-Qold则执行传统除法行 为(默认为Qold)。你也可以帮助你的用户使用-Qwarn或-Qwarnall参数度过过渡时期。

关于这次变化的详细信息可以参考PEP238。如果你对这场论战感兴趣，也可以翻阅2001 年的comp.lang.python归档。表5.2总结了除法运算符在不同Python版本中的行为差异。

#### 取余

整数取余相当容易理解， 浮点数取余就略复杂些

表 5.2 除法操作符的行为

对于复数,取余的定义类似于浮点数,不同之处在于商仅取其实数部分,即: x - (math.floor((x/y).real) * y)。

#### 幂运算

幂运算操作符和一元操作符之间的优先级关系比较特别: 幂运算操作符比其左侧操作数

的一元操作符优先级低,比

起右侧操作数的一元操作符的优先级高,由于这个特性你会在算术运算符表中找到两个

** .下面举几个例子:

\>>> 3 ** 2

9

\>>> -3 ** 2 # ** 优先级高于左侧的 --9

\>>> (-3) ** 2 # 加括号提高 -的优先级 9

\>>> 4.0 ** -1.0 # ** 优先级低于右侧的 -0.25

第2种情况下解释器先计算 3**2 再取其相反数,我们需要给"-3"加上括号来得到我们希

Traceback (innermost last):

File "<stdin>"， line 1， in ?

ValueError: integer to the negative power



#### 总结

表5.3 总结了所有的算术运算符， 从上到下， 计算优先级依次降低。 这里列出的所有 运算符都比即将在5.5.4小节讲到的位运算符优先级高。

表 5.3 算术运算符 算术去处符    功能

![img](07Python38c3160b-354.jpg)



| 表达式1 | 表达式2 | 结果           |
| ------- | ------- | -------------- |
| +expr   |         | 结果符号不变   |
| -expr   |         | 对结果符号取负 |
| 表达式1 | 表达式2 | 结果           |



![img](07Python38c3160b-355.jpg)



expr1    * expr2    表达式1

expr1    / expr2    表达式1

expr1    // expr2    表达式1

expr1    % expr2    表达式1

expr1    + expr2    表达式1

expr1    - expr2    表达式1

乘 表达式2

除以 表达式2(传统除或真正除) 地板除以 表达式2 对表达式2 取余 加 表达式2 减 表达式2

注：** 运算符优先级高于单目运算符

下面是更多Python数值运算的例子：

\>>> -442 - 77

-519

\>>>



![img](07Python38c3160b-357.jpg)



64

\>>>

\>>> 4.2 ** 3.2

98.7183139527

\>>> 8 / 3

2

\>>> 8.0 / 3.0

2.66666666667

\>>> 8 % 3

2

\>>> (60. - 32.) * ( 5. / 9. )

15.5555555556

\>>> 14 * 0x04

56

\>>> 0170 / 4

30

\>>> 0x80 + 0777

639

![img](07Python38c3160b-358.jpg)



\>>> 45L * 22L 990L

![img](07Python38c3160b-359.jpg)



\>>> 16399L + 0xA94E8L 709879L

\>>> -2147483648L - 52147483648L

-54294967296L

\>>> 64.375+1j + 4.23-8.5j

(68.605-7.5j)

\>>> 0+1j ** 2 # same as 0+(lj**2) (-1+0j)

\>>> 1+1j ** 2 # same as 1+(lj**2) 0j

\>>> (1+1j) ** 2

2j

注意指数运算符的优先级高于连接实部和虚部的+号运算符。就上面最后一个例子来说，我 们人为的加上了括号，这就改变运算顺序， 从而得到我们想要的结果。

### 5.5.4 *位运算符（只适用于整数）

![img](07Python38c3160b-360.jpg)



•负数会被当成正数的2进制补码处理。

•左移和右移N位等同于无溢出检查的2的N次幂运算：2**N。

•对长整数来说，位运算符使用一种经修改的2进制补码形式，使得符号位可以无限的 向左扩展。

取反(~)运算的优先级与数字单目运算符相同， 是所有位操作符中优先级最高的一个。 左 移和右移运算的优先级次之，但低于加减法运算。与， 或， 异或 运算优先级最低。所有位运 算符按优先级高低列在表 5.4 中。

![img](07Python38c3160b-362.jpg)



表5.4



整型位运算符

位运算符    功能



![img](07Python38c3160b-363.jpg)



~num    单目运算，对数的每一位取反。结果为

| num1 | <<   | num2 | Num1           | 左移 num2 位    |
| ---- | ---- | ---- | -------------- | --------------- |
| num1 | >>   | num2 | Num1           | 右移 num2 位    |
| num1 | &    | num2 | num1           | 与 num2 按位 与 |
| num1 | 八   | num2 | num1 异或 num2 |                 |
| num1 | \|   | num2 | num1           | 与 num2 按位 或 |

下面是几个使用整数30(011110)，45(101101)，60(111100)进行位运算的例子：

\>>> 30 & 45 12



63

\>>> 45 & 60 44

\>>> 45 | 60 61

\>>> ~30

-31

\>>> ~45

-46

\>>> 45 << 1 90

\>>> 60 >> 2 15

》〉30 " 45

51

5.6 内建函数与工厂函数

5.6.1 标准类型函数

在上一章中， 我们介绍了 cmp(), str() 和 type() 内建函数。 这些函数可以用于所有 的标准类型。对数字对象来说， 这些函数分别比较两个数的大小， 将数字转换为字符串， 以

及返回数字对象的类型。

〉〉〉 cmp(-6, 2)

-1

〉〉〉 cmp(-4.333333, -2.718281828)

-1

〉〉〉 cmp(0xFF, 255)

0

〉〉〉 str(0xFF)

'255'

〉〉〉 str(55.3e2)

'5530.0'

〉〉〉 type(0xFF)

<type 'int'〉

〉〉〉 type(98765432109876543210L)

\>>> type(2-1j)

<type 'complex'>

### 5.6.2 数字类型函数

Python现在拥有一系列针对数字类型的内建函数。一些函数用于数字类型转换，另一些 则执行一些常用运算。

#### 转换工厂函数

函数 int(), long(), float() 和 complex() 用来将其它数值类型转换为相应的数值类型

从Python 1.5版本开始，这些函数也接受字符串参数，返回字符串所表示的数值。从Python 1.6版开始，int()和longO在转换字符串时，接受一个进制参数。如果是数字类型之间的 转换，则这个进制参数不能使用。

从Python2.2起，有了第五个内建函数bool()。它用来将整数值1和0转换为标准布尔 值True和False•从Python2.3开始，Python的标准数据类型添加了一个新成员：布尔 (Boolean)类型。从此true和false现在有了常量值即True和False (不再是1和0)。 要了解布尔类型的更多信息， 参阅5.7.1小节。

另外，由于Python 2.2对类型和类进行了整合(这里指Python的传统风格类和新风格类 ——译者注)，所有这些内建函数现在都转变为工厂函数。我们曾经在第四章介绍过工厂函数， 所谓工厂函数就是指这些内建函数都是类对象，当你调用它们时，实际上是创建了一个类实例。

不过不用担心， 这些函数的使用方法并没有什么改变。

下面是一些使用内建函数的示例：

\>>> int(4.25555)

4

\>>> long(42)

42L

\>>> float(4)

4.0

\>>> complex(4)

(4+0j)

\>>>

(2.4-8j)

\>>>

\>>> complex(2.3e-10， 45.3e4)

(2.3e-10+453000j)

表5.5 数值工厂函数总结

类(工厂函数)    操作



bool(obj) b



返回obj对象的布尔值，也就是

obj.__nonzero__()方法的返回值

int(obj, base=10)



long(obj, base=10)



![img](07Python38c3160b-370.jpg)



float(obj)



返回一个字符串或数值对象的整数表

示，类似 string.atoi();从 Python 1.6 起，

引入了可选的进制参数。

返回一个字符或数据对象的长整数表

示，类似string.atol(),从Python1.6起，

引入了可选的进制参数

返回一个字符串或数据对象的浮点数

表示，类似 string.atof()



![img](07Python38c3160b-371.jpg)



complex(str) or

complex(real, imag=0.0) 返回一个字符串的复数表示，或 者根据给定的实数(及一个可选 的虚数部分)生成一个复数对象。

a.    在Python2.3之前，这些都是内建函数

b.    Python2.2中新增的内建函数，在Python2.3中改变为工厂函数

#### 功能函数

Python有五个运算内建函数用于数值运算:abs()， coerce()， divmod()， pow()， pow() 和roundO。我们将对这些函数逐一浏览，并给出一些有用的例子：

![img](07Python38c3160b-372.jpg)



num.imag2)。下面是几个abs()函数的示例:

〉〉〉 abs(-1)

1

〉〉〉 abs(10.)

10.0

〉〉〉 abs(1.2-2.1j)

2.41867732449 〉〉〉 abs(0.23 - 0.78)

0.55



函数coerceO,尽管从技术上讲它是一个数据类型转换函数，不过它的行为更像一个运算 符，因此我将它放到了这一小节。在5.5.1小节，我们讨论了 Python如何执行数值类型转换。 函数coerce（）为程序员提供了不依赖Python解释器，而是自定义两个数值类型转换的方法。 对一种新创建的数值类型来说，这个特性非常有用。函数coerceO仅回一个包含类型转换完 毕的两个数值元素的元组。下面是几个例子：

〉〉〉 coerce(1, 2)

![img](07Python38c3160b-374.jpg)



(1, 2)

〉〉〉

〉〉〉 coerce(1.3, 134L) (1.3, 134.0)

〉〉〉

〉〉〉 coerce(1, 134L)

(1L, 134L)

〉〉〉

〉〉〉 coerce(1j, 134L)

(1j, (134+0j))

〉〉〉

〉〉〉 coerce(1.23-41j, 134L) ((1.23-41j), (134+0j))

divmodO内建函数把除法和取余运算结合起来，返回一个包含商和余数的元组。对整数来 说，它的返回值就是地板除和取余操作的结果。对浮点数来说， 返回的商部分是 math.floor（num1/num2），对复数来说，商部分是 ath.floor（（num1/num2）.real）。

〉〉〉 divmod（10，3）

（3， 1）

〉〉〉 divmod（3，10）

![img](07Python38c3160b-375.jpg)



![img](07Python38c3160b-376.jpg)



\>>> divmod(10,2.5)

(4.0, 0.0)

\>>> divmod(2.5,10)

(0.0, 2.5)

\>>> divmod(2+1j, 0.5-1j) (0j, (2+1j))

函数 pow() 和双星号 (**) 运算符都可以进行指数运算。不过二者的区别并不仅仅在于 一个是运算符，一个是内建函数。

在Python 1.5之前，并没有**运算符。内建函数pow()还接受第三个可选的参数，一个 余数参数。如果有这个参数的， pow() 先进行指数运算，然后将运算结果和第三个参数进行取 余运算。这个特性主要用于密码运算，并且比 pow(x,y) % z 性能更好， 这是因为这个函数的 实现类似于C函数pow(x,y,z)。

\>>> pow(2,5)

32

\>>>

![img](07Python38c3160b-377.jpg)



\>>> pow(5,2)

25

\>>> pow(3.141592,2)

9.86960029446

\>>>

\>>> pow(1+1j, 3) (-2+2j)

内建函数roundO用于对浮点数进行四舍五入运算。它有一个可选的小数位数参数。如果 不提供小数位参数， 它返回与第一个参数最接近的整数(但仍然是浮点类型)。第二个参数告 诉round函数将结果精确到小数点后指定位数。

\>>> round(3)

3.0

\>>> round(3.45)

3.0

\>>> round(3.4999999)

3.0

\>>> round(3.4999999, 1)

3.5

\>>> import math

![img](07Python38c3160b-378.jpg)



print round(math.pi， eachNum)

3.0

3.1

3.14

3.142

3.1416

3.14159

3.141593

3.1415927

3.14159265

3.141592654

3.1415926536

\>>> round(-3.5)

-4.0

\>>> round(-3.4)

-3.0

\>>> round(-3.49)

-3.0

\>>> round(-3.49， 1)

-3.5

值得注意的是round()函数是按四舍五入的规则进行取整。也就是round(0.5)得到1, round(-0.5)得到一1。猛一看int()， round()， math.floor()这几个函数好像做的是同一件

事， 很容易将它们弄混，是不是？下面列出它们之间的不同之处：

•函数int()直接截去小数部分。(返回值为整数)

•函数floorO得到最接近原数但小于原数的整数。(返回值为浮点数)

•函数roundO得到最接近原数的整数。(返回值为浮点数)

•的例子用四个正数和四个负数作为这三个函数的参数，将返回结果列在一起做个比较。 (为了便于比较，我们将int()函数的返回值也转换成了浮点数)。

\>>> import math

\>>> for eachNum in (.2， .7， 1.2， 1.7， -.2， -.7， -1.2， -1.7): ... print "int(%.1f)\t%+.1f" % (eachNum， float(int(each-Num)))

... print "floor(%.1f)\t%+.1f" % (eachNum，

... print "round(%.1f)\t%+.1f" % (eachNum， round(eachNum)) ... print '-' * 20



int(0.2) +0.0 floor(0.2) +0.0 round(0.2) +0.0 int(0.7) +0.0 floor(0.7) +0.0 round(0.7) +1.0 int(1.2) +1.0 floor(1.2) +1.0 round(1.2) +1.0

int(1.7) +1.0 floor(1.7) +1.0 round(1.7) +2.0

![img](07Python38c3160b-382.jpg)



int(-0.2) +0.0 floor(-0.2) -1.0 round(-0.2) +0.0

int(-0.7) +0.0 floor(-0.7) -1.0 round(-0.7) -1.0 int(-1.2) -1.0 floor(-1.2) -2.0 round(-1.2) -1.0 int(-1.7) -1.0 floor(-1.7) -2.0 round(-1.7) -2.0

表5.6 数值运算函数一览

表5.6 数值运算内建函数

![img](07Python38c3160b-383.jpg)



abs(num)    返回 num 的绝对值

coerce(num1, num2)将num1和num2转换为同一■类型，然后以一■个元组的形式

返回。

divmod(num1, num2)除法一取余运算的结合。返回一个元组(num1/num2,num1 % num2)。对浮点数和复数的商进行下舍入(复数仅取实

数部分的商)

pow( numl, num2, mod=1)取numl的num2次方，如果提供mod参数,贝1J计算结果 再对mod进行取余运算

round(T!t, ndig=0)接受一个浮点数fit并对其四舍五入，保存ndig位小数。

若不提供ndig参数，则默认小数点后0位。

round()仅用于浮点数。(译者注：整数也可以，不过并没有什么

实际意义)

### 5.6.3 仅用于整数的函数

除了适应于所有数值类型的内建函数之外，Python还提供一些仅适用于整数的内建函数(标 准整数和长整数)。这些函数分为两类，一类用于进制转换，另一类用于ASCII转换。

#### 进制转换函数

前面我们已经看到，除了十进制标准，Python整数也支持八进制和16进制整数。除此之 外，Python还提供了两个内建函数来返回字符串表示的8进制和16进制整数。它们分别是oct() 和hex()。它们都接受一个整数(任意进制的)对象，并返回一个对应值的字符串对象。下面 是几个示例：

\>>> hex(255) '0xff'

'0x1606627L'

\>>> hex(65535*2) '0x1fffe'

\>>>

\>>> oct(255) '0377'

\>>> oct(23094823l) '0130063047L'

\>>> oct(65535*2) '0377776'

#### ASCII 转换函数

Python也提供了 ASCII (美国标准信息交换码)码与其序列值之间的转换函数。每个字符 对应一个唯一的整数(0 — 255)。对所有使用ASCII表的计算机来说，这个数值是不变的。这 保证了不同系统之间程序行为的一致性。函数chr()接受一个单字节整数值，返回一个字符串， 其值为对应的字符。函数ord()则相反，它接受一个字符，返回其对应的整数值。

\>>> ord('a')

97

\>>> ord('A')

65

\>>> ord('0')

48 >>> chr(97)

，，

'a'

\>>> chr(65L)

'A'

\>>> chr(48)

'0'

表5.7 列出了用于整数类型的所有内建函数 表5.7 仅适用于整数的内建函数

函数    操作

![img](07Python38c3160b-388.jpg)



chr(num)    将ASCII值的数字转换成ASCII字符，范围只

能是0 <= num <= 255。

ord( chr)    接受一个ASCII或Unicode字符(长度为1的字符串)，返回相应的ASCII

或 Unicode 值。

unichr(num)接受Unicode码值，返回其对应的Unicode字符。所接受的码值范围依赖于 你的Python是构建于UCS-2还是UCS-4。

### 5.7 其他数字类型

![img](07Python38c3160b-389.jpg)



### 5.7.1 布尔“数”



![img](07Python38c3160b-390.jpg)



从Python2.3开始，布尔类型添加到了 Python中来。尽管布尔值看上去是“True”和“False， 但是事实上是整型的子类，对应与整数的1和0。下面是有关布尔类型的主要概念：

•有两个永不改变的值True或False。

•布尔型是整型的子类，但是不能再被继承而生成它的子类。

•没有__nonzero__0方法的对象的默认值是True。

•对于值为零的任何数字或空集(空列表、空元组和空字典等)在Python中的布尔值都 是 False。

•在数学运算中，Boolean值的True和False分别对应于1和0。

•以前返回整数的大部分标准库函数和内建布尔型函数现在返回布尔型。

• True和False现在都不是关键字，但是在Python将来的版本中会是。

所有Python对象都有一个内建的True或False值，对内建类型来说，这个值宄竟是True 还是False请参阅章节4.3.2中的核心备注。下面是使用内建类型布尔值的一些例子：

![img](07Python38c3160b-391.jpg)



![img](07Python38c3160b-392.jpg)



\#    intro

\>>> bool(1) True

\>>> bool(True) True

\>>> bool(0) False

\>>> bool('1') True

\>>> bool('0') True

\>>> bool([]) False

\>>> bool ( (1，) ) True

\#    使用布尔数

\>>> foo = 42

\>>> bar = foo < 100

\>>> bar

True

\>>> print bar + 100

101

\>>> print '%s' % bar

True

\>>> print '%d' % bar

![img](07Python38c3160b-393.jpg)



1

\# 无 __nonzero__()

\>>> class C: pass

\>>> c = C()

\>>>

\>>> bool(c) True

\>>> bool(C) True

\#    重载 __nonzero__() 使它返回 False >>> class C:

... def __nonzero__(self):

... return False

\>>> c = C()

\>>> bool(c) False

\>>> bool(C) True

\#    哦，别这么干!! (无论如何不要这么干！) >>> True， False = False， True

\>>> bool(True) False

![img](07Python38c3160b-394.jpg)



![img](07Python38c3160b-395.jpg)



你可以在Python文档和PEP 285看到有关布尔类型的知识。

### 5.7.2 十进制浮点数

从Python2.4起（参阅PEP327）十进制浮点制成为一个Python特性。这主要是因为下面

的语句经常会让一些编写科学计算或金融应用程序的程序员抓狂：

\>>> 0.1

0.1000000000000001

为什么会这样？这是因为语言绝大多数C语言的双精度实现都遵守IEEE 754规范，其中 52位用于底。因此浮点值只能有52位精度，类似这样的值的二进制表示只能象上面那样被截 断。0.1的二进制表示是0.11001100110011 . . .

因为最接近的二进制表示就是.0001100110011...或 1/16 +1/32 + 1/256 + . . .

![img](07Python38c3160b-396.jpg)



你可以看到，这些片断不停的重复直到舍入出错。如果我们使用十进制来做同样的事情， 感觉就会好很多，看上去会有任意的精度。注意下面，你不能混用十进制浮点数和普通的浮点 数。你可以通过字符串或其它十进制数创建十进制数浮点数。你必须导入 decimal 模块以便

![img](07Python38c3160b-397.jpg)



使用 Decimal 类：

\>>> from decimal import Decimal >>> dec = Decimal(.1)

Traceback (most recent call last): File "<stdin>", line 1, in ?

File "/usr/local/lib/python2.4/decimal.py", line 523, in __new__ raise TypeError("Cannot convert float to Decimal. " +

TypeError: Cannot convert float to Decimal. First convert the float to a string

\>>> dec = Decimal('.1')

\>>> dec Decimal("0.1")

\>>> print dec 0.1

\>>> dec + 1.0

Traceback (most recent call last): File "<stdin>", line 1, in ?

File "/usr/local/lib/python2.4/decimal.py", line 906, in __add__ other = _convert_other(other)

File "/usr/local/lib/python2.4/decimal.py", line 2863, in _convert_other

![img](07Python38c3160b-398.jpg)



TypeError: You can interact Decimal only with int， long or Decimal data types.

\>>>

\>>> dec + Decimal('1.0') Decimal("1.1")

\>>> print dec + Decimal('1.0')

1.1

你可以从Python文档中读取相关的PEP以了解十进制数。值得庆幸的是，十进制数和其 它数值类型一样， 可以使用同样的算术运算符。由于十进制数本质上是一种用于数值计算的特 殊类， 我们在本章的剩余部分将不再专门讲解十进制数。

### 5.8 相关模块

在Python标准库中有不少专门用于处理数值类型对象的模块，它们增强并扩展了内建函数 的功能和数值运算的功能。 表5.8列出了几个比较核心的模块。要详细了解这些模块，请参阅 这些模块的文献或在线文档。

对高级的数字科学计算应用来说，你会对著名的第三方包Numeric(NumPy)和SciPy感兴 趣。关于这两个包的详细请访问下面的网址。

<http://numeric.scipy.org/>

<http://scipy.org/>

表5.8 数字类型相关模块

模块    介绍

decimal    十进制浮点运算类 Decimal

array    高效数值数组(字符，整数，浮点数等等)

math/cmath标准C库数学运算函数。常规数学运算在match模块，

复数运算在cmath模块

operator    数字运算符的函数实现。比如tor.sub(m,n)等价

random 多种伪随机数生成器

核心模块: random

当你的程序需要随机数功能时，random模块就能派上用场。该模块包含多个伪随机数发生

器，它们均以当前的时间戳为随机数种子。这样只要载入这个模块就能随时开始工作。下面列

出了该模块中最常用的函数：

两个整数参数，返回二者之间的随机整数

randrange()    它接受和 range ()函数一样的参数， 随机返回

range([start,]stop[, step])结果的一项

uniform() 几乎和randint()—样，不过它返回的是二者之间的一个浮点数(不包括范围

上限)。

random() 类似 uniform() 只不过下限恒等于0.0，上限恒等于1.0 choice() 随机返回给定序列(关于序列，见第六章)的一个元素

到这儿，我们的 Python 数值类型之旅就该结束了。

表5.9总结了数值类型的所有内建函数和运算符。

![img](07Python38c3160b-403.jpg)



| abs ()    | .Absolute value    •     | • •  | »    | number3' |      |           |
| --------- | ------------------------ | ---- | ---- | -------- | ---- | --------- |
| chr()     | Character                | •    |      |          |      | str       |
| coerce()  | Numeric coercion         | •    |      | •        | 拳   | tuple     |
| complex() | Complex factory function | •    |      | •        | «    | complej   |
| divmod()  | Division/inodulo         | •    |      | •        | #    | tuple     |
| float()   | Float factory function   | •    |      | •        | 拳   | float     |
| hex()     | Hexadecinnil string      | •    |      |          |      | str       |
| int ()    | Int factory function     | •    |      |          | •    | int       |
| long U    | Long factory function    | •    |      | »        | 拳   | 1 ong     |
| oc t ()   | Octal string             | •    |      |          |      | str       |
| ord()     | Ordinal                  |      |      |          |      | int       |
| pow()     | Exponentiation           | 學   |      |          | »    | number    |
| round()   | Float rounding           |      |      |          |      | float     |
| *         | Exponentiation           | •    |      |          |      |           |
| +c        | No change                | •    |      |          |      | number    |
|           | N elation                | •    |      |          |      | number    |
| ^JS       | Bit inversion            | •    |      |          |      | int /1 oi |
|           | Exponentiation           | •    |      |          |      |           |
| •it       | Multiplication           | •    |      |          |      | number    |
| /         | Classic or true division | •    |      |          |      | mttnber   |
|           | Floor division           | 學   |      |          |      | number    |
| %         | M odula/remaLnder        | •    |      |          |      | tiumber   |

Table 5.9 Operators and Built-in Functions for All Numeric Types



![img](07Python38c3160b-404.jpg)



![img](07Python38c3160b-405.jpg)



Operator/

Built-in    Description Int Long Float Complex    Resulta

| +    | Addition加法    | ••   | •    | •    | number |
| ---- | --------------- | ---- | ---- | ---- | ------ |
| -    | Subtraction减法 | ••   | •    | •    | number |

<<    Bit left shift    • • int/lo

位左移

\>>    Bit right shift    • • int/lo

位右移

| &    | Bitwise AND按位与运算   | ••       | int/lo |
| ---- | ----------------------- | -------- | ------ |
| 八   | Bitwise XOR按位异或运算 | ••       | int/lo |
| \|   | Bitwise OR按位或运算    | • v • vv | int/lo |

a.    结果为 number 表示可以为所有四种数值类型，可能与操作数相同

b.    与单目运算符有特殊关系，参阅5.5.3小节和表5.2

c.    单目运算符

Edit By Vheavens



### 5.9 练习

本章的练习可以先通过应用程序的形式实现。一旦功能齐备并且调试通过， 建议读者将自 己的代码功能用函数封装起来，以便 在后面的练习中重用代码。关于编程风格我在这儿提醒一 下，最好不要在函数内使用 print 语句输出信息，而是通过 return 语句返回必要的值。 这 样调用函数的代码就可以自己处理显示方式。这样你的代码就适应性更广，更便于重用。

![img](07Python38c3160b-408.jpg)



5-1整形讲讲Python普通整型和长整型的区别 5-2运算符

(a) 写一个函数，计算并返回两个数的乘积

(b) 写一段代码调用这个函数，并显示它的结果

5-3标准类型运算符. 写一段脚本，输入一个测验成绩，根据下面的标准，输出他的评分 成绩(A-F)。

A: 90-100 B: 80-89 C: 70-79 D: 60-69 F: <60

5-4取余。判断给定年份是否是闰年。使用下面的公式：

![img](07Python38c3160b-409.jpg)



一个闰年就是指它可以被4整除，但不能被100整除， 或者它既可以被4又可以被100整 除。比如 1992， 1996和2000年是闰年，但1967和1900则不是闰年。下一个是闰年的整世 纪是 2400 年。

![img](07Python38c3160b-410.jpg)



5-5取余。取一个任意小于1美元的金额，然后计算可以换成最少多少枚硬币。硬币有1 美分，5美分，10美分，25美分四种。1美元等于100美分。举例来说，0.76美元换算结果 应该是 3枚25美分，1枚1美分。类似76枚1美分，2枚25美分+2枚10美分+1枚5美分+1 枚1美分这样的结果都是不符合要求的。

5-6算术。写一个计算器程序 你的代码可以接受这样的表达式，两个操作数加一个运算符： N1运算符N2.其中N1和N2为整数或浮点数，运算符可以是+，-，*，/，％, **分别表示 加法，减法， 乘法， 整数除，取余和幂运算。计算这个表达式的结果，然后显示出来。提示： 可以使用字符串方法split()，但不可以使用内建函数eval().

5-7营业税。随意取一个商品金额，然后根据当地营业税额度计算应该交纳的营业税。

5-8几何。计算面积和体积：

(a)    正方形 和 立方体

(b)    圆 和 球

5-9. 数值形式 回答下面关于数值格式的问题：

(a) 为什么下面的例子里 17+32 等于49， 而 017+32等于47，    017+032等于41？

\>>> 17 + 32

![img](07Python38c3160b-411.jpg)



\>>> 017+ 32 47

\>>> 017 + 032 41

(b)    为什么下面这个表达式我们得到的结果是134L而不是1342 ?

\>>> 56l + 78l 134L

5-10转换。写一对函数来进行华氏度到摄氏度的转换。转换公式为C = (F - 32) * (5 / 9)

应该在这个练习中使用真正的除法， 否则你会得到不正确的结果。

5-11 取余。

(a)    使用循环和算术运算，求出 0－20之间的所有偶数

(b)    同上，不过这次输出所有的奇数

(c)    综合(a)和(b)请问辨别奇数和偶数的最简单的方法是什么？

(d)    使用(c)的成果，写一个函数，检测一个整数能否被另一个整数整除。先要求用户输 1 入两个数，然后你的函数判断两者是否有整除关系，根据判断结果分别返回True和False; '

5-12系统限制。写一段脚本确认一下你的Python所能处理的整数，长整数，浮点数和复 数的范围。

5-13转换。写一个函数把由小时和分钟表示的时间转换为只用分钟表示的时间。

5-14银行利息。写一个函数，以定期存款利率为参数， 假定该账户每日计算复利，请计

算并返回年回报率。

5-15.    最大公约数和最小公倍数。请计算两个整数的最大公约数和最小公倍数。

5-16家庭财务。给定一个初始金额和月开销数， 使用循环，确定剩下的金额和当月的支

出数， 包括最后的支出数。 Payment() 函数会用到初始金额和月额度， 输出结果应该类似下

面的格式(例子中的数字仅用于演示)：

Enter opening balance:100.00

![img](07Python38c3160b-414.jpg)



Amount Remaining

| Pymt# | Paid     | Balance                      |
| ----- | -------- | ---------------------------- |
| 0     | $ 0.00   | $100.00                      |
| 1     | $16.13   | $ 83.87                      |
| 2     | $16.13   | $ 67.74                      |
| 3     | $16.13   | $ 51.61                      |
| 4     | $16.13   | $ 35.48                      |
| 5     | $16.13   | $ 19.35                      |
| 6     | $16.13   | $ 3.22                       |
| 7     | $ 3.22   | $ 0.00                       |
| 5-17  | 随机数。 | 熟读随机数模块然后解下面的题 |

![img](07Python38c3160b-415.jpg)



生成一个有N个元素的由随机数n组成的列表，其中N和n的取值范围分别为：(1 < N <= 100)， (0 <= n <= 231 -1)。然后再随机从这个列表中取 N (1 <= N <= 100)个随机数 出来， 对它们排序，然后显示这个子集。

![img](07Python38c3160b-416.jpg)
