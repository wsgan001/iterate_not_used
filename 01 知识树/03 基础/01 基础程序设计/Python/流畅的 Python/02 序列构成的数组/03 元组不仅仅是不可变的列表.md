
### 2.3 元组不仅仅是不可变的列表

有些 Python 入门教程把元组称为“不可变列表”，然而这并没有完全概括元组的特点。除 了用作不可变的列表，它还可以用于没有字段名的记录。鉴于后者常常被忽略，我们先来

看看元组作为记录的功用。

2.3.1 元组和记录

元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个

字段的位置。正是这个位置信息给数据赋予了意义。

如果只把元组理解为不可变的列表，那其他信息——它所含有的元素的总数和它们的位置

——似乎就变得可有可无。但是如果把元组当作一些字段的集合，那么数量和位置信息就

变得非常重要了。

示例 2-7 中的元组就被当作记录加以利用。如果在任何的表达式里我们在元组内对元素排 序，这些元素所携带的信息就会丢失，因为这些信息是跟它们的位置有关的。

示例 2-7 把元组用作记录

\>>> lax_coordinates = (33.9425, -118.408056) O

\>>> city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)    ©

\>>> traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'),    ©

...    ('ESP', 'XDA205856')]

\>>> for passport in sorted(traveler_ids): ©

...    print('%s/%s' % passport)❺

BRA/CE342567

ESP/XDA205856

USA/31195855

\>>> for country, _ in traveler_ids: ©

... print(country)

USA

BRA

ESP

❶ 洛杉矶国际机场的经纬度。

❷ 东京市的一些信息：市名、年份、人口（单位：百万）、人口变化（单位：百分比）

和面积（单位：平方千米）。

❸ 一个元组列表，元组的形式为 （country_code, passport_number）。

❹ 在迭代的过程中， passport 变量被绑定到每个元组上。

❺ % 格式运算符能被匹配到对应的元组元素上。

❻for循环可以分别提取元组里的元素，也叫作拆包(unpacking)。因为元组中第二个

元素对我们没有什么用，所以它赋值给“_”占位符。

拆包让元组可以完美地被当作记录来使用，这也是下一节的话题。

2.3.2 元组拆包

示例 2-7 中，我们把元组 ('Tokyo', 2003, 32450, 0.66, 8014) 里的元素分别赋值

给变量city、year、pop、chg和area，而这所有的赋值我们只用一行声明就写完了。 同样，在后面一行中，一个 % 运算符就把 passport 元组里的元素对应到了 print 函数 的格式字符串空档中。这两个都是对元组拆包的应用。

元组拆包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中 的元素数量必须要跟接受这些元素的元组的空档数一致。除非我们用 * 来表示忽略 多余的元素，在“用 * 来处理多余的元素”一节里，我会讲到它的具体用法。 Python 爱 好者们很喜欢用元组拆包这个说法，但是可迭代元素拆包这个表达也慢慢流行了起

来，比如“PEP 3132—Extended Iterable

Unpacking” ([ ](https://www.python.org/dev/peps/pep-3132/)[https://www.python.org/dev/peps/pep-3 132/](https://www.python.org/dev/peps/pep-3132/))的标题就是这么用的。

最好辨认的元组拆包形式就是平行赋值，也就是说把一个可迭代对象里的元素，一并赋

值到由对应的变量组成的元组中。就像下面这段代码：

\>>> lax_coordinates = (33.9425, -118.408056)

\>>> latitude, longitude = lax_coordinates # 元组拆包 >>> latitude

33.9425

\>>> longitude

-118.408056

另外一个很优雅的写法当属不使用中间变量交换两个变量的值：

\>>> b, a = a, b

还可以用 * 运算符把一个可迭代对象拆开作为函数的参数：

\>>> divmod(20, 8)

(2, 4)

\>>> t = (20, 8)

\>>> divmod(*t)

(2, 4)

\>>> quotient, remainder = divmod(*t) >>> quotient, remainder (2, 4)

下面是另一个例子，这里元组拆包的用法则是让一个函数可以用元组的形式返回多个值， 然后调用函数的代码就能轻松地接受这些返回值。比如 os.path.split() 函数就会返回 以路径和最后一个文件名组成的元组 (path, last_part):

\>>> import os

\>>> _, filename = os.path.split('/home/luciano/.ssh/idrsa.pub')

\>>> filename

'idrsa.pub'

在进行拆包的时候，我们不总是对元组里所有的数据都感兴趣， _ 占位符能帮助处理这种

情况，上面这段代码也展示了它的用法。

如果做的是国际化软件，那么_可能就不是一个理想的占位符，因为它也是 gettext.gettext 函数的常用别名， gettext 模块的文档 ([ ](https://docs.python.org/3/library/gettext.html)[https://docs.python.org/3/library/gettext.html ](https://docs.python.org/3/library/gettext.html))里提到了这一点。在其他情况下， _ 会 是一个很好的占位符。

除此之外，在元组拆包中使用 * 也可以帮助我们把注意力集中在元组的部分元素上。 用*来处理剩下的元素

在 Python 中，函数用 *args 来获取不确定数量的参数算是一种经典写法了。

于是 Python 3 里，这个概念被扩展到了平行赋值中：

| >>>  | a,   | b, *rest = | range(5) |
| ---- | ---- | ---------- | -------- |
| >>>  | a,   | b, rest    |          |
| (0,  | 1,   | [2, 3, 4]) |          |
| >>>  | a,   | b, *rest = | range(3) |
| >>>  | a,   | b, rest    |          |
| (0,  | 1,   | [2])       |          |
| >>>  | a,   | b, *rest = | range(2) |
| >>>  | a,   | b, rest    |          |
| (0,  | 1,   | [])        |          |

在平行赋值中， * 前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的 任意位置：

| >>>  | a, *body, c, d = | range(5) |
| ---- | ---------------- | -------- |
| >>>  | a, body, c, d    |          |
| (0,  | [1, 2], 3, 4)    |          |
| >>>  | *head, b, c, d = | range(5) |
| >>>  | head, b, c, d    |          |
| ([0, | 1], 2, 3, 4)     |          |

另外元组拆包还有个强大的功能，那就是可以应用在嵌套结构中。

2.3.3 嵌套元组拆包

接受表达式的元组可以是嵌套式的，例如(a, b, (c, d))。只要这个接受元组的嵌套结 构符合表达式本身的嵌套结构， Python 就可以作出正确的对应。示例 2-8 就是对嵌套元组 拆包的应用。

#### 示例 2-8 用嵌套元组来获取经度

metro_areas = [

('Tokyo','JP',36.933,(35.689722,139.691667)),    # O

('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833)),

]

print('{:15} | {:A9} | {:A9}'.format('', 'lat.', 'long.')) fmt = '{:15} | {:9.4f} | {:9.4f}'

for name, cc, pop, (latitude, longitude) in metro_areas: # © if longitude <= 0: # ©

print(fmt.format(name, latitude, longitude))

#### ❶ 每个元组内有 4 个元素，其中最后一个元素是一对坐标。

#### ❷ 我们把输入元组的最后一个元素拆包到由变量构成的元组里，这样就获取了坐标。

#### ❸ if longitude <= 0: 这个条件判断把输出限制在西半球的城市。 示例 2-8 的输出是这样的：

| \|                 | lat.    \|  | long.    |
| ------------------ | ----------- | -------- |
| Mexico City    \|  | 19.4333 \|  | -99.1333 |
| New York-Newark \| | 40.8086 \|  | -74.0204 |
| Sao Paul    \|     | -23.5478 \| | -46.6358 |

在Python 3之前，元组可以作为形参放在函数声明中，例如def fn(a, (b, c), d)：。然而Python 3不再支持这种格式，具体原因见于“PEP 3113—Removal of Tuple Parameter Unpacking” ([http://python+org/dev/peps/pep-3113/](http://python.org/dev/peps/pep-3113/)) 。需要弄清楚的 是，这个改变对函数调用者并没有影响，它改变的是某些函数的声明方式。

#### 元组已经设计得很好用了，但作为记录来用的话，还是少了一个功能：我们时常会需要给

记录中的字段命名。 namedtuple 函数的出现帮我们解决了这个问题。

2.3.4 具名元组

collections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一

个有名字的类——这个带名字的类对调试程序有很大帮助。

用namedtuple构建的类的实例所消耗的内存跟元组是一样的，因为字段名都 被存在对应的类里面。这个实例跟普通的对象实例比起来也要小一些，因为 Python 不会用 __dict__ 来存放这些实例的属性。

#### 在第 1 章的示例 1-1 中是这样新建 Card 类的：

Card = collections.namedtuple('Card', ['rank', 'suit'])

#### 示例 2-9 展示了如何用具名元组来记录一个城市的信息。 示例 2-9 定义和使用具名元组

\>>> from collections import namedtuple

\>>> City = namedtuple('City', 'name country population coordinates') O

\>>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) ©

\>>> tokyo

City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722,

139.691667))

\>>> tokyo.population ©

36.933

\>>> tokyo.coordinates

(35.689722, 139.691667)

\>>> tokyo[1]

'JP'

#### ❶ 创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者

可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。

#### ❷ 存放在对应字段里的数据要以一串参数的形式传入到构造函数中(注意，元组的构造 函数却只接受单一的可迭代对象)。

#### ❸ 你可以通过字段名或者位置来获取一个字段的信息。

除了从普通元组那里继承来的属性之外，具名元组还有一些自己专有的属性。示例 2-10

中就展示了几个最有用的：_fields类属性、类方法_make(iterable)和实例方法 _asdict()。

示例 2-10 具名元组的属性和方法(接续前一个示例)

\>>> City._fields O

('name', 'country', 'population', 'coordinates')

\>>> LatLong = namedtuple('LatLong', 'lat long')

\>>> delhi_data = ('Delhi NCR', 'IN', 21.935, LatLong(28.613889, 77.208889)) >>> delhi = City._make(delhi_data) ©

\>>> delhi._asdict() ©

OrderedDict([('name', 'Delhi NCR'), ('country', 'IN'), ('population',

21.935), ('coordinates', LatLong(lat=28.613889, long=77.208889))])

\>>> for key, value in delhi._asdict().items(): print(key + ':', value)

name: Delhi NCR country: IN population: 21.935

coordinates: LatLong(lat=28.613889, long=77.208889)

\>>>

❶ _fields 属性是一个包含这个类所有字段名称的元组。

❷ 用 _make() 通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟 City(*delhi_data) 是一样的。

❸ _asdict() 把具名元组以 collections.OrderedDict 的形式返回，我们可以利用它

来把元组里的信息友好地呈现出来。

现在我们知道了，元组是一种很强大的可以当作记录来用的数据类型。它的第二个角色则

是充当一个不可变的列表。下面就来看看它的第二重功能。

2.3.5 作为不可变列表的元组

如果要把元组当作列表来用的话，最好先了解一下它们的相似度如何。在表 2-1 中可以清 楚地看到，除了跟增减元素相关的方法之外，元组支持列表的其他所有方法。还有一个例 外，元组没有 __reversed__ 方法，但是这个方法只是个优化而

已， reversed(my_tuple) 这个用法在没有 __reversed__ 的情况下也是合法的。

表2-1：列表或元组的方法和属性(那些由object类支持的方法没有列出来)

|                | 列表 | 元组 |                       |
| -------------- | ---- | ---- | --------------------- |
| 2s_(dda__s     | •    | •    | 接拼2s+s              |
| 2)s_(ddai__s   | •    |      | 接拼地就2s=+s         |
| edneppas       | •    |      | 素元新个一加添部尾在  |
| aelcs          | •    |      | 素元有所除删          |
| e__sniatnoc__s | •    | •    | e含包否是s            |
| yocs           | •    |      | 制复浅的表列          |
| e)tnuocs       | •    | •    | 数次的现出中s在e      |
| _(metiled__s   | •    |      | 除删素元的p于位把     |
| tidnetxes      | •    |      | s给加追ti象对代迭可把 |
|                |      |      |                       |

| s.__getitem__(p) | •                   | •    | s[p]，获取位置p的元素 |                                                              |
| ---------------- | ------------------- | ---- | --------------------- | ------------------------------------------------------------ |
| s.               | __getnewargs__()    |      | •                     | 在pickle中支持更加优化的序列化                               |
| s.               | index(e)            | •    | •                     | 在s中找到元素e第一次出现的位置                               |
| s.               | insert(p, e)        | •    |                       | 在位置p之前插入元素e                                         |
| s.               | __iter__()          | •    | •                     | 获取s的迭代器                                                |
| s.               | __len__()           | •    | •                     | len(s)，元素的数量                                           |
| s.               | __mul__(n)          | •    | •                     | s [1](#bookmark33) n，n个s的重复拼接                         |
| s.               | __imul__(n)         | •    |                       | s [1](#bookmark33)= n，就地重复拼接                          |
| s.               | __rmul__(n)         | •    | •                     | n [1](#bookmark33) s，反向拼接[1](#bookmark33)               |
| s.               | pop([p])            | •    |                       | 删除最后或者是(可选的)位于p的元素，并返回它的值              |
| s.               | remove(e)           | •    |                       | 删除s中的第一次出现的e                                       |
| s.               | reverse()           | •    |                       | 就地把s的元素倒序排列                                        |
| s.               | __reversed__()      | •    |                       | 返回s的倒序迭代器                                            |
| s.               | __setitem__(p, e)   | •    |                       | s[p] = e，把元素e放在位置p，替代己经在那个位置的元素         |
| s.[r             | sort([key],everse]) | •    |                       | 就地对s中的元素进行排序，可选的参数有键(key)和是否倒序 ( reverse ) |
