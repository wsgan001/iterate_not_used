## 文件I/O

3.1引言

本章开始讨论UNIX系统，先说明可用的文件VO困数一打开文件、读文件、写文件等。 UNIX系统中的大多数文件I/O只需用到5个函数：open、read、write、lseek以及close。 然后说明不同缓冲长度对read和write函数的影响。

本章描述的函数经常被称为不带缓冲的I/O （unbuffered VO,与将在第5章中说明的标准I/O 函数相对照）。术语不带缓冲指的是每个read和write都调用内核中的一个系统调用。这些不 带缓冲的I/O函数不是ISO C的组成部分，但是，它们是POSEX.1和Single UNIX Specification的 组成部分。

只要涉及在多个进程间共享资源，原子操作的概念就变得非常重要。我们将通过文件VO和open 函数的参数来讨论此概念。然后，本章将进一步讨讼在多个进程间如何共享文件，以及所涉及的内核 有关数据结构。往描述了送些特征后，将说明dup、fcntl、sync、fsync和ioctl函数。

3.2文件描述符

对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打 开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，

使用open或creat返回的义件描途符标i只读文件，将其作为参数传送给read或write。 「61 |

按照惯例，UNIX系统shell把文件描述符0与进程的标准输入关联，文件描述符1与标准输 出关联，文件描述符2与标准错误关联。这是各种shell以及很多应用程序使用的惯例，与UNIX 内核无关。尽管如此，如果不遵循这种惯例，很多UNIX系统应用程序就不能正常工作。

在符合POSIX.1的应用程序中，幻数0、1、2虽然己被标准化，但应当把它们替换成符号常 量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO以提髙可读性。这些常量都在头文 件＜111^3七＜1.11＞中定义。

文件描述符的变化范围是0〜OPEN_MAX-1 （见图2-11）。早期的UNIX系统实现采用的上限 值是19 （允许每个进程最多打开20个文件），但现在很多系统将其上限值增加至63。

! 对于FreeBSD 8.0、Linux 3.2.0、Mac OS X 10.6.8以及Solaris 10:文件描述符的变化范围几乎 1是无限的，它只受到系统配置的存储器总量、整型的字长以及系统管理员所配置的软限制和硬限 J制的约束。

3.3 函数 open 和 openat

调用open或openat函数可以打开或创建一个文件。

\#include <fcntl.h>

int open (const char *path, int oflag, . . . /* mode_t mode */);

int openat (int fd, const char *path, int oflag, ... /* mode_t mode */ )；

两函数的返回值：若成功.返回文件描述符：若出银，返回-]

我们将最后一个参数写为...»ISOC用这种方法表明余下的参数的数量及其类型是可变的。 对于open函数而言，仅当创建新文件时才使用最后这个参数（稍后将对此进行说明）。在函数原 型中将此参数放置在注释中。

pd参数是要打开或创建文件的名字。参数可用来说明此函数的多个选项。用下列一个 或多个常量进行“或”运算构成妍呀参数（这些常量在头文件＜fcntl.h＞中定义）。

O_RDONLY    只壞打开。

O_WRONLY    只写打开。

O_RDWR    读、写打开。

I    大多數实现将O_RDONLY定义为0, 0_WRONLY定义为1，O_RDWR定义为2,以与早期

J的程序兼容。

O_EXEC    只执行打开。

| 62 | O_SEARCH    只搜索打开（应用于目录）。

I    O.SEARCH常量的貝的在于在目录打开时验狂它的搜索权限。对目录的文件据述符的后续操

作就不需要再次检查对该目录的搜索权限。本书中涉及的操作系统目前都没有支持O_SEARCH。

在这5个常量中必须指定一个且只能指定一个。下列常量则是可选的。

O_APPEND    每次写时都追加到文件的尾端。3.11节将详细说明此选项。

O.CLOEXEC    把FD_CLOEXEC常量设置为文件描述符标志。3.14节中将说明文件描述

符标志。

O_CREAT    若此文件不存在则创建它。使用此选项时，open函数需同时说明第3个

参数mode （openat函数需说明第4个参数morfe），用mode指定该新文 件的访问权限位（4.5节将说明文件的权限位，那时就能了解如何指定 mode，以及如何用进程的umask值修改它）。

O_DIRECTORY

O_EXCL



如果引用的不是目录，则出错。

如果同时指定了 O.CREAT,而文件已经存在，则出错。用此可以测试一 个文件是否存在，如果不存在，则创建此文件，这使测试和创建两者成

为一个原子操作。3.11节将更详细地说明原子操作。

O_NOCTTY    如果path引用的是终端设备，则不将该设备分配作为此进程的控制终端。

9.6节将说明控制终端。

O_NOFOLLOW 如果曲引用的是一个符号链接，则出错。4.17节将说明符号链接。 O_NONBLOCK 如果pafA引用的是一个FIFO、一个扶特殊文件或一个字符特殊文件，则

此选项为文件的本次打开操作和后续的I/O操作设置非阻塞方式。14.2节 将说明此工作模式。

, 较早的System V 入了 O_NDELAY （不延迟）标志，它与OJJONBLOCK （不阻塞）选 项类似，但它的读操作返因值具有二义性。如果不能从管道、FIFO或设备读得數据.则不延 i迟选项使read返回0,这与表示已读到文件尾端的返回值0冲突。基于SVR4的系统仍支

（持这种语义的不延迟选项，但是新的应用程序应当使用不阻塞选项代替之。

O_SYNC    使每次write等待物理VO操作完成,包括由该write操作引起的文件

属性更新所需的I/O。3.14节将使用此选项。

O_TRUNC    如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0。 |-63~|

O_TTY_INIT    如果打开一个还未打开的终端设备，设置非标准termios参数值，使其

符合Single UNIX Specification。第18章将讨论终端I/O的termios结构。

下面两个标志也是可选的，它们是Single UNIX Specification （以及POSIX.1）中同步输入和

输出选项的一部好。

O.DSYNC    使每次write要等待物理I/O操作完成，但是如果该写操作并不影响读

取刚写入的数据，则不需等待文件属性被更新。

J O_DSYNC和O_SYNC标志有微妙的区别。仅当文件属性需要更新以反映文件教据变化 :（例如，更新文件大小以反映文件中包含了更多的數据）时，O_DSYNC标志才影响文件属性。

而设置O_SYNC标志后，數据和属性总是同步更新u当文件用O_DSYN标志打开，在重写其 ］现有的部分内容时，文件时间属性不会同步更新。与此相反，如果文件是用O_SYNC标志打 丨开，那么对该文件的每一次write都将在write送回前更新文件时间，这与是否改写现有 1字节或追加写文件无关。

O_RSYNC    使每一个以文件描述符作为参数进行的read操作等待,直至所有对文件

同一部分挂起的写操作都完成。

Solaris 10支持所有这3个标志。FreeBSD （和Mac OS X ）设置了另外一个标志 ；（O_FSYNC ）,它与标志O_SYNC的作用相同。因为这两个标志是等效的，它们定义的标志具 |有相同的值。FreeBSD 8.0不支持O_DSYNC或O_RSYNC标志。Mac OS X并不支持O_RSYNC，

但却定义了 O_DSYNC,处理 O_DSYNC 与处理 O_SYNC 相同。Linux 3.2.0 定义了 O_DSYNC,

但处理O_RSYNC与处理O_SYNC相同。

由open和openat函数返回的文件描述符一定是最小的未用描述符数值。这一点被某些应 用程序用来在标准输入、标准输出或标准错误上打开新的文件。例如，一个应用程序可以先关闭 标准输出（通常是文件描述符1）,然后打开另一个文件，执行打开操作前就能了解到该文件一定 会在文件描述符1上打开。在3.12节说明duP2函数时，可以了解到有更好的方法来保证在一个 给定的描述符上打开一个文件。

允参数把open和openat函数区计开，共有3种可能性。

（1）    p尔A参数指定的是绝对路径名，在这种情况下，沖参数被忽略I openat函数就相当于 open函数。

（2）    path参数指定的是相对路径名，片参数指出了相对路径名在文件系统中的开始地址。片

参数是通过打开相対路径名所在的目录来获取。    ®

(3) p⑽参数指定了相对路径名，岁参数具有特殊值AT_FDCWD。在这种情况下，路径名在 当前工作目录中获取，openat函数在操作上与open函数类似。

openat函数是POSIX.1最新版本中新增的一类函数之一，希望解决两个问题。第一，让线 程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。在第11章我们会看 到，同一进程中的所有线程共享相同的当前工作目录，因此很难让同一进程的多个不同线程在同 —时间工作在不同的目录中。第二，可以避免time-of-check-to-time~of-use (TOCTTOU)错误。

TOCTTOU错误的基本思想是：如果有两个基于文件的函数调用，其中第二个调用依赖于第 —个调用的结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间文件 可能改变了，这样也就造成了第一个调用的结果就不再有效，使得程序最终的结果是错误的。文 件系统命名空间中的TOCTTOU错误通常处理的就是那些颠覆文件系统权限的小把戏，这些小把 戏通过骗取特权程序降低特权文件的权限控制或者让特权文件打开一个安全漏洞等方式进行。 Wei和Pu[2005]在UNIX文件系统接口中讨论了 TOCTTOU的缺陷。

文件名和路径名截断

如果NAME_MAX是14’而我们却试图在当前目录中创建一个文件名包含15个字符的新文件’此时 会发生什么呢？按厮传统，早期的SystemV版本(如SVR2)允许这种使用方注，但总是将文件名截断 为14个字符，而且不给出任何信息，而BSD类的系统则返回出错状态，并将errno设置为 ENAMETOOLONGo无声无息地截断文件客会弓I起问题，而且忘不仅仅影响到创建新文件。如果NAMELMAX 是14,而存在一个文件名恰好就是14个字符的文件，那么以路授名作为其飼fe的任一函数(open, stat 等)都无怯确定孩文件的原始名是什么。其原因是送些函数无浩判断该文件名是否被截断过=

在POSIX.1中，常量_POSIX_NO_TRUNC决定是要截断过长的文件名或路径名，还是返回一个 出错。正如我们在第2章中已经见过的，根据文件系统的类型，此值可以变化。我们可以用 fpathconf或pathconf来査询目录具体支持何种行为，到底是截断过长的文件名还是返回出错。

J 是否返回一个出借值在很大程度上是历史形成的。例如。基于SVR4的系统对传统的System V j文件系统(S5)并不出错，但是它对BSD风格的文件系统(UFS)则出構。作为另一个例子(参

见图2-20)，Solaris对UFS返回出错，对与DOS兼容的文件系统PCFS则不返回出错，其原因是 j DOS会无声无息地截断不匹配8.3格式的文件名。BSD类系统和Linux总是会返回出错。

g_POSIX_NO_TRUNC有效，则在整个路桂名超过PATH_MAX，或路桂名中的任一文件名超 过NAMELMAX时，出错返回，并将errno设置为ENAMETOOLONGo

大多数的现代文件系统支持文件名的最大长度可以为255。因为文件名通常比这个限制要短， [65~|    :因此对大多数应用程序来说这个限制还未出现什么问题。

##### 3.4 函数 creat

也可调用creat函数创建一个新文件。

\#include <fcntl.h>

int creat (const char *path, mode_t mode);

   返回值：若成功，返回为只写打开的文件描述符；若出错，返回-1

注意，此函数等效于:

open {path, O_WRONLY I O_CREAT I O_TRUNC, mode、；

在早期的UNIX系统版本中.open的第二个参数只能是0、1或2。无法打开一个尚未存在 '的文件，因此需要另一个系统调用creat以创建新文件。现在，open函数提供了选项O_CREAT j和OJTRUNC，于是也就不再需要单独的creat函教。

在4.5节中，我们将详细说明文件访问权限，并说明如何指定

creat的一个不足之处是它以只写方式打开所创建的文件。在提供open的新版本之前，如 果要创建一个临时文件，并要先写该文件，然后又读该文件，则必须先调用creat, close，然 后再调用open。现在则可用下列方式调用open实现：

open {path, O_RDWR I O_CREAT I O_TRUNC, mode);

##### 3.5 函数 close

可调用close函数关闭一个打开文件。

\#include <unistd.h> int close (int fd)；

返回值：若成功，返回0;若出错，返回-1

关闭一个文件时还会释放垓进程加在该文件上的所有记录锁。14.3节将讨沧这一点。

当一个进程终止时，内核自动关闭它所有的打开文件。很多程序都利用了这一功能而不显式 地用close关闭打开文件。实例见图1-4程序。

3.6 函数 lseek

每个打开文件都有一个与其相关联的“当前文件偏移量”(current file offset)。它通常是一个 非负整数，用以度量从文件开始处计算的字节数(本节稍后将対“非负”这一修饰词的某些例外 进行说明)。通常，读、写操作都从当前文件偏移量处开始，井使偏移量増加所读写的字节数。

按系统默认的情况，当打开一个文件时，除非指定O」\PPEND选项，否则该偏移量被设置为0。［KI

可以调用lseek显式地为一个打开文件设置偏移量。

\#include <unistd.h>

off_t lseekfint fd, off_t offset, int whence):

返回值：若成功，返回新的文件偏移量：若出错，返回为-1

財参数offset的解释与参数whence的值有英。

•若是SEEK_SET,则将该文件的偏移量设置为距文件开始处0价权个字节。

•若w/ie/ice是SEEK_CUR，则梅孩文件的偏棲量设置为其当前值加o脚6 o龙付可为正或负。 •若w/ience是SEEK_END,则将该文件的偏移量设置为文件长度加o」!冷eb o加打可正

可负。

若lseek成功执行，则返回新的文件偏移量，为此可以用下列方式确定打开文件的当前偏移量：

of f_t    currpos;

currpos = lseek(fd, 0, SEEK_CUR);

这种方法也可用来确定所涉及的文件是否可以设置偏移量。如果文件描述符指向的是一个管 道、FIFO或网络套接字，则lseek返回-1，并将errno设置为ESPIPE。

3个符号常量SEEK_SET、SEEK_CUR和SEEK_END是在System V中引入的。在System V之 前，iv/KTwe被指定为0 （绝对偏移量）、1 （相对于当前位置的偏移量）或2 （相对文件尾端的偏 移量）。很多软件仍然把这些数字直接写在代码里。

在lseek中的字符1表示长整型。在引入of 数据类型之前，巧冷权参数和返回值是长整 型的。lseek是在UNIX V7中引入的，当时C语言中增加了长整型（在UNIX V6中，用函数seek 和tell提供类似功能）。

~实例

图3-1所示的程序用于测试对其标准输入能否设置偏移量。

\#include "apue.h"

int

main(void)

if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1) printf("cannot seek\n");

else

printf("seek OK\n"); exit(0);

)

[67~|    图3-1测试标准输入能否被设置偏移量

如果用交互方式调用此程序，则可得

$ . /a. out < /atc/pasatrd

seek OK

$ cat < /atc/passwd| ./a.out

cannot seek

$ ./a.out < /var/spool/cron/FIFO

cannot seek

通常，文件的当前偏移量应当是一个非负整数，但是，某些设备也可能允许负的偏移量。但 对于普通文件，其偏移量必须是非负值。因为偏移量可能是负值，所以在比较lseek的返回值 时应当谨慎，不要测试它是否小于0,而要测试它是否等于一1。

在Intel x86处理器上运行的FreeBSD的设备/dev/kmem支持负的偏移量。

因为偏移量（off_t）是带符号数据类型（见图2-21 ），所以文件的最大长度会减少一半。例 如，若of 是32位整型，则文件最大长度是23|-1个字节。

lseek仅将当前的文件偏移量记录在内核中，它并不引起任何I/O操作。然后，垓偏移量用 于下一个读或写操作。

文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长孩文件， 并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0。

文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位 到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于原文件尾端和新开始写位

置之间的部分则不需要分配磁盘块。

实例

图3-2所示的程序用于创建一个具有空洞的文件。

\#include "apae.h"

^include <fcntl.h>

char    bufl[] = "abcdefghij"；

Char    buf2[] = "ABCDEFGHIJ";

int

main(void)

{

int fd;

if ((fd = creat("file.hole", FILE_MODE)) < 0) err_sys("creat error”};

if (write(fd, bufl, 10) != 10) err_sys("bufl write error");

/* offset now = 10 */

if (lseek(fd, 16384, SEEK_SET) == -1) err_sys("lseek error");

/* offset now = 16384 */

if (write(fd, buf2, 10) != 10)

err_sys("buf2 write error");

/* offset now = 16394 */

exit(0);

图3-2创建一个具有空洞的文件

运行该程序得到:

$ ./a.out

$ la -1 file.hole -rw-r--r-- 1 sar



$ od -c file.hole

0000000 a b c d e f 0000020 \0 \0 \0 \0 \0



检査其大小

16394 Nov 25 01:01 file.hole 观察实际内容

g h i j \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0

0040000 ABCDEFGHXJ 0040012

使用Od(l)命令观察该文件的实际内容。命令行中的-c标志表示以字符方式打印文件内容。从中 可以看到，文件中间的30个未写入字节都被读成0。每一行开始的一个7位数是以八进制形式表 示的字节偏移量。

为了证明在该文件中确实有一个空洞，将刚创建的文件与同样长度但无空洞的文件进行 比较：

$ Is -Is file.hole fila.nohole 比较长度

8 -rw-r--r—- 1 sar    16394 Nov 25 01:01 file.hole

20 -rw-r--r-- 1 sar    16394 Nov 25 01:03 file.nohole

虽然两个文件的长度相同，但无空洞的文件占用了 20个磁盘块，而具有空洞的文件只占用8 个磁盘块。

在此实例中调用了将在3.8节中说明的write函数。4.12节将对具有空洞的文件进行更多 说明。

因为lseek使用的偏移量是用off_t类型表示的，所以允许具体实现根据各自特定的平台 自行选择大小合适的数据类型。现今大多数平台提供两组接口以处理文件偏移量。一组使用32 位文件偏移量，另一组则使用64位文件偏移量。

Single UNIX Specification向应用程序提供了一种方怯，使其通过sysconf函数确定支持何 [69]种环境(见2.5.4节)。图3-3总结了定义的sysconf常量。

| 选项名称               | 说明                                             | name参数            |
| ---------------------- | ------------------------------------------------ | ------------------- |
| _POSIX_V7_ILP32_OFF32  | int、long、指针和off_t类型是32位                 | _SC_V7_ILP32_OFF32  |
| _POSIX_V7_ILP32_OFFBIG | int、long、指针类型是32位，of f_t类型 至少是64位 | _SC_V7_ILP32_OFFBIG |
| _POSIX_V7_LP64_OFF64   | int类型是32位，long、指针和off t类 型是64位      | _SC_V7_LP64_OFF64   |
| _POSIX_V7_LP64_OFFBIG  | int类型是32位.long、指针和of f_t类 型至少是64位  | _SC_V7_LP64_OFFBIG  |

图3-3 sysconf的数据大小选项和name参数

C99编译器要求使用getCOnf(l)命令将所期望的数据大小模型映射为编译和链接程序所需 的标志。根据每个平台支持环境的不同，可能需要不同的标志和库。

j 遗憾的是，在这方面，实现还未跟上标准的步伐。如果你的系统没有匹配标准的最新版本，那 J么系统还可能支持Single UNIX Specification前一版本中的选项名：_POSIX_V6„ILP32_OFF32、 s _POSIX_V6_ILP32_OFFBIG、_POSIX_V6_LP64_OFF64 ^_P0SIX_V6_LP64_0FFBIGo

为了避开这一点，应用程序可以将符号常量_FILE_OFFSET_BITS设置为64，以支持64位 j偏移量。这样就将Off_t定义更改为64位带符号整型D符号常量设置 j为32以支持32位偏移量。但是r应当注意的是，虽然本书讨论的4种平台都支持32位和64位 ｛文件偏移量，但是通过设符号常量的值这种方法并不能保证应用程序是

可移植的，也有可能达不到预期的效果。

图3~4总结了在本书涉及的4种平台上，当应用程序没有定义_FILE_OFFSET_BITS时，off_t :教据类型的字节数以及_FILE_OFFSET_BITS被定义成32或64时，off_t数据类型的字节数。

| 操作系统        | CPU架构     | _FILE_OFFSET_BITS 值 |      |      |
| --------------- | ----------- | -------------------- | ---- | ---- |
| 未定义          | 32          | 64                   |      |      |
| FreeBSD 8.0     | x86 32 位   | 8                    | 8    | 8    |
| Linux 3.2.0     | x86 64 位   | 8                    | 8    | 8    |
| Mac OS X 10.6.8 | x86 64 位   | 8                    | 8    | 8    |
| Solaris 10      | SPARC 64 位 | S                    | 4    | 8    |

图M不同平台上of ^七的字节数

注意：尽管可以实现64位文件偏移量，但是能否创建一个大于2 GB （231_1字节）的文件 则依赖于底层文件系统的类型。    S

##### 3.7 函数 read

调用read函数从打开文件中读数据。

| #include <unistd.h>                 |                                                              |
| ----------------------------------- | ------------------------------------------------------------ |
| ssize t read (int fd, void *buf, s: | ze t nbytes）;返回值：读到的字节数，若已到文件尾，返回0:若出错，返回-1 |

如read成功，则返回读到的字节数。如已到达文件的尾端，则返回0。

有多种情况可使实际读到的字节数少于要求读的字节数：

•读普通文件时，在读到要求字节数之前已到迖了文件尾端。例如，若在到达文件尾端之前 有30个字节，而要求读100个字节，则read返回30。下一次再调用read时，它将返回 0 （文件尾端）。

•当从终端设备读时，通常一次最多读一行（第18章将介绍如何改变这一点）。

•当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。

•当从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际

可用的字节数。

•当从某些面向记录的设备（如磁带）读时，一次最多返回一个记录。

•当一信号造成中断，而已经读了部分数据量时。我们将在10.5节进一步讨论此种情况。

读操作从文件的当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数。 POSIX.1从几个方面对read函数的原型做了更改。经典的原型定义是：

int read （int fd, char *buf, unsigned nbytes、；

•首先，为了与ISO C—致，第2个参数由char*改为void*。在ISO C中，类型void * 用于表示通用指针。

•其次，返回值必须是一个带符号整型（ssize_t）,以保证能够返回正整数字节数、0 （表 示文件尾端）或一 1 （出错）。

•最后，第3个参数在历史上是一个无符号整型，这允许一个16位的实现一次读或写的数 据可以多达65 534个字节。在1990 POSIX.1标准中，引入了新的基本系统数据类型 ssize.t以提供带符号的返回值，不带符号的size_t则用于第3个参数（见2.5.2节中 的 SSIZE_MAX 常量）。    | 7「|

##### 3.8 函数 write

调用write函数向打开文件写数据。

\#include <unistd.h>

ssize_t write （int fd, const void *buf, size_t nbytes）;

返回值：若成功，返回已写的字节数；若出错，返回-I

其返回值通常与参数的值相同，否则表示出错。write出错的一个常见原因是磁盘己 写满，或者超过了一个给定进程的文件长度限制（见7.11节及习题10.11）。

对于普通文件，写操作从文件的当前偏移量处开始。如果在打开该文件时，指定了 O„APPEND 选项|则在每次写操作之前，将文件偏移量设置在文件的当前结尾处。在一次成功写之后，垓文 件偏移量増加实际写的字节数。

##### 3.9 I/O的效率

图3-5程序只使用read和write函数复制一个文件。

^include "apue.h"

\#define BUFFSIZE 4096

int

main(void)

{

int n;

char buf[BUFFSIZE];

while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0) if (write(STDOUT_FILENO, buf, n) != n)

err_sys("write error");

if (n < 0)

err_sys("read error");

exit(0);

图3-5将标准输入复制到标准输出

关于该程序应注意以下几点。

•它从标准输入读，写至标准输出，这就假定在执行本程序之前，这些标准输入、输出已 由shell安排好。确宴，所有常用的UNIX系统shell都提供一种方法，它在标准输入上打 开一个文件用于读，在标准输出上创建（或重写）一个文件。这使得程序不必打开输入

□I]    和输出文件，并允许用户利用shell的I/O重定向功能。

•考虑到进程终止时，UNIX系统内核会关闭进程的所有打开的文件描述符，所以此程序并 不关闭输入和输出文件。

•对UNIX系统内核而言，文本文件和二进制代码文件并无区别，所以本程序对这两种文 件都有效。

我们还没有回答的一个问题是如何选取BUFFSIZE值。在回答此问题之前，让我们先用各种 不同的BUFFSIZE值来运行此程序。图3-6显示了用20种不同的缓冲区长度，读516 581 760字 节的文件所得到的结果。

用图3-5的程序读文件，其标准输出被重新定向到/dev/null上。此测试所用的文件系统 是Linuxext4文件系统，其磁盘块长度为4 096字节（磁盘块长度由st_blksiZe表示，在4.12 节中说明其值为4096）。这也证明了图3-6中系统CPU时间的几个最小值差不多出现在 BUFFSIZE为4 096及以后的位置，继续增加缓冲区长度对此时间几乎没有影响。

| BUFFSIZE | 用户CPU Cs) | 系统CPU (s) | 时钟时间（s） | 循环次数    |
| -------- | ----------- | ----------- | ------------- | ----------- |
| 1        | 20.03       | 117.50      | 138.73        | 516581 760  |
| 2        | 9.69        | 58.76       | 68+6          | 258 290 880 |
| 4        | 4.60        | 36.47       | 41.27         | 129 145 440 |
| 8        | 2.47        | 15.44       | 18.38         | 64 572 720  |
| 16       | 1.07        | 7.93        | 9.38          | 32 286 360  |
| 32       | 0.56        | 4.51        | 8.82          | 16 143 180  |
| 64       | 0.34        | 2.72        | 8.66          | 8 071 590   |
| 128      | 0.34        | 1.84        | 8.69          | 4 035 795   |
| 256      | 0.15        | 1.30        | 8.69          | 2 017 898   |
| 512      | 0.09        | 0.95        | 8.63          | 1 008 949   |
| 1 024    | 0.02        | 0.78        | 8,58          | 504 475     |
| 2 048    | 0.04        | 0.66        | 8.68          | 252 238     |
| 4 096    | 0+03        | 0.58        | 8+62          | 126 119     |
| 8 192    | 0.00        | 0.54        | 8.52          | 63 060      |
| 16 384   | 0.01        | 0.56        | 8.69          | 31 530      |
| 32 768   | 0.00        | 0.56        | 8.51          | 15 765      |
| 65 536   | 0.01        | 0.56        | 9.12          | 7 883       |
| 131 072  | 0.00        | 0.58        | 9.08          | 3 942       |
| 262 144  | 0.00        | 0.60        | 8.70          | 1 971       |
| 524 288  | 0.01        | 0.58        | 8.58          | 986         |

图3-6 Linux上用不同缓冲长度进行读操作的时间结果

大多数文件系统为改善性能都采用某种预读（read ahead）技术。当捡测到正进行顺序读取时，

系统就试图谟入比应用所要求的更多数据，并假想应用很快就会读这些数据。预读的效果可以从 图3-6中看出，缓冲区长度小至32字节时的时钟时间与拥有较大缓冲区校度时的时钟时间几乎一样。EtT|

我们以后还将回到这一实例上。3.14节将用此说明同步写的效果，5.8节将比较不带缓冲的 I/O时间与标准I/O库所用的时间。

' 应当了解，在什么时间对实施文件读、写操作的程序进行性能度量。操作系统试图用高速缓存技术 =将相关文件放置在主存中，所以如若重复度量程序性能，那么后续运行该租序所得到的计时很可能好于 :第一次。其原因是，第一次运行使得文件进入系统高速缓存，后续各次运行一般从系统高速缓存访问文

件，无需读、写磁盘。（incore这个词的意思是在主存中，早期计算机的主存是用铁氧体磁心（ferrite core）

-做的，这也是“coredump”这个词的由来：程序的主存键像存放在磁盘的一个文件中以便测试诊断）。

在图3-6所示的测试数据中，不同缓冲区长度的各次运行使用不同的文件副本，所以后一次 ；运行不会在前一次运行的高速缓存中找到它需要的数据。这些文件都足够大，不可能全部保留在 :高速缓存中（测试系统配置了 6GB RAM）。

###### 3.10文件共享

UNIX系统支持在不同进程间共享打开文件。在介绍dup函数之前，先要说明这种共享。为 此先介绍内核用于所有I/O的数据结构。

下面的说明是概念性的，与特定实现可能匹配，也可能不匹配。请参阅Bach[1986]对System V :中相关数据结构的讨论。McKusick等[1996]说明4.4BSD中的相关数据结构。McKusick和 ;Neville-Nell[2005]对FreeBSD 5.2进行了介绍。对Solaris的类似讨论请参见McDougall和

Marno[2007]o Linux2.6 内核体系结构介绍请参见 Bovet 和 Cesati[2006]。

内核使用3种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另 一个进程可能产生的影响。

（1）    每个进程在进程表中都有一个记录项，记录项中包含一张打幵文件描述符表，可将其视 为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：

a.    文件描述符标志（close_on_exec»参见图3-7和3.M节）：

b.    指向一个文件表项的指针。

（2）    内核为所有打开文件维持一张文件表。每个文件表项包含：

a.    文件状态标志（读、写、添写、同步和非阻塞等，关于这些标志的更多信息参见3.14节）；

b.    当前文件偏移量：

c.    指向该文件v节点表项的指针。

（3）    每个打开文件（或设备）都有一个v节点（v-node）结构。v节点包含了文件类型和对 间此文件进行各种操作函数的指针。对于大多数文件，v节点还包含了该文件的i节点（i-node，索

引节点）。这些信息是在打开文件时从磁盘上读入内存的，所以，文件的所有相关信息都是随时 可用的。例如，i节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘:上所在位置 的指针等（4.14节较详细地说明了典型UNIX系统文件系统，并将更多地介绍i节点）。

J    Linux没有使用v节点，而是使用了通用i节点结构。虽然两种实现有所不同，但在概念上，

J v节点与i节点是一样的。两者都指向文件系统特有的i节点结构。

我们忽略了那些不影响讨论的实现细节。例如，打开文件描述符表可存放在用户空间（作为一 个独立的对应于每个进程的结构，可以换出），而非进程表中。这壁表也可以用多种方式实现，不 必一定是数组，例如，可将它们实现为结构的链表。如果不考虑实现细节的话，通用概念是相同的。

图3-7显示了一个进程対应的3张表之间的关系。该进程有两个不同的打开文件：一个文件 从标准输入打开（文件描述符0），另一个从标准输出打开（文件描述符为1）。

进程表项    文件表项    V节点表项

图3-7 打开文件的内核数据结构



文件指针



-,d2

|      |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |



从UNIX系统的早期版本［Thompson 1978］以来，这3张表之间的关系一直保持至今。选种关 系对于在不同进程之间共享文件的方式非常重要。在以后的章节中涉及其他文件共享方式时还会

冈回到这张图上来。

； 创建v节点结构的目的是对在一个计算机系统上的多文件系统类型提供支持。这一工作是 l' Peter Weinberger （贝尔实验室）和Bill Joy （ Sun公司）分别我立完成的。Sun把这种文件系统称

为虚拟文件系统（Virtual File System ），把与文件系统无关的i节点部分称为v节点［Kleiman 1986］。 J当各个制造商的实现增加了对Sun的网络文件系统（NFS）的支持时，它们都广泛采用了 v节点 =结构。在BSD系列中首先提供v节点的是增加了 NFS的4.3BSD Reno。

］ 在SVR4中，v节点替代了 SVR3中与文件系统无关的i节点结构。Solaris是从SVR4发屎而 '来的，因此它也使用v节点。

!    Linux没有将相关数据结构分为i节点和v节点，而是采用了一个与文件系统相关的i节点和

丨一个与文件系统无关的i节点。

如果两个独立进程各自打开了同一文件，则有图3-8中所示的关系。

进程表项

fd

标志文件姗

进程表项



文件指针

0;k2:3:4: ,dfdfdfdfd

|      |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |



文件表项



图＞8两个独立进程各自打开同一个文件

我们假定第一个进程在文件描述符3上打开该文件，而另一个进程在文件描述符4上打开该文件。

打开该文件的每个进程都获得各自的一个文件表项，但对一个给定的文件只有一个v节点表项。之所 以每个进程都获得自己的文件表项，是因为选可以使每个进程都有它自己的对该文件的当前偏移量。

给出了这些数据结构后，现在对前面所述的操作进一步说明。    EKI

•在完成每个write后，在文件表项中的当前文件偏移量即増加所写入的字节数。如果这 导致当前文件偏移量超出了当前文件长度，则将i节点表项中的当前文件长度设置为当前 文件偏移量（也就是该文件加长了）。

•如果用O_APPEND标志打开一个文件，则相应标志也被设置到文件表项的文件状态标志中。

每次对这种具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先会被 设置为i节点表项中的文件松度。这就使得每次写入的数据都追加到文件的当前尾端处。

•若--个文件用lseek定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为i节 点表项中的当前文件长度（注意，这与用O_APPEND标志打开文件是不同的：详见3.11节）。

• lseek函数只修改文件表项中的当前文件偏移量，不进行任何I/O操作。

可能有多个文件描述符项指向同一文件表项，在3,12节中讨论dup函数时，我们就能看到 这一点。在fork后也发生同样的情况，此时父进程、子进程各自的每一个打开文件描述符共享 同一个文件表项(见8.3节)。

注意，文件描述符标志和文件状态标志在作用范围方面的区别，前者只用于一个进程的一个 描述符，而后者则应用于指向该给定文件表项的任何进程中的所有描述符。在3.14节说明fcntl 函数时，我们将会了解如何获取和修改文件描述符标志和文件状态标志。

本节前面所述的一切对于多个进程读取同一文件都能正确工作。每个进程都有它自己的文件 表项，其中也有它自己的当前文件偏移量。但是，当多个进程写同一文件时，则可能产生预想不 到的结果。为了说明如何避免这种情况，需要理解原子操作的概念。

###### 3.11原子操作

1.追加到一个文件

考虑一个进程，它要将数据追加到一个文件尾端。早期的UNIX系统版本并不支持open的 O_APPEND选项，所以程序被编写成下列形式：

if (lseek(fd,OL, 2) < 0)    "position to EOF*/

err_sys("lseek error");

if (write(fd, buf, 100) != 100) "and write*/

| 77err_sys ("write error");

对单个进程而言，这段程序能正常工作，但若有多个进程同时使用这种方法将数据追加写到 同一文件，则会产生问题(例如，若此程序由多个进程同时执行，各自将消息追加到一个日志文 件中，就会产生这种情况)。

假定有两个独立的进程A和B都对同一文件进行追加写操作。每个进程都已打开了该文件， 但未使用O_APPEND标志。此时，各数据结构之间的关系如图3-8中所示。每个进程都有它自己 的文件表项，但是共享一个v节点表项。假定进程A调用了 lseek,它将进程A的该文件当前 偏移量设置为1500字节(当前文件尾端处乂然后内核切换进程，进程B运行■■进程B执行lseek, 也将其对该文件的当前偏移量设置为1500字节(当前文件尾端处)-然后B调用write,它将B 的该文件当前文件偏移量增加至1600。因为该文件的长度已经增加了，所以内核将v节点中的当 前文件长度更新为1600。然后，内核又进行进程切换，使进程A恢复运行■■当A调用write时， 就从其当前文件偏移量(1500)处开始将数据写入到文件。这样也就覆盖了进程B刚才写入到该

文件中的数据。

问题出在逻辑操作“先定位到文件尾端，然后写”，它使用了两个分开的函数调用。解决问题 的方法是使这两个操作对于其他进程而言成为一个原子操作。任何要求多于一个函数调用的操作都 不是原子操作，因为在两个函数调用之间，内核有可能会临时挂起进程C正如我们前面所假定的)-

UNIX系统为这样的操作提供了一种原子操作方法，即在打开文件时设置O_APPEND标志。 正如前一节中所述，这样做使得内核在每次写操作之前，都将进程的当前偏移量设置到该文件的 尾端处，于是在每次写之前就不再需要调用lseek。

2.函数 pread 和 pwrite

Single UNIX Specification包括了 XSI扩展，该扩展允许原子性地定位并执行I/O。pread和 pwrite就是这种扩展。

\#include <unistd.h>

ssize_t pread(int fd, void *buf, size_t nbytes, of f_t offset、；

返回值：读到的字节数，若已到文件尾，返回0:若出错，返回-1

ssize_t pwrite (int fd, const void *buf, size_t nbytes, of f_t offset)；

返回值：若成功，返回已写的字节数：若出错，返回-1

调用pread相当于调用lseek后调用read,怛是pread又与这种顺序调用有下列重要区别。

•调用pread时，无法中断其定位和读操作。

•不更新当前文件偏移量。    [78：

调用pwrite相当于调用lseek后调用write，但也与它们有类似的区别。

3.创建一个文件

对open函数的O_CREAT和0.EXCL选项进行说明时，我们已见到另一个有关原子操作的 例子。当同时指定这两个选项，而该文件又已经存在时，open将失败。我们曾提及检査文件 是否存在和创建文件这两个操作是作为一个原子操作执行的。如果没有这样一个原子操作，那 么可能会编写下列程序段：

if ((fd = open(pathname, O_WRONLY)) <0>{ if (errno == ENOENT) {

if ((fd » creat(path, mode)) < 0) err_sys("creat error");

} else{

err_sys("open error")；

} _

如果在open和creat之间，另一个进程创建了垓文件，就会出现问题。若在这两个函数调用 之间，另一个进程创建了该文件，并且写入了一些数据，然后，原先进程执行这段程序中的creat, 这时，刚由另一进程写入的数据就会被擦去。如若将这两者合并在一个原子操作中，这种问题 也就不会出现。

一般而言，原子操作Catomic operation)指的是由多步组成的一个操作。如果该操作原子地 执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。在4.15 节描述link函数以及在14.3节中说明记录锁时，还将讨论原子操作。



##### 3.12 函数 dup 和 dup2

下面两个函数都可用來复制一个现有的文件描述符。

林include <unistd.h>

int dup (int fd);

int dup2 (int fd, int fd2) •,

两函数的返回值：若成功，返回新的文件描述符：若出错，返回-1 由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值，对于duP2,可以 用参数指定新描述符的值，如果/必已经打开.则先将其关闭。如若fd等于fd2,则duP2 返回/rf2,而不关闭它。否则，/必的FD_CLOEXEC文件描述符标志就被清除，这样在进程

IZEI调用 exec时是打开状态。

这些函数返回的新文件描述符与参数仲共享同一个文件表项，如图3-9所示。 进程表项

fd

标志文件指针



文件表    v节点表



图3-9 dup(l)后的内核数据结构 在此图中，我们假定进程启动时执行了： newfd = dup ⑴；

当此函数开始执行时，假定下一个可用的描述符是3 (这是非常可能的，因为0, 1和2都由shell 打开)，因为两个描述符指向同一文件表项，所以它们共享同一文件状态标志(读、写、追加等) 以及同一当前文件偏移量。

每个文件描述符都有它自己的一套文件描述符标志。正如我们将在下一节中说明的那样，新 描述符的执行时芙闭(close-on-exec)标志总是由dup困数清除。

复制一个描述符的另一种方法是使用fcntl函数，3.14节将対该函数进行说明。实际上，

调用

dup(fd)；

等效于

fcntl (fd, F_DUPFD, 0); 而调用

dup2(fd, fd2):

等效于

close(fd2);

fcntl(fd, F_DUPFD, fd2)；

间在后一种情况下，dup2并不完全等同于close加上fcntl。它们之间的区别具体如下。

(1)    dup2是一■个原子操作，而close和fcntl包括两个函数调用。有可能在close和 fcntl之间调用了信号捕获函数，它可能修改文件描述符(第W章将说明信号)。如果不同的线 程改变了文件描述符的话也会出现相同的问题(第11章将说明线程)。

(2)    dup2 和 fcntl 有一些不同的 errno，

i dup2系统调用起源于V7，然后传播至所有BSD版本。而复制文件描述符的fcntl方法则 |首先由系统III使用，然后由System V继续采用。SVR3.2选用了 dup2函数，4.2BSD则选用了 :fcntl函数及F_DUPFD功能。POSIX.1要求兼有dup2及fcntl的F_DUPFD两种功能。

##### 3.13 函数 sync、f sync 和 fdatasync

传统的UNIX系统实现在内核中设有缓冲医髙速缓存或页髙速缓存，大多数磁盘I/O都通过缓冲 区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再 写入磁盘，这种方式被称为地迟写(delayed write) (Bach[1986]的第3章详细讨论了缓冲区髙速缓存)。

通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盤。 为了保证磁盘上实际文件系统与缓冲区中内容的一致性，UNIX系统提供了 sync. fsync和 fdatasync三个函数。

| #include<unistd.h>      |                                      |
| ----------------------- | ------------------------------------ |
| int fsync (int fd)；    |                                      |
| int fdatasync (int fd}; | 返回值：若成功，返回0:若出错，返回-1 |
| void sync(void);        |                                      |

sync只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。

通常，称为update的系统守护进程周期性地调用(一般每隔30秒)sync函数。这就保证

了定期冲洗(flush)内核的块缓冲区。命令sync(l)也调用sync函数。

fsync函数只对由文件描述符片指定的一个文件起作用，并且等待写磁盘操作结束才返回。

fsync可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。

fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数裾外，fsync述会同

步更新文件的属性。

本书说明的所有4种平台都支持sync和fsync西數。但是.FreeBSD 8.0不支持fdatasync。|幻|

##### 3-14 函数 fcntl

fcntl函数可以改变已经打开文件的属性。

| #include<fcntl.h>             |                                                              |
| ----------------------------- | ------------------------------------------------------------ |
| int fcntl (int fd, int cmd,.. | ./* int arg */);返回值：若成功，则依赖于(见下)；若出错，返回-1 |

在本节的各实例中，第3个参数总是一个整数，与上面所示函数原型中的注释部分对应。但 是在14.3节说明记录锁时，第3个参数则是指向一个结构的指针。

fcntl函数有以下5种功能。

(1)    复制一个已有的描述符F_DUPFD 或 F_DUPFD_CLOEXEC)。

(2)    获取/设置文件描述符标志

(3)    获取/设置文件状态标志(cme/=f_GETFL或ELSETFL)。

(4)    获取/设置异步I/O所有权((?卯/=7」^|1'0卵或7_35110卵)。

(5)    获取/设置记录锁(cW=F_GETLK. F_SETLK 或 F_SETLKW)。

我们先说明这11种cmd中的前8种(14.3节说明后3种，它们都与记录锁有关)。参照图3-7,我

们将讨论与进程表项中各文件描述符相关联的文件描述符标志以及每个文件表项中的文件状态标志。 F_DUPFD    复制文件描述符片。新文件描述符作为函数值返回。它是尚未打开的

各描述符中大于或等于第3个参数值（取为整型值）中各值的最小值。 新描述符与片共享同一文件表项（见图3-9）。但是，新描述符有它 自己的一套文件描述符标志，其FD_CLOEXEC文件描述符标志被清 除（这表示该描述符在exec时仍保持有效，我们将在第8章对此进 行讨论）。

F_DUPFD_CLOEXEC复制文件描述符，设置与新描述符关联的FD_CLOEXEC文件描述符标 志的值，返回新文件描述符。    _

F_GETFD    对应于汾的文件描述符标志作为函数值返回当前只定义了一个文件

描述符标志FD_CLOEXEC。

[82] F_SETFD    对于片设置文件描述符标志。新标志值按第3个参数（取为整型值）

设置。

:    要知道，很多现有的与文件描述符标志有关的程序并不使用常量FD_CLOEXEC,而是将此标

志设置为0 （系统跃认，在exec时不关闭 > 或1 （在exec时关闭）。

F_GETFL    对应于片的文件状态标志作为函数值返回。我们在说明open函数时，

已描述了文件状态标志。它们列在图3-10中。

| 文件状态标志 | 说明                              |
| ------------ | --------------------------------- |
| O^RDONLY     | 只读打开                          |
| O_WRONLY     | 只写打开                          |
| O_RDWR       | 读、写打开                        |
| O_EXEC       | 只执行打开                        |
| O_SEARCH     | 只搜索打开目录                    |
| O_APPEND     | 追加写                            |
| 0_NONBLOCK   | 非阻塞模式                        |
| CLSYNC       | 等待写完成（数据和属性）          |
| O_DSYNC      | 等待写完成（仅数据）              |
| O_RSYNC      | 同步读和写                        |
| O_FSYNC      | 等待写完成（仅FreeBSD和Mac OS X） |
| O ASYNC      | 异步 I/O C仅 FreeBSD 相 Mac OS X) |

图3-10对于fcntl的文件状态标志

遗憾的是，5 个i方问方式标志（O_RDONLY、O_WRONLY、O_RDWR、O_EXEC 以及O_SEARCH）并不各占1位（如前所述，由于历史原因，前3个标 志的值分别是0、1和2。这5个值互斥，一个文件的访问方式只能取 这5个值之一）。因此首先必须用屏蔽字O.ACCMODE取得访问方式位， 然后将结果与这5个值中的每一个相比较。

F„SETFL    将文件状态标志设置为第3个参数的值（取为整型值），可以更改的几

个标志是：O_APPEND> O_NONBLOCK, O_SYNC、O_DSYNC、O_RSYNC、 O_FSYNC 和 0_ASYNCo

F^GETOWN    获取当前接收SIGIO和SIGURG信号的进程ID或进程组ID。14.5.2

节将论述这两种异步I/O信号。

F_SETOWN



设置接收SIGIO和SIGURG信号的进程ID或进程组ID。正的山^指 定一个进程ID，负的表示等于azg绝对值的一个进程组ID。 fcntl的返回值与命令有关。如果出错，所有命令都返回一1，如果成功则返回某个其他值。

下列4个命令有特定返回值：F_DUPFD、F_GETFD、F_GETFL以及F_GETOWN。第1个命令返回 新的文件描述符，第2个和第3个命令返回相应的标志，最后一个命令返回一个正的进程ID或负nn 的进程组ID。

'■实例

图3-11中所示程序的第1个参数指定文件描述符，并对于该描述符打印其所选择的文件标 志说明。

\#include "apue.h"

\#include <fcntl.h>

int

main(int argc, char *argv[])

int val;

if (argc != 2)

err_quit("usage: a.out <descriptor#>");

if ((val = fcntl(atoi(argv[l]), F_GETFL, 0)) < 0)

err_sys("fcntl error for fd %d", atoi(argv[1]));

switch (val & O_ACCM0DE) { case O_RDONLY:

printf{"read only"); break;

case O_WRONLY:

printf("write only"); break;

case O_RDWR:

printf{"read write"); break;

default:

err_dump("unknown access mode");

if (val & O_APPEND)

printf (•’，append");

if (val & O_NONBLOCK)

printfnonblocking");

if (val & O_SYNC)

printf synchronous writes");

\#if !defined(_POSIX_C_SOURCE) && defined(O_FSYNC) && (O_FSYNC !■ O_SYNC) if (val & O_FSYNC)

printf(", synchronous writes");

\#endif

putchar(*\n')； exit(O) i

图3-11对于指定的描述符打印文件标志

注意，我们使用了功能测试*_POSIX_C_SOURCE,并且条件编译了 POSIX.1中没有定义的 I 84 |文件谛问标志。下面显示了从bash (Boume-again shell)调用该程序时的几种情况。当使用不同

shell时，结果会有些不同。

$./a.out 0 < /dov/tty

read only

$./a.out 1 > tonqi.foo $ cat tnr fnci write only

$./a.out 2 2»tooq>.foo

write only, append

$ ./a.out 5 Soteap.foo

read write

子句5<>temp. foo表示在文件描述符5上打开文件temp, foo以供读、写。

、实例

在修改文件描述符标志或文件状态标志时必须谨慎，先要获得现在的标志值，然后按照期望修改 它，最后设置新标志值。不能只是执行命令，这样会关闭以前设置的标志位。

图3-12是对于一个文件描述符设置一个或多个文件状态标志的函数。

\#include "apue.h"

♦include <fcntl.h>

void

set_f1(int fd, int flags) /* flags are file status flags to turn on */

int    val;

if ({val = fcntltfd, F_GETFL, 0)) < 0) err_sys (''fcntl F_GETFL error");

val I= flags;    /* turn on flags */

if {fcntl(fd, F_SETFL, val) < 0)

err_sys (•• fcntl F_SETFL error");

J

图3-12对一个文件描述符开启一个或多个文件状态标志

如果将中间的一条语句改为：

val &= —flags;    /* turn flags off */

就构成另一个函数，我们称为clr_fl,并将在后面某些例子中用到它。此语句使当前文件状态 RTI标志值val与flags的反码进行逻辑“与”运算。

如果在图3-5程序的开始处加上下面一行以调用set_fl,则开启了同步写标志。

set_fl{STDOUT_FILENO, O_SYNC）;

这就使每次write都要等待，直至数据已写到磁盘上再返回。在UNIX系统中，通常write只 是将数据排入队列，而实际的写磁盘操作则可能在以后的某个时刻进行。而数据库系统则需要使 用O_SYNC，这样一来，当它从write返回时就知道数据已确实写到了磁盘上，以免在系统异 常时产生数据丢失，

程序运行时，设置O_SYNC标志会增加系统时间和时钟时间。为了测试这一点，先运行图3-5程 序，它从一个磁盘文件中将492.6 MB的数据复制到另一个文件。然后，对比设置了 O_SYNC标志的 程序，使其完成同样的工作。在使用ext4文件系统的Linux上执行上述操作，得到的结果如图3-13 所示。

| 操作                               | 用户CPU （s〉 | 系统CPU (s) | 时钟吋间（S） |
| ---------------------------------- | ------------- | ----------- | ------------- |
| 取自图3-6中BUFFSIZE=4 096的读时间  | 0.03          | 0.58        | 8.62          |
| 正常写到磁盘文件                   | 0.00          | 1.05        | 9.70          |
| 设置O_SYNC后写到磁盘文件           | 0.02          | 1.09        | 10.28         |
| 写到磁盘后接着调用fdatasync        | 0.02          | 1.14        | 17.93         |
| 写到磁盘后接着调用fsync            | 0.00          | 1.19        | 18.17         |
| 设置CLSYNC后写到磁盘.接着调用fsync | 0.02          | 1.15        | 17.88         |

图3-13在Linux ext4中采用各种同步机制后的计时结果 图3-13中的6行都是在BUFFSIZE为4 096字节时测量的。图3-6中的结果所测量的情

况是读一个磁盘文件，然后写到/dev/mill，所以没有磁盘输出。图3-13中的第2行对应于 读一个磁盥文件，然后写到另一个磁盘文件中。这就是为什么图3-13中第1行与第2行有差 别的原因。在写磁盘文件时，系统时间增加了，其原因是内核需要从进程中复制数据，并将 数据排入队列以便由磁盘驱动器将其写到磁盘上。当写至磁盘文件时，我们期望时钟时间也 会增加。

当支持同步写时，系统时间和时钟时间应当会显著增加。但从第3行可见，同步写所用的系 统时间并不比延迟写所用的时间增加很多。这意味着要么Linux操作系统对延迟写和同步写操作 的工作量相同（这其实是不太可能的），要么O_SYNC标志并没有起到期望的作用。在这种情况 下，Linux操作系统并不允许我们用fcntl设置O_SYNC标志，而是显示失败但没有返回出错（但 如果在文件打开时能指定该标志，我们还是应该f重这个标志的）。

最后3行中的时钟时间反映了所有写操作写入磁盘时需要的附加等待时间。同步写入 文件之后，我们希望对fsync的调用并不会产生效果。这种情况理应在图3-13中的最后[86] 一行中呈现，但既然O_SYNC标志并没有起到预期的作用，所以最后一行和第5行的表现 几乎相同。

图3-14显示了在采用HFS文件系统的Mac OS X 10.6.8上运行同样的测试得到的计时结 果。该计时结果与我们的期望相符：同步写比延迟写所消耗的时间增加了很多，而且在同步 写后再调用函数fsync并不产生测量结果上的显著差别。还要注意的是，在延迟写后增加一 个fsync函数调用，测量结果的差别也不大。其可能原因是，在向某个文件写入新数据时，

操作系统已经将以前写入的数据都冲洗到了磁盘上，所以在调用函数fsync时只需要做很少 的工作。

| 操作                                | 用户CPU Cs) | 系统CPU (s) | 时钟时间（s） |
| ----------------------------------- | ----------- | ----------- | ------------- |
| 写到/dev/null                       | 0.14        | 1.02        | 5.28          |
| 正常写到磁盘文件                    | 0.14        | 3.21        | 17.04         |
| 设置O_SYNC后写到磁盘文件            | 0.39        | 16.89       | 60.82         |
| 写到磁盘后接着调用fsync             | 0.13        | 3.07        | 17.10         |
| 设置0 SYNC后写到磁盘，接着调用fsync | 0,39        | 18.18       | 62.39         |

图3-14在Mac OS XHFS中采用各种同步机制后的计时结果

比较fsync和fdatasync,两者都更新文件内容，用了 0_SYNC标志，每次写入文件时都 更新文件内容。每一种调用的性能依赖很多因素，包括底层的操作系统实现、磁盘驱动器的速度 以及文件系统的类型。    ■-

在本例中，我们看到了 fcntl的必要性。我们的程序在一个描述符（标准输出）上进行操作， 但是根东不知道由shell打开的相应文件的文件名。因为这是shell打开的，因此不能在打开时按我 们的要求设置O^SYNC标志。使用fcntl,我们只需要知道打开文件的描述符，就可以修改描述符的 属性。在讲解管道时（15.2节）还会用到fcntl,因为对于管道，我们所知的只有其描述符。

##### 3.15 函数 ioctl

ioctl函数一直是I/O操作的杂物箱。不能用本章中其他函数表示的I/O操作通常都能用ioctl 表示。终端I/O是使用ioctl最多的地方（在第18章中将看到，POSIX.1已经用一些单独的函 数代替了终端I/O操作）。

\#include <unistd.h> /* System V *7

♦include <sys/ioctl.h> /* BSD and Linux */

int ioctl {int fd, int request,…)；

.    返回值：若出错，返回-1:若成功，返回其他值

ioctl曲数是Single UNIX Specification标准的一个扩展部分，以便处理STREAMS设备[Rago 1993],但是，在SUSv4中已被移至弃用状态。UNIX系统实現用它进行很多杂项设备操作。有些

I实现甚至将它扩展到用于普通文件。

我们所示的函数原型对应于POSIX.1, FreeBSD 8.0和Mac OS X 10.6.8将第2个参数声明为 unsigned long。因为第2个参数总是头文件中一个#def ined的名字，所以这种细节并没有 什么影响-

对于ISO C原型，它用省略号表示其余参数、但是，通常只有另外一个参数，它常常是指向 一个变量或结构的指针。

在此原型中，我们表示的只是ioctl函数本身所要求的头文件。通常，还要求另外的设 备专用头文件。例如，除POSIX.1所说明的基本操作之外，终端I/O的ioctl命令都需要头 文件<termios. h><»

每个设备驱动程序可以定义它自己专用的一组ioctl命令，系统则为不同种类的设备提供 通用的ioctl命令。图3-15中总结了 FreeBSD支持的通用ioctl命令的一些类别。

| 类别      | 常量名  | 头文件            | ioctl数 |
| --------- | ------- | ----------------- | ------- |
| 盘标号    | DIOxxx  | <sys/disklabel.h> | 4       |
| 文件I/O   | FIOxxx  | <sys/filio.h>     | 14      |
| 磁带I/O   | MTIOXXX | <sys/mtio.h>      | 11      |
| 套接字I/O | SIOxxx  | <sys/sockio.h>    | 73      |
| 终端I/O   | TIOxxx  | <sys/ttycom.h>    | 43      |

图3-15 FreeBSD中通用的ioctl操作

磁带操作使我们可以在磁带上写一个文件结束标志、倒带、越过指定个数的文件或记录等，

用本章中的其他函数(read、write. Iseek等)都难于表示这些操作，所以，对这些设备进 行操作最容易的方法就是使用ioctl。

在18.12节中将说明使用ioctl函数获取和设置终端窗口大小，19.7节中使用ioctl函数 访问伪终端的高级功能。

3-16 /dev/fd

较新的系统都提供名为/dev/fd的目录，其目录项是名为0、1、2等的文件。打开文件 /dev/fd/n等效于复制描述符(假定描述符《是打开的)。

丨    /dev/fd这一功能是由Tom Duff开发的，它首先出现在Research UNIX系统的第8版中，

\* 本书说明的所有 4 种系统(FreeBSD 8.0、Linux 3.2.0, Mac OS X 10.6.8 和 Solaris 10)都支持这一 J功能。它不是POSIX.1的组成部分。

在下列函数调用中：    [88]

fd = open("/dev/fd/0", mode);

大多数系统忽略它所指定的node,而另外一些系统则要求mode必须是所引用的文件(在这里 是标准输入)初始打开时所使用的打开模式的一个子集。因为上面的打开等效于

fd = dup(0);

所以描述符0和fd共享同一文件表项(见图3-9)。例如，若描述符0先前被打开为只读，那么 我们也只能对fd进行读操作。即使系统忽略打开模式，而且下列调用是成功的：

fd = open("/dev/fd/0", O_RDWR)，-我们仍然不能对fd进行写操作。

Linux实现中的/dev/fd是个例外。它把文件描述符映射成指向底层物理文件的符号链接。

；例如，当打开/dev/fd/0时，事实上正在打开与标准输入关联的文件，因此近回的新文件描述符 '的模式与/dev/fd文件描述符的模式其实并不相关。

我们也可以用/dev/fd作为路径名参数调用creat,这与调用open时用O_CREAT作为第 2个参数作用相同。例如，若一个程序调用create并且路径名参数是/dev/fd/1，那么该程序 仍能工作。

注意，在Linux上这么做必须非常小心。因为Linux实现使用指向实际文件的符号链接，在 /dev/fd文件上使用creat会导致底居文件被截断。

某些系统提供路授名/dev/stdin, /dev/stdout和/dev/stderr ,这些等效于 /dev/fd/O、 /dev/fd/1和/dev/fd/2。

/dev/fd文件主要由shell使用，它允许使用路径名作为调用参数的程序，能用处理其他路 径名的相同方式处理标准输入和输出。例如，cat(l)命令对其命令行参数采取了一种特殊处理. 它将单独的一个字符解释为标准输入。例如：

filter file2 I cat filel - file3 1 lpr

首先cat读filel，接着读其标准输入(也就是filter file2命令的输出〉，然后读file3, 如果支持/ciev/fd，则可以删除cat对的特殊处理，于是我们就可键入下列命令行：

filter file2 I cat filel /dev/fd/0 file3 \ lpr

作为命令行参数的特指标准输入或标准输出，这己由很多程序采用。但是这会带来一 些问题，例如.如果用指定第一个文件，那么看来就像指定了命令行的一个选项。/dev/fd

®则提髙了文件名参数的一致性，也更加清晰。

##### 3.17小结

本章说明了 UNIX系统提供的基本I/O函数。因为read和write都在内核执行，所以称 这些函数为不带缓冲的I/O函数。在只使用read和write情况下，我们观察了不同的I/O长度 对读文件所需时间的影响。我们也观察了许多将已写入的数据冲洗到磁盘上的方法，以及它们对 应用程序性能的影响。

在说明多个进程对同一文件进行追加写操作以及多个进程创建同一文件时，本章介绍了 原子操作。也介绍了内核用来共享打开文件信息的数据结构。在本书的稍后还将涉及这些数 据结构。

我们还介绍了 ioctl和fcntl函数,本书后续部分还会涉及这两个函数。第14章还将fcntl 用于记录锁，第18章和第19章将ioctl用于终端设备。

3.1当读/写磁盘文件时，本章中描述的函数确实是不带缓冲机制的吗？请说明原因。

3.2    编写一个与3.12节中duP2功能相同的函数，要求不调用fcntl函数，并且要有正确的出 错处理。

3.3    假设一个进程执行下面3个函数调用：

fdl = open(path, oflags);

fd2 = dup(fdl);

fd3 = open(path, oflags);

画出类似于图3-9的结果图。对fcntl作用于fdl来说，F_SETFD命令会影响哪一个文 件描述符？ F_SETFL呢？

3.4许多程序中都包含下面一段代码：

dup2(fd, 0); dup2(fd, 1);

dup2(fd, 2); if {fd > 2)

close(fd);

为了说明if语句的必要性，假设fd是1，画出每次调用dup2时3个描述符项及相应的 文件表项的变化情况，然后再画出fd为3的情况。

3.5    在 Bourne shell、Boume-again shell 和 Korn shell 中’    表示要将描述狩 </初7/

重定向至描述符冰的同一文件。请说明下面两条命令的区别。

./a.out > outfile 2>&1 ./a.out 2>&1 > outfile (提示：shell从左到右处理命令行。)

3.6    如果使用追加标志打开一个文件以便读、写，能否仍用lseek在任一位置开始读？能否用

Iseek更新文件中任一部分的数据？请编写一段程序验证。    [9?]
