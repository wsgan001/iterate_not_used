
## 边缘检测

Goal: Identify sudden changes (discontinuities) in an image

- Intuitively, most semantic and shape information from the image can be encoded in the edges
- More compact than pixels

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/A1La1LDDfc.png?imageslim)


Why do we care about edges?
- Extract information , recognize objects ![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/6A0cGeiJk3.png?imageslim)
- Recover geometry and viewpoint ![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/Lj98jmhCK0.png?imageslim)

可见，应用还是有的，通过物体来找到一副图像的水平线的位置。


### 边缘是怎么产生的？

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/bDd5J1dla9.png?imageslim)

- 一种是由于深度上的不连续，即景深，标杆与树的景深是不同的，在他们的交界处产生了边缘。
- 还有一种是物体表面对于光的反射率不同，在路面上，涂的指示标识。
- 还有就是照明的问题，在树的下面会产生树荫，这个也会产生边缘。

### 下面，我们看一下，在图像里面是如何产生边缘的：

- Look for detectable, meaningful parts of the image
- Edges are detected at places where the image values exhibit sharp variation

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/lKKf8d8mkl.png?imageslim)

由于明暗的变化，就会产生边缘。

在真实的图像中肯定不会突变的，

对于一维的，我们想知道边缘，就可以求导：

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/BmDL35Gcdk.png?imageslim)

那么求导在编程的时候怎么实现：

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/hFm9I3e9Jj.png?imageslim)

可见，这个求导的过程，导数可以看做左右两个点的差的平均值，也就可以看成一个 1*3 的模板，在图像中水平滑动。<span style="color:red;">厉害。</span>

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/cA3lfffHDb.png?imageslim)

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/hF1ek3cc2H.png?imageslim)

刚才我们已经拿到了竖直方向的边缘： ![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/lHfFHD0i4E.png?imageslim)

同样的，我们可以知道水平方向的边缘：![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/K0i8KC2E81.png?imageslim)


我们举个例子：

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/8d5H0E55D1.png?imageslim)

左下角的图就是竖直方向的边缘，右下角的图就是水平边缘。

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/gm2j5Hhd3l.png?imageslim)

上面这个图表达的是梯度大小，后面我们讲到车牌识别的时候，会用不同的边缘和不同的方向来滤波。

## 去噪，然后边缘检测

实际上呢，上面我们求边缘的时候还是很顺利的，相当于左右两个像素的差分，但是，实际中我们真正拿到的数据是含有噪声的，

Consider a single row or column of the image

- Plotting intensity as a function of position gives a signal

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/J02A9H5hE2.png?imageslim)

这样的含有噪声的图像来做微分，噪声会非常大，根本找不到边缘的位置。

因此，在我们拿到一副图像之后，要先用滤波器去燥，然后再进行边缘检测。

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/FlKjdA97hE.png?imageslim)

我们要有个概念：进行梯度运算对噪声是非常敏感的，因此我们需要一个 smooth 的过程，不管是高斯滤波器还是滑动平均都可以。就相当于加了一个线性滤波器。

这样，我们就拿到了一个新的 3*3 的边缘检测的滤波器：

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/CfFHg7F73h.png?imageslim)

This mask is called the (vertical) Prewitt Edge Detector
Outer product of box filter $[1\, 1\, 1]^T$ and $[-1\, 0\, 1]$

这样我们就可以再竖直方向进行去燥，同时检测出这个方向的边缘。

同样的：水平方向的去噪和边缘检测：

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/9lBjB34fa5.png?imageslim)

This mask is called the (horizontal) Prewitt Edge Detector

这就是非常著名的 prewitt 边缘检测。



举个例子：

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/94d0380mF2.png?imageslim)

可见，我们清晰的检测到了边缘。



OK，下面我们修改一下这个滤波器的权重：

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/L6b9hGj9F0.png?imageslim)

距离中心越近，权重越大，越远，权重越小。这个滤波器也是非常常用的。

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/c4dJhGac9f.png?imageslim)

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/1j4LjkF4kG.png?imageslim)


Robinson Compass Masks

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/cid0iG18Ga.png?imageslim)

这个在图像处理了领域用的非常的多，他进行不同的排列，得到了不同的边缘信息，上面箭头的方向指的是灰度的变化方向，不是边缘的方向。

其实，我们在做CNN 的时候，其实就是要拿到图像中的某种信息，通过不同的mask 进行卷积运算，就能抽取到图像的边缘信息，把这些信息组合起来，作为图像的表达，当这种信息足够充足的时候，这时候提出来的 feature 是非常 rubost 的。




Other edge detectors - second-order
derivative filters (1D)

- Peaks of the first-derivative of the input signal, correspond to “zero-crossings” of the second-derivative of the input signal.

我们看到，

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/13I8IEg0aB.png?imageslim)


![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/Hm6ig9Ki2a.png?imageslim)

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/3H4JKjebaJ.png?imageslim)

这样的操作，只对 filter 进行操作，就减少了很多的计算量，这样就算出了二阶导数，二阶导数为 0 的位置就是边缘的位置。

Edge Detection (2D)

我们看一下数学：

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/jm61L595E2.png?imageslim)

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/DBi4k7KJJ6.png?imageslim) 也叫作图像的拉普拉斯。

求二阶导一个重要的弊端，就是他对噪声非常的敏感。


Notes about the Laplacian:
- $\triangledown ^2|(x,y)$ is a SCALAR
    -  Can be found using a SINGLE mask
    -  Orientation information is lost
- $\triangledown ^2|(x,y)$ is the sum of SECOND-order derivatives
    - But taking derivatives increases noise
    - Very noise sensitive!
- It is always combined with a smoothing operation:
- Filter Laplacian of Gaussian LOG filter

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/Df3Adk6eaj.png?imageslim)

所以，我们在应用图像的拉普拉斯的时候，要在前面加上滤波器，一般都是 高斯滤波器，这样就组成了一个 高斯-拉普拉斯滤波器 也就是 LOG

这个 LOG 滤波器我们在后面会大量的用到。

我们看一下 从一维到二维的变化：

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/ELiiEH106f.png?imageslim)


![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/0eIihFae15.png?imageslim)

在二维的时候图像如下：叫做 Mexican Hat 墨西哥帽

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/4gBAJ6HAdm.png?imageslim)

这个了解一下就行，属于小波的一种。

我们回过来谈一下在离散域上怎么计算二阶导数：

一维的高斯滤波器挪到二维上：

We know better alternative to smoothing

Smooth using Gaussian filter

g(x) is a 1-D Gaussian filter, g(x,y) – 2-D Gaussian filter

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/KifLa1IcGJ.png?imageslim)

Taking a derivative – linear operation (take the derivative of the filter)

![mark](http://pacdb2bfr.bkt.clouddn.com/blog/image/180806/ajCDiJ2bmB.png?imageslim)
