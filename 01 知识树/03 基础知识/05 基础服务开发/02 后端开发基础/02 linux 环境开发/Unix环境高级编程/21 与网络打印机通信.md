### 第21章

#### _与网賄印机通信

##### 21.1引言

现在我们开发一个能够与网络打印机通信的程序。这些打印机通过以太网与多个计算机互 联，并且通常既支持纯文本文件也支持PostScript文件。尽管一些应用程序也支持其他通信协议， 但一般使用网络打印协议(Internet Printing Protocol，IPP)与打印机通信。

我们将描述两个程序：打印假脱机守护进程(print spooler daemon)将作业发递到打印机：命令行 程序将打印作业jmu假脱机守护进程。因为假脱机守护进程必须处理很多操作(与客户端通信来提交 作业、与打印机通信、读文件、扫描目录等)，这就提供了一个机会来使用前面章节所提到的函数。例 如，■线程(第11章和第12章)来简化»机守护进程的设计，棚套齡(第16章)在调度文 件打印的程序和打印假脱机守护递程之间通信，也可以在打印假脱机守护进程与网络打印机之间通信。

21.2网络打印协议

网络打印协议(ipp)为建立基于网络的打印系统指定了通信规则。通过将一个ipp服务器嵌 入到带网卡的打印机中，打印机就能够对许多计算机系统的请求加以服务。这些计算机系统实际 上并不需要在同一个物理网络中。因为ipp是建立在标准的因特网协议上的，所以任何一台能够

®与打印机建立TCP/IP连接的计算机都能向打印机提交打印作业。

IPP由一系列IETF标准文档(Requests For Comment, RFC)说明，这些文档可以在 <http://www.ietf>. org/rfc.html 上获得。IEEE 相关的打印机工作组(Printer Working Group)制定的标准草案也可以在http://www.pwg.org/ipp上获得。图21-1列出了 IPP的 主要文档，还有许多其他文档进一步说明了过程管理、作业属性等信息。

| 文件                 | 标题                        |
| -------------------- | --------------------------- |
| RFC 2567             | IPP设计目标                 |
| RFC 2568             | IPP模型与协议架构的基本原理 |
| RFC 2911             | IPP/1.1:模型与语义          |
| RFC 2910             | IPP/1.1：编码与传输         |
| RFC 3196             | IPP/1-b实现者指南           |
| 候选标准5100.12-2011 | IPP2.0,第 2 版              |

图21-1基本的IPP文档

候选标淮5100.12-2100指明实现提供的所有功能都要能够支持符合不同的IPP标准版本。有

许多建议性的IPP协议扩展（具体的功能在IPP相关文档中定义）。将这些功能分组创建出不同的 一致性分级：每一级是一个不同的协议版本。对于兼容性，每个更髙的一致性级别要符合低版本 定义的大多数要求。本章的示例中使用的是IPP 1.1版本。

IPP 建立在超文本传输协议（Hypertext Transfer Protocol, HTTP）之上（21.3 节）。HTTP 又 建立在TCP/IP之上。IPP报文的结构如图21-2所示。

| 以太网 | IP   | TCP  | HTTP | IPP  |              |
| ------ | ---- | ---- | ---- | ---- | ------------ |
| 首部   | 首部 | 首部 | 首部 | 首部 | 要打印的数据 |

图21-2 IPP报文结构

IPP是请求响应协议。客户端发送请求到服务器，服务器用响应报文回答这个请求。IPP首部 包含一个域来指示所需操作，这咎操作可以定义成提交打印作业、取消打印作业、获取作业属性、

获取打印机属性、暂停和重启打印机、挂起一个作业和释放一个挂起的作业。

图21-3显示了一个IPP首部的结构。前两个字节表示IPP版本号，对于1.1版本协议，每个 字节的值是1。对于一个请求协议，接下来两个字节包含一个值来指示请求操作的类型。对于一 个响应协议，这两个字节包含一个状态码。    ®

| tt本号                      | （2字节）  |
| --------------------------- | ---------- |
| 操作ID（清求》/状态再（触） | （2字节｝  |
| 请求ID                      | （4字节）  |
| 属性                        | (0_n字节＞ |
| 厲性结束标志                | （1字节）  |
| 图21-3 IPP首部结构          |            |

接下来4字节包含一个整数以标识请求，使得请求和响应相匹配。接着是可选的属性，然后 用属性结束标志终止。贤接着属性结束标志之后是任何与请求相关联的数据。

在首部，整数以有符号二进制补码以及大端字节序（即网络字节序）方式存储。属性按照组 来存储。每个组都以标识该组的一个字节开始。在每一个组中，属性通常表示为：1字节的禄志， 然后是2字节属性名长度，接着是属性名，然后是2字节属性值长度，最后是属性值本身。属性 值可以编码成字符串、二进制整数或者更为复杂的结构，如日期/时间戳。

图21-4显示了 attributes-charset属性是如何编码成utf-8类型的值的。

| 厲性标志= 0x47            | （1字节） |
| ------------------------- | --------- |
| 属性名长度=18             | （2字节） |
| 属性名=attributes-charset | (18       |
| 属性值长度=5              | （2字节） |
| 属性值=utf-8              | （5字节） |
| 图21~4 IPP属性编码样例    |           |

根据所请求的操作，一些属性需要在请求报文中提供，而另一些是可选的。例如，图12-5显 [79?]示了用于为打印作业请求定义的属性。

| 属性                        | 状态 | 描述                                                         |
| --------------------------- | ---- | ------------------------------------------------------------ |
| attributes-charset          | 必需 | text或name类型属性所使用的字符集                             |
| attributes-natural-language | 必需 | text或name类型属性所使用的自然语言                           |
| printer-uri                 | 必需 | 打印机的统一资源标识符                                       |
| requesting-user-name        | 可选 | 提交作业的用户名（如果可以，可用于认证）                     |
| job-name                    | 可选 | 用于区别多个作业的作业名                                     |
| ipp-attribute-fidelity      | 可选 | 如果为真，告诉打印机如果属性不匹配就拒绝作业：否 则，打印机尽可能打印作业 |
| document-name               | 可选 | 文档名C如适合打印一个旗标）                                  |
| document-format             | 可选 | 文档格式（如纯文本、PostScript）                             |
| document-natural-language   | 可选 | 文档的自然语言                                               |
| compression                 | 可选 | 压缩文档的算法                                               |
| job-k-octets                | 可选 | 以1 024字节单位计算的文档大小                                |
| job-impressions             | 可选 | 作业中提交的图（嵌入在页面中的图像〉的数量                   |
| job-media-sheets            | 可选 | 作业打印张数                                                 |

图21-5打印作业请求的属性

IPP首部包含了文本和二进制混合数据。属性名存储为文本，而数据大小存储为二进制整数。 这使得构建和分析首部的过程变得复杂，因为需要考虑诸如网络字节序、主机处理器是否在任意 字节边界编址对齐之类的问题。一个较好的可选方案是将首部设计成仅包含文本。这样以稍微膨 胀一些协议报文为代价简化处理过程。

##### 21.3超文本传输协议HTTP

HTTPV1.1由RFC2616说明。HTTP也是请求响应协议。请求报文包含的一个开始行，跟着 是首部行，接着是空白行，然后是一个可选的实体主体。在我们这种情况，实体主体包含IPP首 部和数据。

HTTP首部是ASCII码，每行以回车（\r）和换行符（\n）结束。开始行包含一个mefAod 来指示客户端请求的操作、一个统一资源定位符（Uniform Resource Locator，URL）来描述服 务器和协议、一个字符串来表示HTTP版本。IPP所用的方法仅为POST,用于将数据发送到 服务器。

首部行指定属性，如实体主体的格式和长度。一个首部行包含一个属性名.后紧随一个冒号， 接着是可选的空格符，然后是属性值，最后以回车和换行符结束。例如，为了指定实体主体包含 IPP报文，应包含如下的首部行：

|792~| Content-Type: application/ipp

下面是对于作者使用的Xerox Phaser8560打印机的打印请求的HTTP首部样例。

POST Zipp HTTP/l.l^M

Content-Length: 21931AM

Content-Type: application/ippAM

Host: phaser8560:631AM

■M

Content-Length行指明了 HTTP报文中数据的字节大小。这个长度不包含了 HTTP首部的大 小，但包括IPP首部的大小。Host行指明了要发送报文的服务器主机名称和端口号。

每行后面的。M是换行符前的回车符。换行符不能被显示成可打印字符。注意，首部的最后一 行是空的，只有回车和换行符。

HTTP响应报文的起始行包含了版本字符串，紧接着的是一个数字状态码和状态信息，最后 以一个回车和换行结束。HTTP响应报文的剩余部分和请求报文的格式一样：首部之后是一个空 白行和可选的实体主体。

打印机需要发送给我们如下的报文作为打印请求的回应：

HTTP/1.1 200 OK"M

Content-Type: application/ipp"M

Cache-Control: no-cache, no-store, must-revalidate"M

Expires: THUr 26 OCT 1995 00:00:00 GMT"M

Content-Length: 215"M

Server: Allegro-Software-RomPager/4,34"M

对于打印假脱机守护进程，我们只关心报文的第一行：它说明了请求成功或者用数字错误码以及 一个短字符串表示请求失败。剩下的报文包含了附加信息，可以通过在客户端和服务器间的节点 来控制缓存以及表明运行在服务器上的软件版本号。

21.4打印假脱机技术

本章中我们开发的程序是一个基本的打印假脱机守护进程。一个简单的用户命令发送一个文 件到打印假脱机守护进程：假脱机守护进程将其保存到磁盘，将请求送入队列，最终将文件发送 到打印机。

所有的UNIX系统至少提供一个打印假脱机系统。FreeBSD安装的是BSD的打印假脱机 系统 LPD（参见 lpd（8）和 Stevens [1990]第 13 章）。Linux 和 Mac OSX 包括 CUPS，即 Common UNIX Printing System（参见cupsd（8））。Solaris提供标准的System V打印假脱机守护进程（参LZ2ll 见1P（1）和lpSChed（lM））。在本章中，我们的兴趣不在于这些假脱机系统本身，而是如何与 网络打印机通信。我们需要开发一个假脱机系统能够解决多用户访问单一资源（打印机）

问题。

我们使用一个简单的命令行程序读取一个文件，将其送到打印假脱机守护进程。这个命令 行程序由一个选项来强制将文件按照文本来处理（默认是PostScript文件）。这个命令行程序是 prints

在我们的打印假脱机守护进程printd中，使用多线程将任务分解给守护进程来完成。

•    一个线程在套接字上监听从运行print的客户端发来的新打印请求。

•对于每个客户端产生一个独立的线程，将要打印的文件复制到假脱机区域。

•    一个线程与打印机通信，一次发送一个队列中的作业。

•—个线程处理信号。

图21-6显示如何将这些组件整合在一起。

打印配置文件是/etc/printer. conf。这个文件标识了运行打印假脱机守护进程的服务器 主机名和网络打印机的主机名。以printserver关键字开始的行标识了假脱机守护进程。以

printer关键字开始的行标识了打印机，空格符之后跟着打印机的主机名，

print

命令



printd 打印假说机 守护进程



###### I配置文a



![img](UNIXaf83d8a7160b-87.png)



文件

1



等待打印文件队列



文件

2



文件

3



打印机

图21-6打印假脱机组件 —个打印机配置文件样例可能包含下列行：

printserver fujin

printer    phaser8560

其中fujin是运行打印假脱机守护进程的计算机系统主机名，phaser8560是网络打印机的主 [794]机名。我们假设这些名字已经在/etc/hosts中列出或者已经通过正在使用的任意服务进行了注

册，这样我们就可以将这些名字转换成网络地址。

可以在运行打印假脱机守护进程的同一台机器上运行print命令，也可以在同一个网络中

的任意机器上定行它。我们只需配置在/etc/printer.conf中的printserver字段即可， 因为只有守护进程需要知道打印机名称。

安全

拥有超级用户特权的程序可能让计算机系统受到攻击。这些程序通常并不比其他程序更脆 弱，但是被攻破时将导致攻击者能够完全访问你的计算机系统。

本章中的打印假脱机守护进程拥有超级用户特权，在这个例子中能够将一个特权TCP端口号 绑定一个套接字。为了使守护进程能更好地抵御攻击，我们可以：

•按照最少特权的原则（8.11节）设计守护进程。我们获得一个绑定到特权端口的套接字 之后，可以将守护进程的用户ID和组的ID更改为非root （如lp）。所有用于存储队列 中打印作业的文件相目录的拥有者应该是非特权用户。如果被攻击，这种情况下攻击者 只能通过守护进程访向打印子系统。虽然这仍然是一个隐患，但是比起攻击者可以完全 访问系统，其危害性已大大降低了。

•审计守护进程源代码中所有已知的潜在脆弱性漏洞，如缓冲区溢出。

•对不期望或者可疑的行为做日志，这样可以引起管理员注意并进一步调査。

###### 21-5源代码

本章的源代码有5个文件，不包括在前面章节中所用的一些公共库例程。 ipp.h    包含IPP定义的头文件。

print.h    包含公用的常数、数据结构定义以及实用工具例程的声明的头文件。

util.c    用于两个程序的实用工具例程。

print, c    用于打印文件的命令行程序C代码。

printd.c 用于打印假脱机守护进程的C代码。

我们按照所列次序依次分析每个文件，

首先从ipp. h头文件开始。

1    #ifndef _IPP_H

2    #define _IPP_H

7    /*

8    * Status code classes.

| 9        | */                                 |                              |                            |                               |
| -------- | ---------------------------------- | ---------------------------- | -------------------------- | ----------------------------- |
| 10       | #define                            | STATCLASS_OK(x)              | ((x>                       | >=0x0000 && (x) <= OxOOff)    |
| 11       | #define                            | STATCLASS_INFO(x)            | ((x)                       | >=0x0100 && (x) <= OxOlff)    |
| 12       | #define                            | STATCLASS_REDXR(x)    ( (x)  | >=0x0300 S& (x) <= 0x03ff) |                               |
| 13       | #define                            | STATCLASS_CLIERR(x)    { (x) | >=0x0400 && (x) <= 0x04ff) |                               |
| 14       | #define                            | STATCLASS_SRVERR(x)    { {x) | >=0x0500 && (x) <= 0x05ff) |                               |
| 15161718 | /** Status codes.*/#define STAT_OK | 0x0000    /*                 | success */                 |                               |
| 19       | #define                            | STAT_OK_ATTRIGN              | 0x0001 Z*                  | OK; some attrs ignored */     |
| 20       | #define                            | STAT_OK_ATTRCON              | 0x0002    /*               | OK; some attrs conflicted */  |
| 21       | #de£ine                            | STAT_CLI_BADREQ              | 0x0400    /*               | invalid client request */     |
| 22       | #define                            | STAT CLI FORBID              | 0x0401 /*                  | request is forbidden */       |
| 23       | #define                            | STAT_CLI_NOAUTH              | 0x0402    /*               | authentication required */    |
| 24       | #define                            | STAT_CLI_NOPERM              | 0x0403 /*                  | client not authorized */      |
| 25       | frdefine                           | STAT_CLI_NOTPOS              | 0x0404    /*               | request not possible *Z       |
| 26       | #define                            | STAT_CLI_TIMOUT              | 0x0405    /*               | client too slow */            |
| 27       | #define                            | STAT_CLI_NOTFND              | 0x0406 /*                  | no object found for ORI */    |
| 28       | #define                            | STAT_CLI_OBJGONE             | 0x0407    /*               | object no longer available */ |
| 29       | #define                            | S TAT_CLI_TOOBIG             | 0x0408 /*                  | requested entity too big */   |
| 30       | ♦define                            | STAT_CLI_TOOLNG              | 0x0409 /*                  | attribute value too large */  |
| 31       | #define                            | STAT_CLI_BADFMT              | 0x040a /*                  | unsupported doc format */     |
| 32       | ♦define                            | STAT CLI NOTSUP              | 0x040b /*                  | attributes not supported */   |
| 33       | 眷define                           | STAT_CLI_NOSCHM              | 0x040c /*                  | URI scheme not supported */   |
| 34       | #define                            | STAT_CLI_NOCHAR              | 0x040d /*                  | charset not supported */      |
| 35       | tdefine                            | STAT_CLI_ATTRCON             | 0x040e /*                  | attributes conflicted */      |
| 36       | #define                            | STAT_CLI_NOCOMP              | 0x040f /*                  | compression not supported */  |
| 37       | ♦define                            | S TAT_CLI_COMPERR            | 0x0410 /*                  | data can't be decompressed */ |
| 38       | #define                            | STAT_CLX_FMTERR              | 0x0411    /*               | document format error */      |
| 39       | #define                            | ST AT CLI ACCERR             | 0x0412    /*               | error accessing data */       |

| 41   | #define           | STAT_SRV_NOTSUP             | 0x0501    / | '* operation not supported */ |                                  |
| ---- | ----------------- | --------------------------- | ----------- | ----------------------------- | -------------------------------- |
| 42   | ♦define           | S TAT_S RV_UNAVAIL          | 0x0502    / | ■*                            | service unavailable */           |
| 43   | #define           | STAT_SRV_BADVER             | 0x0503 /*   | version not supported */      |                                  |
| 44   | #define           | STAT_SRV_DEVERR             | 0x0504 I    | ■*                            | device error */                  |
| 45   | #define           | STAT_SRV_TMPERR             | 0x0505    / | 1 *                           | temporary error */               |
| 46   | #define           | STAT_SRV_REJECT             | 0x0506 /    | ir                            | server not accepting jobs */     |
| 47   | #define           | STAT_SRV_TOOBUSY            | 0x0507    / | ★                             | server too busy */               |
| 48   | ftdefine          | STAT_SRV_CANCEL             | 0x0508    / | *                             | job has been canceled */         |
| 49   | ttdefine          | STAT_SRV_NOMULTI            | 0x0509 /*   | multi-doc jobs unsupported */ |                                  |
| 50   | /*                |                             |             |                               |                                  |
| 51   | * Operation IDs   |                             |             |                               |                                  |
| 52   | */                |                             |             |                               |                                  |
| 53   | #define           | OP_PRINT_JOB                | 0x02        |                               |                                  |
| 54   | #define           | OP_PRINT_URI                | 0x03        |                               |                                  |
| 55   | #define           | OP_VALIDATE_JOB             | 0x04        |                               |                                  |
| 56   | #define           | OP_CREATE_JOB               | 0x05        |                               |                                  |
| 57   | #define           | OP_SEND_DOC                 | 0x06        |                               |                                  |
| 58   | #define           | OP_SEND_URI                 | 0x07        |                               |                                  |
| 59   | #define           | OP_CANCEL_JOB               | 0x08        |                               |                                  |
| 60   | #define           | OP_GET_JOB_ATTR             | 0x09        |                               |                                  |
| 61   | Mef ine           | OP_GET_JOBS                 | 0x0a        |                               |                                  |
| 62   | ♦define           | OP_GET_PRINTER_ATTR    0x0b |             |                               |                                  |
| 63   | #define           | OP_HOLD_JOB                 | 0x0c        |                               |                                  |
| 64   | #define           | OP_RELEASE_JOB              | OxOd        |                               |                                  |
| 65   | #define           | OP_RESTART_JOB              | OxOe        |                               |                                  |
| 66   | #define           | OP_PAUSE_PRINTER            | 0x10        |                               |                                  |
| 67   | #define           | OP_RESUME_PRINTER           | 0x11        |                               |                                  |
| 68   | #define           | OP_PURGE_JOBS               | 0x12        |                               |                                  |
| 69   | /*                |                             |             |                               |                                  |
| 70   | * Attribute Tags. |                             |             |                               |                                  |
| 71   | */                |                             |             |                               |                                  |
| 72   | #define           | TAG_OPERATION_ATTR          | 0x01        |                               | /* operation attributes tag */   |
| 73   | #define           | TAG_JOB_ATTR                | 0x02        |                               | /* job attributes tag */         |
| 74   | #define           | TAG_END_OF_AT T R           | 0x03        |                               | /* end of attributes tag */      |
| 75   | #define           | TAG_PRINTER_ATTR            | 0x04        |                               | ,* printer attributes tag */     |
| 76   | #define           | TAG UNSUPP ATTR             | 0x05        |                               | 1* unsupported attributes tag */ |

[40〜49] 继续定义状态码。0x500〜0x5ff是服务器错误码。RFC 2911中13.1.1节至13.1.5 节描述了所有的状态码。

[50〜68] 接着定义各种操作H^IPP中定义的每个操作有一个ID（参见RFC 2911的4.4.15节〉。 在本例中，仅用到打印作业操作，

困[69〜76] 属性标志限定了 IPP中请求和响应报文的属性组。这瘦值定义在RFC 2910的3.5.1节。

77    /*

| 78   | * Value | ! Tags. |              |      |      |                      |
| ---- | ------- | ------- | ------------ | ---- | ---- | -------------------- |
| 79   | */      |         |              |      |      |                      |
| 80   | #define | TAG,    | .UNSUPPORTED | 0x10 | /*   | unsupported value */ |
| 81   | #define | TAG.    | •UNKNOWN     | 0x12 | /*   | unknown value */     |
| 82   | #define | TAG—    | .NONE        | 0x13 | /*   | no value */          |
| 83   | #define | TAG.    | ■INTEGER     | 0x21 | /*   | integer */           |
| 84   | #define | TAG_    | ■BOOLEAN     | 0x22 | /*   | boolean */           |
| 85   | #define | TAG.    | ■ENOW        | 0x23 | /*   | enumeration */       |

| 86   | tdefine TAG_OCTSTR             | 0x30                                 | /* octetstring */         |
| ---- | ------------------------------ | ------------------------------------ | ------------------------- |
| 87   | #define TAG_DATETIME           | 0x31                                 | /* dateTime */            |
| 88   | ftdefine TAG_RESOLUTION        | 0x32                                 | /* resolution */          |
| 89   | #define TflG_INTRANGE          | 0x33                                 | /* rangeOfInteger */      |
| 90   | #define TAG_TEXTWLANG          | 0x35                                 | /* textWithLanguage */    |
| 91   | 昝define TAG_NAMEWLANG         | 0x36                                 | /* nameWithLanguage */    |
| 92   | #define TAG_TEXTWOLANG         | 0x41                                 | /* textWithoutLanguage */ |
| 93   | ttdefine TAG_NAMEWOLANG        | 0x42                                 | /* nameWithoutLanguage */ |
| 94   | #define TAG_KEYWORD            | 0x4 4                                | /* keyword */             |
| 95   | #define TAG_URI                | 0x45                                 | /* URI */                 |
| 96   | #define TAG_URISCHEME          | 0x4 6                                | /* uriScheme */           |
| 97   | #define TAG_CHARSET            | 0x4 7                                | /* charset */             |
| 98   | #define TAG_NATULANG           | 0x48                                 | /* naturalLanguage */     |
| 99   | #define TAG_MIMETYPE           | 0x4 9                                | /* mimeMediaType */       |
| 100  | struct ipp_hdr {               |                                      |                           |
| 101  | int8_t major_version; /*       | always                               | 1 */                      |
| 102  | int8_t mino r_vers i on;    /* | always                               | 1 */                      |
| 103  | union {                        |                                      |                           |
| 104  | intl6_t op; /* operation ID *  | Z                                    |                           |
| 105  | intl6_t st; /* status          | */                                   |                           |
| 106  | )u;                            |                                      |                           |
| 107  | int32_t request_id;    /*      | request                              | ID */                     |
| 108  | char    attr_group[1];    /*   | start of optional attributes group ' |                           |
| 109  | /* optional data follows       | */                                   |                           |
| 110  | ｝；                           |                                      |                           |
| 111  | #define operation u.op         |                                      |                           |
| 112  | #define status u.st            |                                      |                           |
| 113  | #endif /* IPP H */             |                                      |                           |

[77-99]    值标志指示每个属性和参数的格式，由RFC 2910的3.5.2节定义。

[100-113]    定义IPP首部的结构。请求报文与响应报文的首部一样，除了请求中的操作ID被

响应中的状态码代替。

在头文件尾部我们用#endif来匹配文件开始的#ifdef。    闹

下一个文件是print.h头文件。

| 1    | #ifndef . | _PRINT_H            |                      |
| ---- | --------- | ------------------- | -------------------- |
| 2    | #define , | _PRINT_H            |                      |
| 3    | /*        |                     |                      |
| 4    | * Print   | server header file. |                      |
| 5    | */        |                     |                      |
| 6    | #include  | <sys/socket.h>      |                      |
| 7    | ♦include  | <arpa/inet.h>       |                      |
| 8    | #include  | <netdb.h>           |                      |
| 9    | #include  | <errno.h>           |                      |
| 10   | #define   | CONFIG_FILE         | "Zetc/printer.conf"  |
| 11   | ♦define   | SPOOLDIR            | "/var/spool/printer" |
| 12   | #define   | JOBFILE             | "jobno"              |
| 13   | #define   | DATADIR             | "data"               |
| 14   | #define   | REQDIR              | "reqs"               |

| 15   | 番if defined{BSD)    |          |
| ---- | -------------------- | -------- |
| 16   | tdefine LPNAME       | "daemon1 |
| 17   | #elif defined(MACOS) |          |
| 18   | #define LPNAME       | "_lp"    |
| 19   | #else                |          |
| 20   | #define LPNAME       | "Ip，'   |
| 21   | #endif               |          |

[1-9]    在这个头文件中包含所需要的所有头文件，应用程序只需简单地包含print.h，而

不需要跟踪所有的头文件依赖关系。

[10〜14]定义实现所需的文件和目录。包含打印守护进程和网络打印机主机名的配置文件在 /etc/printer.conf中。需要打印的文件副本在目录/var/spool/printer/ data中：对于每个请求的控制信息在目录/var/spool/printer/reqs中，包含 下一个作业编号的文件是/var/spool/printer/jobno。

目录必须由管理员创建并且由运行打印守护进程的账户所有。如果这些目录不存在， 守护进程也不会创建这些目录，因为守护进程需要root权限来创建/var/spool 中的目录，我们的设计初衷是当以root权限运行时，尽量让守护进程少做一些事情， 以减少产生安全漏洞的可能。

[15-21] 接着定义运行打印守护进程的账户名。在Linux和Solaris中，这个张户名是lp。在 Mac OS X中，账户名是_lp，FreeBSD没有为打印守护进程定义单独的账户，所以 画_我们使用为系统守护进程保留的账户。_

| 22   | 番define            | FILENMSZ    64                                           |                                      |
| ---- | ------------------- | -------------------------------------------------------- | ------------------------------------ |
| 23   | 番define            | FILEPERM    (S.IRUSRIS_XWUSR)                            |                                      |
| 24   | #define             | USERNM_MAX                                               | 64                                   |
| 25   | tdefine             | JOBNM_MAX                                                | 256                                  |
| 26   | #define             | MSGLEN_MAX                                               | 512                                  |
| 27   | tifndef             | HOST_NAME_MAX                                            |                                      |
| 28   | Idefine             | HOST_NAME_MAX                                            | 256                                  |
| 29   | #endif              |                                                          |                                      |
| 30   | #define             | IPP_PORT                                                 | 631                                  |
| 31   | #define             | QLEN                                                     | 10                                   |
| 32   | tdefine             | IBUFSZ                                                   | 512 Z* IPP header buffer size */     |
| 33   | ♦define             | HBUFSZ                                                   | 512    /* HTTP header buffer size ★/ |
| 34   | tdefine             | I0BUFS2                                                  | 8192 Z* data buffer size */          |
| 35   | #ifndef             | ETIME                                                    |                                      |
| 36   | #define             | ETIME ETIMEDOUT                                          |                                      |
| 37   | #endif              |                                                          |                                      |
| 38   | extern              | int getaddrlist(const char *, const char *,              |                                      |
| 39   | struct addrinfo **) |                                                          |                                      |
| 40   | extern ■            | char *get_printserver(void);                             |                                      |
| 41   | extern              | struct addrinfo *get_printaddr(void)；                   |                                      |
| 42   | extern .            | ssize_t tread(int, void *, size_t, unsigned int);        |                                      |
| 43   | extern .            | ssize_t treadn(int, void *, size_t, unsigned int)；      |                                      |
| 44   | extern              | int connect_retry(int, int, int, const struct sockaddr ■ |                                      |

45    socklen_t）;

46    extern int initserver（int, const struct sockaddr *, socklen_t,

47    int）;

[22〜34]接下来定义限制和常量。FILEPERM是创建要打印的文件副本使用的权限。这个权限 是被限制的，因为我们不希望普通用户在等待打印时能够读取他人的文件。我们定义 HOST_NAME_MAX作为用sysconf不能够确定系统的限制时能够支持的最大的主机名。

IPP被定义为使用端口 631 c^LEN是恃递给listen的backlog参数（具体细节见16.4节）。

[35〜37] —些平台没有定义错误码ETIME,因此另外定义一个错误码，使得在这些系统上有意 义。当读超时时，返回这个错误码（我们不希望在从套接字读的时候服务器无限期地 阻塞）。

[38〜47]接着，定义所有包含在util.c中的公共例程（稍后将分析这些例程）。注意，图16-11

中的connect_retry函数和图16-22中的initserver函数没有包含在util.c中。|80。|

| 484950515253545556  | /** Structure describing a print request.                    |                                |                              |                     |         |
| ------------------- | ------------------------------------------------------------ | ------------------------------ | ---------------------------- | ------------------- | ------- |
| */struct printreq { | Z* size in bytes */                                          |                                |                              |                     |         |
| J；                 | uint32_t size;uint32_t flags;char usernm[USERNM_MAX]; char jobnm[JOBNM_MAX]； |                                |                              |                     |         |
| /*/*/*              | see below */user* s name */ job's name */                    |                                |                              |                     |         |
| 57                  | /*                                                           |                                |                              |                     |         |
| 58                  | *                                                            | Request flags.                 |                              |                     |         |
| 59                  |                                                              | （                             |                              |                     |         |
| 60                  | ttdefine PR_TEXT    0x01                                     | /*                             | treat file as plain          | text */             |         |
| 61                  | /*                                                           |                                |                              |                     |         |
| 62                  | *                                                            | The response from the spooling | daemon to the print command. |                     |         |
| 63                  | */                                                           | f                              |                              |                     |         |
| 64                  | struct printresp {                                           |                                |                              |                     |         |
| 65                  |                                                              | uint32_t retcode;              | /*                           | 0=success, !0=error | code */ |
| 66                  |                                                              | uint32_t jobid;                | /*                           | job ID */           |         |
| 67                  |                                                              | char msg[MSGLEN_MAX];          | /*                           | error message *7    |         |
| 68                  |                                                              |                                |                              |                     |         |
| 69                  | #endif /* PRINT H */                                         |                                |                              |                     |         |

[48〜69] printreq结构和printresp结构定义了 print程序和打印假脱机守护进程之间 的协议。print程序发送printreq结构到打印假脱机守护进程，该结构定义了作 业大小（以字节为单位）、作业性质、用户名和作业名。打印假脱机守护进程用 printresp结构回应，该结构包括返回码、作业ID和错误消息（如果请求失败）。 PR_TEXT作业性质表明要打印的文件只能被视为纯文本C而不是PostScript）。我们为 所有的标志定义一个掩码而非対每个标志定义一个独立的字段。尽管目前只定义了一 个标志值，将来还可以増加更多性质来扩展这个协议。例如，我们可以在增加一个标 志位用来请求双面打印。不需要改变结构的大小就可以有31个额外的标志位的空间。 改变结构的大小意味着可能会引入客户端和服务器的兼容性问题，除非对两访同时更 新。另一个可选方案就是增加一个报文版本号，以允许不同版本的结构有所改变。




412    req.flags |= PR_TEXT；

413    }

[385〜401] 将请求头中的整数字段转换成主机字节序，调用get_newjobno来保存这个打印 请求的下一个作业编号。建立作业数据文件，客为/var/spool/printer/data/

记是请求的作业ID。采用权限许可来防止其他人读取这些文件（print .h 中定义FILEPERM为S_IRUSR| S_IWUSR）。如果不能创建该文件，记录错误日志， 发送兔败响应给客户端，调用pthread_exit结束线程。

[402〜413] 读取来自客户端的文件内容，要将其写入数据文件的私有副本中。但是在写任何东西之 前，需要在第一次循环时检查一下是否是PostScript文件。如果该文件不是以％!PS模式 开头，可以假定为其为纯文本文件，这种情况下在请求头中设置PR_TEXT标志。（如果 在print命令中有-t标志，那么客户端也会设置此标志。）尽管PostScript程序不要求 以模式％! PS开始，但文档格式指南（AdobeSystems[1999]）强烈推荐这种方式。

| 414  | nw = write(fd, buf.                             | nr);                                 |
| ---- | ----------------------------------------------- | ------------------------------------ |
| 415  | if (nw != nr) {                                 |                                      |
| 416  | res.jobid = 0;                                  |                                      |
| 417  | if (nw < 0)                                     |                                      |
| 418  | res.retcode                                     | 莫 htonl(errno);                     |
| 419  | else                                            |                                      |
| 420  | res.retcode                                     | =htonl(EIO);                         |
| 421  | log_msg("client.                                | thread： canft write %s: %s", name,  |
| 422  | strerror(res.retcode));                         |                                      |
| 423  | close(fd);                                      |                                      |
| 424  | strncpy(res.msg,                                | strerror(res.retcode), MSGLEN_MAX)： |
| 425  | writen(sockfd, &res, sizeof(struct printresp)); |                                      |
| 426  | unlink(name);                                   |                                      |
| 427  | pthread_exit({void *)1);                        |                                      |
| 428  | }                                               |                                      |
| 429  | }                                               |                                      |

430 close(fd|；

43L    /*

432    •    Create    the    control    file.    Then    writ-e    the

433    ■    print    request    Information    to    th«    control

434    •    file，

435    */

436    sprintf tnaffie,    SPOOLDIElf W&QDIR, :jobidji

437    fd - cr«^t <namQf FILEPERH}；

439 If (fd < 0) {

439    f«s.jobid - D；

4 4 0    r«s.rfttcod« — htonl {ermo);

441    lo^jnsg (**cliflnt_thcft*.d: c«nr t    tat %s"r n&n«,

4 42    strerror t r«s,retcode;

4 4 3    strncpy Izes.msg, 3tcerror (res.ntc&de}, M3GLCM_MAXI i

4 4 4    writen(9ockfd« 4res< 3iEeof(struct pfintresp))7

445    sprintf (n^rae,    dATAOIF, jtibid);

4 4 6    urtlink7

“7    pthrflfld^eHit t    (void *)1]；

m }_

(414-4301 ~~将来自客户端_的如裾W入到数据文件.如巣write失畋，记泉镨读0志,关闭敵S

文利^的文件描述符，发送出错消息给客户端，删除数据文件.调用pthread.exit

退出.注意*不S要显式关闭套接宇文件描述符，当调用pthread_exit时.线程

消理处理程序会处理这些亊情、

S接收到所有要打印的数据，关闭数据文件的文件描述符.

[431〜448]    接T來，创建文件？var/3pool/printer/j：eq3//aAid以记住打印请求.如果失

函_败.记录错误曰志.发送出错晌应给客户城，脚除教据文件，终止线程，_

| W    | nw                                   | -write    fi-reQj aizeaf (struct printreq) ) t             |
| ---- | ------------------------------------ | ---------------------------------------------------------- |
| 4 50 | i£                                   | [nw !- siaesf(struct printrtq>) f                          |
| 451  |                                      | r&a.jobid - 0j                                             |
| 4 52 |                                      | if (nw < 0>                                                |
| 453  |                                      | rea.retccxle » htonl (errnol t                             |
| 454  |                                      | else                                                       |
| 455  |                                      | rea + retc(xle ■ htonl (EIO) j                             |
| 456  |                                      | 1 og_pisg■("c 1 ieflt_thread: c*n( t write ts: ^a4*. nunar |
| 4&1  |                                      | stc&rror(tea.retcode))?                                    |
| 459  |                                      | close(fd)f                                                 |
|      |                                      | strncp^p ires-fnag, atrarror (rcs.E«tc(Kl«), MSGLEN_KAX) i |
| 4GD  |                                      | writeti l$0ckfdr ir«9F ALaeef ^struct printresp));         |
| 4C1  |                                      | u/alink tnAfflel t                                         |
| 4 62 |                                      | Sprintf (name, w»a?%s/%eln, SPOOLDIR, DATADIB, Jobid)      |
| 4B3  |                                      | urtlirtk indne) t                                          |
| 464  |                                      | pthrflad_flHit t(void *}H；                                |
| 465  | k                                    |                                                            |
| 466  | close(fd);                           |                                                            |
| 46?  | /*                                   |                                                            |
|      | *                                    | Send response to client h                                  |
| 4 69 | V                                    |                                                            |
| 470  | res. retcW辛-0?                      |                                                            |
| <71  | res                                  | .jobld - htonl (jobid);                                    |
| 4 72 | Aprintf \|r«s.rnsg^ "request ID    t |                                                            |

473    writen(sockfd, &res, sizeof(struct printresp));

474    /*

475    * Notify the printer thread, clean up, and exit.

476    */

477    log_msg ("adding job %d to queue’’，jobid);

478    add_job (&req, jobid);

479    pthread_cleanup_pop (1)；

480    return((void *)0);

481    }_

[449〜465]    将printreq结构写入控制文件。如果出错，则记录日志，关闭控制文件描述符，

发送失败响应给客户端，删除数据和控制文件，终止线程。

[466〜473]    关闭控制文件的文件描述符，并发送消息给客户端，该消息包括作业ID和成功状

态(retcode 设为 0)。

[474〜481]    调用add_job将接收的文件加入到挂起作业列表中，调用pthread_cleanup_pop

完成猜理过程。当返回时线程终止。

注意，线程退出之前，必须关闭不再使用的任何文件描述符。与线程终止不同，

490    struct worker_thread *wtp;

491

492

493

494

495

496

497

498 599

500

501

502

503

504

505



if ((wtp = malloc(sizeof(struct worker_thread))) == NULL) { log_ret("add_worker： can't malloc"); pthread_exit((void *)1);

}

wtp->tid = tid;

wtp->sockfd = sockfd;

pthread_mutex_lock <&workerlock);

wtp->prev = NULL;

wtp->next = workers;

if (workers != NULL)

workers ->prev = wtp;

workers = wtp;

pthread_mutex_unlock(&workerlock);

512    kill_workers(void)

513    {

514    struct worker_thread *wtp;

515    pthread_rautex_lock(fiworkerlock);

516    for {wtp = workers? wtp != NULL; wtp = wtp->next)

517    pthread_cancel(wtp->tid);

518    pthread_mutex_unlock(Sworkerlock);

519    }_

[482〜505] add_worker将一个worker_thread结构加入活动线程列表中。分配该结构需 要的内存，初始化它，锁住workerlock互斥量，将结构加入到列表的头部，然 后解锁互斥量。

[506-519] kill.workers函数遍历工作者线程列表，然后一一删除。遍历列表时持有 workerlock互斥量。注意，pthread_cancel仅仅将线程列入删除计划，实际

[§28]    的删除动作在每个线程到达下一个删除点时发生。

530

531

532

533

534

535

536

537

538

539

540

541

542

543

544

545

546

547

548



tid = (pthread_t)((long)arg);

pthread_mutex_lock(sworkerlock);

for {wtp = workers; wtp != NULL; wtp = wtp->next) { if (wtp->tid == tid> {

if (wtp->next != NULL)

wtp->next->prev = wtp->prev;

if (wtp->prev != NULL)

wtp->prev->next = wtp->next;

else

workers = wtp->next; break；

}

}

pthread_mutex_unlock(Sworkerlock);

if (wtp != NULL) {

close(wtp->sockfd); free(wtp);

[520〜542]函数client_cleanup是与客户端命令通信的工作者线程的线程清理程序。当线 程调用pthread_exit时，或者用一个非0参数调用pthread_cleanup_pop, 或者响应一个删除请隶时，client_cleanup函数会被调用■>其参数是终止线程 的线程ID。

锁住worker lock互斥量然后搜索工作者线程列表，直到找到一个匹配的线程ID。

当找到一个匹配时，从列表中删除工作者线程结构并且停止捜索。

[543〜548]解锁workerlock互斥量，关闭线程用于和客户端通信的套接字文件描述符，然

后释放worker_thread结构的内存。

既然要获得workerlock互斥量，当kill_workers函数正在遍历列表时，如果 一个线程到达一个删除点时，必须等待直到kill_WorkerS释放互斥量时才可以 继续处理。

557    int    err, signo;

558

559

560

561

562

563

564

565

566

567

568

569

570



for (;;) {

err = sigwait(smask, &signo); if (err != 0)

log_quit("sigwait failed: %s", strerror(err)); switch (signo) { case SIGHUP:

/*

\* Schedule to re-read the configuration file. */

pthread_mutex_lock(&configlock); reread = 1;

pthread_mutex_unlock(ficonfiglock); break;

571    case SIGTERM:

572    kill_workers();

573    log.mag("terminate with signal %s", strsignal(signoj);

574    exit (0);

575    default:

576    kill_workers();

577    log_quit("unexpected signal %d"( signo);

[549〜562]函数signal_thread由负责处理信号的线程运行。在main函数中初始化信号掩 码，该掩码包括SIGHUP和SIGTERM。这里，调用sigwait来等待这些信号中 的一个出现。如果sigwait失败，记录出错日志并退出。

[563〜570]如果接收到SIGHUP，然后获得configlock互斥量，将reread变量设为1，释放 互斥量。这就告诉打印机守护进程在其处理循环的下一次迭代时再次读取紀置文件。

[571〜574]如果接收到SIGTERM,调用kill_workers来杀死所有的工作者线程，记录日志， 然后调用exit终止进程。

[575-580]如果接收到非期望的信号，则杀死工作者线程并调用log_quit来记录日志然

后退出。

| 581  | /*                        |                                   |
| ---- | ------------------------- | --------------------------------- |
| 582  | * Add an option to the    | IPP header.                       |
| 583  | *                         |                                   |
| 584  | * LOCKING: none.          |                                   |
| 585  | */                        |                                   |
| 586  | char *                    |                                   |
| 587  | add_opt土on{char *cp, int | tag, char *optname, char *optval) |
| 588  | t                         |                                   |
| 589  | int    n;                 |                                   |
| 590  | union {                   |                                   |
| 591  | intl6_t s;                |                                   |
| 592  | char c[2];                |                                   |
| 593  | )    u;                   |                                   |
| 594  | *cp++ = tag;              |                                   |
| 595  | n = strlen(optname);      |                                   |
| 596  | u.s = htons(n)；          |                                   |
| 597  | *cp++ = u.c[0];           |                                   |
| 598  | *cp++ = u.c[1];           |                                   |
| 699  | strcpy(cp, optname);      |                                   |
| 600  | cp += n;                  |                                   |
| 601  | n = strlen(optval);       |                                   |
| 602  | u.s = htons(n);           |                                   |
| 603  | *cp++ = u.c[0];           |                                   |
| 604  | *cp++ = u.c[1];           |                                   |
| 605  | strcpy(cp, optval);       |                                   |
| 606  | return(cp + n);           |                                   |
| 607  | 1                         |                                   |

[581-593]    函数add.option用于在送到打印机的IPP首部中添加一个选项，回忆图21-4,

属性的格式是丨字节的描述属性类型的标志，然后是以2字节的二进制整数形式 存储的属性名字的长度，接着是名字，属性值的长度，最后是属性值本身。

IPP没有打算去控制嵌入在首部的二进制整数的对齐方式。一些处理器架构，例如 SPARC,并不能从任意地址装入一个整数。这意味着不能通过如下方式在IPP首 部存放一个整数：该方式将一个指针转换成指向在首部存放整数的地 址。相反，需要一次复制1字节整数。这就是为什么我们定义一个包含16位整数

和2字节数组的union。

[594-607]



在首部存储标志并将属性名字的长度转换为网络字节序。一次复制1个字节到首 部。接着复制属性名字。重复这个过程，继续复制属性值，并卑回首部中下一个 应该开始的部分的地址。

608 /*

609    * Single thread to communicate with the printer.

616    struct job    *jp;

| 617  | int                                    | hlen, ilen, sockfd, fd, n         | ir, nw, extra; |
| ---- | -------------------------------------- | --------------------------------- | -------------- |
| 618  | char                                   | *icp, *hcp, *p;                   |                |
| 619  | struct ipp_hdr                         | *hp;                              |                |
| 620  | struct stat                            | sbuf;                             |                |
| 621  | struct iovec                           | iov[2];                           |                |
| 622  | char                                   | name[FlLENMSZ];                   |                |
| 623  | char                                   | hbuf[HBUFSZ];                     |                |
| 624  | char                                   | ibuf[IBUFSZ];                     |                |
| 625  | char                                   | buf[IOBUFSZ];                     |                |
| 62 6 | char                                   | str[64];                          |                |
| 627  | struct timespec                        | ts = { 60, 0 };    /* 1 minute */ |                |
| 628  | for (;;) {                             |                                   |                |
| 62 9 | /*                                     |                                   |                |
| 630  | * Get a job                            | to print.                         |                |
| 631  | */                                     |                                   |                |
| 632  | pthread_mutex_lock(ijoblock);          |                                   |                |
| 633  | while (jobhead =                       | =NULL) {                          |                |
| 634  | log_msg{"printer_thread: waiting..."); |                                   |                |
| 635  | pthread_cond_wait(&jobwait, &joblock,; |                                   |                |
| 636  |                                        |                                   |                |
| 637  | remove」ob(jp =                        | jobhead);                         |                |
| 638  | log_msg{"printer                       | _thread: picked up job %d",       | jp->jobid);    |
| 639  | pthread_mutex_unlock(ijoblock);        |                                   |                |
| 640  | update jobno ()，-                     |                                   |                |

[608〜627]    函数printer_thread由与网络打印机通信的线程运行。使用icp和ibuf来

建立IPP首部。使用hep和hbuf建立HTTP首部。需要在独立的缓冲区中建立 首部。HTTP首部包括ASCII表示的长度字段，而且在拼装出IPP首部之前，并 不知道应该预留多大的空间。在一次调用中使用writev来写这两个头。

[628〜640]    打印机线程在一个等待将作业传送到打印机的无限循环中运行。使用joblock

互斥量来保护作业列表。如果作业没有挂起，使用pthread_cond_wait来等 待到来的作业。当一个作业准备好时，调用removedob将其从列表中删除。

646    freeaddrinfo(printer);

647    printer = NULL;

648    printer_narae = NULL;

649    reread = 0;

650    pthread_mutex_unlock(ficonfiglock);

651    init_printer();

652    } else {

653    pthread_mutex_unlock(ficonfiglock);

654    }

655    /*

656    * Send job to printer.

| 657  | */                                                           |
| ---- | ------------------------------------------------------------ |
| 658  | sprintf (name, ”％s/%s/%ld", SPOOLDIR, DATADIR, jp->jobid)，- |
| 659  | if ((fd = open(name, O_RDONLY)) < 0) {                       |
| 660  | log_msg{"job %ld canceled - can't open %s: %3",              |
| 661  | jp->jobid, name, strerror(errno));                           |
| 662  | free(jp);                                                    |
| 663  | continue;                                                    |
| 664  | J                                                            |
| 665  | if (fstat(fd, &sbuf) < 0) {                                  |
| 666  | log_msg("job %ld canceled - can11 fstat %s: %s",             |
| 667  | jp->jobid, name, strerror(errno)};                           |
| 668  | free (jp);                                                   |
| 669  | close(fd);                                                   |
| 670  | continue;                                                    |
| 671  |                                                              |

[641〜654] 现在有了要打印的作业，检查一下配置文件有无改变。锁住configlock互斥量 并检査reread变量。如果该值非0,那么释放旧的addrinfo列表，清空指针，

解锁互斥量，然后调用init^printer来重新初始化指针信息。既然从main线 程初始化后只有这个上下文可以査看并可能更改打印机信息，因此除了使用 configlock互斥量来保护reread标志的状态外，不需要任何其他的同步手段。 注意，尽管在此函数中获得和释放两个不同互斥量，但是并没有同时持有两个互斥 量，因此不需要建立一个锁层次(见11.6.2节)。

[655〜671]如果不能打开数据文件，则记录出错日志，释放job结构，然后继续。打开文件之后， 晒    调用fstat来找到文件的大小。如果失败，记录出错日志并清理，然后继续。

672    if {(sockfd = connect_retry(AF_INET, SOCK—STREAM, 0,

673    printer->ai_addr, printer->ai_addrlen)) < 0) {

674    log_msg("job %d deferred - canr t contact printer: %s*',

675    jp->jobid, strerror(errno));

676    goto defer;

685    hp->operation = htons(OP_PRINT_JOB);

686    hp->request_id = htonl(jp->jobid);

687    icp += offsetof(struct ipp_hdr, attr_group);

688    *icp++ = TAG_O P ERATION_ATTR;

689    icp = add_option(icp, TAG_CHARSET, "attributes-charset",

690    "utf-8");

691    icp = add_option(icp, TAG_NATULANG,

692    "attributes-natural-language", "en-us");

693    sprintf {str, "http: //%s/ipp'1, printer_name);

694    icp = add_option(icp, TAG_URI, "printer-uri", str);

695    icp = add_option(icp, TAG_NAMEWOLANG,

696    "requesting-user-name", jp->req.usernm);

697    icp = add_option{icp, TAG_NAMEWOLANG, "job-name",

698    jp->req.jobnm);

[672〜677] 打开一个连接到打印机的流套接字。如果connect_retry调用失败，跳到defer 处，在这里清理、延迟一段时间，然后再尝试。

[678-698]接下来，建立IPP首部。其操作是打印作业(print-job)请求。使用htons将2字 节的操作ID从主机转换为网络字节序，使用htonl将4字节的作业ID从主机转 换为网络字节序。完成首部的初始化之后，设置标志值来指示其后跟随操作属性。

调用add_option将属性添加到报文中。图12-5列出了打印作业请求所需的操作 属性，前3个是必需的。将字符集设为UTF-8,该字符集是打印机必须支持的；指 定语言为en-us,即代表美国英语(U.S. English)；另外一个必需的属性是URI (Uniform Resource Identifier)，将其设为 http: //printer_name/ipp。

推荐使用requesting-user-name属性，但不是必需的。job-name属性也是 可选的。print命令将要打印的文件名作为作业名发送，该名字能够帮助用户区别

_多个要处理的作业。_ [834]

| 699       | if (jp->req.flags & PR_TEXT} {                               |
| --------- | ------------------------------------------------------------ |
| 700       | p = "text/plain";                                            |
| 701       | extra = 1;                                                   |
| 702       | } else {                                                     |
| 703       | p = "application/postscript"；                               |
| 704       | extra = 0;                                                   |
| 705       | }                                                            |
| 706       | icp = add_option(icp, TAG_MIMETYPE, "document-format", p);   |
| 707       | *icp++ = TAG_END_OF_ATTR;                                    |
| 708       | ilen = icp - ibuf;                                           |
| 709       | /*                                                           |
| 710       | * Set up the HTTP header.                                    |
| 711       | */                                                           |
| 712       | hep = hbuf;                                                  |
| 713       | sprintf(hep, "POST /ipp HTTP/1.l\r\n");                      |
| 714       | hep += strlen(hep);                                          |
| 715       | sprintf(hep, "Content-Length: %ld\r\n",                      |
| 716       | (long)sbuf.st_size + ilen + extra);                          |
| 717       | hep += strlen(hep);                                          |
| 718       | strepy(hep, "Content-Type: application/ipp\r\n");            |
| 719       | hep += strlen(hep);                                          |
| 720       | sprintf (hep, "Host: %s：%d\r\n'1, printer_name, IPP_PORT,;  |
| 721       | hep += strlen(hep);                                          |
| 722       | *hcp++ = •\rf ;                                              |
| 723       | *hcp++ = '\n*;                                               |
| 724       | hlen = hep - hbuf;                                           |
| [699—708] | 提供的最后一个属性是document-format。如果省略该属性，则假定文件格式 是打印机默认格式。对于PostScript打印机，格式可能是PostScript,但是一些打印 机可以自动检测格式并在PostScript与纯文本或PCL (HP的打印机命令语言)格 式间做选择。如果PR_TEXT标志被设置，则将文档格式设置为text/plain。否 则，设置为application/postscripto然后在属性结束处用结束属性标志定 界并计算IPP首部的大小。 |

整数extra用来记录任何可能需要传输到打印机的附加字符。稍后会看到，需要 发送一个附加字符以能够可靠地打印纯文本。当要计算内容长度时，需要考虑这个 附加字符。

[709〜724] 现在知道了 IPP首部的大小，可以建立HTTP首部。将Context-Length设为IPP 首部的字节长度加上要打印文件的大小再加上需要发送的附加字符的长度。 Content-Type为application/ipp。用回车换行符结束HTTP首部。最后，

SS]    计算HTTP首部的大小。

725    /*

726    * Write the headers first. Then send the file.

727

728

729

730

731

732

733

734



736

737

738

739

740

741

742

743

744



745

746

747

748

749

750

751

752

753



iov[0].iov_base = hbuf;

iov[0].iov_len = hlen;

iov[1】.iov_base = ibuf;

iov[l].iov_len = ilen;

if (writev(sockfd, iov, 2) != hlen + ilen) { log_ret("can* t write to printer"); goto defer;

if (jp->req.flags & PR_TEXT) {

\* Hack: allow PostScript to be printed as plain text.

if (write(sockfd, "\b", 1)    != 1)    {

log_ret("can,t write to printer"); goto defer;

while ((nr = read(fd, buf, IOBUFSZ)) >0) {

if ((nw = writen(sockfd, buf, nr)) != nr) {

if {nw < 0)

log_ret("can* t write to printer"); else

log_msg("short write (%d/%d) to printer", nw, nr); goto defer;

}

)

[725〜735]将iovec数组的第一个元素指向HTTP首部，第二个元素指向IPP首部。然后采 用writev将两个首部送往打印机。如果写失败或者写入少于请求的字节数，则记 录日志并跳转到defer,在这里清理并延迟一段时间，然后再次尝试。

[736-744]即使指明了纯文本，Phaser 8560还是会自动检测文档格式。为了防止它识别出要以 纯文本格式打印的文件的开头，将退格作为第一个发送字符，这个字符不会被打印 出來，并且能够使自动识别文件格式功能失效。这就可以打印PostScript源文件而 不用打印PostScript文件的镜像。

[745—753]通过IOBUFSZ块将数据文件发往打印机。当套接字缓冲区满的时候，write的发 送少于请求，因此可以用write处理这种情况。当写首部时，不必担心这种情况，

岡    因为它们都很小，但要打印的文件却是很大的。

| 754  | if                                                           | (nr < 0) {                                              |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------- |
| 755  |                                                              | log_ret("can* t read %s", name);                        |
| 756  |                                                              | goto defer;                                             |
| 757  | }                                                            |                                                         |
| 758  | /*                                                           |                                                         |
| 759  | *                                                            | Read the response from the printer.                     |
| 760  | *>                                                           | t                                                       |
| 761  | if                                                           | <printer_status(sockfd, jp)) {                          |
| 762  |                                                              | unlink(name);                                           |
| 763  |                                                              | sprintf(name, "%s/%s/%d", SPOOLDIR, REQDIR, jp->jobid), |
| 764  |                                                              | unlink{name);                                           |
| 765  |                                                              | free(jp);                                               |
| 766  |                                                              | jp = NULL;                                              |
| 767  | }                                                            |                                                         |
| 768  | defer:                                                       |                                                         |
| 769  | close(fd);                                                   |                                                         |
| 770  | if                                                           | (sockfd >= 0)                                           |
| 771  |                                                              | close(sockfd);                                          |
| 772  | if                                                           | (jp != NULL) {                                          |
| 773  |                                                              | replace_job(jp);                                        |
| 774  |                                                              | nanosleep(Sts, NULL);                                   |
| 775  | )                                                            |                                                         |
| 776  | }                                                            |                                                         |
| 777  | }                                                            |                                                         |
| 778  | /*                                                           |                                                         |
| 779  | * Read data from the printer, possibly increasing the buffer. |                                                         |
| 780  | * Returns offset of end of data in buffer or -1 on failure.  |                                                         |
| 781  | *                                                            |                                                         |
| 782  | * LOCKING: none.                                             |                                                         |
| 783  | */                                                           |                                                         |
| 784  | ssize_t                                                      |                                                         |
| 785  | readmore{int sockfd, char **bpp, int off, int *bszp)         |                                                         |

[754〜757]读到文件末尾时，read返回0。如果壞失败，记录错误信息日志并跳至defer。

[758〜767]将文件发送给打印机后，调用printer_status来读取打印机对于请求的响应。

如果成功，printer_StatUS返回一个非0值，就可以删除数据文件和控制文件。

然后释放job结构，将其指针设为NULL，然后到达defer•标签

[768〜777]在defer■标签处，关闭打开的数据文件描述符。如果套接字描述符是有效的，也 将其关闭。如出错，jp指向要打印作业的作业结构，这样就可以将作业放在挂起 作业列表的头部然后延迟1分钟。如果成功，jp为NULL，此时只需回到循环开始 处，获得下一个要打印的作业。

[778〜785] readmore函数用于读取♦自打印机的部分响应消息。_画

| 786787788 | {ssize_t nr;  |                             |         |
| --------- | ------------- | --------------------------- | ------- |
| char      | *bp = *bpp，- |                             |         |
| 789       | int           | bsz =*bszp;                 |         |
| 790       | if (off       | >=bsz) {                    |         |
| 791       | bsz           | += IOBUFSZ;                 |         |
| 792       | if            | ((bp = realloc(*bpp, bsz})= | « NULL) |

| 793  |                                         | log_ays("readmore: can* t allocate bigger read buffer"),    |
| ---- | --------------------------------------- | ----------------------------------------------------------- |
| 7 94 |                                         | *bszp *bsz;                                                 |
| 795  |                                         | *bpp =bp;                                                   |
| 796  |                                         | }                                                           |
| 7 97 |                                         | if ((nr = tread(sockfd, &bp[off], bsz-off, 1)) > 0)         |
| 7 98 |                                         | return(off+nr);                                             |
| 799  |                                         | else                                                        |
| 800  |                                         | return(-1);                                                 |
| 801  | }                                       |                                                             |
| 802  | /*                                      |                                                             |
| 803  | *                                       | Read and parse the response from the printer. Return 1      |
| 804  | *                                       | if the request was successful, and 0 otherwise.             |
| 805  | *                                       |                                                             |
| 806  | *                                       | LOCKING: none.                                              |
| 807  | A                                       | /                                                           |
| 808  | int                                     |                                                             |
| 809  | printer_status(int sfd, struct job *jp) |                                                             |
| 810  | {                                       |                                                             |
| 811  |                                         | int    i, success, code, len, found, bufsz, datsz;          |
| 812  |                                         | int32_t    jobid;                                           |
| 813  |                                         | ssize_t    nr;                                              |
| 814  |                                         | char    *bp, *cp, *statcode, *reason, *contentlen;          |
| 815  |                                         | struct ipp_hdr h;                                           |
| 816  |                                         | /*                                                          |
| 817  |                                         | * Read the HTTP header followed by the IPP response header. |
| 818  |                                         | * They can be returned in multiple read attempts. Use the   |
| 819  |                                         | * Content-Length specifier to determine how much to read.   |
| 820  |                                         | */                                                          |

[786〜801]如果到达缓冲区尾部，通过相应的参数bpp和bszp重新分配一个大一点的缓冲区 并返回该新的缓冲区的起始地址以及缓冲区大小。上述任何一种情况下，从缓冲区 已读数据的末尾开始读取缓冲区所能容纳的尽可能多的数据。返回相应的已读数据 的新偏移量。如果read失败，或者超时，返回-1。

[802〜820] printer_status函数读取打印机对一个打印作业请求的响应消息。不知道打印机会 如何响应：也许会在多个报文中回送一个响应，也许在一个报文中回送完整的响应，或

國_者包括一个中间确认，诸如HTTP 100 Continue报文。需要处理所有的可能性。

821    success =0 ;

822    bufsz =IOBUFSZ;

823    if ((bp = malloc(IOBDFSZ)) == NULL)

824    log_sys("printer_status: can't allocate read buffer");

825    while ({nr = tread(sfd, bp, bufsz, 5)) > 0) {

834    statcode =cp;

835

836

837

838

839

840

841

842

843

844

845

846

847

848

849

850

851

852



while (isdigit((int)*cp)) cp++；

if (cp == statcode) { /* Bad format; log it and move on */ log_msg(bp);

} else {

*cp++ =f\0'; reason =cp;

while (*cp != '\r' && *cp != f\n') cp++;

*cp ='\0';

code =atoi(statcode); if (HTTP_INFO(COde))

continue;

if (!HTTP_SUCCESS(code)) { /* probable error: log it */ bp[datsz] =,\0*; log_msg("error: %s", reason); break;

}

[821—838] 好配一个缓冲匡并读取来自打印机的数据，期望5秒之内有可用的响应。跳过HTTP/1.1 和报文开始的所有空格’然后是数字状态码。如果不是，在日志中记录报文的内容。

[839-844] 如果在响应中找到一个数字状态码，将其开始的非数字字符转换成null字节（这一 字符是某种形式的空白）。接下来是一个表明原因的字符串（文本消息），搜索回车 或换行符，并乘用null字节结束文本字符串。

[845-852] 调用atoi函数将状态码字符串转化成一个整数。如果仅是提供信息的报文，将其 忽略并继续循环。我们期望看到的要么是成功消息要么是出错消息。如果得到出错

_消息，记录出错日志井退出循环。_画

853

854

855

856

857

858

859

860 861 862

863

864

865

866 8 67 8 68

869

870



\*    HTTP request was okay, but still need to check

\*    IPP status. Search for the Content-Length.

*/

i = cp - bp;

for (;;) {

while (*cp !=，C' && *cp !=，cr && i < datsz) { cp++; iW

}

if (i >= datsz) { /* get more header */

if ((nr = readmore(sfd, &bpf i, &bufsz)) < 0) {

goto out;

} else (

cp =&bp[i]; datsz += nr;

}

if (strncasecmp(cp, "Content-Length:", 15) == 0) { cp += 15;

while (isspace((int)*cp))



871

872

873

874    cp++;

875    contentlen =cp;

876    while (isdigit((int)*cp))

877    Cp++；

| 878879880881882883884885886                                  | *cp++ =，\0f; i = cp - bp; len =atoi(contentlen);break;} else {cp++;i++；} } |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [853 〜870]                                                  | 如果HTTP请求成功，需要检査IPP状态。搜索整个报文直到找到Content-Length 属性D HTTP首部的关键字是大小写敏感的，因此需要同时检査小写和大写字符。如 |
| [871-886]                                                    | 果缓冲区空间耗尽，需要调用readmore,通过它再调用realloc增加缓冲区大小。 因为缓冲区地址可能改变，需要调整cp指向正确的缓冲区位置。使用strncasecmp函数进行大小写敏感比较。如果找到Content-Length属性字 符串，就搜索它的值将数字字符串转换为整数并退出这个for循环。如果比较失败， |
| 函                                                           | 继续逐个字节搜索缓冲区。如果直到缓冲区末尾仍未找到Content-Length属性， 就从打印机读取更多数据并继续搜索。 |
| 887888889890891892893894                                     | if {i >= datsz) { /* get more header */if "nr = readmore (sfd, Sbp, i, fibufsz)) < 0) {goto out;} else {cp =&bp[i]; datsz += nr;} } |
| 895896897898899900901902903904905906907908909910911912913914915916 | found =0 ;while (!found) { /* look for end of HTTP header */ while (i < datsz -2} {if (*cp == f\n' && *(cp + 1) == *\rf &&* (cp + 2) == '\n'} ffound =1 ; cp += 3; i += 3;break;cp++;i++；}if (i >= datsz) { /* get more header */if ((nr = readmore(sfd, &bp, i, Sbufsz)) < 0) 1goto out;J else tcp =&bp[i]； datsz += nr;fJ |
| 917918919                                                    | if (datsz - i < len) ( /* get more header */if {(nr = readmore(sfd, &bp, i, Sbufsz)) < 0) {goto out; |

920    } else {

921    cp =&bp[i];

922    datsz += nr;_

[887—916]现在知道报文的长度了（通过Content-Length属性）。如果耗尽缓冲区，那么 从打印机再次读取。接下来搜索HTTP首部的末尾（空白行）。如果找到了，就设 置found标志并跳过空白行。无论何时调用readmore,都要将cp设置为与之前 指向的缓冲区偏移量相同，以防止重分配时缓冲区地址改变。

[917-922]如果找到HTTP首部的末尾，计算HTTP首部所用的字节数。如果读取的值减去HTTP 首部的大小后不等于IPP报文的数据长度（该值从内容长度Content-Length中计

_算），需要读取更多的数据。_画

要调用ntohs和ntohl将其转换为主机字节序。

[928-939] 如果作业ID不匹配，表明并非是对我们请求的响应，那么记录日志并退出外层

while循环。如果EPP状态指不为成功*保存返回值并退出循环。

[940-947] 在退出之前，要释放用來存放响应报文的缓冲区。如果打印请求成功则返回1，否则

失败，返回0。    ®

这里总结本章中这个扩展的例子。本章中的程序在Xerox Phaser 8560网络PostScript打印机

上测试。遗憾的是，当文档格式设置为text/plain时，这个打印机并没有禁止它的自动识别 格式功能。我们使用了一个小技巧，使得在想要以纯文本格式射待一个文档时，打印机不自动识



| 923  | }                                                       |
| ---- | ------------------------------------------------------- |
| 924  | }                                                       |
| 925  | memcpy(&h, cp, sizeof) (struct rpp_hdr);                |
| 926  | i = ntohs(h.status);                                    |
| 927  | jobid = ntohl(h.request_id);                            |
| 928  | if (jobid != jp->jobid) {                               |
| 929  | /*                                                      |
| 930  | * Different jobs. Ignore it.                            |
| 931  | */                                                      |
| 932  | log_msg("jobid %d status code %d", jobid, i);           |
| 933  | break;                                                  |
| 934  | }                                                       |
| 935  | if (STATCLASS_OK(i))                                    |
| 936  | success = 1;                                            |
| 937  | break;                                                  |
| 938  | }                                                       |
| 939  |                                                         |
| 940  | out:                                                    |
| 941  | free(bp);                                               |
| 942  | if (nr < 0) {                                           |
| 943  | log_msg("jobid %d: error reading printer response: %s", |
| 944  | jobid, strerror(errno));                                |
| 945  | }                                                       |
| 946  | return(success);                                        |
| 947  | }                                                       |

[923-927] 从IPP首部中获取状态和作业ID。两者均以网络字节序的整数形式存储，因此需

别文挡格式。一种替代的方法是使用诸如a2PS(l)这样的实用工具将源打印成一个PostScript程 序。a2ps(l)可以在打印前封装PostScript程序D





##### 21.6小结

本章仔细考查了两个完整的程序：一个打印假脱机守护进程将作业发送到网络打印机和一个 命令行程序将打印作业提交到假脱机守护进程。这给我们一个机会，考査在一个实际程序中使用 前面章节所讲述的许多特性，如线程、I/O多路技术、文件I/O、套接字I/O以及信号。

习题

21.1将iPP.h中所列的IPP错误码转换成错误消息。然后修改打印假脱机守护进程，当IPP首 部指示有打印机错误时，在printer_status函数结尾处记录日志。

21.2增强print命令和printd守护进程，使得用户可以请求双面打印，并支持横向打印和纵 向打印。

21.3修改打印假脱机守护进程，当其开始时，能够联系打印机并找出所支持的特性，这样守护 进程就不会请求打印机不支持的选项。

21.4写一个命令行程序来报告挂起的打印作业状态。

21.5写一个命令行程序来取消一个挂起的打印作业。使用作业ID作为命令参数来指明取消哪个 作业。如果防止一个用户取消另一个用户的打印作业？

21.6在打印假脱机守护进程中支持多个打印机，并包括将一个打印作业从本打印机移到另一个 打印机的方式。

21.7解释为什么在打印机守护进程中，当信号处理线程捕捉到SIGHUP并将reread设置为1 时，不需要唤醒打印机线程？

21.8在printer_status函数中，通过查找HTTP的Content-Length属性搜索IPP报文的 长度，这一技术在使用块传输编码的打印机上不起作用，在RFC 2616中査找块消息是如何 格式化的，然后修改printer_statuS，使其也能够支持这种形式的响应。

21.9在update_jobn。函数中，当下一个作业编号从最大正值回绕到1时(参见get„jiewjobno)， 可能会将一个较大的编号改写为一个较小的编号。这可能导致守护进程重启时读到一个错

®    误的编号。对于这一问题是否有简单的解决方法？
