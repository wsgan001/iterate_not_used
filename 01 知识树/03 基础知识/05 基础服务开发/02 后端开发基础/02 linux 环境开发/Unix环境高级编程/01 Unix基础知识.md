##### 1.1弓I言

所有操作系统都为它们所运行的程序提供服务。典型的服务包括：执行新程序、打开文件、读 文件、分配存储区以及获得当前时间等，本书集中阐述不同版本的UNIX操作系统所提供的服务。

想要按严格的先后顺序介绍UNIX,而不超前引用尚未介绍过的术语，这几乎是不可能的（可 能也会令人厌烦）。本章从程序员的角度快速浏览UNIX,对书中引用的一些术语和概念进行简要 的说明并给出实例。在以后各章中，将对这些概念做更详细的说明。对于初涉UNIX环境的程序 员，本章还简要介绍了 UNIX提供的各种服务，

##### 1-2 UNIX体系结构

![img](UNIX环境高级编程_files/UNIXaf83d8a7160b-2.png)



从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境， 我们通常将这种软件称为内核（kernel）,因为它相对较小，

而且位于环境的核心。图1-1显示了 UNIX系统的体系结构。

内核的接口被称为系统调用（systemcall,图1-1中的阴 影部分）。公用函数库构建在系统调用接口之上，应用程序 既可使用公用函数库，也可使用系统调用，（我们将在1.11 节对系统调用和库函数做更多说明。）shell是一个特殊的应 用程序，为运行其他应用程序提供了一个接口。

从广义上说，操作系统包括了内核和一些其他软件，这 些软件使得计算机能够发挥作用，并使计算机具有自己的特 性。这里所说的其他软件包括系统实用程序（system utility ）＞

应用程序、shell以及公用函数库等。

例如，Linux是GNU操作系统使用的内核。一些人将这种操作系统称为GNU/Linux操作系 统，但是，更常见的是简单地称其为Linux。虽然这种表达方法在严格意义上讲并不正确，但鉴 于“操作系统”这个词的双重含义，这种叫法还是可以理解的（这样的叫法更简洁）。

###### 1.3登录

1.登录名

用户在登录UNIX系统时，先键入登录名，然后键入口令。系统在其口令文件（通常是/etc/

passwd文件）中査看登录名。口令文件中的登录项由7个以冒号分隔的字段组成，依次是：登录 名、加密口令、数字用户ID （205〉、数字组ID （105）、注释字段、起始目录（/home/sar）以及 shell 程序（/bin/ksh）。

sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh

目前，所有的系统已将加密口令移到另一个文件中。第6章将说明这种文件以及访问它们的 rn函数。

\2. shell

用户登录后，系统通常先显示一些系统信息.然后用户就可以向shell程序键入命令。（当 用户登录时，某些系统启动一个视窗管理程序，但最终总会有一个shell程序运行在一个视窗 中）。shell是一个命令行解释器，它读取用户输入，然后执行命令。shell的用户输入通常来自 于终端（交互式shell），有时则来自于文件（称为shell脚本）。图1-2总结了 UNIX系统中常见 的 shell。

| 名称              | 路径      | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris 10 |
| ----------------- | --------- | ----------- | ----------- | --------------- | ---------- |
| Bourne shell      | /bin/sh   | •           | -           | bash的副本      |            |
| Boume-again shell | /bin/bash | 可选的      | -           | •               |            |
| C shell           | /bin/csh  | 链接至tcsh  | 可选的      | 链接至tcsh      |            |
| Kom shell         | /bin/ksh  | 可选的      | 可选的      | •               |            |
| TENEX C shell     | /bin/tcsh | •           | 可选的      | •               |            |

图1-2 UNIX系统中常见的shell

系统从口令文件中相应用户登录项的最后一个字段中了解到应该为该登录用户执行哪一 个 shell。

自V7以来，由SteveBoume在贝尔实验室开发的Boumeshell得到了广泛应用，几乎每一个 现有的UNIX系统都提供Bourne shell,其控制流结构类似于Algol 68。

C shell是由Bill Joy在伯克利开发的，所有BSD版本都提供这种shell。另外，AT&T的 System V/386R3.2和System VR4 （SVR4）也提供C shell （下一章将对这些不同版本的UNIX 系统做更多说明）。C shell是在第6版shell而非Bourne shell的基础上构造的，其控制流类似 于C语言，它支持Boumeshell没有的一些特色功能，例如作业控制、历史机制以及命令行编 辑等。

Korn shell是Bourne shell的后继者，它首先在SVR4中提供。Korn shell是由贝尔实验室的 David Korn开发的，在大多数UNIX系统上运行，但在SVR4之前，通常它需要另行购买，所以 没有其他两种shell流行。它与Bourne shell向上兼容，并具有使C shell广泛得到应用的一些特色 功能，包括作业控制以及命令行编辑等。

Bourne-again shell是GNU shell,所有Linux系统都提供这种shell。它的设计遵循POSIX 标准，同时也保留了与Bourne shell的兼容性。它支持C shell和Korn shell两者的特色 功能。

TENEX C shell是C shell的加强版本。它从TENEX操作系统（1972年BBN公司开发）借 鉴了很多特色|例如命令完备。TENEX C shell在C shell基础上增加了很多特性，常被用来替 换 C sheik

|~3~|    POSIX 1003.2标准对shell进行了标准化，这项规范基于Kom shell和Bourne shell的特性。

不同的Linux系统使用不同的默认shell。一些Linux默认使用Boume-againshe）lo另外一些使用BSD 的对Bourne shell的替代品dash （Dd）ianAlmquist shell,最早由Kenneth Ahnquist斤发，并在后来移植入 Linux ）o FreeBSD 的默认用户 shell 衍生于 Almquist shell。Mac OSX 的默认 shell 是 Boume-again shell。

Solaries继承了 BSD和System V两者，它提供了困1-2中所示的所有shell。在因特网上可以 '：找到shell的自由移植版软件。

!    本书将使用这种形式的注释来描述历史注释，并对不同的UNIX系统的实现进行比较。当我

'们了解到历史缘由后，会更好地理解采用某种特定实现技术的原因。

本书将使用很多交互式shell实例来执行所开发的程序，这些实例使用了 Bourne shell、Korn shell 和 Boume-again shell 通用的功能。

1.4文件和目录

1.文件系统

UNIX文件系统是目录和文件的一种层次结构，所有东西的起点是称为根（root）的目录，这 个目录的名称是一个字符“/”。

目录（directoiy）是一个包含目录项的文件。在逻辑上，可以认为每个目录项都包含一个文 件名，同时还包含说明该文件属性的信息。文件属性是指文件类型（是普通文件还是目录等）、 文件大小、文件所有者、文件权限（其他用户能否访问该文件）以及文件最后的修改时间等，stat 和fstat函数返回包含所有文件属性的一个信息结构。第4章将详细说明文件的各种属性。

目录项的逻辑视图与实际存放在磁盘上的方式是不同的。UNIX文件系统的大多数实现并不 在目录项中存放属性，这是因为当一个文件具有多个竣链接时，很难保持多个属性副本之间的同

步。这一点将在第4章讨论硬键接时理解得更明晰。

\2.    文件名

目录中的各个名字称为文件名（filename）。只有斜线（/）和空字符这两个字狩不能出现在 文件名中。斜线用来分隔构成路径名的各文件名，空字符则用来终止一个路径名。尽管如此，好 的习惯还是只使用常用印刷字符的一个子集作为文件名字符（如果在文件名中使用了某些shell 的特殊字符，则必须使用shell的引号机制来引用文件名，这会带来很多麻烦）。事实上，为了可 移植性，POSIX.1推荐将文件名限制在以下字符集之内：字母（a〜z、A〜Z）、数字（0〜9）、

句点（•）、短横线（-）和下划线（_）。

创建新目录时会自动创建了两个文件名：.（称为点）和..（称为点点）。点指向当前目录，

点点指向父目录。在最髙层次的根目录中，点点与点相同。    m

Research UNIX System和某些早期UNIX System V的文件系统限制文件名的最大长度为14个 字符，BSD版本则将这种限制扩展为255个字符Q现今，几乎所有商业化的UNIX文件系统都支 持超过255个字符的文件名。

\3.    路径名

由斜线分隔的一个或多个文件名组成的序列（也可以斜线开头）构成路往名（pathname）,以斜线 开头的路授名梅为绝对路径名（absolute pathname）,吾则称为相对路径名（relative pathname〉。相对路 径名指向相对于当前目录的文件。文件系统根的名字（/）是一个特殊的绝財路径名，它不包含文件名。

■实例

不难列出一个目录中所有文件的名字，图1-3是ls(l)命令的简要实现。

番include "apue.h"

linclude <dirent.h>

int

main(int argc, char *argv[])

{

DIR    *dp；

struct dirent *dirp;

if (argc != 2)

err_quit("usage: Is directory_name");

if { {dp = opendir(argv[1])) == NULL)

err_sys("can't open %s", argv[1]);

while ((dirp = readdir(dp)) != NULL) printf{"%s\n", dirp->d_name);

closedir(dp); exit(0);

}

图1-3列出一个目录中的所有文件

ls(l)这种表示方法是UNIX系统的惯用方法，用以引用UNIX系统手册中的一个特定项。 1S(1)引用第一部分中的Is项。各部分通常用数字1〜8编号，在每个部分中的各项则按字母顺 序排列。在本书中始终假定你有自己所使用的UNIX系统的手册。

早期的UNIX系统把8个部分都集中在一本《UNIX程序员手册》(

Manual} to随着萸数的增加，现在的趋势是把这些部分分别安排在不同的手册中，例如用户 手册、程序员手册以及系统管理贝手册等。

一些UNIX系统用大写字母把某一部分手册进一步分成若干小部分，例如，AT&T[1990e]中 的所有标准I/O函数都被指明位于3S部分中，例如fopen(3S)。另一些UNIX系统不用数字而是 用字母将手册分成若干部分.如用C表示命令部分等。

现今，大多数手册都以电子文档形式提供。如果用的是联机手册，则可用下面的命令査看Is 命令手册页：

man 1 Is man -si Is

图1-3只打印一个目录中各个文件的名字，不显示其他信息，如果该源文件名为myls.c， 则可以用下面的命令对其进行编译，编译结果是生成默认名为a.out的可执行文件中。

cc myls.c

历史上，cc（l）是C编译器。在配置了 GNU C编译系统的系统中，C编译器是gcc（l）。其中， cc通常链接至gcc。

示例输出如下：

$ ./a.out /dav

cdrom

stderr

stdout

stdin

sda4

sda3

sda2

sdal

sda

tty2

ttyl

console

tty

zero

null

很多行未显示

mem

$ ./a.out /etc/ssl/pcivata

can’t open /etc/ssl/private: Permission denied $ ./a.out /dov/tty

can't open /dev/tty: Not a directory

本书将以以下方式表示输入的命令及其输出：输入的字符以等宽粗体表示，程序输出则以上 面所示的等宽字体表示。对输出的注释以中文宋体表示。输入之前的美元符号（$）是shell的提 示符，本书总是将shell提示符表示为$。

注意，myls程序列出的目录中的文件名不是以字母顺序列出的，而Is命令一般是按字母顺 序打印目录项。

在这个20行的程序中，有很多细节需要考虑。

•首先，其中包含了一个头文件apue.h。本书中几乎每一个程序都包含此头文件。它包含 了某些标准系统头文件，定义了许多常量及函数原型，这些都将用于本书的各个实例中， 附录B列出了这一头文件。

•接下来，我们包含了一个系统头文件dirent, h，以便使用opendir和readdir的函 数原型，以及dirent结构的定义。在其他一些系统里，这些定义被分成多个头文件。 比如，在Ubuntu 12.04中，/usr/include/dirent.h声明了函数原型，并且包含 bits/dirent .h,后者定义了 dirent 结钩（真正存放在/usr/include/x86_64-linux-gnu/bits 下

• main函数的声明使用了 ISO C标准所使用的风格（下一章将对ISO C标准进行更多 说明）。

•程序获取命令行的第1个参数argv[l]作为要列出其各个目录项的目录名。第7章将说 明main函数如何被调用，程序如何存取命令行参数和环境变量。

•因为各种不同UNIX系统目录项的实际格式是不一样的，所以使用函数opendir、 readdir和closedir对目录进行处理。

• opendir函数返回指向DIR结构的指针，我们将该指针传送给readdir函数。我们并 不关心DIR结构中包含了什么。然后，在循环中调用readdir来读每个目录项。它返 回一个指向dirent结构的指针，而当目录中已无目录项可读时则返回null指针。在 dirent结构中取出的只是每个目录项的名字(d_name)。使用该名字，此后就可调用 stat函数(见4.2节)以获傳该文件的所有属性。

•程序调用了两个自编的函数対错误进行处理：err_SyS和err_qUit。从上面的输出中 可以看到，err_sys 函数打印一条消息(“Permission denied” 或 “Not a directory”)，说 明遇到了什么类型的错误。这两个出错处理函数在附录B中说明，1.7节将更多地叙述出 错处理。

•当程序将结束时，它以参数0调用函数exit。函数exit终止程序。按惯例，参数0的 意思是正常结束，参数值1-255则表示出错。8.5节将说明一个程序(如shell或我们所 编写的程序)如何获得它所执行的另一个程序的exit状态。

\4.    工作目录

每个进程都有一个工作目录(working directory)，有时称其力当前工作目录(current working directory)-所有相对路径名都从工作目录开始解释。进程可以用chdir函数更改其工作目录。

例如，相对路径名doc/memo/joe指的是当前工作目录中的doc目录中的memo目录中的 文件(或目录)joe。从读路授名可以看出，doc和memo都应当是目录，但是却不能廿辨joe 是文件还是目录。路径名/urs/lib/lint是一个绝对路径名，它指的是根目录中的usr目录中 的lib目录中的文件(或目录)lint。

\5.    起始目录

登录时，工作目录设置为起始目录(homedirectory),该起始目录从口令文件(见1.3节)中 相应用户的登录项中取得。

1.5输入和输出

\1.    文件描述符

文件描述符(file descriptor)通常是一个小的非负整数，内核用以标识一个特定进程正在访 问的文件。当内核打开一个现有文件或创建一个新文件时，它都返回一个文件描述符。在谏、写 文件时，可以使用这个文件描述符。

\2.    标准输入、标准输出和标准错误

按惯例，每当运行一个新程序时，所有的shell都为其打开3个文件描述符，即标准输入 (standardinput)>枯准输出(standardoutput)以及标准错误(standarderror)0如果不做特殊处理， 例如就像简单的命令Is,则这3个描述符都链接向终端。大多数shell都提供一种方法，使其中 任何一个或所有这3个描述符都能重新定向到某个文件，例如：

Is > file.list

执行Is命令，其标淮输出重新定向到名为file.list的文件。

3.不帝缓冲的I/O

函数open、read、write、lseek以及close提供了不带缓冲的I/O。这些函数都使用文 件描述符。

■L实例

如果愿意从标准输入读，并向标准输出写，则图14中所示的程序可用于复制任一UNIX普 通文件。    m

番include ’’apue. h"

禅define BUFFSIZE 4096

int

main(void)

{

int n;

Char buf[BUFFSIZE];

while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0) if (write(STDOUT_FILENO, buf, n) != n)

err_sys("write error");

if (n < 0>

err_sys("read error");

exit(0);

J

图将标准输入复制到标准输出

头文件＜unistd.h＞ （apue.h中包含了此头文件）及两个常量STDIN_FILENO和STDOUT_ FILENO是POSIX标准的一部分（下一章将对此做更多的说明）。头文件含了很 多UNIX系统服务的函数原型，例如图M程序中调用的read和write。

两个常量STDIN_FILENO和STDOUT_FILENO定义在＜unistd.h＞头文件中，它们指定了 标准输入和标准输出的文件描述符。在POSIX标准中，它们的值分别是0和1，但是考虑到可读 性，我们将使用这些名字来表示这些常量。

3.9节将详细讨论BUFFSIZE常量，说明它的各种不同值将如何影响程序的效率。但是不管 该常量的值如何，此程序总能复制任一 UNIX普通文件。

read函数返回读取的字节数，此值用作要写的字节数。当到达输入文件的尾端时，read返 回0,程序停止执行-如果发生了一个读错误，read返回-1。出错时大多数系统函数返回-1。

如果将该程序编译成标准名称的a.out文件，并以下列方式执行它：

./a.out ＞ data

那么标准输入是终端，标准输出则重新定向至文件data,标准错误也是终端。如果此输出文件 并不存在，则shell会创建它。该程序将用户键入的各行复制到标淮输出，键入文件结束符（通常 是Ctrl+D）时，将终止本次复制。

若以下列方式执行该程序：

./a.out < infile > outfile

会将名为infile文件的内容复制到名为outfile的文件中。

第3章将更详细地说明不带缓冲的I/O函数。

4.标准I/O

标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需 担心如何选取最佳的缓冲E大小，如图中的BUFFSIZE常量的大小。使用标准I/O函数还简 化了对输入行的处理（常常发生在UNIX的应用程序中例如，fgets函数读取一个完整的行， 而read函数读取指定字节数。在5.4节中我们将了解到，标准I/O函数库提供了使我们能够控 制该库所使用的缓冲风格的函数，

我们最熟悉的标准I/O函数是printf。在调用printf的程序中，益是包含＜31＜110.h＞（在 本书中，该头文件包含在apue.h中），该头文件包括了所有标准I/O函数的原型。

图1-5程序的功能类似于前一个调用了 read和write的程序，5.8节将对此程序进行更详 细的说明。它将标准输入复制到标准输出，也就能复制任一 UNIX普通文件。

frinclude "apue.h" int

main(void)

{

int    c;

while { {c = getc(stdin))    != EOF)

if (putc(c, stdout) == EOF)

err_sys("output error");

if (ferror(stdin))

err_sys("input error");

exit(0);

图1-5用标准I/O将标准输入复制到标准输出

函数getc—次读取一个字符，然后函数putc将此字符写到标淮输出。读到输入的最后一 个字节时，getc返回常量EOF （该常量在＜stdio .h＞中定义）。标准I/O常量stdin和stdout 也在头文件＜3七011.0.?1＞中定义，它们分别表示标准输入和标准输出。    ■錄


1.6程序和进程

\1.    程序

程序（program）是一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数（7个 間exec函数之一），将程序读入内存，并执行程序。8.10节将说明这些exec函数。

\2.    进程和进程ID

程序的执行实例被称为进程（process）。本书的每一页几乎都会使用这一术语。某些操作系 统用任务（task）表示正在被执行的程序。

UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID （process ID）。进程ID总 是一个非负整数。

■实例

图1-6程序用于打印进程ID。

\#include "apue.h" int

main(void)

f

printf("hello world from process ID %ld\n", (long)getpid()); exit (0);

}

图1-6打印进程ID

如果将该程序编课成a.out文件，然后执行它，则有：

$ ./a.out

hello world from process ID 851

$ ./a.out

hello world from process ID 854

此程序运行时，它调用函数getpid得到其进程ID。我们将会在后面看到，getpid返回一个 Pid_t数据类型。我们不知道它的大小，仅知道的是标准会保证它能保存在一个长整型中。因为 我们必须在printf函数中指定需要打印的每一个变量的大小，所以我们必须把它的值强制转换 为它可能会用到的最大的数据类型（这里是长整型）。虽然大多数进程ID可以用整型表示，但用 长整型可以提高可移植性。

3.进程控制

有3个用于进程控制的主要函数：fork、exec和waitpid。（exec函数有7种变体，但 经常把它们统称为exec函数。）

实例

UNIX系统的进程控制功能可以用一个简单的程序说明（见图］-7）。该程序从标准输入读取 命令，然后执行送些命令。它类似于shdi程序的基本实施部分。    rm

\#include "apue.h"

♦include <sys/wait.h> int

main(void)

{

char buf [MAXLINE] ；    /* from apue.h */

pid_t pid; int status;

printf("%% ");    /* print prompt (printf requires %% to print %) */

while (fgets(buf, MAXLINE, stdin) != NULL) {

if (buf[strlen(buf) - 1I == *\n')

buf[strlen(buf) - 1] = 0; /* replace newline with null */

if ((pid = fork()) < 0) { err_sys("fork error");

} else if (pid == 0) {    /* child */

execlp(buf, buf, (char *)0); err_ret("couldn1t execute: %g", buf); exit(127)；

/* parent */

if ((pid = waitpid(pid, Sstatus, 0)) < 0) err_sys{"waitpid error");

printf("%% ");

)

exit(0);

图1-7从标准输入读命令并执行 在这个30行的程序中，有很多功能需要考虑。

•用标准I/O函数fgets从标准输入一次读取•一行。当键入文件结束符（通常是Ctrl+D）作 为行的第一个字符时，fgets返回一个null指针，于是循环停止，进程也就终止。第18 章将说明所有特殊的终端字符（文件结束、退格字符、整行擦除等），以及如何改变它们。

.因为fgets返回的每一行都以换行符终止，后随一个null字节，因此用标准C函数strlen 计算此字符串的长度，然后用一个null字节替换换行符。这样做是因为execlp函数要 求的参数是以null结束的而不是以换行符结束的。

•调用fork创建一个新进程。新进程是调用进程的一个副本，我们称调用进程为父进程， 新创建的进程为子进程。fork对父进程返回新的子进程的进程ID （—个非负整数），对

DTI    子进程则返回0。因为fork创建一个新进程，所以说它被调用一次（由父进程），但返

回两次（分别在父进程中和在子进程中），

•在子进程中，调用execlp以执行从标准输入读入的命令。这就用新的程序文件替换了 子进程原先执行的程序文件。fork和跟随其后的exec两者的组合就是某些操作系统所 称的产生（spawn） —个新进程。在UNIX系统中，这两部分分离成两个独立的函数。第 8章将对这些函数进行更多说明，

•子进程调用execlp执行新程序文件，而父进程希望等待子进程终止，这是通过调用 waitpid实现的，其参数指定要等待的进程（即pid参数是子进程ID）。waitpid函 数返回子进程的终止状态（status变量）。在我们这个简单的程序中，没有使用该值。 如果需要，可以用此值准确地判定子进程是如何终止的，

•该程序的最主要限制是不能向所执行的命令传递参数。例如不能指定要列出目录项的目 录名，只能对工作目录执行Is命令。为了传递参数，先要分析输入行，然后用某种约定 把参数分开（可能使用空格或制表符），再将分隔后的各个参数传递给execlp函数。尽 管如此，此程序仍可用来说明UNIX系统的进程控制功能。

如果运行此程序，将得到下列结果。注意，该程序使用了一个不同的提示符（%），以区别于 shell的提示符。

$ ./a.out % date

Sat Jan 21 19:42:07 EST 2012

% who

sar    console    Jan    1    14:59

sar    ttysOOO    Jan    1    14 ： 59

sar    ttysOOl    Jan    15    15:28

% pwd

/home/sar/bk/apue/3e

% Is

Makefile a. out shelll.c

键入文件结束符 常规的shell提示符



% *D

$

；    "D表示一个控制字符。控制字符是特殊字符，其构成方法是：在键盘上按下控制键——通常

;被标记为Control或Ctrl,同时按另一个键。Ctrl+D或AD是默认的文件结束符。在第18章中

讨论终端I/O时，会介绍更多的控制字符。

4.线程和线程ID

通常，一个进程只有一个控制线程（thread）——某一时刻执行的一组机器指令。对于某些 问题，如果有多个控制线程分别作用于它的不同部分，那么解决起来就容易得多。另外，多个接 制线程也可以充分利用多处理器系统的并行能力。

一个进程内的所有线程共享同一地址空间、文件描述符、桟以及与进程相关的属性。因为它 们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。

与进程相同，线程也用ID标识。但是，线程ID只在它所属的进程内起作用。一个进程中的 线程ID在另一个进程中没有意义。当在一进程中对某个特定线程进行处理时，我们可以使用孩 线程的ID引用它。

控制线程的函数与控制进程的函数类似，但另有一套。线程模型是在进程模型建立很久之后才被 引入到UNIX系统中的，然而这两种模型之间存在复杂的交互，在第12章中，我们会对此进行说明。

1.7出错处理

当UNIX系统函数出错时，通常会返回一个负值，而且整型变量errno通常被设置为具有特定 信息的值。例如，open函数如果成功执行则返回一个非负文件描述符，如出错则返回-1。在open 出错时，有大约15种不同的errno值（文件不存在、权限问题等）。而有些函数对于出错则使用另 一种约定而不是返回负值。例如，大多数返回指向对象指针的函数，在出错时会返回一个皿11指针。

文件＜扛2：110』＞中定义丁 errno以及可以赋与它的各种常量。这些常量都以字狩E开头。 另外，UNIX系统手册第2部分的第1页，intro（2）列出了所有这些出错常量。例如，若errno 等于常量EACCES，表示产生了权限问题（例如，没有足够的权限打开请求文件）。

在Linux中，出错常量在errno（3）手册页中列出。

POSIX和ISO （3将errno定义为一个符号，它扩展成为一个可修改的整形左值（lvalue）。 它可以是一个包含出错编号的整数，也可以是一个返回出错编号指针的函数。以前使用的定义是：

extern int errno;

但是在支持线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno riTI以避免一个线程干扰另一个线程。例如，Linux支持多线程存取61^110,将其定义为：

extern int *_errno_location(void);

\#define errno (*_errno_location())

对T errno应当注意两条规则。第一条规则是，如果没有出错，其值不会被例程清除。因 此，仅当函数的返回值指明出错时，才检验其值。第二条规则是：任何函数都不会将errno值 设置为0,而且在<errnO.h>中定义的所有常量都不为0。

C标准定义了两个函数，它们用于打印出错信息。 ftinclude <string.h> char *strerror (int ermum};

返回值：指向消息字符串的指针

strerror函数将(通常就是errno值)映射为一个出错消息字符串，并且退回此 字符串的指针。

perror函数基于errno的当前值，在标准错误上产生一条出错消息，然后返回。

\#include <stdio.h>

void perror (const char *msg);

它首先输出由m呀指向的字符串，然后是一个冒号，一个空格，接着是对应于errno值的 出错消息，最后是一个换行符。

、实例

图1-8程序显示了这两个出错函数的使用方法。

\#include "apue.h"

\#include <errno.h>

int

main(int argc, char *argv[])

{

fprintf(stderr, "EACCES: %s\n", strerror(EACCES)); errno = ENOENT; perror(argv[0]); exit (0);

图 1-8 例示 strerror 和 perror 如果将此程序编译成文件a.cmt，然后执行它，则有

S ./a-out

EACCES: Permission denied

./a.out: No such file or directory

注意，我们将程序名(argv[0],其值是./a .out)作为参数传递给perror。这是一个标准的 UNIX惯例。使用这种方法，在程序作为管道的一部分执行时I例如：

progl < inputfile I prog2 I prog3 > outputfile

我们就能分清3个程序中的哪一个产生了一条特定的出错消息。

本书中的所有实例基本上都不直接调用strerror或perror,而是使用附录B中的出错函 数。该附录中的出错函数使我们只用一条C语句就可利用ISOC的可变参数表功能处理出错情况。

出错恢复

可将在＜errn0.h＞中定义的各种出错分成两类:致命性的和非致命性的。对于致命性的错误， 无法执行恢复动作。最多能做的是在用户屏幕上打印出一条出错消息或者将一条出错消息写入日 志文件中，然后退出。対于非致命性的出错，有时可以较妥善地进行处理。大多数非致命性出错 是暂时的（如资源短缺），当系统中的活动较少时，这种出错很可能不会发生。

与资源相关的非致命性出错包括：EAGAIN、ENFILE. ENOBUFS、ENOLCK、ENOSPC、 EWOULDBLOCK，有时ENOMEM也是非致命性出错。当EBUSY指明共享资源正在使用时，也可将 它作为非致命性出错处理。当EINTR中断一个慢速系统调用时，可将它作为非致命性出错处理 （在10.5节対此会进行更多说明）。

对于资源相关的非致命性出错的典型恢复操作是延迟一段时间，然后重试。这种技术可应用 于其他情况。例如，假设出错表明一个网络连接不再起作用，那么应用程序可以采用这种方法，

在短时间延迟后，尝试重建该连接。一些应用使用指数补偿算法，在每次迭代中等待更长时间。

最终，由应用的开发者决定在哪些情况下应用程序可以从出错中恢复。如果能够采用一种合 理的恢复策略，那么可以避免应用程序异常终止，进而就能改善应用程序的健壮性，

1.8用户标识

\1.    用户ID

口令文件登录项中的用户ID （userID）是一个数值，它向系统标识各个不同的用户。系统 管理员在确定一个用户的登录名的同时，确定其用户ID。用户不能更改其用户ID。通常每个用 户有一个唯一的用户ID。下面将介绍内核如何使用用户ID来检验该用户是否有执行某些操作 的权限。

用户1D为0的用户为根用户（root）或超级用户（superuser〉。在口令文件中，通常有一个 登录项，其登录名为root，我们称这种用户的特权为超级用户特权。我们将在第4章中看到，

如果一个进程具有超级用户特权，则大多数文件权限检查都不再进行。某些操作系统功能只向超 级用户提供，超级用户对系统有自由的支配权。    nn

: MacOSX客户端版本交由用户使用时，禁用超级用户账户，服务器版本则可使用该账户。在 丨Apple的网站可以找到使用说明，它告知如何才能使用该赚户。参见<http://support>.

[apple.com/kb/HTl528。

\2.    组 ID

口令文件登录项也包括用户的组ID （group ID）,它是一个数值。组ID也是由系统管理 员在指定用户登录名时分配的。一般来说，在口令文件中有多个登录项具有相同的组nx组 被用于将若干用户集合到项目或部门中去-这种机制允许同组的各个成员之间共享资源（如 文件）。4.5节将介绍可以通过设置文件的权限使组内所有成员都能访问该文件，而组外用户 不能i方问。

组文件将组名映射为数值的组ID。组文件通常是/etc/group。

使用数值的用户ID和数值的组1D设置权限是历史上形成的。对于磁盘上的每个文件，文件 系统都存储该文件所有者的用户ID和组ID-存储这两个值只需4个字节(假定每个都以双字节 的整型值存放)。如果使用完整ASCII登录名和组名，则需更多的磁盘空间。另外，在检验权限 期间，比较字符串较之比较整型数更消耗时间。

但是対于用户而言，使用名字比使用数值方便，所以口令文件包含了登录名和用户ID之间 的映射关系，而组文件则包含了组名和组江＞ 之间的映射关系。例如，Is -1命令使用口令文件 将数值的用户ID映射为登录名，从而打印出文件所有者的登录名。

早期的UNIX系统使用16位整型數表示用户ID和组ID。现今的UNIX系统使用32位整型 ；教表示用户1D和组ID。

t实例

图1-9程序用于打印用户ID和组ID。 昝include "apue.h"

int

main(void)

t

printf("uid = %d, gid = %d\n", getuidt), getgid()); exit{0);

_

图1-9打印用户ID和组ID

程序调用getuid和getgid以返回用户ID和组ID。运行该程序的结果如下：

$ ./a.out

1 17 |    uid = 205, gid = 105

3.附属组ID

除了在口令文件中对一个登录名指定一个组ID外，大多数UNIX系统版本还允许一个用户 属于另外一些组。这一功能是从4.2BSD开始的，它允许一个用户属于多至16个其他的组。登录 时，读文件/etc/group,寻找列有该用户作为其成员的前16个记录项就可以得到该用户的附 属组ID (supplementary group ID)O在下一章将说明，POSIX要求系统至少应支持8个附属组， 实际上大多数系统至少支持16个附属组。

##### 1.9信号

信号(signal)用于通知进程发生了某种情况。例如，若某一进程执行除法操作，其除数为0, 则将名为SIGFPE (浮点异常)的信号发送给该进程。进程有以下3种处理信号的方式。

(1)    忽略信号。有些信号表示硬件异常，例如，除以0或访问进程地址空间以外的存储单元 等，因为这些异常产生的后果不确定，所以不推荐使用这种处理方式。

(2)    按系统默认方式处理。对于除数为0,系统默认方式是终止读进程。

(3)    提供一个函数，信号发生时调用该函数，这被称为捕捉该信号。通过提供自编的函数， 我们就能知道什么时候产生了信号，并按期望的方式处理它。

很多情况都会产生信号。终端键盘上有两种产生信号的方法，分别称为中断键（interrupt key, 通常是Delete键或Ctrl+C）和退出键（quitkey,通常是Ctrl+\）,它们被用于中断当前运行的进程。

另一种产生信号的方法是调用kill函数。在一■个进程中调用此函数就可向另一个进程发送一个信 号。当然这样做也有些限制：当向一个进程发送信号时，我们必须是那个进程的所有者或者是超级 用户。

賤•实例

回忆一下基本的shell实例（见图1-7程序）。如果调用此程序，然后按下中断键，则执行此 程序的进程终止。产生这种后果的原因是：对于此信号（SIGINT）的系统默认动作是终止进程。 该进程没有告诉系统内核应该如何处理此信号，所以系统按默认方式终止该进程。

为了能捕捉到此信号，程序需要调用signal函数，其中指定了当产生SIGINT信号时 要调用的函数的名字。函数名为sig_int,当其被调用时，只是打印一条消息，然后打印［KI —个新提示符。在图1-7程序中添加了 11行，构成了图1-10程序（添加的11行以行首的+

号指示）。

\#include "apue.h"

\#include <sys/wait.h>

十 static void sig_int（int）;    /* our signal-catching function */

main(void)

{

char buf[MAXLINE]; /* from apue.h */ pid_t pid; int status;

\+    if (signal(SIGINT, sig_int) == SIG_ERR}

\+    err_sys("signal error");

+

printf("%% "); /* print prompt (printf requires %% to print %) */ while (fgets{buf, MAXLINE, stdin) != NULL) {

if (buf[strlen(buf) - 1] == 1\n')

buf[strlen(buf) - 1] = 0; /* replace newline with null */

if ( (pid = fork{) ) < 0) { err_sys("fork error");

} else if (pid == 0) {    /* child */

execlp (buf, buf, (char *)0); err_ret("couldn1t execute: %s", buf); exit(127);

/* parent */

if ((pid = waitpid(pid, Sstatus, 0)) < 0) err_sys ("waitpid error'1};

printf("%% ");

1

exit (0);

\+ void

\+ sig_int{int signo)

\+ (

\+ printf("interrupt\n%% "); + }

图1-10从标准输入读命令并执行

冈    因为大多数重要的应用程序都对信号进行处理，所以第10章将详细介绍信号。

###### 1.10时间值

历史上，UNIX系统使用过两种不同的时间值。

(1)    日历时间。该值是自协调世界时(Coordinated Universal Time, UTC) 1970年1月1日 00X)0:00这个特定时间以来所经过的秒数累计值(早期的手册称UTC为格林尼治标准时间)。这 些时间值可用于记录文件最近一次的修改时间等。

系统基本数据类型time_t用于保存这种时间值。

(2)    进程时间。也被称为CPU时间，用以度量进程使用的中央处理器资源。进程时间以时钟 滴答计算。每秒钟曾经取为50、60或100个时钟滴答。

系统基本数据类型clock.t保存这种时间值。2.5.4节将说明如何用sysconf函数得到每 秒的时钟滴答数。

当度量一个进程的执行时间时(见3.9节)，UNIX系统为一个进程维护了 3个进程时间值：

•时钟时间；

•用户CPU时间；

•系统CPU时间。

时钟时间又称为墙上时钟时间(wall clock time)，它是进程运行的时间总量，其值与系统 中同时运行的进程数有关。每当在本书中提到时钟时间时，都是在系统中没有其他活动时进行 度量的》

用户CPU时间是执行用户指令所用的时间量。系统CPU时间是为该进程执行内核程序所经 历的时间。例如，每当一个进程执行一个系统服务时，如read或write，在内核内执行该服务 所花费的时间就计入该进程的系统CPU时间。用户CPU时间和系统CPU时间之和常被称为CPU 时间=

要取得任一进程的时钟时间、用户时间和系统时间是很容易的——只要执行命令time(l)， 其参数是要度量其执行时间的命令，例如：

$ cd /use/xnoluda

$ ♦•Ana -p gcap _POSIX_SODRCB */*.h > /dav/null

real oraO,81s user omO.11s sys omO.07s

time命令的输出格式与所使用的shell有关，其原因是某些shell并不运行/usr/bin/time，而 是使用一个内置函数测量命令运行所使用的时间。

[20~|    8.17节将说明一个运行进程如何取得这3个时间=关于时间和日期的一般说明见6.10节。

1.11系统调用和库函数

所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的UNIX实 现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用（systemcall,

见图1-1）。Research UNIX系统第7版提供了约50个系统调用，4.4BSD提供了约110个系统调 用，而SVR4则提供了约120个系统调用。具体数字在不同操作系统版本中会不同，新近的大多 数系统大大增加了支持的系统调用的个数。Linux 3.2.0提供了 380个系统调用，FreeBSD 8.0提供 的系统调用超过450个。

系统调用接口总是在《UNIX程序员手册》的第2部分中说明，是用C语言定义的，与具体 系统如何调用一个系统调用的实现技术无关。这与很多早期的操作系统不同，那些系统按传统方 式用机器的汇编语言定义内核入口点。

UNIX所使用的技术是为每个系统调用在标准C库中设置一个具有同样名字的函数。用户进 程用标准C调用序列来调用这些函数，然后，函数又用系统所要求的技术调用相应的内核服务。

例如，函数可将一个或多个C参数送入通用寄存器，然后执行某个产生软中断进入内核的机器指 令。从应用角度考虑，可将系统调用视为c函数。

《UNIX程序员手册》的第3部分定义了程序员可以使用的通用库函数。虽然这些函数可能会 调用一个或多个内核的系统调用，但是它们并不是内核的入口点。例如，printf函数会调用 write系统调用以输出一个字符串，但函数strcpy （复制一个字狩串）和atoi （将ASCII转 换为整数）并不使用任何内核的系统调用。

从实现者的角度来看，系统调用和库函数之间有根本的区别，但从用户角度来看，其区别并 不重要。在本书中，系统调用和库函数都以C函数的形式出现，两者都为应用程序提供服务。但 是，我们应当理解，如果希望的话，我们可以替换库函数，但是系统调用通常是不能被替换的。

以存储空间分配函数malloc为例。有多种方法可以进行存储空间分配及与其相关的无用空 间回收操作（最佳适应、首次适应等），并不存在对所有程序都最优的一种技术。UNIX系统调用 中处理存储空间分配的是sbrk（2）,它不是一个通用的存储器管理器。它按指定字节数增加或减 少进程地址空间。如何管理该地址空间却取决于进程。存储空间分配函数mallOC（3）实现一种特 定类型的分配。如果我们不喜欢其操作方式，则可以定义自己的malloc函数，它很可能将使用 sbrk系统调用。事实上，有很多软件包，它们使用sbrk系统调用实现自己的存储空间分配算 法。图1-11显示了应用程序、malloc函数以及sbrk系统调用之间的关系。    [10

从中可见，两者职责不同，内核中的系统调用分配一块空间给进程，而库函数malloc则在 用户层次管理这-•空间。

另一个可说明系统调用和库函数之间差别的例子是，UNIX系统提供的判断当前时间和日期 的接口。一些操作系统分别提供了一个返回时间的系统调用和另一个返回日期的系统调用。任何 特殊的处理，例如正常时制和夏令时之间的转換，由内核处理或要求人为干预。UNIX系统则不 同，它只提供一个系统调用，该系统调用返回自协调世界时1970年1月1日零时这个特定时间 以来所经过的秒数。对该值的任何解释，例如将其变换成人们可读的、适用于本地时区的时间和 日期，都留给用户进程进行处理。在标准C库中，提供了若干例程以处理大多数情况。这些库函 数处理各种细节，如各种夏令时算法等。

应用程序既可以调用系统调用也可以调用库函数。很多库函数则会调用系统调用。图1-12显

示了这种差别。

图1-11 malloc函数和sbrk系统调用



图1U2 C库函数和系统调用之间的差别



系统调用和库函数之间的另一个差别是：系统调用通常提供一种最小接口，而库函数通常提 [22]供比较复杂的功能。我们从sbrk系统调用和malloc库函数之间的差别中可以看到这一点。当 我们比较不带缓冲的I/O函数（见第3章）和标准I/O函数（见第5章）时，还将看到这种差别。

进程控制系统调用（fork、exec和wait）通常由用户应用程序直接调用（请回忆图1-7 中的基本shell）。但是为了简化某些常见的情况，UNIX系统也提供了一些库函数，如system 和popen。8.13节将说明system函数的一种实现，它使用基本的进程控制系统调用a 10.18节 还将强化这一实例以正确地处理信号。

为使读者了解大多数程序员应用的UNIX系统接口，我们不得不既说明系统调用，又介绍某 些库函数。例如，若只描述sbrk系统调用，那么就会忽略很多应用程序使用的malloc库函数 本书除了必须要区分两者时，对系统调用和库函数都使用函数（function）这一术语来表示。

##### 1.12小结

本章快速浏览了 UNIX系统。说明了某些以后会多次用到的基本术语，介绍了一些小的UNIX [23]程序实例。读者可以从中大概了解到本书其余部分将要介绍的内容，

下一章是关于UNIX系统的标准，以及这方面的工作对当前系统的影响。标准，特别是ISO C 标准和POSEX.1标准，将影响本书的余下部分。

习题

1.1在系统上验证，除根目录外，目录.和..是不同的。

1.2分析图1-6程序的输出，说明进程ID为852和853的进程发生了什么情况？

1.3 在1.7节中，perror的参数是用ISO C的属性const定义的，而strerror的整型参数 没有用此属性定义，为什么？

1.4若日历时间存放在带符号的32位整型数中，那么到哪一年它将溢出？可以用什么方法扩展 溢出浮点数？采用的策略是否与现有的应用相兼容？

1.5 若进程时间存放在带符号的32位整型数中，而且每秒为100时钟滴答，那么经过多少天后

该时间值将会溢出？    ®
