### 第18章

##### 18.1引言

无论在哪种操作系统中，终端I/O的处理都是非常繁琐的一部分，UNIX系统也不例外。在 大多数版本的编程手册中，终端I/O手册页常常是最长的几个部分之一。

在20世纪70年代后期，系统m在V7的基础上发展出一套不同的终端例程，由此使得UNIX 终端I/O处理分立为两种不同的风格。一种是系统in的风格，由System V沿续下来，另一种是 V7的风格，它成为BSD派生的系统终端I/O处理的标准。如同信号一样，POSIX.1在这两种风 格的基础上制定了终端1/0标准。本章将介绍POSIX.1的所有终端函数，以及某些平台特有的増 加部分。

终端I/O系统之所以如此复杂，部分原因是人们将其应用在众多的事物上：终端、计算机之 间的直接连接、调制解调器以及打印机等。

##### 18.2综述

终端I/O有两种不同的工作模式。

ci）规范模式输入处理。在这种模式中，对终端输入以行为单位进行处理。対于每个读请求， 终端驱动程序最多返回一行。

岡 （2）非规范模式输入处理。输入字符不装配成行。

如果不做特殊处理，则默认模式是规范模式。例如，若shell将标准输入重定向到终端，并用

read和write将标准输入复制到标准输出，则终端以规范模式进行工作，每次read最多返回 一行。处理整个屏幕的程序（如vi编辑器）使用非规范模式，原因是它的命令可能是由单个字 符组成的，并且不以换行符终止。另外，该编辑器并不希望系统対特殊字符进行处理，因为这些 字符很可能与编辑命令中使用的字符重叠。例如，Ctrl+D字符通常是终端的文件结束符，但在vi 中它是向下滚动半个屏幕的命令。

V7和较早的BSD风格类的终端驱动程序支持3种终埔输入模式：（a）精细加工模式（輪入 装&成行，并对特殊字符进行处理（b）原始模式（徐入不装纪成行，也不对特殊字符进行处理）；

1 （c） cbreak模式（格■入不装配成行，但对某些特殊字符进行处理）。图18-20显示了将终端设置为

cbreak或原始模式的POSIX.1函數。

POSIX.1定义了 11个特殊输入字符，其中9个可以更改。本书已经用到了其中几个，例

如文件结束符（通常是Ctrl+D）和挂起字符（通常是Ctrl+Z）。18.3节将対这些字符逐一进行 说明。

可以认为终端设备是由通常位于内核中的终端驱动程序控制的。每个终端设备都有一个输入 队列和一个输出队列，如图18-1所示。

进程写的下一个字符    进程读的下一个字符

输出队列



如果打开回显功能



输入队列



传送到设备的 下一个字符



^1-MAX_INPUT

从设备中读取的 下-个字符

图18-1终端设备的输入、输出队列的逻辑结构

对此图要说明以下几点。

•如果打开了回显功能，则在输入队列和输出队列之间有一个隐含的连接。

•输入队列的长度MAX_INPUT （见图2-11）是有限值。当一个特定设备的输入队列己经填 满时，系统的行为将依赖于实现。这种情况发生时大多数UNIX系统回显响铃字符。    [672]

■图中没有显示另一个输入限制MAX_CANON»这个限制是一个规范输入行的最大字 节数，

•虽然输出队列的长度通常也是有限的，但是程序并不能获得这个定义其长度的常量，因 为当输出队列将要填满时，内核便直接使写进程休眠，直至写队列中有可用的空间。

•我们将说明如何使用冲洗函数tcflush冲洗输入或输 出队列。与此类似，在说明tcsetattr函数时，将会 了解到如何通知系统只有在输出队列为空时，才能改变 一个终端的属性。（例如，想要改变输出属性时就要这样 做。〉也可以通知系统，让它在改变终端属性时丢弃输入 队列中的所有东西，（如果正在改变输入属性，或者在规 范模式和非规范模式之间进行转换，就需要这样做，以 免以错误的模式对以前输入的字符进行解释。）

大多数UNIX系统在一个称为终鴻行规程（terminal line discipline）的模块中进行全部的规范处理D可以将这个模块设想 成一个盒子|位于内核通用读、写函数和实际设备驱动程序之间 （见图 18-2）。

由于将规范处理分离为单独的模块，所有的终端驱动程序 都能够一致地支持规范处理。在第19章讨论伪终端时还将使用 此图。

所有可以检测和更改的终端设备特性都包含在termios结 构中。该结构定义在头文件＜termios.h＞中，本章使用这一头

用户进程

实际设备

图18-2终端行规程



文件。

struct termios { tcflag_t c_iflag; tcflag_t c_oflag; tcflag_t c_cflag; tcflag_t c_lflag; cc„t    c_cc【NCCS];

/* input flags */

/* output flags */

/* control flags */

/* local flags */

/* control characters */



};

粗略地说，输入标志通过终端设备驱动程序控制字符的输入（例如，剥除输入字节的第8位， 允许输入奇偶校验），输出标志则控制驱动程序输出（例如，执行输出处理、将换行符转换为 CR/LF）,控制标志影响RS-232串行线（例如，忽略调制解调器的状态线、每个字符的一个或两 个停止位），本地标志影响驱动程序和用户之间的接口（例如，回显打开或关闭、可视地擦除字 符、允许终端产生的信号以及对后台输出的作业控制停止信号）。

类型tcflag_t的丧度足以保存每个标志值，它经常被定义为unsigned int或者unsigned long. c_cc数组包含了所有可以更改的特殊字符=NCCS是该数组中元素的数量.其典型值在15-20 （因为大多数UNIX实现支持的特殊字符都比POSIX.1所定义的11个要多）。型的长 度足以保宿每个特殊字符，典型的是unsigned char。

POSIX标准之前的System V板本有一个名为＜termio. h＞的头文件和一个名为termio的數 丨据结构。为了与先前版本有所区别，POSIX.1在这些名字后加了一个S。

图18-3至图18-6列出了所有可以更改以影响终端设备特性的终端标志。注意，虽然Single UNIX Specification定义了供所有平台启动所用的公共子集，但所有实现都有自己的扩充部分，这 些扩充部分大多来自各系统之间的历史差异。18.5节将对这些标志值进行详细的讨论。

| 标志       | 说明                        | POSIX.1 | FreeBSD8.0 | Linux3.2,0 | Mac OSX 10.6.8 | Solaris10 |
| ---------- | --------------------------- | ------- | ---------- | ---------- | -------------- | --------- |
| CBAUDEXT   | 扩充的波特率                |         |            |            |                | •         |
| CCAR_OFLOW | 输出的DCD流控制             |         |            |            |                |           |
| CCTS_OFLOW | 输出的CTS流控制             |         |            |            |                | •         |
| CDSR_OFLOW | 输出的DSR流控制             |         |            |            |                |           |
| CDTR_IFLOW | 输入的DTR流控制             |         |            |            |                |           |
| CIBAUDEXT  | 扩充输入波特率              |         |            |            |                | •         |
| CIGNORE    | 忽略控制标志                |         |            |            |                |           |
| CLOCAL     | 忽略调制解调器状态行        | •       |            |            |                | •         |
| CMSPAR     | 标记或空奇偶性              |         |            |            |                |           |
| CREAD      | 启用接收装置                |         |            |            |                | •         |
| CRTSCTS    | 启用硬件流控制              |         |            |            |                | •         |
| CRTS_IFLOW | 输入的RTS流控制             |         |            |            |                | •         |
| CRTSXOFF   | 启用输入硬件流控制          |         |            |            |                | •         |
| CSIZE      | 字符大小屏蔽字              |         |            |            |                | •         |
| CSTOPB     | 发送两个停止位，否则发送1位 |         |            | •          |                | •         |
| HUPCL      | 最后关闭吋挂断              |         |            | •          |                | •         |
| MDMBUF     | 与 CCAR_OFLOW 相同          |         |            |            |                |           |
| PARENB     | 启用奇偶校验                |         |            | •          |                | •         |
| PAREXT     | 标记或空奇偶性              |         |            |            |                | •         |
| PARODD     | 奇校验，否则为偶校验        |         |            | •          |                | •         |

图 18-3

c_cflag终端标志

| 碱      | 说明                           | POSIX.1 | FreeBSD8.0 | Linux3.2.0 | Mac OS X 10.6.8 | Solaris10 |
| ------- | ------------------------------ | ------- | ---------- | ---------- | --------------- | --------- |
| BRKINT  | 接到BREAK时产生SIGINT          |         |            |            |                 |           |
| ICRNL   | 将输入的CR转换为NL             |         |            |            |                 |           |
| IGNBRK  | 忽略BREAK条件                  |         |            |            |                 |           |
| IGNCR   | 忽略CR                         |         |            |            |                 |           |
| IGNPAR  | 忽略奇偶校验出错的字符         |         |            |            |                 |           |
| IMAXBEL | 在输入队列满时振铃             |         |            |            |                 |           |
| INLCR   | 将输入的NL转换为CR             |         |            |            |                 |           |
| INPCK   | 打开输入奇偶校验               |         |            |            |                 |           |
| ISTRIP  | 剥除输入字符的第8位            |         |            |            |                 |           |
| IUCLC   | 将瑜入的大写字符转換成小写字符 |         |            |            |                 |           |
| IUTF8   | 输入是UTF-8                    |         |            |            |                 |           |
| IXANY   | 使任何字符都重新启动输出       | -       | •          |            |                 |           |
| IXOFF   | 使启用糜用输入流持制起作用     | •       | •          |            |                 |           |
| IXON    | 使启用/禁用输出流控制起作用    | •       |            |            |                 |           |
| PARMRK  | 标记奇偶检验错误               | •       | •          |            |                 |           |

图184 c_iflag终端标志

| 标志             | 说明                                    | POSIX.I | FreeBSD8.0 | Linux3.2.0 | Mac OS X 10.6.8 | Solaris10 |
| ---------------- | --------------------------------------- | ------- | ---------- | ---------- | --------------- | --------- |
| ALTWERASEECHO    | 使用替换WERASE算法 启用回显             | •       |            |            |                 |           |
| ECHOCTL          | 回显控制字符为A (Char)                  |         |            |            |                 |           |
| ECHOE            | 可视地擦除字符                          | •       |            |            |                 |           |
| ECHOK            | 回显杀死符                              | •       |            |            |                 |           |
| ECHOKE           | 杀死的可见擦除                          |         |            |            |                 |           |
| ECHONL           | 回显NL                                  | 帝      |            |            |                 |           |
| ECHOPRT          | 硬拷贝的可见擦除方式                    |         |            |            |                 |           |
| EXTPROCFLUSHO    | 外部字符处理 冲洗输出                   |         |            |            |                 |           |
| ICANON           | 规范输入                                | •       |            |            |                 |           |
| IEXTEN           | 使扩充的输入字符处理起作用              | •       |            |            |                 |           |
| ISIG             | 使终端产生的信号起作用                  | •       |            |            |                 |           |
| NOFLSH           | 在中断或退出后不冲洗                    | •       |            |            |                 |           |
| NOKERNINFOPENDIN | 无来自STATUS的内核输出 重新键入未决输入 |         |            |            |                 |           |
| TOSTOP           | 对于后台输出发送SIGTTOU                 | •       |            |            |                 |           |
| XCASE            | 规范的丈/小写表示                       |         |            |            |                 |           |

图18-5 c_lflag终端标志

给出了所有可用的选项后，如何才能检测和更改终端设备的这些特性呢？图18。7总结并 列出了 Single UNIX Specification所定义的对终端设备进行操作的各个函数。(列出的所有函 数都是POSIX基本规范的组成部分，9.7节已说明了 tcgetpgrp、tcgetsid和tcsetpgrp 函数。)

注意，对终端设备，Single UNIX Specification没有使用经典的ioctl,而是使用了图18-7 中列出的13个函数。这样做的理由是：对于终端设备的ioctl函数，其最后一个参数的数据类 型随执行动作的不同而改变。因此，不可能对参数进行类型检査。

| 标志   | 说明                           | POSIX.1 | FreeBSD8.0 | Linux3.2.0 | Mac OS X 10.6.8 | Solaris10 |
| ------ | ------------------------------ | ------- | ---------- | ---------- | --------------- | --------- |
| BSDLY  | 退格延迟屏蔽字                 | XSI     |            |            |                 |           |
| CRDLY  | CR延迟屏蔽字                   | XS1     |            |            |                 |           |
| FFDLY  | 换页延迟屏蔽字                 | XSI     |            |            |                 |           |
| NLDLY  | NL延迟屏蔽字                   | XSI     |            |            |                 |           |
| OCRNL  | 将输出的CR映射为NL             | XS1     |            |            |                 |           |
| OFDEL  | 填充符为DEL,否则为NUL          | XSI     |            |            |                 |           |
| OFILL  | 延迟使用填充符                 | XSI     |            |            |                 |           |
| OLCUC  | 将输出的小写字符陕射为大写字符 |         |            |            |                 |           |
| ONLCR  | 将NL映射为CR-NL                | XSI     |            |            |                 |           |
| ONLRET | NL执行CR功能                   | XSI     |            |            |                 |           |
| ONOCR  | 在0列不输出CR                  | XSI     |            |            |                 |           |
| ONOEOT | 在输出中丢弃EOT字符（AD）      |         |            |            |                 |           |
| OPOST  | 执行输出处理                   | •       |            |            |                 |           |
| OXTABS | 将制表符扩充为空格             |         |            |            |                 |           |
| TABDLY | 水平制表符延迟屏敵字           | XSI     |            |            |                 |           |
| VTDLY  | 垂直制表符延迟屏蔽字           | XSI     |            |            |                 |           |

图18-6 c_of lag终端标志

| 函数        | 说明                              |
| ----------- | --------------------------------- |
| tcgetattr   | 获取属性（termios结构）           |
| tcsetattr   | 设置属性（termios结构）           |
| cfgetispeed | 获得输入速度                      |
| cfgetospeed | 获得输出速度                      |
| cfsetispeed | 设置输入速度                      |
| cfaetospeed | 设置输出速度                      |
| tcdrain     | 等待所有输出都被传输              |
| tcflow      | 挂起传输或接收                    |
| tcflush     | 冲洗未决输入和/或输出             |
| tcsendbreak | 发送BREAK字符                     |
| tcgetpgrp   | 获得前台进程组ID                  |
| tcsetpgrp   | 设置前台进程组ID                  |
| tcgetsid    | 得到控制TTY的会话首进程的进程组ID |

图18-7终端I/O函数汇总

虽然在终端设备上进行操作的只有13个函数，但是图18-7中的前两个函数（tcgetattr 和tcsetattr）能处理大约70种不同的标志（见图18-3至图18-6）。终端设备有大量选 项可供使用，此外，对于某个特定设备（假设其为终端、调制解调器、打印机或任何其他 设备），决定其需要哪些选项对我们来说也是一种挑战，这些都使得对终端设备的处理变 得异常复杂。

图18-7中列出的13个函数之间的关系如图18-8所示。

1    POSIX.1没有指定将波特率信息存储在termios结构中的什么地方，它依核于实现的细节。

I某些系统，如Solaris,将此信息存储在0_0£139字段中。Linux和BSD派生的系统，如FreeBSD

和MacOSX,则在此结构中有两个分开的字段：一个存借检入速度，另一个存储输出速度。

struct

termios



![img](UNIXaf83d8a7160b-70.png)



图18-8与终端有关的各函数之间的关系



674

I

677



18.3特殊输入字符

POSIX.1定义了 11个在输入时要特妹处理的字符。実现定义了另外一些特殊宇符。图18-9 总结井列出了这些特殊字符。

| 字符         | 说明                        | c_cc下标       | 由…            | 启用          | 麵值       | POSDC1 | FreeBSD8.0 | Linux32.0 | Mac OS X 10.6.8 | Solsis10 |
| ------------ | --------------------------- | -------------- | -------------- | ------------- | ---------- | ------ | ---------- | --------- | --------------- | -------- |
| 字段         | 标志                        |                |                |               |            |        |            |           |                 |          |
| CR           | 回车                        | （不能更改）   | c_lflag        | ICANON        | \r         | -      |            |           |                 |          |
| DISCARDDSUSP | 丢弃输出（SIGTSTP）         | VDISCARDVDSUSP | c_lflagc_lflag | IEXTENISIG    | X)AY       |        |            |           |                 |          |
| EOF          | 文件结束                    | VEOF           | c_lflag        | ICANON        | AD         | •      |            |           |                 |          |
| EOLEOL2      | 鴻束備换的概束              | VEOLVEOL2      | c_lflagc_lflag | ICANONICANON  |            | *      |            |           |                 |          |
| ERASEERASE2  | 向m除辨 供替换的向前擦 鮮符 | VERASEVERASE2  | c_lflagc_lflag | ICANONICANON  | aH,a?AH,A? |        |            |           |                 |          |
| INTR         | 中断信号 （SIGINT）         | VINTR          | c_lflag        | ISIG          |            | •      |            |           |                 |          |
| KILL         |                             | VKILL          | c_lflag        | ICANON        |            | •      |            |           |                 |          |
| LNEXT        | 下一个字符的字 面值         | VLNEXT         | c_lflag        | IEXTEN        | aV         |        |            |           |                 |          |
| NL           | 鮪                          | （不能更改）   | c_lflag        | ICANON        | \n         |        |            |           |                 |          |
| QUIT         | 退出信号 （SIGQUIT）        | VQUIT          | c_lflag        | ISIG          |            |        |            |           |                 |          |
| REPRINT      | 再打印金部输入              | VREPRINT       | c_lflag        | ICANON        | AR         |        |            |           |                 |          |
| START        | 恢复输出                    | VSTART         | c_iflag        | 工 XON/ IXOFF |            |        |            |           |                 |          |

图18-9终端特殊输入字符汇总

| 铺     | 说明            | c_cc下标 | 由••…   | 启用       | 典型值 | POSIX.1 | FreeBSD8.0 | Lirnxx3^.0 | Mac OS X 10.6.8 | Solaris10 |
| ------ | --------------- | -------- | ------- | ---------- | ------ | ------- | ---------- | ---------- | --------------- | --------- |
| 字段   | 标志            |          |         |            |        |         |            |            |                 |           |
| STATUS | 状态清求        | VSTATUS  | c_lflag | ICANON     | AT     |         |            |            |                 |           |
| STOP   | 停止输出        | VSTOP    | c_iflag | IXON/IXOFF | AS     | •       | •          | •          | •               | •         |
| SUSP   | 概信号(SIGTSTP) | VSUSP    | c_lflag | ISIG       | AZ     | •       | •          | •          | •               | •         |
| WERASE | 向前擦除一个字  | VWERASE  | c lflag | ICANON     | AW     |         | •          | •          |                 | •         |

图18-9终端特殊输入字符汇总（续）

在POSIX.1的11个特殊字符中，其中有9个字符的值可以任意更改。不能更改的两个特殊 字符是换行符和回车符（分别是\^和\1），也可能是STOP和START字符（依赖于实现）。为了 更改，只需要修改termios结构中c_cc数组的相应项。该数组中的元素都用名字作为下标进 行引用，每个名字都以字母V开头（见图18-9中的第3列）。

POSIX.1允许禁止使用这咎字符。若将c_cc数组中的某项设置为_POSIX_VDISABLE的值， 则禁止使用相应特殊字符。

在Single UNIX Specification的早期版本中，支持_POSIX_VDISABLE是可选项，现在则是必选项。 本书讨论的4种平台都支持此特性。Linux32.0和Solaris 10^POSIX_VDISABLE定义为0，而

I FreeBSD 8.0 和 Mac OS X 10.6.8 则将其定义为 Oxf f。

:'    某些早期的UNIX系统所用的方法是：若与某一特性相应的特殊檢入字符是0,则禁止使用该特性。

画

■实例

在详细说明各特殊字符之前，先看一个更改特殊字符的小程序。图18-10所示的程序禁用中 断字符，并将文件结束符设置为Ctrl+B。

林include "apue.h" #include <termios.h>

int

main <void)

1

struct termios    term;

long    vdisable;

if (isatty(STDIN_FILENO) = 0)

err_quit("standard input is not a terminal device");

if ((Vdisable = fpathconf(STDIN_FILENO, _PC_VDISABLE)) < 0)

err_quit("fpathconf error or _POSXX_VDISABLE not in effect");

if (tcgetattr(STDIN_FILENO, sterm) < 0J /* fetch tty state */ err_sys("tcgetattr error");

term.c_cc[VINTRI = vdisable; /* disable INTR character */ term.c_cc[VEOF] =2;    Z* EOF is Control-B */

if (tcsetattr(STDIN_FILENO, TCSAFLUSH, iterm) < 0>

err_sys("tcsetattr error");

exit{0);

图18-10禁用中断字狩并更改文件结束符 対此程序要说明以下几点。

.仅当标准输入是终端设备时才修改终職殊字符。调用isatty （见18.9节）对此进行检测=

•用 fpathconf 获取_POSIX_VDISABLE 值。

•函数tcgetattr （见18.4节）从内核获取termios结钩。在修敌了此结构后，调 用tcsetattr函数设置属性，只有我们所希望修改的属性被更改了，而其他属畦保 持不变。

•禁用中断键与忽略中断信号是不同的。图18-10中的程序所做的只是禁用使终端驱动程序 产生SIGINT信号的特殊字符。我们仍可使用kill函数将该信号发送至进程。    [679]

下面较详细地说明各个特殊字符。我们称这些字符为特殊输入字符，但是其中有两个字 符——STOP和START （Ctri+S和Ctrl+Q）,在输出时也要进行特殊处理。注意，这些字符中的大 多数在被终端驱动程序识别并进行特殊处理后会被丢弃，并不将它们返回给执行读终端操作的进 程。返固给读进程的例外字符是换行符（NL、EOL、EOL2）和回车符（CR）。

CR    回车符。不能更改此字符。以规范模式进行输入时识别此字符。在已设置ICANON

（规范模式）和ICRNL （将CR映射为NL）但并未设置IGNCR （忽略CR）时，CR 字符会被转换成NL,并具有与NL字符相同的作用。此字符返回给读进程（很可 能是在转换为NL之后）。

DISCARD 丢弃符。在扩充模式（IEXTEN）下进行输入时识别此字符。在输入另一个DISCARD 字符之前或在丢弃条件被清除之前（见FLUSHO选项），此字符使后续输出都被丢 弃。此字符在处理后即被丢弃（即不传送给读进程）。

DSUSP    延返挂起作业控制字符（delayed-suspend job-control character）o在扩充模式

（IEXTEN）下，若支持作业控制，并且己设置ISIG标志，则在输入时识别此字符。

与SUSP字符的相同之处是：延迟挂起字符产生SIGTSTP信号，该信号被发送至 前台进程组中的所有进程（见图9-7）。但是，信号产生的时间并不是在键入延迟挂 起字符之时，而是在某个进程从控制终端读到此字符时才产生。此字符在处理后即 被丢弃（即不传送给读进程）。

EOF    文件结束符。以规范模式（ICANON）进行输入时识别此字符。当键入此字符时，

等待被读的所有字节都被立即传送给谏进程。如果没有字节等待读，则返回0。在 行首输入一个EOF字符是向程序指示文件结束的正常方式。此字符在规范模式下 处理后即被丢弃（即不传递给读进程）。

EOL    附加的行定界符，与NL作用相同。以规范模式（ICANON）进行输入时识别此字

符，并将此字符返回给读进程。但是此字符不常用。

EOL2    另一个行定界符，与NL作用相同。对此字符的处理方式与EOL字符相同。

ERASE    向前擦除字符（退格）。以规范模式（ICANON）输入时识别此字符。它擦除行中的

前一个字符，但不会超越行首字符擦除上一行中的字符。此字符在规范模式下处理 后即被丢弃（即不传送给读进程）=    ®

| ERASE2INTR | 供替换的向前擦除字符（退格对此字符的处理与向前擦陵字符（ERASE）完全相同。 中断字符。若已设置ISIG标志，则在输入中识别此字符。它产生SIGINT信号， |
| ---------- | ------------------------------------------------------------ |
| KILL       | 孩信号被送至前台进程组中的所有进程（见图9-7）。此字符在处理后即被丢弃（即 不传送给读进程）。杀死字符。（名字“杀死”在这里又一次被误用，kill函数是用来将某一信号发 |
| LNEXT      | 送给进程的，而此字符应被称为行擦除符，它与信号亳无关系。）以规范模式 （ICANON）输入时识别此字符。它擦除一整行，并在处理后即被丢弃（即不传送 给读进程）。下一个字符的字面值（literal-next character）□以扩充方式（IEXTEN）输入时识别 |
| NL         | 此字符，它使下一个字符的任何特殊含意都被忽略。这对本节提及的所有特殊字符 都起作用。使用这一字符可向程序键入任何字符。LNEXT字符在处理后即被丢弃， 但输入的下一个字符被传送给读进程。换行字符，也被称为行定界符。不能更改此字符。以规范模式（ICANON）输入时 |
| QUIT       | 识别此字符。此字符返回给读进程。退出字符。若已设置ISIG标志，则在输入中识别此字符。它产生SIGQUIT信号， 该信号又被送至前台进程组中的所有进程（见图9-7）。此字符在处理后即被丢弃 |
| REPRINT    | （即不传送给读进程）。回忆图10-b INTR和QUIT的区别是：QUIT字符不仅按默认规则终止进程，而且 还产生一个core文件。再打印字符。以扩充规范模式（设置了 IEXTEN和工CANON标志）进行输入时识别此 |
| START      | 字符。它使所有未读的输入被输出（再回显）。此字符在处理后即被丢弃（即不传 送给读进程）。启动字符。若已设置IXON标志，则在输入中识别此字符。若己设置IXOFF标志， |
| 圆STATUS   | 则自动产生此字符作为输出。已设置IXON时，接收到的START字符使停止的输 出（由以前输入的STOP字符造成）重新启动。在此情形下，此字符在处理后即被 丢弃（即不传送给读进程）。已设置IXOFF标志时，若新的输入不会使输入缓冲区溢出，则终端驱动程序自动 产生一个START字符来恢复以前被停止的输入。BSD的状态请求字符。以扩充规范模式（设置了工EXTEN和工CANON标志）进行输入 |
| STOP       | 时识别此字符。它产生SIGINFO信号，孩信号又被送至前台进程组中的所有进程 （见图9-7）。另外，如果没有设置NOKERNINFO标志，则有关前台进程组的状态信 息也显示在终端上。此字符在处理后即被丢弃（即不传送给读进程）。停止字符。若已设置IXON标志，则在输入中识别此字符。若己设置IXOFF标志， 则自动产生此字符作为输出，已设置IXON时，接收到STOP字符则停止输出。在 此情形下，此字符在处理后即被丢弃（即不传送给读进程）。当输入一个START字 |
| SUSP       | 符后，被停止的输出重新启动。已设置IXOFF时，终端驱动程序自动产生一个STOP字符以防止输入缓冲区溢出。 挂起作业控制字符。若支持作业控制并且已设置ISIG标志，则在输入中识别此字 符。它产生SIGTSTP信号，该信号又被送至前台进程组的所有进程（见图9-7）。此 字符在处理后即被丢弃（即不传送给读进程）。 |

WERASE 字擦除字符。以扩充规范模式（设置了 IEXTEN和ICANON标志）进行输入时识别 此字符。它使前一个字被擦除。首先，它向前尚过任意一个空白字符（空格或制表 符），然后再向前跃过前一记号，使光标处在前一个记号的第一个字符位置上。通 常，前一个记号在碰到一个空白字符时即终止。但是，可通过设置ALTWERASE标 志来改变这个行为。此标志使前一个记号在碰到第一个非字母、非数字字符时即终 止。此字符在处理后即被丢弃（即不传送给读进程），

需要为终端设备定义的另一个“字符”是BREAK字符。BREAK实际上并不是一个字符，

而是在异步串行数据传送时发生的一个条件。根据串行接口的不同，可以有多种方式通知设备驱 动程序发生了 BREAK条件。

大多数早期的串行终端都有一个标记为BREAK的键，用其可以产生BREAK条件，这就是 1为什么大多数人认为BREAK就是一个字符的原因。某些较新的终端键盘没有BREAK键。在PC 1上，BREAK键可能有其他用途。例如，键入Ctrl+BREAK可中断Windows命令解释器。

对于异步串行数据侍送，BREAK是一个0值的位序列’其持续时间长于要求发送一字节的时间。

整个0值位序列被视为是一个BREAK。18.8节将说明如何用tcsendbreak函数发送一个BREAK。

画

18.4获得和设量终端属性

为了获得和没置termios结构，可以调用tcgetattr和tcsetattr函数。这样就可以 检测和修改各种终端选项标志和特殊字符，使终端按我们所希望的方式进行操作。

♦include <termios.h>

int tcgetattr{int fd, struct termios *termptr);

int tcsetattr(int fd, int opt, const struct termios *termptr);

两个函数的返回值：若成功，返回0:若出错，返回-1

这两个函数都有一个指向termios结钩的指针作为其参数，它们或者返回当前终端的属性， 或者设置该终端的属性。因为这两个函数只对终端设备进行操作，所以若和没有引用终端设备则 出错返回-1，errno设置为ENOTTY。

tcsetattr的参数使我们可以指定在什么时候新的终端属性才起作用。叩/可以指定为 下列常量中的一个。

TCSANOW    更改立即发生。

TCSADRAIN发送了所有输出后更改才发生。若更改输出参数则应使用此选项。

TCSAFLUSH发送了所有输出后更改才发生。更进一步，在更改发生时未读的所有输入数 据都被丢弃（冲洗乂

Tcsetattr函数的返回状态在使用时易产生混淆。如果它执行了任意一种所要求的动作， 即使未能执行所有要求的动作，它也返回OK （表示成功）》如果该函数返回OK，则我们有责任 检查该函数是否执行了所有要求的动作。这就意味着，在调用tcsetattr设置所希望的属性后， 需调用tcgetattr,然后将实际终端属性与所希望的属性相比较，以检测两者是否有区别。

在终端第一次被打开时，其属性视具体情况而定。一些系统可能会将终端属性初始化为具体 实现所定义的值，另一些系统可能会保留并使用最后一次使用终端时的属性值。通过打开一个带

有O_TTY_INIT标志（见3.3节）的驱动设备，可以确认终端的行为是否遵循标准，这样就能在 调用tcgetattr时，确保初始化termios结构中的任何非标推部分，使得在修改属性和调用 tcgetattr时，终端的表现符合预期。

18.5结端选项标志

本节将列出所有不同的终端选项标志，扩展图18-3至图18-6中的说明。我们将按字母顺序列 出各个选项并指出每个选项出现在4个终端标志字段中的哪一个。（从选项名字中看不出它所处的

[6831字段。）还将说明每个选项是否是Single UNIX Specification定义的，并列出了支持该选项的平台。

列出的所有选项标志（除所谓的屏蔽字标志外）都用一位或多位（设置或清除）表示。屏蔽

字标志定义多个位，它们组合在一起，可以定义一组值。屏蔽字标志有一个定义名，每个值也有 一个名字。例如，为了设置字符长度，首先用字符长度屏蔽字标志CSIZE将表示字符长度的位 清0，然后设置下列值之一：CS5、CS6、CS7或CS8。

由Linux和Solaris支持的6个延迟值也有屏蔽字标志：BSDLY、CRDLY、FFDLY、NLDLY、 TABDLY和VTDLY。对于每个延迟值的长:度请参阅Solaris中的termio （71）手册页。在所有情况 下，延迟屏蔽字为0就表示没有延迟。如果指定了延迟，则由OFILL和OFDEL标志决定是由驱 动器进行实际延迟还是只传输填充字符。

■实例

图18-11演示了如何使用这些屏蔽字标志取一个值或者设置一个值。

♦include "apue.h"

\#include <termios.h>

int

main (void)

struct termios term;

if (tcgetattr(STDIN_FILENO, &term) < 0) err_sys("tcgetattr error");

switch (term.c_cflag & CSIZE) { case CS5:

printf ("5 bits/byte\n"); break;

case CS6:

printf("6 bits/byte\n")； break;

case CS7:

printf("7 bits/byte\n"); break;

case CS8:

printf("8 bits/byte\n"); break；

default:

printf("unknown bits/byte\n");

term.c_cflag &= -CSIZE;    /* zero out the bits */

term.c_cflag I= CS8;    /* set 8 bits/byte */

if (tcsetattr(STDIN_FILENO, TCSANOW, &term) < 0)

err_sys("tcsetattr error");

exit(0);

图 18-11 tcgetattr 和 tcsetattr 实例

下面说明各选项标志。



ALTWERASE



BRKINT



BSDLY

CBAUDEXT

CCAR_OFLOW

CCTS_OFLOW

CDSR_OFLOW

CDTR_IFLOW

C工BAUDEXT

CIGNORE CLOCAL

CMSPAR



(c_lflag，FreeBSD、Mac OS X)已设置此标志时，若输入WERASE字符， 则使用一个替换的字擦除算法。它不是向前移动到前一个空白字符为止，而是 向前移动到第一个非字母、非数字字符为止。

(c_iflag，POSIX.l、FreeBSD、Linux-. MacOSX、Solaris)若已设置此标志， 而未设置IGNBRK，则在接到BREAK时，冲洗输入、输出队列，并产生一个 SIGINT信号D如果此终端设备是一个控制终端，则此信号就是为前台进程组 产生的。

若未设置IGNBRK和BRKINT，但是设置了 PARMRK,则BREAK被读作一个 3字节序列\377、\0和\0:若也未设置PARMRK,则BREAK被读作单个字 符\0。

(c_oflag，XSI、Linux, Solaris)退格延迟屏蔽字。此屏栽字的值是BS0或BS1。 (c_cflag，Solaris)扩充的波特率。用于允许大于B38400的波特率。(将在 18.7节讨论波特率3

(c_cf lag，FreeBSD、Mac OS X)使用 RS-232 调制解调器 DCD (Data-Camer-Detect,数据载波检测)信号打开输出的硬件流控制。这与早期的MDMBUF标志 相同。

(c_cflag» FreeBSD、Mac OS X> Solaris)使用 RS-232CTS (Clear-To-Send» 清除发送)信号打开输出的硬件流接制，

(c_cflag, FreeBSD、Mac OS X)根据 RS-232 DSR (Data-Set-Ready，数据准 备就绪)信号进行输出的流控制。

(c_cflag，FreeBSD, Mac OS X)根据 RS-232 DTR (Data-Terminal-Ready, 数据终端就绪)信号进行输入的流控制。

(c_cflag, Solaris)扩充的输入波特率。用于允许大于B38400的输入波特率。 (将在18.7节讨论波特率。)

(c_cflag，FreeBSD- Mac OS X)忽略控制标志》

(c_cflag, POSIX.l、FreeBSD、Linux、Mac OS X、Solaris)若设置，则忽 略调制解调器状态线。这通常意味着该设备是直接连接的。例如，若未设置 此标志，则打开一个终端设备常常会遭遇阻塞，直到调制解调器回应呼叫并 建立连接。

(c_oflag( Linux)选择标记或空奇偶校验。若已设置PARODD,则奇偶校验 位总是1 (标记奇偶校验)。否则奇偶校验位总是0 (空奇偶校验)。

CRDLY

函

CREAD

CRTSCTS

CRTS_IFLOW

CRTSXOFF

CSIZE

CSTOPB

ECHO

ECHOCTL



ECHOE



ECHOK



(c^oflag, XSI、Linux、Solaris)回车延迟屏蔽字。此屏蔌字的可能值是CRO、 CR1、CR2 和 CR3。

(c.cflag, POSIX.1、FreeBSD、Linux、Mac OS X, Solaris)若设置，则接收 者被启用，可以接收字符，

Cc_cflag, FreeBSD、Linux、Mac OS X、Solaris)其行为依赖于平台。对于 Solaris,若设置该标志，则允许带外硬件流控制。在另外3个平台上，则既允 许带内硬件流控制，又允许带外硬件流控制(等价于CCTS_OFLOW | CRTS^ I FLOW )。

(c_cflag, FreeBSD、MacOSX、Solaris)输入的 RTS (Request-To~Send，请 求发送)流控制。

(c_cflag，Solaris)若设置，则允许带内硬件流控制，RS-232 RTS信号的状态 控制了流控制。

(c_cflag, POSIX.U FreeBSD、Linux、Mac OS X、Solaris)此字段是一个屏 蔽字标志，它指定发送和接收的每个字节的位数。此长度不包括可能有的奇偶 校验位。由此屏蔽字定义的字段值是CS5、CS6、CS7和CS8,分别表示每个 字节包含5位、6位、7位和8位。

(c.cflag, POSIX.1、FreeBSD、Linux、MacOSX、Solaris)若设置，则使用 两个停止位，否则只使用一个停止位。

(c_lflag，POSIX.U FreeBSD、Linux、Mac OS X、Solaris)若设置，则将输 入字符回显到终端设备。在规范模式和非规范模式下都可以回显输入字符。 (c_lflag. FreeBSD、Linux、Mac OS X、Solaris)若设置并且也设置ECHO， 则除ASCn TAB、ASCII NL以及START和STOP字符外，其他ASCII控制字 符(ASCII字符集中0至八进制37对应的字符)都被回显为其中，Y是相 应控制字符加上八进制100所构成的字符。例如，ASCnCtrl+A字符(八进制1) 被回显为AA。ASCH DELETE字符(八进制177)则回显为若未设置此标 志，则ASCII控制字符按其原样回显》如同ECHO标志，在规范模式和非规范 模式下，此标志对控制字符回显都起作用。

应当了解的是，某些系统以不同方式回显EOF字符，因为EOF的典型值是Ctrl+D (而Ctrl+D是ASCIIEOT字符，它可能使某些终端挂断)。请查看有关手册。 (c_lflag，POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)若设置并且也设 置ICANON,则ERASE字符从显示中擦除当前行中的最后一个字符。这通常是 在终端驱动程序中写一个3字符序列实现的，该序列是：退格、空格、退格。 若支持WERASE字符，则ECH0E用一个或若干个上述3字符序列擦除前一个字。 若支持ECH0PRT标志，则这里说明的关于ECHOE的动作是在假定未设置 ECH0PRT标志的条件下得出的。

(c_lflag» POSIX.l、FreeBSD- Linux、Mac OS X- Solaris)若设置并且也设 置ICANON,则KILL字符从显示中擦除当前行，或者输出NL字符(用以强调 已擦除整个行)。

若支持ECH0KE标志，则关于ECH0K的说明是在假定未设置ECH0KE标志的条 件下得出的。

ECHOKE

ECHONL

ECHOPRT

EXTPROC

FFDLY

FLUSHO

HUPCL

工CANON

ICRNL

IEXTEN

IGNBRK

IGNCR

I GN PAR

IMAXBEL

INLCR



(c_lflag, FreeBSD、Linux、Mac OS X、Solaris)若设置并且也设置 ICANON,

则回显KILL字符的方式是擦除行中的每一个字符。擦除每个字符的方法则由 ECHOE和ECHOPRT标志选择。

(c_lflag, POSEX.U FreeBSD、Linux、Mac OS X> Solaris)若设置并且也设 置ICANON,即使没有设置ECHO,也回显NL字符。

(c_lflag，FreeBSD、Linux> Mac OS X、Solaris)若设置并且也设置 ICANON 和ECHO,则ERASE字符(以及WERASE字符，若受到支持)使所有正被擦 除的字符按它们被擦除的方式被打印。这一方法常在硬拷贝终端上显示其作用，

它可以使我们确切地看到哪些字符正被刪除。

(c_lflag, FreeBSD、Linux、Mac OS X)若设置，规范字符处理在操作系统 之外执行。如果串行通信外设卡能够通过执行某些行规程处理减轻主机处理器 负载，那么就可以这样设置。在使用伪终端时(见第19章)，也可以这样设置。 (c_oflag, XSI、Linux、Solaris)换页延迟屏蔽字。此屏蔽字标志值是FF0或FF1。 (c_lflag，FreeBSD、Linux, Mac OS X、Solaris)若设置，则冲洗输出。当 键入DISCARD字符时设置此标志。当键入另一个DISCARD字符时，此标志 被清除。可以通过设置或清除此终端标志来设置或清除此条件。

(c_cflag，POSIX.1、FreeBSD, Linux、MacOSX、Solaris)若设置，则当最 后一个进程关闭设备时，调制解调器控制线降至低电平(也就是调制解调器的 连接断开)。

(c.lflag, POSIX.K FreeBSD、Linux、MacOSX、Solaris)若设置，则按规 粗模式工作(见18.10节)。这使下列字符起作用：EOF、EOL、EOL2、ERASE、

KILL、REPRINT、STATUS 和 WERASE。输入字符被装配成行。    [687]

如果不以规范模式工作，则读请求直接从输入队列取字符。在至少接到MIN个字 节或两个字节之间的超时值TIME到期时，read才返回。详细情况参见18.11节。 (c_iflag, POSIX.1、FreeBSD、Linux、MacOSX、Solaris)若设置并且未设 置IGNCR,则将接收到的CR字符转换成NL字符。

(c_lflag, POSIX.l、FreeBSD、Linux、Mac OS X、Solaris)若设置，则识别 并处理扩展的、由实现定义的特殊字符。

(c_iflag, POSDL1、FreeBSD、Linux、Mac OS X、Solaris)在已设置时，忽 略输入中的BREAK条件。关于BREAK条件是产生SIGINT信号还是被作为 数据读取，见BRKINT。

Cc_iflag, POSIX.l、FreeBSD、Linux、Mac OS Solaris)若设置，则忽略 接收到的CR字符。若未设置此标志，而设置了 ICRNL标志，则有可能将接收 到的CR字符转换成NL字符，

(c^iflag, POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)在已设置时，忽 略带有结构出错(非BREAK)或奇偶出错的输入字节。

(c^iflag, FreeBSD a Linux、Mac OS X, Solaris)当输入队列满时响铃。

(c_iflag, POSIX.1、FreeBSD. Linux、MacOSX、Solaris)若设置，则将接 收到的NL字符转换成CR字符。

| INPCK                | (c_iflag, POSIX.l、FreeBSD、Linux、Mac OS X、Solaris)在己设置时，使 输入奇偶校验起作用。若未设置INPCK,则使输入奇偶校验不起作用。奇偶“产生和检测”和“输入奇偶校验”是两件不同的事。奇偶位的产生和检 测是由PARENB标志控制的。设置该标志后通常会使串行接口的设备驱动程序 对输出字符产生奇偶位，对输入字符则验证其奇偶性。PARODD标志决定该奇 偶性应当是奇还是偶。如果一个其奇偶性错误的输入字符到来，则检査INPCK 标志的状态。若已设置此标志，则检査IGNPAR标志(以决定是否应忽略带奇 偶出错的输入字节)；若不应忽略此输入字节，则检査PARMRK标志以决定应该 向读进程传送哪些字符。 |
| -------------------- | ------------------------------------------------------------ |
| ISIG                 | (c_lflag, POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)若设置，则判别 输入字符是否是要产生终端信号的特殊字符(INTR、QUIT. SUSP和DSUSP); 若是，则产生相应信号。 |
| ISTRIP               | (c_iflag, POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)在已设置此标志 时，有效输入字节被剥离为7位，在未设置时，则处理全部8位。 |
| \|688\| IUCLC工 UTF8 | (c_iflag，Linux、Solaris)将输入的大写字符转换成小写字符。(c_iflag, Linux、Mac OS X)允许使用UTF-8多字节字符进行字符擦除处理。 |
| IXANY                | (c_iflag, XSk FreeBSD、Linux、Mac OS X、Solaris)使任何字符都能重新 启动输出。 |
| IXOFF                | (c_iflag, POSIX.K FreeBSD、Linux、Mac OS X, Solaris)若设置，则使启 动-停止输入控制起作用。当终端驱动程序发现输入队列将要填满时，输出一个 STOP字符。此字符应当由发送数据的设备识别，并使该设备停止。此后，当把 输入队列中的字符处理完毕之后，终端驱动程序将输出一个START字符，使该 设备恢复发送数据。 |
| IXON                 | (c_iflag，POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)若设置，则使启 动-停止输出控制起作用。当终端驱动程序接收到一个STOP字符时，输出停止。 在输出停止时，下一个START字符恢复输出。若未设置此标志，则START和 STOP字符由进程作为一般字符谪取。 |
| MDMBUF               | (c_cflag，FreeBSD、Mac OS X)按照调制解调器的载波标志进行输出流控制。 这是CCAR_OFLOW标志的曾用名。 |
| NLDLY                | (c_oflag，XSK Linux、Solaris)换行延迟屏蔽字。此屏蔽字的值是NL0或NL1。 |
| NOFLSH               | (c_lflag, POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)按系统默认，当 终端驱动程序产生SIGINT和SIGQUIT信号时，输入和输出队列都被冲洗。 另外，当它产生SIGSUSP信号时，输入队列被冲洗。若已设置NOFLSH标志，则在这些信号产生时，不对输入、输出队列进行常规冲侁。 |
| NOKERNXNFO           | (c_lflag, FreeBSD、Mac OS X)在已设置时，此标志阻止STATUS字符打印 前台进程组的信息。但是无论是否设置此标志，STATUS字符都会使SIGINFO 信号被发送至前台进程组。 |
| OCRNL                | (c_oflag，XSI、FreeBSD, Linux、Solaris)若设置，则将输出的 CR 字符转 换成NL字符。 |

OFDEL

OFILL

OLCUC

NLCR

ONLRET

ONOCR

ONOEOT

OPOST

OXTABS

PARENB

PAREXT

PARMRK

PARODD

PENDIN

TABDLY



(c_oflag，XSI、Linux. Solaris)若设置，则输出填充字符是ASCII DEL:否 则是ASCUNUL。见OFILL标志。

(c_oflag, XSI、Linux、Solaris)若设置，则传递填充字符(ASCII DEL 或 ASCn NUL,见OFDEL标志)以实现延迟，而不使用时间延迟。见6个延迟屏 蔽字标志：BSDLY、CRDLY、FFDLY、NLDLY、TABDLY 和 VTDLY。

(c_oflag, Linux、Solaris)若设置，则将小写字符转换成大写字符。    [689)

(c_oflag，XSI、FreeBSD、Linux、Mac OS X、Solaris)若设置，将输出的 NL字符转换成CR-NL字符。

(c_oflag，XSI、FreeBSD、Linux、Solaris)若设置，则假定输出的 NL 字符 执行回车功能。

(c^oflag, XSI、FreeBSD、Linux、Solaris)若设置，则在 0 列不输出 CR字符。 (c_oflag, FreeBSD、Mac OS X)若设置，则在输出中丢弃EOT (AD)字符。

在某些将Ctrl+D解释为挂断的终端上，设置此标志可能是必需的。

(c_oflag，POSIX.1、FreeBSD、Linux, Mac OS X、Solaris)若设置，则进行 实现定义的输出处理。关于c_of lag字段的各种实现定义标志，见图18-6。 (c_oflag, FreeBSD, Mac OS X)若设置，则制表符在输出中被扩展为空格。

这与将水平制表符延迟(TABDLY)设置为XTABS或TAB3所产生的效果相同。 (c^cflag, POSIX.1、FreeBSD、Linux、Mac OS X、Solaris)若设置，则对输出 字符产生奇偶位，对输入字符执行奇偶校验。若已设置PARODD，则奇偶校验是 奇校验；否则是偶校验。另见对INPCK、IGNPAR和PARMRK标志的讨论。

(c_cflag，Solaris)选择标记或空奇偶性。若PARODD设置，则奇偶位总是1 (标记奇偶性)：否则，奇偶位总是0 (空奇偶性)。

(c_iflag，POSIX.l、FreeBSD、Linux、Mac OS X、Solaris)在已设置时，

若未设置IGNPAR，则带有结构出错(非BREAK)的字节或带有奇偶出错的 字节将被进程读作一个3字符序列\377、\0和X其中X是接收到的出错字 节。若未设置ISTRIP，则一个有效的\377被传送给进程时为\377, \377。

若未设置IGNPAR和PARMRK，则带有结构出错误或奇偶出错的字节都被读作 一个字符\0。

(c_cflag, POSK.1、FreeBSD、Linux、Mac OS X. Solaris)若设置，则输出 和输入字符的奇偶性都是奇，否则为偶。注意，PARENB标志控制奇偶性的产 生和检测。

在已设置CMSPAR或PAREXT标志时，PARODD标志也控制是否使用标记或空 奇偶性。

(c_lflag, FreeBSD、Linux、Mac OS X、Solaris)若设置，则在下一个字符 输入时，尚未读的任何输入都由系统重新打印。这一动作与键入REPRINT字符 时的作用相类似。    ®

(c_oflag，XSL Linux> Mac OS X、Solaris)水平制表符延迟屏蔽字。此屏厳 字的值是 TABO、TAB1、TAB2 或 TAB3。

XTABS的值等于TAB3。此值使系统将制表符扩展成空格。系统假定制表符的 长度为8个空格，不能更改此假定。

TOSTOP    (c_lflag, POSIX.K FreeBSD、Linux、Mac OS X, Solaris)若设置，并且该

实现支持作业控制，则将信号SIGTTOU送到试图写控制终端的一个后台进程的 进程组。按默认，此信号暂停该进程组中所有进程。如果写控制终端的后台进 程忽略或阻塞此信号，则终端驱动程序不产生此信号。

VTDLY    (c_oflag, XSI、Linux, Solaris)垂直制表延迟屏蔽字此屏蔽字的值是VT0

和 VT1。

XCASE    (c_lflag，Linux、Solaris)若设置，并且也设置工CANON,则终端被假定为只

支持大写字符，全部输入转换为小写字符。要想输入一个大写字符，要在其前 面加一个反斜杠。与之类似，系统输出大写字符时，也要在其前面加一个反斜 杠。(如今这个选项标志已奔用，因为只支持大写字符的终端即使不是全部，也 是绝大部分都已经不存在了



##### 18.6 stty 命令

上节说明的所有选项都可以被检査和更改：在程序中用tcgetattr和tcsetattr函数 (见18.4节)进行检査和更改：在命令行(或shell脚本〉中用stty(l>命令进行检査和更改。简 单地说，stty⑴命令就是图18-7中所列的前6个函数的接口。如果以-a选项执行此命令，则显 示终端的所有选项：

$ stty

speed 9600 baud; 25 rows; 80 columns;

Iflags: icanon isig iexten echo echoe -echok echoke -echonl echoctl

-echoprt -altwerase -noflsh -tostop -flusho pendin -nokerninfo -extproc

iflags: -istrip icrnl -inlcr -igncr ixon -ixoff ixany imaxbel -ignbrk brkint -inpck -ignpar -parmrk

oflags: opost onlcr -ocrnl -oxtabs -onocr -onlret

cflags: cread cs8 -parenb -parodd hupcl -clocal -cstopb -crtscts

-dscflow -dtrflow -mdmbuf

cchars: discard = A0; dsusp = eof = AD; eol = <undef>;

eol2 = <undef>; erase = AH; erase2 = A?; intr = AC; kill = AU; lnext = AV; min = 1; quit = A; reprint = AR; start = AQ; status = AT； stop = AS; susp = AZ; time = 0; werase = ^W;

若在选项名前有一个连字符，表示该选项禁用。最后4行显示各终端特殊字符(见18.3节) 的当前设置。第1行显示当前终端窗口的行数和列数，18.12节将对终端窗口大小进行讨论。

; stty命令使用它的标准输入获得和设置终搞的选项标志。虽然，某些较早的实现使用标准输 1出，但POSIX.1要求使用标准输入=本书讨论的4种实现提供了在标准输入上操作的stty版本。

这意味着如果希望了解名为ttyla的终端的设置，那么可以键入 ;■ stty -a </dev/ttyla

18.7波特率函数

术语波特率(baudrate)是一个历史沿用的术语，现在它指的是“位/秒” (bit per second).虽然大

多数终端设备对输入和输出使用同一波特率，但是只要硬件许可，可以将它们设置为两个不同值。 ^include <termios.h>

speed_t cfgetispeed(const struct termios *termptr); speed_t cfgetospeed (const struct termios *termptr}；

两个函数的返回值：波特率值

int cfsetispeed (struct termios *termptr, speed_t speed}; int cfsetospeed (struct termios *termptr, speed_t speed)；

两个函数的返回值：若成功，返回0:出错，返回-1

两个cfget函数的返回值，以及两个cf set函数的平6«/参数都是下列常量之一，B50、 B75、 B110、 B134、 B150、 B200、 B300、 B600、 B1200、 B1800、 B2400、 B4800、 B9600、 B19200或B38400。常量B0表示“挂断' 在调用tcsetattr时，如若将输出波特率指定为 B0,则调制解调器的控制线就不再起作用。

大多数系统定义了另外的波特率值，如B57600以及B115250。

使用这些函数时，必须认识到输入、输出波特率是存储在设备的termios结构中的，如图184 所示。在调用两个cfget函数中的任意一个之前，要先用tcgetattr获得设备的termios结 构。与此类似，在调用两个cfset函数中的任意一个之后，要做的就是在termios结构中设置 波特率。为使这种更改影响到设备，应当调用tcsetattr函数。即使所设置的两个波特率中的 任意•-个出错，在调用tcsetattr之前可能也不会发现这个错误。

这4个波特率函数的存在使应用程序不必考虑具体实现在termios结构中表示波特率的不同 方法。Linux和BSD派生的平台趋向于存储波特率的数值。（即9 600波特率存储成值9 600）,然 而，System V派生的平台（如Solaris）趋向于以位屏蔽方式编码波特率。从cfget函数得至！I的速 度值以及向cfset函数传送的速度值都未转换，与它们存储在termios结构中的表示琅式一样。

18.8行控制函数

下列4个函数提供了终端设备的行控制能力。4个函数都要求参数/rf引用一个终端设备，否 则出错返回-1，errno设置为ENOTTY。

^include <termios.h>

int tcdrain （int fd};

int tcflow{int fd, int action）;

int tcflush （int fd, int queue）;

int tcsendbreak {int fd, int duration）；

4个函数的返回值：若成功，返回0:若出错.返回-1 tcdrain函数等待所有输出都被传递。tcflow函数用于对输入和输出流控制进行控制。 action参数必定是下列4个值之一。

TCOOFF    输出被挂起。

TCOON    重新启动以前被挂起的输出。

TCIOFF    系统发送一个STOP字符，这将使终端设备停止发送数据。

TCION    系统发送一个START字符，这将使终端设备恢复发送数据。

tcflush函数冲洗（抛弃）输入缓冲区（其中的数据是终端驱动程序已接收到，但用户程序

尚未读取的）或输出缓冲区（其中的数据是用户程序己经写入，但尚未被传递的）。炉/ewe参数必 定是下列3个常量之一。

TCIFLUSH    冲洗输入队列。

TCOFLUSH    冲洗输出队列。

[6931 TCIOFLUSH    冲洗输入队列和输出队列。

tcsendbreak函数在一个指定的时间匡间内发送连续的0值位流。若duration参数为0,

则此种传递延续0.25〜0.5秒。POSIX.1说明若rfwrorfon非0，则传递时间依赖于实现。

###### 18.9终端标识

历史上，在大多数UNIX系统版本中，控制终端的名字一直是/dev/tty。POSIX.1提供了 一个运行时函数，可用来确定控制终端的名字。

tinclude <stdio.h> char *ctermid（char *ptr）；

返回值：若成功，返回指向控制终竭名的指针；若出错，返回指向空字符串的指针

如果婢非空，则被认为是一个指针，指向长度至少为L.ctermid字节的数组，进程的控 制终端名存储在该数组中。常量L_ctermid被定义在<31;也0.11>中。若p/r是一个空指针，则 该函数为数组（通常作为静态变量）分配空间。同样，进程的控制终端名存储在该数组中。

在这两种情况中，该数组的起始地址都被作为函数值返回，因为大多数UNIX系统都使用 /dev/tty作为控制终端名，所以此函数的主要作用是改善向其他操作系统的可移植性。

『 当调用ctermid函數时，本书说明的所有4种平台都送回字符串/dev/tty。

醐实例：cfcermid函数

图18-12给出的是POSIX.1 ctermid函数的一个实现。

\#include    <stdio.h>

linclude    <string.h>

static char ctermid_name[L_ctermid];

char *

ctermid{char *str)

{

if (str == NULL)

str = ctermid_name;

return(strcpy{str, "/dev/tty"));    /* atrcpy() returns str */

务

个终端设备，则isatty返回真，ttyname返回的是在该文件描述符上打开的终端设备的路径名。

| ♦include <unistd.h>     |                                 |                  |
| ----------------------- | ------------------------------- | ---------------- |
| int isatty (int fd};    | 返回值：若为终端设备，返回1 (真 | 否则，返回0 (假) |
| char *ttyname (int fd}; | 返回值：指向终端路径名的指针:   | 若出错，返回NULL |

醒实例：isatty函数

如图18-13所示，isatty函数很容易实现。我们只尝试使用了其中一个终端专用函数(如 果成功执行，它不改变任何东西)，并査看了其返回值-#include    <termios.h>

int

isatty{int fd)

(

struct termios ts;

return(tcgetattr(fd, &ts) != -1); /* true if no error (is a tty) */ j

图18-13 POSIX.1 isatty函数的实现 使用图18-14中的程序测试isatty函数。

\#include "apue.h"

int

main(voidj

| printf( | 'fd  | 0:   | %s\n" | isatty(0) |      | "tty" | "not | a tty");   |
| ------- | ---- | ---- | ----- | --------- | ---- | ----- | ---- | ---------- |
| printf( | fd   | 1:   | %s\n" | isatty(1) |      | "tty" | "not | a tty");   |
| printf( | •fd  | 2:   | %s\n" | isatty(2) |      | "tty" | "not | a tty'，}; |
| exit(0) |      |      |       |           |      |       |      |            |

图 18-14 测试 isatty 函数    |695|

运行图18-14中的程序，得到如下输出：

5 ./a.out

fd 0: tty fd 1: tty fd 2: tty

S ./a.out </atc/passwd 2>/dav/null

fd 0: not a tty fd 1： tty

fd 2: not a tty    ■

M实例：ttynaae垂数

ttyname函数(见图18-15)比较长，因为它要搜索所有设备表项，寻找匹配项。

♦include #include #include ♦include ^include #include tinclude



<sys/stat.h>

<dirent.h>

〈limits.h>

<string.h>

<termios.h>

<unistd.h>

<stdlib.h>

struct devdir {

struct devdir char

*d__next;

*d_name;



static struct devdir static struct devdir static char



★head;

•tail;

pathname [_POSIX_PATH_MAX + 1];



static void

add(char * di rname)

{

struct devdir    *ddp;

int    len;



len = strlen(dirname);

/*

\* Skip ., ", and /dev/fd.

*/

if ((dirname [len-1] == *.') && (dirname【len-2] == *" I I (dirname[len-2] == *.* && dirname[len-3] = '/')))

return;

if (strcmp(dirname, "/dev/fd") == 0) return;

if ({ddp = malloc{sizeof{struct devdir))I == NULL) return;

if ((ddp->d_name = strdup(dirname)) == NULL) { free(ddp); return;



ddp->d_next = NULL; if (tail 坊 NULL) { head = ddp; tail = ddp;

} else {

tail->d_next = ddp; tail = ddp;

)

}

static void

cleanup(void)

{



struct devdir



★ddp, *nddp;



ddp = head;

while (ddp != NULL) 1 nddp = ddp->d_next; free{ddp->d_name); free(ddp);

ddp = nddp;

}

head = NULL;

tail = NULL;

static char *

searchdir (char *d.irname, struct stat *fdstatp)

struct stat

devstat;

*dp;

devlen;

*dirp;



DIR

int

struct dirent strcpy{pathname, dirname)；

if ((dp = opendir(dirname)) == NULL) return(NULL);

strcat {pathname, ••/"};

devlen = strlen(pathname);

while {(dirp = readdir(dp)) != NULL) {

strncpy(pathname + devlen, dirp->d_name,

_POSIX_PATH_MAX - devlen);

\* Skip aliases.

*/

if (strcmp(pathname, "/dev/stdin") == 0 I I strcmp(pathname, "/dev/stdout") == 0 I I strcmp(pathname, "Zdev/stderr") == 0)

continue;

if (stat(pathname, &devstat) < 0J continue;

if (S_ISDIR(devstat.st_mode,) { add(pathname); continue;

}

if (devstat.st_ino = fdstatp->st_ino && devstat.st_dev == fdstatp->st_dev) (    /* found a match */

closedir(dp); return{pathname);

)

}

closedir(dp); return{NULL);

char *

ttyname{int fd)

struct stat    fdstat?

struct devdir    *ddp;

char    *rval;

if (isatty(fd) == 0) return(NULL);

if (fstat(fd, &fdstat) < 0) return(NULL);

if (S_ISCHR(fdstat.st_mode) == 0) return(NULL);

rval = searchdir("/dev", Sfdstat); if (rval == NULL) {

for (ddp = head； ddp != NULL; ddp = ddp->d_next)

if ((rval = searchdir(ddp->d_name, &fdstat))    != NULL)

break;

}

cleanup (); return(rval);

}

图 18-15 POSIX.l ttyname 函数的实现

此处使用的技术是读/dev目录，寻找具有相同设备号和i节点编号的表项。回忆4.24节， 每个文件系统都有一个唯一的设备号（stat结构中的st_dev字段，见4.2节），文件系统 中的每个目录项都有一个唯一的i节点编号（stat结构中的st_ino字段）。在此函数中，

[698]假定在找到一个匹配的设备号和匹配的i节点号时，就能找到所希望的目录项。也能验证这两 个表项与st_rdev字段（终端设备的主设备号和次设备号）相匹配，还能验证该目录项是一 个字符特殊文件。但是，因为已经验证了文件描述符参数既是一个终端设备，又是一个字符 特殊文件，而且因为在UNIX系统中，匹配的设备号和i节点编号是唯一的，所以不再需要进 行另外的比较。

终端名可能在/dev的子目录中。于是，需要搜索/dev下的整个文件系统树。我们跳过了少 数几个可能会产生不正确结果或奇怪结果的目录：/dev/.、/dev/..和/dev/fd。我们也跳过 了一些另ij名：/dev/stdin、/dev/stdout 以及/dev/stderr，因为它们是/dev/fd 目录中 文件的符号链接。

使用图18-16中的程序测试这一实现。

^include "apue.h"

int

main(void)

char *name; if (isatty(O)) {

name = ttyname(0); if (name == NULL)

name = "undefined";

J else {

name



"not a tty";



printf ("fd 0: %s\n", name"

if (isatty⑴){

name = ttyname(1); if (name == NULL)

name = "undefined";

} else {

name = "not a tty";

I

printf{"fd 1: %s\n", name);

if (isatty(2)) {

name = ttyname(2); if (name == NULL)

name - "undefined";

)else (

name = "not a tty"；

}

printf("fd 2： %s\n", name);

exit(0,;

图 18-16 测试 ttyname 函数    j699|

运行图18-16中的程序，得到：

$ ./a.out < /dev/console 2> /dov/null

fd 0: /dev/console fd 1: /dev/ttys001

fd 2: not a tty    ■

###### 18.10规箔模式

规范模式很简单：发一个读请求，当一行已经输入后，终端驱动程序即返回。以下几个条件 造成读返回。

•所请求的字节数已读到时，读返回，无需读一个完整的行。如果读了部分行，那么也不 会丢失任何信息，下一次读从前一次读的停止处开始。

•当读到一个行定界符时，读返回=回忆18.3节，在规范模式中，下列字符被解释为“行 结束”：NL、EOL、EOL2和EOF。另外，在18.5节中也曾说明，如若已设置ICRNL，

但未设置IGNCR,则CR字符的作用与NL字符一样，也终止一行。

在这5个行界定符中，只有一个EOF符在终端驱动程序对其进行处理后即被丢弃。其他 4个字符则作为其所处行的最后一个字符返回给调用者。

•如果捕捉到信号，并且该函数不再自动重启(见10.5节)，则读也返回。

I实例：getpass函数

下面说明getpass函数，它读入用户在终端上键入的口令。此函数由login(l)和crypt(l) 程序调用。为了读取口令，该函数必须关闭回显，但仍可使终端以规范模式进行工作，因为不管 键入什么作为口令都能构成一个完整行。图18-17显示了 UNIX系统中的一个典型实现。

\#include #include #include



<signal.h>

<stdio.h>

<terraios.h>

ttdefine



MAX_PASS_LEN    8



/* max #chars for user to enter */



char *

getpass(const char {

static char

char

sigset_t



struct termios ts, ots; FILE    *fp;

int    c;



★prompt)

buf[MAX_PASS_LEN + 1J; *ptr;

sig, osig;



/* null byte at end */



if ({fp = fopen{ctermid(NULL), "r+")) == NULL) return(NULL);

setbuf(fp, NULL);

sigemptyset(&sig);

sigaddset(ssig, SIGINT); sigaddset <&sig, SIGTSTP); sigprocmask(SIG_BLOCK/ &sig,

tcgetattr(fileno(fp), &ts);



/* block SIGINT */

/* block SIGTSTP */

&osig);    /* and save mask */

/* save tty state */



ots = ts;    /* structure copy */

ts.c_lflag &= -(ECHO | ECHOE | ECHOK | ECHONL); tcsetattr(fileno(fp), TCSAFLUSH, &ts);

fputs(prompt, fp);



ptr = buf;

while ( (c = getc (fp)) ! = EOF &.& c != ' \n') if (ptr < &buf [MAX_PASS_LEN])

*ptr++ = c;

*ptr = 0;    /* null terminate */

putc('\n', fp);    /* we echo a newline */

tcsetattr(fileno(fp), TCSAFLUSH, &ots); /* restore TTY state */ sigprocmask(SIG_SETMASK, &osig, NULL)；    /* restore mask */

fclose (fp)，-    Z* done with /dev/tty */

return(buf)；

图18-17 getpass函数的实现

在此例中，应当考虑以下几个方面。

•调用ctennid函数打开控制终端，而不是直接将/dev/tty写在程序中。

•只是读、写控制终端，如果不能以读、写模式打开此设备则出错返回。还有一些其他的 使用约定。在GNUC函数库版本中，如果不能以读、写模式打开控制终端，则getpass 读取标准输入，写到标准错误。在Solaris版本中，如果不能打开授制终端，则getpass 失败。

•阻塞两个信号SIGINT和SIGTSTP。如果不这样做，在输入INTR字符时就会使程序异

常中止，并使终端仍处于禁止回显状态。与此相类似，输入SUSP字符时将使程序停止，

并且在禁止回显状态下返回到shell。在禁止回显时，我们选择了阻塞这两个信号。如果 这两个信号是在读取口令期间产生的，则它们会一直被保持，直到getpass返回，阻塞 才会解除。也有其他方法来处理这些信号。有些getpass版本忽略SIGINT （保存它以I 前的动作），在返回前将其动作恢复为以前的值。这就意味着，在该信号被忽略期间所发 生的这种信号都会丢失。其他版本捕捉SIGINT （保存它以前的动作），如果捕捉到此信 号，则在恢复终端状态和信号动作后，用kill函数发送此信号。没有一个getpass版 本捕捉、忽略或阻塞SIGQUIT，所以输入QUIT字符就会使程序异常中止，并且很可能 使终端保持在禁止回显状态。

•请注意，某些shell,尤其是Korn shell,在以交互方式读输入时都使终端处于回显状态。 这些shell是提供命令行编耩的shell，因此在每次输入一条交互命令时都处理终端状态。

所以如果在这种shell下调用此程序，并且用QUIT字符使其异常中止，则这种shell可 能会恢复回显状态。其他不提供命令行编舞的shell （如Bourne shell）将使程序异常中 止，并使终端保持在不回显状态。如果对终端做了这种操作，则stty命令能使终端恢 复到回显状态。

•使用标准I/O读、写控制终端。我们特地将流设置为不带缓冲的，否则在流的读、写之间 可能会有某些交叉（这样就需要多次调用fflush）,也可使用不带缓冲的I/O （见第3 章），但是在这种情况下就只能用read来模仿getc函数。

•最多只存储8个字符作为口令。输入的其他多余字符则全部被忽略。

图18-18中的程序调用getpass并且打印我们输入的内容。这是为了验证ERASE和KILL

字符能否正常工作（如同它们在规范模式下应该表现的那样）。

持 include "apue.h" char *getpass(const char *);

int

main(void)

char *ptr；

if ((ptr = getpasa("Enter password:")) == NULL) err_sys("getpass error");

printf("password: %s\n", ptr);

/* now use password (probably encrypt it) ... */

while (*ptr != 0)

*ptr++ = 0;    /* zero it out when we * re done with it */

exit(0);

们就可能会读到这个明文口令。（“明文”是指我们在getpass打印的提示符处键入的口令。大 多数UNIX系统程序会对这个明文口令进行修改，将它转换成一个“加密” 口令。例如，口令文 件（见6.2节）中的pw^passwd字段包含的是加密口令，而不是明文口令。）    B®

###### 18.11非规范模式

可以通过兔闭termios结构中c_lflag字段的I CANON标志来指定非规范模式。在非规范 模式中，输入数据不装配成行，不处理下列特殊字符（见18.3节）：ERASE、KILL、EOF、NL、 EOL、EOL2、CR、REPRINT, STATUS 和 WERASE。

如前所述，规范模式很容易理解：系统每次至多返回一行。但在非规范模式下，系统如何 知道在什么时候将数据返回给我们呢？如果它一次返回一个字节，那么系统开销就会过大。（回 忆图3-6,从中可以看到每次读一个字节的开销有多大。如果每次返回的数据加倍，那么系统调 用的开销就可以减半■>）在启动读数据之前，往往不知道要读多少数据，所以系统不能总是一次 返回多个字节。

解决方法是，当己读了指定量的数据后，或者已经超过了给定量的时间后，即通知系统返回， 这种技末使用了 termios结构中c_cc数组的两个变量：MIN和TIME。c_cc数组中的这两个 元素的下标名为VMIN和VTIME。

MIN指定一个read返回前的最小字节数。TIME指定等待数据到达的分秒数（分秒为秒的 1/10）。有下列4种情形。

情形 A: MINX）, TIME>0

TIME指定一个字节间定时器（interbytetimer）,它只在第一个字节被接收时启动。

在该定时器超时之前，若已接到MIN个字节，则read返回MIN个字节，如果在 接到MIN个字节之前，该定时器己超时，则read返回已接收到的字节。（因为定 时器是在第一个字节被接收后启动的，所以在定时器超时时，read至少会返回一 个字节。）在这种情形中，第一个字节被接收之前，调用者会一直阻塞。如果在调 用read时数据已经可用，则就如同在read后数据被立即接收了一样。

情形 B: MINX）, TIME=0

[7031    read在接收到MIN个字节之前不返回。这会造成read无限期阻塞。

情形 C: MIN=0，TIMEX）

TIME指定一个调用read时启动的读定时器。（与情形A相比较，两者是不同的。 在情形A中，非0 TIME表示字节间定时器，该定时器要等到第一个字节被接收时 才启动在接到一个字节或者该定时器超时时，read即返回。如果是定时器超时，

则read返回0。

情形 D: MIN=0, TIME=0

如果有数据可用，则read最多返回所要求的字节数。如果无数据可用，则read 立即返回0。

在所有这巷情形中，MIN只是最小值。如果程序要求的数据多于MIN个字节，那么它或许 能接收到所要求的字节数。这也适用于MIN=0的情形C和情形D。

图18-19总结并列出了非规范模式输入的4种不同情形。在这个图中，是read的第 三个参数（返回的最大字节数）。

MIN>0

MIN = O

| TIMEX)   | A：在定时器超时前，read 返回［MIN, nbytes］-,如果定时器超时，read 返回［1，MIN］。（TIME=^节间定时器。调用者会无限期阻塞。） | C：在定时器超时前，read 返回［1, nbytes}-,如果定时器超时， read返回0。（TIME=read 定时器。） |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| TIME = 0 | B：当有可用数据时，read 返回［MIN, nbytes}.（调用者可无限期阻塞，） | D： read 立即返回［0,                                        |

图18-19非规范输入的4种情形

请注意，P0S1X.1允许下标VMIN和VTIME的值分别与VEOF和VEOL的相同。砩实，Solaris就 是这样做的，这样就援供了与SystonV的早期版本的兼容性。但是，这也带来了可移植性问题。从非 規范模式转换为規范模式时，必须恢复VEOF和VEOL。如果VMIN等于VEOF，且不恢复它们的值， 那么当把VMIN的典型值设置为1时，文件结束符就变成了 Ctrl+A。解决这一问题最簡单的方法是： 在要转入非规范模式时，将整个termios结构保存起来，以后再要转回规范模式时恢复它。

鼹■实例

图18-20中的程序定义了函数tty_cbreak和tty_raw，它们将终端好别设置为cbreak模 式（cbreak mode）和原始模式（raw mode）。（术语cbreak卸康始来自于V7的终端驱动程序》） tty_reset函数的功能是将终端恢复到原始的工作状态（也就是调用tty_cbreak或tty_raw 之前的工作状态）6

如果已调用tty_cbreak，那么在调用tty_raw之前需要调用tty_reset。如果已调用 tty_raw,然后又要调用tty_cbreak，那么在此之前同样也要调用tty_reset。这减少了出 错时终端处于不可用状态的机会。    网

读程序述提供了另外两个函数：tty_atexit和tty_termioso tty_atexit可被登记为 退出处理程序，以保证exit恢复终端工作模式。tty_termios则返回一个指向原来规范模式 下termios结构的指针。

finclude "apue.h"

\#include <termios.h>

♦include <errno.h>

static struct termios    save_terraios;

static int    ttysavefd = -1;

static enum ( RESET, RAW, CBREAK } ttystate = RESET;

int

tty_cbreak(int fd) /* put terminal into a cbreak mode */

int    err;

struct termios buf;

if (ttystate != RESET) { errno = EINVAL; return (-1);

}

if (tcgetattr(fd, &buf) < 0) return(-1);

save_termios = buf; /* structure copy */

/*

\*    Echo off, canonical mode off.

*/

buf.c_lflag &= -(ECHO I ICANON);

/*

\*    Case B: 1 byte at a time, no timer.

*/

buf.c_cc[VMIN] = 1；

buf.c_cc[VTXME] = Of

if (tcsetattr(fd, TCSAFLUSH, &buf) < 0) return(-1);

\*    Verify that the changes stuck, tcsetattr can return 0 on

\*    partial success.

*/

if (tcgetattr{fd, &buf) < 0) { err = errno;

tcsetattr(fd, TCSAFLUSH, &save_termios); errno = err; return(-1J;

}

if <(buf.c_lflag & (ECHO | ICANON)) || buf.c_cc[VMIN] != 1 I I buf.c_cc[VTIME] != 0) {

/*

\*    Only some of the changes were made. Restore the

\*    original settings.

*/

tcsetattr(fd, TCSAFLUSH, &save_termios); errno - EINVAL; return (-1);

}

ttystate = CBREAK;

ttysavefd = fd;

return(0);

int

tty_raw(int fd)    /* put terminal into a raw mode */

t

int    err;

struct termios buf;

if (ttystate != RESET) { errno = EINVAL; return(-1,;

)

if (tcgetattr(fd, &buf) < 0)

return(-1);

save_termios = buf;    /* structure copy */

/*

\*    Echo off, canonical mode off, extended input

\*    processing off, signal chars off.

*/

buf.c_lflag S= ~(ECHO I ICANON I IEXTEN I ISIG);

\*    No SIGINT on BREAK, CR-to-NL off, input parity

*    check off, don't strip 8th bit on input, output

\*    flow control off.

*/

buf.c_iflag S= ~(BRKINT I ICRNL | INPCK | ISTRIP | IXON);

\* Clear size bits, parity checking off. */

buf.c_cflag S=〜(CSIZE I FARENB);

\*    Set 8 bits/char.

*/

buf,c_cflag [= CSS;

/*

\*    Output processing off.

buf.c_oflag &=〜(OPOST"

\* Case B: 1 byte at a time, no timer. */

buf.c_cc[VMIN] = 1;

buf.c_cc[VTIME] =0;

if (tcsetattr(fd, TCSAFLUSH, &buf) < 0) return(-1);

\*    Verify that the changes stuck, tcsetattr can return 0 on

\*    partial success.

*/

if {tcgetattr(fd, &buf> < 0) { err = errno;

tcsetattr(fd, TCSAFLUSH, ssave_termios); errno = err; return (-1);

if ((buf.c.lflag & (ECHO I ICANON I IEXTEN I ISIG)) I I

(buf.C_iflag & (BRKINT | ICRNL I INPCK I ISTRIP 1 IXON" I I (buf.c_cflag S (CSIZE | PARENB | CS8)) != CSB I I

(buf.c_oflag & OPOST) || buf.c_cc[VMIN] != 1 I I buf-c_cc[VTIME] != 0) {

\*    Only some of the changes were made. Restore the

\*    original settings.

*/

tcsetattr(fd, TCSAFLUSH, &save_termios);

errno = EINVAL;

return(-1);

ttystate = RAW; ttysavefd = fd; return(0);

int

tty_reset(int fd)    Z* restore terminal * s mode */

{

if {ttystate == RESET) return(0);

if (tcsetattr(fd, TCSAFLUSH, &3ave_termios) < 0) return(-1);

ttystate = RESET;

_    return(0);

画}

void

tty_atexit(void)    /* can be set up by atexit(tty_atexit) */

if (ttysavefd >= 0)

tty_reset(ttysavefd);

}

struct termios *

tty_termios(void)    /* let caller see original tty state */

{

return(&save_termios);

}

图18-20将终端模式设置为cbreak模式或原始模式 cbreak模式的定义如下。

•非规范模式。如本节开始处所述，这种模式关闭了对某些输入字符的处理。这种模式没 有关闭対信号的处理，所以用户始终可以键入一个能够触发终端产生信号的字符。请注 意，调用者应当捕捉这些信号，否则这种信号就有可能终止程序，并且使终端保持在 cbreak 模式。

作为一般规则，在编写更改终端模式的程序时，应当捕捉大多数信号，以便在程序终止 前恢复终端模式。

•关闭回显。

•每次输入一个字节，为此，将MIN设置为1,将TIME设置为0。这是图18-19中的情形 至少有一个字节可用时，read才返回。

对原始模式的定义如下。

•非规范模式。也关闭了对信号产生字符(ISIG)和扩充输入字符(IEXTEN)的处理。

另外还禁用了 BRKINT字符，使BREAK字符不再产生信号。

•关闭回显。

•禁止输入中的CR到NL映射（ICRNL）、输入奇偶检测（INPCK）、剥离输入字节的第8 位（ISTRIP）以及输出流控制（工XON）。

• 8位字符（CS8）,且禁用奇偶校验（PARENB）。

•禁止所有输出处理（OPOST）。

•每次输入一个字节TIME=0）o 图18-21中的程序测试原始模式和cbreak模式。

\#include "apue.h" static void

sig_catch(int signo)

{

printf("signal caught\n")； tty_reset(STDIN_FILENO); exit(0);

J

int

main(void)

{

int    i;

char    c;

if (signal(SIGINT, sig_catch) == SIG_ERR) /* catch signals */ err_sys("signal{SIGINT) error">;

if (signal(SIGQUIT, sig_catch) = SIG_ERR) err_sys("signal(SIGQUIT) error");

if {signal(SIGTERM, sig_catch) == SIG_ERR) err_sys("signal(SIGTERM) error");

if (tty_raw(STDIN_FILENO) < 0) err_sys("tty_raw error");

printf ("Enter raw mode characters, terminate with DELETE\nH) ,• while ((i = read(STDIN_FILENO, &c, 1)) == 1)(

if ((c &= 255) == 0177)    /* 0177 = ASCII DELETE */

break;

printf ("%o\n", c);

if <tty_reset(STDIN_FILENO》< 0) err_sys("tty_reset error")；

if (i <= 0)

err_sys("read error"); if (tty_cbreak(STDIN_FILENO> < 0)

err_sys("tty_cbreak error");

printf{"\nEnter cbreak mode characters, terminate with SIGINT\n"); while ((i = read(STDIN_FILENO, &c, 1)) == 1) {

c &= 255;

printf("%o\n", c);

}

if (tty_reset(STDIN_FILENO> < 0)

err_sys("tty_reset error"); if (i <= 0)

err_sys("read error");

exit(0);

[709]    图18-21测试原始终端模式和cbreak终端模式

运行图18-21中的程序，可以观察这两种终端工作模式的工作情况。

$ ./a.out

Enter raw mode characters, terminate with DELETE

4

33

133

61

70

176

键入Delete

Enter cbreak    mode characters, terminate with SIGINT

1    键入 Ctrl+A

10    键入退格

signal caught    键入中断键

在原始模式中，输入的字符是Ctri+D (04)和特殊功能键F7。在所用的终端上，此功能键产生5 个字符：ESC (033〉、[ (0133)、1 (061)、8 ( 070)和~ (0176)。注意，在原始模式下关闭了输 出处理('OPOST),所以在每个字符后没有得到回车符。另外还要注意的是，在cbreak模式下， 不对输入特殊字符进行处理(因此没对Ctrl+D、文件结束符和退格进行特殊处理〉，但是仍对终 端产生的信号进行处理。    ■■

18.12终端窗□大小

大多数UNIX系统都提供了一种跟踪当前终端窗口大小的方法，在窗口大小发生变化时，使 内核通知前台进程组。内核为每个终端和伪终端都维护了一个winsize结构：

struct winsize {

unsigned short ws_row；    /* rows, in characters */

unsigned short ws_col;    /* columns, in characters */

unsigned short ws^xpixel; Z* horizontal size, pixels (unused) */ unsigned short ws_ypixel; /* vertical size, pixels (unused) */

J；

此结构的规则如下，

•用ioctl (见3.15节)的TIOCGWINSZ命令可以取此结构的当前值。

•用ioctl的TXOCSWINSZ命令可以将此结构的新值存储到内核中=如果此新值与存储

在内核中的当前值不同，则前台进程组会收到SIGWINCH信号。(注意，从图10-1中可 闹    以看出，此信号的系统默认动作是被忽略。)

•除了存储此结构的当前值以及在此值改变时产生一个信号以外，内核对该结构不进行任 何其他操作。对结构中的值进行解释完全是应用程序的工作。

提供这种功能的目的是，当窗口大小发生变化时应用程序能够得到通知(如vi编辑器)。应

用程序接收此信号后，可以获取窗口大小的新值，然后重绘屏幕。

鼸■实例

图18-22所示的程序打印当前窗口大小，然后休眠。每次窗口大小改变时，程序就捕捉到 SIGWINCH信号，然后打印新的窗口大小。我们必须用一个信号终止此程序。

\#include "apue.h"

\#include <termios.h>

\#ifndef TIOCGWINSZ

tfinclude <sys/ioctl.h>

番endif

static void

pr_winsize(int fd)

{

struct winsize size;

if (ioctl(fd, TIOCGWINSZ, (char *) &size) < 0) err_sys("TIOCGWINSZ error")；

printf ("%d rows, %d columns\n*', size.ws_row, size.ws_col);

}

static void

sig_winch(int signo)

{

printf("SIGWINCH received\n">; pr_winsize(STDIN_FILENO>;

int

main(void)

{

if (isatty(STDIN_FILENO) == 0) exit(l);

if (signal(SIGWINCH, sig_winch) = SIG_ERR) err_sys("signal error")；

pr_winsize(STDIN_FILENO);    /* print initial size ♦/

for ( ; ; }    /* and sleep forever */

pause ();

)

图18-22打印窗口大小 在一个带窗口终端的系统上运行图18-22中的程序得到:

$ ./a.out 35 rows, SIGWINCH 40 rows, SIGWINCH 42 rows.



80 columns received 123 columns received 33 columns



初始大小

更改窗口大小：捕提到信号

再一次

##### 18-13 tecmcap、tezminfo 和 curses

termcap的意思是终端能力（terminal capability）.它涉及文本文件/etc/termcap和 —套读此文件的例程。termcap这种技术是在伯克利开发的，注意是为了支持vi编辑器。 termcap文件包含了对各种终端的说明：终端支持哪些功能（如行数、列数、终端是否支持 退格），如何使终端执行某些操作（如清屏、将光标移动到给定位置）。把这些信息从编译过 的程序中取出来并把它们放在易于编辑的文本文件中，这样就使得vi编辑器能在很多不同的 终端上运行。

最后，栴支持termcap文件的例程从vi编辑器中抽取出来，放在一个单独的curses库 中。为使这套库可供要进行屏幕处理的任何程序使用，还增加了很多功能。

termcap这种技术并不是很完善。当越来越多的终端被加到数据文件中时，为找到一个特定 的终端，需要花费更长的时间扫描此数据文件。这个数据文件还用两个字符的名字来禄识不同的 终端属性o这坚蚨陪迫使开发人员开发出了 terminfo以及与其相关的curses库。在terminfo 中，终端说明基本上都是文本说明的编译版本，在运行时易于被快速定位。terminfo最初由 SVR2开始使用，此后所有System V的版本都使用它。

历史上，基于System V的系统使用terminfo, BSD派生的系统使用termcap,但是现在， j系统通常两者都提供。然而Mac OS X仅支持terminfo。

Goodheart[1991]对terminfo和curses库进行了详细说明，但此书已不再增印。Strang[1986] 说明了 curses 圍数库的伯克利版本》Strang、Mui 和 O’ReilIy[1988]则对 termcap 和 terminfo 进行了说明。

i    可在 <http://invisible-island.net/ncurses/ncurses.html> 或 <http://www.gnu>,

org/software/ncurses上找到与SVR4 curses接口兼容的开放版ncurses岛数库。

不论是termcap还是terminfo,它们本身都不处理本章所述及的问题：更改终端的模 闹式、更改终端特殊字符、处理窗口大小等。它们所提供的是在各种终端上执行典型操作（清屏、 移动光标）的方法。另一方面，在本章所述问题方面，curses能提供某种具体细节方面的帮 助。curses提供了很多函数，用来设置原始模式、设置cbreak模式、打开和关闭回显等。注 意，curses库是为基于字符的哑终端设计的，而如今，它们大部分已被以基于像素的图形终

端所代替。

##### 18.14小结

终端有很多特征和选项，其中大多数都可按需进行更改，本章描述了很多更改终端操作（即 更改特殊输入字符和可选择标志）的函数，还介绍了可对终端设备进行设置或恢复的各个终端特 殊字符以及众多选项。

终端的输入模式有两种一规范的（每次一行）和非规范的。本章中包含了若干这两种工作 模式的实例，也提供了一些函数，它们在POSIX.1终端选项和较早的BSD cbreak模式及原始模 式之间进行映射。本章还说明了如何获取和改变终端窗口大小。

习题

18.1编写一个调用tty_raw并且不恢复终端模式就终止的程序。如果系统提供reset（l）命令 （本书说明的4种平台全都提供），使用该命令恢复终端模式。

18.2 c_cflag字段的PARODD标志允许我们设置奇检验或偶校验，而BSD中的tip程序也允 许奇偶校验位为0或1，它是如何实现的？

18.3如果你系统中的stty（l）命令输出MIN和TIME值，做下面的练习。登录系统两次，其中 —次登录时打开vi编辑器，在另外一次登录中用stty命令确定vi设置的MIN和TIME 值（因为vi将终端设置为非规范模式）。（如果你的终端上有窗口系统正在运行，那么你也 可以进行同样的测试，方法是：登录一次，然后用两个分开的窗口。）    [U3]
