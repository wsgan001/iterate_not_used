## 第 19 章 动态属性和特性

特性至关重要的地方在于，特性的存在使得开发者可以非常安全并且确定可行地将公 共数据属性作为类的公共接口的一部分开放出来。 1

——Alex Martelli Python 贡献者和图书作者

1《Python技术手册(第2版)》第101页。(该书中文版把“property”译为属性，这里改为“特性”，其他内容与原来的 翻译相同。一译者注)

在Python中，数据的属性和处理数据的方法统称属性(attribute)。其实，方法只是可调 用的属性。除了这二者之外，我们还可以创建特性(property)，在不改变类接口的前提 下，使用存取方法(即读值方法和设值方法)修改数据属性。这与统一访问原则相符：

不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式

使用。 2

| 2Bertrand Meyer, Object-Oriented Software Construction, 2E, p. 57+

除了特性，Python还提供了丰富的API，用于控制属性的访问权限，以及实现动态属性。 使用点号访问属性时(如 obj.attr)， Python 解释器会调用特殊的方法(如 __getattr__ 和 __setattr__)计算属性。用户自己定义的类可以通过 __getattr__ 方法实现“虚拟属性”，当访问不存在的属性时(如obj.no_such_attribute)，即时计 算属性的值。

动态创建属性是一种元编程，框架的作者经常这么做。然而，在 Python 中，相关的基础

技术十分简单，任何人都可以使用，甚至在日常的数据转换任务中也能用到。下面以这种

任务开启本章的话题。

### 19.1 使用动态属性转换数据

在接下来的几个示例中，我们要使用动态属性处理 O'Reilly 为 OSCON 2014 大会提供的 JSON 格式数据源。示例 19-1 是那个数据源中的 4 个记录。 3

3关于这个数据源及其使用规则，请阅读"“DIY: OSCON schedule”一文 ([http://conferences+oreilly+com/oscon/oscon2014/public/content/schedulefeed](http://conferences.oreilly.com/oscon/oscon2014/public/content/schedulefeed))。那个 JSON 文件有 744KB，我写作本书时

还在网上([http://www+oreilly+com/pub/sc/osconfeed](http://www.oreilly.com/pub/sc/osconfeed))。本书代码仓库中的oscon-schedule/data/目录里有个副本，文件名 为 osconfeed+ json([https://github+com/fluentpython/example-code/tree/master/19-dyn-attr-prop/oscon/data](https://github.com/fluentpython/example-code/tree/master/19-dyn-attr-prop/oscon/data))。

示例 19-1 osconfeed+json 文件中的记录示例；节略了部分字段的内容

{ "Schedule":

{ "conferences": [{"serial": 115 }],

"events": [

{ "serial": 34505,

"name": "Why Schools Don't Use Open Source to Teach Programming", "event_type": "40-minute conference session",

"time_start": "2014-07-23 11:30:00",

"time_stop": "2014-07-23 12:10:00",

"venue_serial": 1462,

"description": "Aside from the fact that high school programming...", "website_url": "<http://oscon.com/oscon2014/public/schedule/detail/34505>", "speakers": [157509],

"categories": ["Education"] }

],

"speakers": [

{ "serial": 157509,

"name": "Robert Lefkowitz",

"photo": null,

"url": "<http://sharewave.com/>",

"position": "CTO",

"affiliation": "Sharewave",

"twitter": "sharewaveteam",

"bio": "Robert 'r0ml' Lefkowitz is the CTO at Sharewave, a startup..." }

],

"venues": [

{ "serial": 1462,

"name": "F151",

"category": "Conference Venues" }

]

}

}

那个 JSON 源中有 895 条记录，示例 19-1 只列出了 4 条。可以看出，整个数据集是一个 JSON对象，里面有一个键，名为"Schedule"；这个键对应的值也是一个映像，有4个 键："conferences"、"events"、"speakers"和"venues"。这 4个键对应的值都是

一个记录列表。在示例 19-1 中，各个列表中只有一条记录。然而，在完整的数据集中， 列表中有成百上千条记录。不过， "conferences" 键对应的列表中只有一条记录，如上 述示例所示。这 4 个列表中的每个元素都有一个名为 "serial" 的字段，这是元素在各个 列表中的唯一标识符。

我编写的第一个脚本只用于下载那个 OSCON 数据源。为了避免浪费流量，我会先检查本 地有没有副本。这么做是合理的，因为 OSCON 2014 大会己经结束，数据源不会再更 新。

示例 19-2 没用到元编程，几乎所有代码的作用可以用这一个表达式概

括：json.load(fp)。不过，这样足以处理那个数据集了。osconfeed.load函数会在

后面几个示例中用到。

#### 示例 19-2 osconfeed.py：下载 osconfeed.json (doctest 在示例 19-3 中)

from urllib.request import urlopen

import warnings import os import json

URL = '<http://www.oreilly.com/pub/sc/osconfeed'> JSON = 'data/osconfeed.json'

def load():

if not os.path.exists(JSON):

msg = 'downloading {} to {}'.format(URL, JSON)

warnings.warn(msg) O

with urlopen(URL) as remote, open(JSON, 'wb') as local: © local.write(remote.read())

with open(JSON) as fp:

return json.load(fp) ©

#### ❶ 如果需要下载，就发出提醒。

❷ 在 with 语句中使用两个上下文管理器(从 Python 2.7 和 Python 3.1 起允许这么做)，

分别用于读取和保存远程文件。

❸ json.load 函数解析 JSON 文件，返回 Python 原生对象。在这个数据源中有这几种数 据类型： dict、 list、 str 和 int。

#### 有了示例 19-2 中的代码，我们可以审查数据源中的任何字段，如示例 19-3 所示。

#### 示例 19-3 osconfeed.py：示例 19-2 的 doctest

\>>> feed = load() O

\>>> sorted(feed['Schedule'].keys()) ©

['conferences', 'events', 'speakers', 'venues']

\>>> for key, value in sorted(feed['Schedule'].items()): ...    print('{:3} {}'.format(len(value), key)) ©

1 conferences 494 events 357 speakers 53 venues

\>>> feed['Schedule']['speakers'][-1]['name']    ©

'Carina C. Zona'

\>>> feed['Schedule']['speakers'][-1]['serial']❺

141590

\>>> feed['Schedule']['events'][40]['name']

'There *Will* Be Bugs'

\>>> feed['Schedule']['events'][40]['speakers']©

[3471, 5199]

❶ feed 的值是一个字典，里面嵌套着字典和列表，存储着字符串和整数。

❷ 列出 "Schedule" 键中的 4 个记录集合。

#### ❸ 显示各个集合中的记录数量。

#### ❹ 深入嵌套的字典和列表，获取最后一个演讲者的名字。

#### ❺ 获取那位演讲者的编号。

❻ 每个事件都有一个 'speakers' 字段，列出 0 个或多个演讲者的编号。

19.1.1使用动态属性访问JSON类数据

示例 19-2 十分简单，不过， feed['Schedule']['events'][40]['name'] 这种句法很 冗长。在 JavaScript 中，可以使用 feed.Schedule.events[40].name 获取那个值。在 Python 中，可以实现一个近似字典的类(网上有大量实现) 4，达到同样的效果。我自己 实现了 FrozenJSON 类，比大多数实现都简单，因为只支持读取，即只能访问数据。不

过，这个类能递归，自动处理嵌套的映射和列表。

4最常提到的一个实现是AttrDict (<https://pypi.python.org/pypi/attrdict>)，还有一个实现能快速创建嵌套的映射-

addict(<https://pypi.python.org/pypi/addict>)。

示例 19-4 演示 FrozenJSON 类的用法，源代码在示例 19-5 中。

示例19-4 示例19-5定义的FrozenJSON类能读取属性，如name，还能调用方 法，如 .keys() 和 .items()

\>>> from osconfeed import load

\>>> raw_feed = load()

\>>> feed = FrozenJSON(raw_feed)

\>>> len(feed.Schedule.speakers) ©

357

\>>> sorted(feed.Schedule.keys())    ©

['conferences', 'events', 'speakers', 'venues']

\>>> for key, value in sorted(feed.Schedule.items()):    ©

...    print('{:3} {}'.format(len(value), key))

1 conferences 494 events 357 speakers 53 venues

\>>> feed.Schedule.speakers[-1].name ❺

'Carina C. Zona'

\>>> talk = feed.Schedule.events[40] >>> type(talk) ©

<class 'explore0.FrozenJSON'>

\>>> talk.name 'There *Will* Be Bugs'

\>>> talk.speakers O [3471, 5199]

\>>> talk.flavor ©

Traceback (most recent call last): KeyError: 'flavor'

❶传入嵌套的字典和列表组成的raw_feed，创建一个FrozenJSON实例。

❷ FrozenJSON 实例能使用属性表示法遍历嵌套的字典；这里，我们获取演讲者列表的元 素数量。

❸也可以使用底层字典的方法，例如.keys()，获取记录集合的名称。

❹ 使用 items() 方法获取各个记录集合及其内容，然后显示各个记录集合中的元素数

量。

❺列表，例如feed.Schedule.speakers，仍是列表；但是，如果里面的元素是映射，

会转换成 FrozenJSON 对象。

❻ events 列表中的 40 号元素是一个 JSON 对象，现在则变成一个 FrozenJSON 实例。

❼ 事件记录中有一个 speakers 列表，列出演讲者的编号。

❽ 读取不存在的属性会抛出 KeyError 异常，而不是通常抛出的 AttributeError 异 常。

FrozenJSON 类的关键是 __getattr__ 方法。我们在 10.5 节的 Vector 示例中用过这个 方法，那时用于通过字母获取Vector对象的分量(例如v.x、v.y、v.z)。我们要记住

重要的一点，仅当无法使用常规的方式获取属性(即在实例、类或超类中找不到指定的属

性)，解释器才会调用特殊的 __getattr__ 方法。

示例 19-4 的最后一行揭露了这个实现的一个小问题：理论上，尝试读取不存在的属性应 该抛出 AttributeError 异常。其实，一开始我对这个异常做了处理，但是 __getattr__ 方法的代码量增加了一倍，而且偏离了我最想展示的重要逻辑，因此为了

教学，后来我把那部分代码去掉了。

如示例 19-5 所示， FrozenJSON 类只有两个方法(__init__ 和 __getattr__)和一个 实例属性__data。因此，尝试获取其他属性会触发解释器调用__getattr__方法。这 个方法首先查看 self.__data 字典有没有指定名称的属性(不是键)，这样 FrozenJSON 实例便可以处理字典的所有方法，例如把 items 方法委托给 self.__data.items() 方法。如果 self.__data 没有指定名称的属性，那么 __getattr__ 方法以那个名称为键，从 self.__data 中获取一个元素，传给

FrozenJSON.build 方法。这样就能深入 JSON 数据的嵌套结构，使用类方法 build 把 每一层嵌套转换成一个 FrozenJSON 实例。

示例19-5 explore0+py：把一个JSON数据集转换成一个嵌套着FrozenJSON对象、

列表和简单类型的 FrozenJSON 对象

from collections import abc class FrozenJSON:

"""一个只读接口，使用属性表示法访问JSON类对象

def __init__(self, mapping):

self.__data = dict(mapping) O

def _getattr_(self, name): © if hasattr(self.__data, name):

return getattr(self._data, name) © else:

return FrozenJSON.build(self._data[name])    ©

@classmethod

def build(cls, obj):❺

if isinstance(obj, abc.Mapping): © return cls(obj)

elif isinstance(obj, abc.MutableSequence): & return [cls.build(item) for item in obj]

else:❻

return obj

❶ 使用 mapping 参数构建一个字典。这么做有两个目的： (1) 确保传入的是字典(或者 是能转换成字典的对象)； (2) 安全起见，创建一个副本。

❷仅当没有指定名称(name)的属性时才调用__getattr__方法。

❸ 如果 name 是实例属性 __data 的属性，返回那个属性。调用 keys 等方法就是通过这 种方式处理的。

❹ 否则，从 self.__data 中获取 name 键对应的元素，返回调用 FrozenJSON.build()

方法得到的结果。 5

I 5这一行中的self._data[name]表达式可能抛出KeyError异常。我们应该处理这个异常，抛出AttributeError 异常，因为这才是__getattr^方法应该抛出的异常种类。建议勤奋的读者实现错误处理代码，当作一个练习。

❺ 这是一个备选构造方法， @classmethod 装饰器经常这么用。

❻ 如果 obj 是映射，那就构建一个 FrozenJSON 对象。

❼ 如果是 MutableSequence 对象，必然是列表， 6 因此，我们把 obj 中的每个元素递归 地传给 .build() 方法，构建一个列表。

| 6数据源是JSON格式，而在JSON中，只有字典和列表是集合类型。

❽ 如果既不是字典也不是列表，那么原封不动地返回元素。

注意，我们没有缓存或转换原始数据源。在迭代数据源的过程中，嵌套的数据结构不断被

转换成 FrozenJSON 对象。这么做没问题，因为数据集不大，而且这个脚本只用于访问或 转换数据。

从随机源中生成或仿效动态属性名的脚本都必须处理一个问题：原始数据中的键可能不适

合作为属性名。下一节处理这个问题。

19.1.2 处理无效属性名

FrozenJSON 类有个缺陷：没有对名称为 Python 关键字的属性做特殊处理。比如说像下面

这样构建一个对象：

\>>> grad = FrozenJSON({'name': 'Jim Bo', 'class': 1982})

此时无法读取 grad.class 的值，因为在 Python 中 class 是保留字：

\>>> grad.class

File "<stdin>", line 1 grad.class

八

SyntaxError: invalid syntax

当然，可以这么做：

\>>> getattr(grad, 'class') 1982

但是， FrozenJSON 类的目的是为了便于访问数据，因此更好的方法是检查传给 FrozenJSON.__init__ 方法的映射中是否有键的名称为关键字，如果有，那么在键名后

加上 _，然后通过下述方式读取：

\>>> grad.class 1982

为此，我们可以把示例 19-5 中只有一行代码的 __init__ 方法改成示例 19-6 中的版本。 示例19-6 explore1.py:在名称为Python关键字的属性后面加上_

def __init__(self, mapping): self.__data = {}

for key, value in mapping.items(): if keyword.iskeyword(key): O key += '_'

self.__data[key] = value

O keyword.iskeyword(...) 正是我们所需的函数；为了使用它，必须导入 keyword 模

块；这个代码片段没有列出导入语句。

如果 JSON 对象中的键不是有效的 Python 标识符，也会遇到类似的问题：

\>>> x = FrozenJSON({'2be':'or not'}) >>> x.2be

File "<stdin>", line 1 x.2be

八

SyntaxError: invalid syntax

这种有问题的键在 Python 3 中易于检测，因为 str 类提供的 s.isidentifier() 方法能

根据语言的语法判断 s 是否为有效的 Python 标识符。但是，把无效的标识符变成有效的 属性名却不容易。对此，有两个简单的解决方法，一个是抛出异常，另一个是把无效的键 换成通用名称，例如attr_0、attr_1，等等。为了简单起见，我将忽略这个问题。

对动态属性的名称做了一些处理之后，我们要分析 FrozenJSON 类的另一个重要功能—— 类方法 build 的逻辑。这个方法把嵌套结构转换成 FrozenJSON 实例或 FrozenJSON 实 例列表，因此 __getattr__ 方法使用这个方法访问属性时，能为不同的值返回不同类型 的对象。

除了在类方法中实现这样的逻辑之外，还可以在特殊的 __new__ 方法中实现，如下一节

所述。

19.1.3 使用 __new__ 方法以灵活的方式创建对象

我们通常把 __init__ 称为构造方法，这是从其他语言借鉴过来的术语。其实，用于构建 实例的是特殊方法 __new__：这是个类方法(使用特殊方式处理，因此不必使用 @classmethod 装饰器)，必须返回一个实例。返回的实例会作为第一个参数(即 self)传给__init__方法。因为调用__init__方法时要传入实例，而且禁止返回任何 值，所以 __init__ 方法其实是“初始化方法”。真正的构造方法是 __new__。我们几乎不 需要自己编写 __new__ 方法，因为从 object 类继承的实现已经足够了。

刚才说明的过程，即从 __new__ 方法到 __init__ 方法，是最常见的，但不是唯一 的。 __new__ 方法也可以返回其他类的实例，此时，解释器不会调用 __init__ 方法。 也就是说， Python 构建对象的过程可以使用下述伪代码概括：

\#    构建对象的伪代码

def object_maker(the_class, some_arg):

new_object = the_class.__new__(some_arg) if isinstance(new_object, the_class):

the_class.__init__(new_object, some_arg) return new_object

\#    下述两个语句的作用基本等效

x = Foo('bar')

x = object_maker(Foo, 'bar')

示例 19-7 是 FrozenJSON 类的另一个版本，把之前在类方法 build 中的逻辑移到了

__new__ 方法中。

示例19-7 explore2.py：使用__new__方法取代build方法，构建可能是也可能不 是 FrozenJSON 实例的新对象

from collections import abc class FrozenJSON:

"""一个只读接口，使用属性表示法访问]SON类对象

def __new__(cls, arg): O

if isinstance(arg, abc.Mapping):

return super().__new__(cls) © elif isinstance(arg, abc.MutableSequence): © return [cls(item) for item in arg] else:

return arg

def __init__(self, mapping): self.__data = {}

for key, value in mapping.items(): if iskeyword(key): key += '_'

self.__data[key] = value

def __getattr__(self, name):

if hasattr(self.__data, name):

return getattr(self.__data, name) else:

return FrozenJSON(self.__data[name]) ©

❶ __new__ 是类方法，第一个参数是类本身，余下的参数与 __init__ 方法一样，只不 过没有 self。

❷ 默认的行为是委托给超类的 __new__ 方法。这里调用的是 object 基类的 __new__ 方 法，把唯一的参数设为 FrozenJSON。

❸ __new__ 方法中余下的代码与原先的 build 方法完全一样。

❹ 之前，这里调用的是 FrozenJSON.build 方法，现在只需调用 FrozenJSON 构造方 法。

__new__ 方法的第一个参数是类，因为创建的对象通常是那个类的实例。所以，在

FrozenJSON.__new__ 方法中， super().__new__(cls) 表达式会调用

object. __new__(FrozenJSON)，而 object 类构建的实例其实是 FrozenJSON 实例， 即那个实例的 __class__ 属性存储的是 FrozenJSON 类的引用。不过，真正的构建操作 由解释器调用 C 语言实现的 object.__new__ 方法执行。

OSCON 的 JSON 数据源有一个明显的缺点：索引为 40 的事件，即名为 'There *Will* Be Bugs' 的那个，有两位演讲者， 3471 和 5199，但却不容易找到他们，因为提供的是 编号，而 Schedule.speakers 列表没有使用编号建立索引。此外，每条事件记录中都有 venue_serial 字段，存储的值也是编号，但是如果想找到对应的记录，那就要线性搜索 Schedule.venues 列表。接下来的任务是，调整数据结构，以便自动获取所链接的记 录。

19.1.4使用shelve模块调整OSCON数据源的结构

标准库中有个shelve （架子）模块，这名字听起来怪怪的，可是如果知道pickle （泡

菜）是 Python 对象序列化格式的名字，还是在那个格式与对象之间相互转换的某个模块

的名字，就会觉得以 shelve 命名是合理的。泡菜坛子摆放在架子上，因此 shelve 模块 提供了 pickle 存储方式。

shelve.open 高阶函数返回一个 shelve.Shelf 实例，这是简单的键值对象数据库，背

后由 dbm 模块支持，具有下述特点。

• shelve.Shelf是abc.MutableMapping的子类，因此提供了处理映射类型的重要

方法。

•此外，shelve.Shelf类还提供了几个管理I/O的方法，如sync和close；它也是

一个上下文管理器。

•只要把新值赋予键，就会保存键和值。

•键必须是字符串。

•值必须是pickle模块能处理的对象。

shelve（[https://docs+python+org/3/library/shelve+html](https://docs.python.org/3/library/shelve.html)）、 dbm（[https://docs+python+org/3/librar](https://docs.python.org/3/library/dbm.html) 和 pickle 模块（ [https://docs+python+org/3/library/pickle+html ](https://docs.python.org/3/library/pickle.html)）的详细用法和注意事项参见 文档。现在值得关注的是， shelve 模块为识别 OSCON 的日程数据提供了一种简单有效 的方式。我们将从 JSON 文件中读取所有记录，将其存在一个 shelve.Shelf 对象中，键 由记录类型和编号组成（例如，’event.33950•或’speaker.3471'），而值是我们即 将定义的 Record 类的实例。

实例19-8是schedule1+py脚本的doctest，使用shelve模块处理数据源。若想以交互式方 式测试，要执行 python -i schedule1.py 命令运行脚本，启动加载了 schedule1 模 块的控制台。主要工作由 load_db 函数完成：调用 osconfeed.load 方法（在示例 19-2 中定义）读取 JSON 数据，把通过 db 传入的 Shelf 对象中的各条记录存储为一个个 Record 实例。这样处理之后，获取演讲者的记录就容易了，例如 speaker = db['speaker.3471']。

示例 19-8 测试 schedule1+py 脚本（见示例 19-9）提供的功能

\>>> import shelve

\>>> db = shelve.open(DB_NAME) O

\>>> if CONFERENCE not in db: ©

... load_db(db) ©

\>>> speaker = db['speaker.3471']    ©

\>>> type(speaker)❺

<class 'schedule1.Record'>

\>>> speaker.name, speaker.twitter ©

('Anna Martelli Ravenscroft', 'annaraven')

\>>> db.close() O

❶ shelve.open 函数打开现有的数据库文件，或者新建一个。

❷ 判断数据库是否填充的简便方法是，检查某个已知的键是否7存在；这里检查的键是

conference.115，即 conference 记录(只有一个)的键。7

7也可以使用len(db)判断，不过，如果是大型dbm数据库，那就很耗费时间。

#### ❸如果数据库是空的，那就调用load_db(db)，加载数据。

#### ❹ 获取一条 speaker 记录。

❺ 它是示例 19-9 中定义的 Record 类的实例。

❻ 各个 Record 实例都有一系列自定义的属性，对应于底层 JSON 记录里的字段。

❼ 一定要记得关闭 shelve.Shelf 对象。如果可以，使用 with 块确保 Shelf 对象会关

闭。 8

8doctest有个突出的弱点：无法正确地设置资源并保证将其销毁。我使用py.test为schedulel.py脚本写了很多测试， 在示例A-12中。

schedule1.py 脚本的代码在示例 19-9 中。

#### 示例19-9 schedulel.py：访问保存在shelve.Shelf对象里的OSCON日程数据

import warnings

import osconfeed O

DB_NAME = 'data/schedule1_db' CONFERENCE = 'conference.115'

class Record:

def __init__(self, **kwargs):

self.__dict__.update(kwargs) ©

def load_db(db):

raw_data = osconfeed.load() ©

warnings.warn('loading ' + DB_NAME)

for collection, rec_list in raw_data['Schedule'].items():    ©

record_type = collection[:-1]❺ for record in rec_list:

key = '{}.{}'.format(record_type, record['serial']) © record['serial'] = key & db[key] = Record(**record)❻

❶ 加载示例 19-2 中的 osconfeed.py 模块。

❷ 这是使用关键字参数传入的属性构建实例的常用简便方式(详情参见下文)。

❸ 如果本地没有副本，从网上下载 JSON 数据源。

❹迭代集合(例如'conferences'、 'events'，等等)。

❺ record_type 的值是去掉尾部 's' 后的集合名(即把 'events' 变成 'event')。

❻ 使用 record_type 和 'serial' 字段构成 key。

❼ 把 'serial' 字段的值设为完整的键。

❽ 构建 Record 实例，存储在数据库中的 key 键名下。

Record.__init__ 方法展示了一个流行的 Python 技巧。我们知道，对象的 __dict__ 属 性中存储着对象的属性——前提是类中没有声明 __slots__ 属性，如 9.8 节所述。因 此，更新实例的 __dict__ 属性，把值设为一个映射，能快速地在那个实例中创建一堆属 性。 9

9顺便说一下，2001 年 Alex Martelli 在“The simple but handy‘collector of a bunch of named stuff'class ”诀窍 (<http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/>)中分享这个技巧时使用的类

名是 Bunch。

不过要知道，在某些应用中，



Record 类可



我不会重述19.1.2节讨论的细节， 能要处理不能作为属性名使用的键。

示例 19-9 中定义的 Record 类太简单了，因此你可能会问，为什么之前没用，而是使用 更复杂的 FrozenJSON 类。原因有两个。第一， FrozenJSON 类要递归转换嵌套的映射和

列表[；而 ](https://docs.python.org/3/library/multiprocessing.html?highlight=namespace%23namespaceobjects)[Record 类不需要这么做，因为转换好的数据集中没有嵌套的映射和列表，记录](https://docs.python.org/3/library/multiprocessing.html?highlight=namespace%23namespaceobjects)

中只有字符串、整数、字符串列表和整数列表。第二， FrozenJSON 类要访问内嵌的 __data 属性(值是字典，用于调用 keys 等方法)，而现在我们也不需要这么做了。

Python标准库中至少有两个与Record类似的类，其实例可以有任意个属性，

由传给构造方法的关键字参数构建-multiprocessing.Namespace类[文档

( <https://docs.python.org/3/library/multiprocessing.html>?

highlight=namespace#namespaceobjects) ，源码

([ ](https://hg.python.org/cpython/file/50d581f69a73/Lib/multiprocessing/managers.py%23l909)[https://hg+python+org/cpython/file/50d58 1f69a73/Lib/multiprocessing/managers+py#l909 ](https://hg.python.org/cpython/file/50d581f69a73/Lib/multiprocessing/managers.py%23l909)) ］

[和 ](https://docs.python.org/3/library/argpa-rse.html%23argparse.Namespace)[argparse.Namespace 类［文档(https://docs+python+ org/3/library/argpa-](https://docs.python.org/3/library/argpa-rse.html%23argparse.Namespace)rse+html#argparse+Namespace)，源码

([https://hg+python+org/cpython/file/50d581f69a73/Lib/argparse+py#l1196](https://hg.python.org/cpython/file/50d581f69a73/Lib/argparse.py%23l1196)) ］。我之所以自 己实现Record，是为了说明一个重要的做法：在__init__方法中更新实例的 __dict__ 属性。

像上面那样调整日程数据集之后，我们可以扩展 Record 类，让它提供一个有用的服务： 自动获取 event 记录引用的 venue 和 speaker 记录。这与 Django ORM 访问 models.ForeignKey 字段时所做的事类似：得到的不是键，而是链接的模型对象。在下 一个示例中，我们要使用特性来实现这个服务。

19.1.5 使用特性获取链接的记录

下一个版本的目标是，对于从 Shelf 对象中获取的 event 记录来说，读取它的 venue 或 speakers 属性时返回的不是编号，而是完整的记录对象。用法如示例 19-10 中的交互代

码片段所示。

示例 19-10 摘自 schedule2+py 脚本的 doctest

\>>> DbRecord.set_db(db)

\>>> event = DbRecord.fetch('event.33950')    ©

\>>> event ©

<Event 'There *Will* Be Bugs'>

\>>> event.venue o <DbRecord serial='venue.1449'>

\>>> event.venue.name ❺

'Portland 251'

\>>> for spkr in event.speakers: ©

... print('{0.serial}: {0.name}'.format(spkr))

speaker.3471: Anna Martelli Ravenscroft speaker.5199: Alex Martelli

❶ DbRecord 类扩展 Record 类，添加对数据库的支持：为了操作数据库，必须为 DbRecord 提供一个数据库的引用。

❷ DbRecord.fetch 类方法能获取任何类型的记录。

❸ 注意， event 是 Event 类的实例，而 Event 类扩展 DbRecord 类。

❹ event.venue 返回一个 DbRecord 实例。

❺ 现在，想找出 event.venue 的名称就容易了。这种自动取值是这个示例的目标 ❻ 还可以迭代 event.speakers 列表，获取表示各位演讲者的 DbRecord 对象。

图 19-1 绘出了本节要分析的几个类。

Record

__init__方法与schedulel.py脚本(见示例19-9)中的一样；为了辅助测试，增加 了 __eq__ 方法。

DbRecord

Record 类的子类，添加了 __db 类属性，用于设置和获取 __db 属性的 set_db 和 get_db 静态方法，用于从数据库中获取记录的 fetch 类方法，以及辅助调试和测试的 __repr__ 实例方法。

Event

DbRecord 类的子类，添加了用于获取所链接记录的 venue 和 speakers 属性，以及 特殊的 __repr__ 方法。

图19-1:改进的Record类和两个子类(DbRecord和Event)的UML类图

DbRecord.__db 类属性的作用是存储打开的 shelve.Shelf 数据库引用，以便在需要使 用数据库的 DbRecord.fetch 方法及 Event.venue 和 Event.speakers 属性中使用。我

把 __db 设为私有类属性，然后定义了普通的读值方法和设值方法，以防不小心覆盖

__db 属性的值。基于一个重要的原因，我没有使用特性去管理 __db 属性：特性是用于

管理实例属性的类属性。 10

10 Stack Ovefow 中有个题为“Class-level read only properties in Python” 的问题

([http://stackoverflow. com/questions/1735434/class-level-read-only-properties-in-python](http://stackoverflow.com/questions/1735434/class-level-read-only-properties-in-python))，为类中的只读属性提供了解决方 案，其中包括 Alex Martelli 提供的一个方案。这些方案要用到元类，因此学习那些方案之前可能要先读本书第 21 章。

本节的代码在本书仓库(<https://github.com/fluentpython/example-code>)里的 schedule2.py 模

块中。这个模块有 100 多行，因此我会分成几部分分析。

schedule2.py 脚本的前几个语句在示例 19-11 中。

示例19-11 schedule2.py：导入模块，定义常量和增强的Record类

import osconfeed

DB_NAME = 'data/schedule2_db'    ©

CONFERENCE = 'conference.115' class Record:

def __init__(self, **kwargs): self.__dict__.update(kwargs)

def __eq__(self, other):    ©

if isinstance(other, Record):

return self.__dict__ == other.__dict__ else:

return NotImplemented

#### O inspect模块在load_db函数中使用（参见示例19-14）。

#### © 因为要存储几个不同类的实例，所以我们要创建并使用不同的数据库文件；这里不用

示例 19-9 中的'schedule1_db'，而是使用’schedule2_db'。

© __eq__ 方法对测试有重大帮助。

![img](08414584Python-88.jpg)



在 Python 2 中，只有“新式”类支持特性。在 Python 2 中定义新式类的方法是，直接或 间接继承 object 类。示例 19-11 中的 Record 类是一个继承体11系的基类，用到了特 性；因此，在 Python 2 中声明 Record 类时，开头要这么写：11

class Record(object):



\# 余下的代码



11在Python 3中明确指明继承object类没有错，但是多余，因为现在所有类都是新式的。此例说明，与过去告别能 让语言更简洁。如果要在Python2和Python 3中运行同一段代码，应该显式继承object类。

#### 接下来， schedule2.py 脚本定义了两个类——一个自定义的异常类型和 DbRecord 类，参 见示例 19-12。

示例 19-12 schedule2.py：MissingDatabaseError 类和 DbRecord 类

DbRecord.__db = db ❺

@staticmethod ©

def get_db():

return DbRecord.__db

@classmethod O

def fetch(cls, ident): db = cls.get_db() try:

return db[ident] © except TypeError:

if db is None:    0

msg = "database not set; call '{}.set_db(my_db)'" raise MissingDatabaseError(msg.format(cls.__name__))

else: © raise

def __repr__(self):

if hasattr(self, 'serial'): ®

cls_name = self.__class__.__name__

return '<{} serial={!r}>'.format(cls_name, self.serial) else:

return super().__repr__()    ®

#### ❶ 自定义的异常通常是标志类，没有定义体。写一个文档字符串，说明异常的用途，比 只写一个 pass 语句要好。

❷ DbRecord 类扩展 Record 类。

❸ __db 类属性存储一个打开的 shelve.Shelf 数据库引用。

#### ❹ set_db 是静态方法，以此强调不管调用多少次，效果始终一样。

❺ 即使调用 Event.set_db(my_db)， __db 属性仍在 DbRecord 类中设置。

❻ get_db 也是静态方法，因为不管怎样调用，返回值始终是 DbRecord.__db 引用的对 象。

❼ fetch 是类方法，因此在子类中易于定制它的行为。

#### ❽ 从数据库中获取 ident 键对应的记录。

#### ❾如果捕获到TypeError异常，而且db变量的值是None，抛出自定义的异常，说明必 须设置数据库。

#### ❿ 否则，重新抛出 TypeError 异常，因为我们不知道怎么处理。

#### ©如果记录有serial属性，在字符串表示形式中使用。

#### ©否则，调用继承的_repr_方法。

示例 19-13 schedule2.py： Event 类

class Event(DbRecord): O

@property

def venue(self):

key = 'venue.{}'.format(self.venue_serial) return self.__class__.fetch(key) ©

@property

def speakers(self):

if not hasattr(self, '_speaker_objs'): ©

spkr_serials = self.__dict__['speakers'] © fetch = self.__class__.fetch ❺

self._speaker_objs = [fetch('speaker.{}'.format(key)) for key in spkr_serials] © return self._speaker_objs O

def __repr__(self):

if hasattr(self, 'name'): ©

cls_name = self.__class__.__name__ return '<{} {!r}>'.format(cls_name, self.name) else:

return super().__repr__()    ©

❶ Event 类扩展 DbRecord 类。

❷在venue特性中使用venue_serial属性构建key，然后传给继承自DbRecord类的 fetch 类方法(详情参见下文)。

❸ speakers 特性检查记录是否有 _speaker_objs 属性。

❹ 如果没有，直接从 __dict__ 实例属性中获取 'speakers' 属性的值，防止无限递 归，因为这个特性的公开名称也是 speakers。

❺ 获取 fetch 类方法的引用(稍后会说明这么做的原因)。

❻ 使用 fetch 获取 speaker 记录列表，然后赋值给 self._speaker_objs。

❼ 返回前面获取的列表。

❽ 如果记录有 name 属性，在字符串表示形式中使用。

❾ 否则，调用继承的 __repr__ 方法。

在示例 19-13 中的 venue 特性里，最后一行返回的是 self.__class__.fetch(key)， 为什么不直接使用 self.fetch(key) 呢？对这个 OSCON 数据源来说，可以使用后者， 因为事件记录都没有 'fetch' 键。哪怕只有一个事件记录有名为 'fetch' 的键，那么在 那个 Event 实例中， self.fetch 获取的是 fetch 字段的值，而不是 Event 继承自

DbRecord 的 fetch 类方法。这个缺陷不明显，很容易被测试忽略；在生产环境中，如果

会场或演讲者记录链接到那个事件记录，获取事件记录时才会暴露出来。

从数据中创建实例属性的名称时肯定有可能会引入缺陷，因为类属性（例如 方法）可能被遮盖，或者由于意外覆盖现有的实例属性而丢失数据。这个问题可能是

Python 字典默认不能像 JavaScript 对象那样访问的主要原因。

如果 Record 类的行为更像映射，可以把动态的 __getattr__ 方法换成动态的 __getitem__ 方法，这样就不会出现由于覆盖或遮盖而引起的缺陷了。使用映射实现 Record 类或许更符合 Python 风格。可是，如果我采用那种方式，就发掘不了动态属性编

程的技巧和陷阱了。

这个示例最后的代码是重写的 load_db 函数，如示例 19-14。

示例 19-14 schedule2.py：load_db 函数

def load_db(db):

raw_data = osconfeed.load() warnings.warn('loading ' + DB_NAME)

for collection, rec_list in raw_data['Schedule'].items(): record_type = collection[:-1] O cls_name = record_type.capitalize() © cls = globals().get(cls_name, DbRecord) © if inspect.isclass(cls) and issubclass(cls, DbRecord): © factory = cls ❺

else:

factory = DbRecord © for record in rec_list: &

key = '{}.{}'.format(record_type, record['serial'])

record['serial'] = key

db[key] = factory(**record) ❻

❶ 目前，与 schedule1.py 脚本（见示例 19-9）中的 load_db 函数一样。

❷把record_type变量的值首字母变成大写（例如，把'event'变成’Event'），获

取可能的类名。

❸ 从模块的全局作用域中获取那个名称对应的对象；如果找不到对象，使用 DbRecord。 ❹ 如果获取的对象是类，而且是 DbRecord 的子类……

❺ ……把对象赋值给 factory 变量。因此， factory 的值可能是 DbRecord 的任何一个 子类，具体的类取决于 record_type 的值。

❻ 否则，把 DbRecord 赋值给 factory 变量。

❼这个for循环创建key，然后保存记录，这与之前一样，不过......

❽ ……存储在数据库中的对象由 factory 构建， factory 可能是 DbRecord 类，也可能 是根据 record_type 的值确定的某个子类。

注意，只有事件类型的记录有自定义的类-Event。不过，如果定义了 Speaker或

Venue 类， load_db 函数构建和保存记录时会自动使用这两个类，而不会使用默认的 DbRecord 类。

本章目前所举的示例是为了展示如何使用基本的工具，如_getattr__方法、hasattr 函数、 getattr 函数、 @property 装饰器和 __dict__ 属性，来实现动态属性。

特性经常用于把公开的属性变成使用读值方法和设值方法管理的属性，且在不影响客户端

代码的前提下实施业务规则，如下一节所述。

### 19.2 使用特性验证属性

目前，我们只介绍了如何使用 @property 装饰器实现只读特性。本节要创建一个可读写 的特性。

19.2.1 Lineltem类第1版：表示订单中商品的类

假设有个销售散装有机食物的电商应用，客户可以按重量订购坚果、干果或杂粮。在这个 系统中，每个订单中都有一系列商品，而每个商品都可以使用示例 19-15 中的类表示。

#### 示例 19-15 bulkfood_v1:最简单的 Lineltem 类

class LineItem:

def __init__(self, description, weight, price): self.description = description self.weight = weight

self.price = price

def subtotal(self):

return self.weight * self.price

#### 这个类很精简，不过或许太简单了。示例 19-16 揭示了一个问题。 示例 19-16 重量为负值时，金额小计为负值

\>>> raisins = LineItem('Golden raisins', 10, 6.95)

\>>> raisins.subtotal()

69.5

\>>> raisins.weight = -20 # 无效输入 ……

\>>> raisins.subtotal() # 无效输出……

-139.0

#### 这个示例像玩具一样，但是没有想象中的那么好玩。下面是亚马逊早期的真实故事。

我们发现顾客买书时可以把数量设为负数！然后，我们把金额打到顾客的信用卡上， 苦苦等待他们把书寄出(想得美)。 12

——Jeff Bezos 亚马逊创始人和 CEO

I12摘自《华尔街日报》的文章，“Birth of a Salesman” (2011年10月15 日，http://www.wsj.com/articles/SB10001424052970203914304576627102996831200)，这是 Jeff Bezos 的原话。

#### 这个问题怎么解决呢？我们可以修改 LineItem 类的接口，使用读值方法和设值方法管理

weight 属性。这是 Java 采用的方式，这里也完全可行。

但是，如果能直接设定商品的 weight 属性，显得更自然。此外，系统可能在生产环境

中，而其他部分已经直接访问 item.weight 了。此时，符合 Python 风格的做法是，把数 据属性换成特性。

19.2.2 LineItem类第2版：能验证值的特性

实现特性之后，我们可以使用读值方法和设值方法，但是 LineItem 类的接口保持不变

(即，设置 LineItem 对象的 weight 属性依然写成 raisins.weight = 12)。

示例 19-17 列出可读写的 weight 特性的代码。

示例 19-17 bulkfood_v2.py：定义了 weight 特性的 LineItem 类

class LineItem:

def __init__(self, description, weight, price): self.description = description self.weight = weight O self.price = price

def subtotal(self):

return self.weight * self.price

@property ©

def weight(self): ©

return self.__weight ©

@weight.setter ❺ def weight(self, value): if value > 0:

self.__weight = value © else:

raise ValueError('value must be > 0') O

❶ 这里已经使用特性的设值方法了，确保所创建实例的 weight 属性不能为负值。

❷ @property 装饰读值方法。

❸实现特性的方法，其名称都与公开属性的名称一样——weight。

❹ 真正的值存储在私有属性 __weight 中。

❺ 被装饰的读值方法有个 .setter 属性，这个属性也是装饰器；这个装饰器把读值方法 和设值方法绑定在一起。

❻ 如果值大于零，设置私有属性 __weight。

❼ 否则，抛出 ValueError 异常。

注意，现在不能创建重量为无效值的 LineItem 对象：

\>>> walnuts = LineItem('walnuts', 0, 10.00) Traceback (most recent call last): ValueError: value must be > 0

现在，我们禁止用户为 weight 属性提供负值或零。虽然买家通常不能设置商品的价格，

但是工作人员可能犯错，应用程序也可能有缺陷，从而导致 LineItem 对象的 price 属 性为负值。为了防止出现这种情况，我们也可以把 price 属性变成特性，但是这样我们 的代码中就存在一些重复。

还记得第 14 章引述 Paul Graham 的那句话吗？他说：“当我在自己的程序中发现用到了模 式，我觉得这就表明某个地方出错了。 ”去除重复的方法是抽象。抽象特性的定义有两种 方式：使用特性工厂函数，或者使用描述符类。后者更灵活，第 20 章会全面讨论。其 实，特性本身就是使用描述符类实现的。不过，这里我们要继续探讨特性，实现一个特性

工厂函数。

但是，在实现特性工厂函数之前，我们要深入理解特性。

### 19.3 特性全解析

虽然内置的 property 经常用作装饰器，但它其实是一个类。在 Python 中，函数和类通

常可以互换，因为二者都是可调用的对象，而且没有实例化对象的 new 运算符，所以调

用构造方法与调用工厂函数没有区别。此外，只要能返回新的可调用对象，代替被装饰的

函数，二者都可以用作装饰器。

property 构造方法的完整签名如下：

property(fget=None, fset=None, fdel=None, doc=None)

所有参数都是可选的，如果没有把函数传给某个参数，那么得到的特性对象就不允许执行

相应的操作。

property 类型在 Python 2.2 中引入，但是直到 Python 2.4 才出现 @ 装饰器句法，因此有那 么几年，若想定义特性，则只能把存取函数传给前两个参数。

不使用装饰器定义特性的“经典”句法如示例 19-18 所示。

示例19-18 bulkfood_v2b.py：效果与示例19-17 —样，只不过没使用装饰器

class LineItem:

def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price

def subtotal(self):

return self.weight * self.price

def get_weight(self): O return self.__weight

def set_weight(self, value): © if value > 0:

self.__weight = value else:

raise ValueError('value must be > 0') weight = property(get_weight, set_weight) ©

❶ 普通的读值方法。

❷ 普通的设值方法。

❸ 构建 property 对象，然后赋值给公开的类属性。

某些情况下，这种经典形式比装饰器句法好；稍后讨论的特性工厂函数就是一例。但是， 在方法众多的类定义体中使用装饰器的话，一眼就能看出哪些是读值方法，哪些是设值方 法，而不用按照惯例，在方法名的前面加上 get 和 set。

类中的特性能影响实例属性的寻找方式，而一开始这种方式可能会让人觉得意外。下一节

会详细说明。

19.3.1 特性会覆盖实例属性

特性都是类属性，但是特性管理的其实是实例属性的存取。

9.9 节说过，如果实例和所属的类有同名数据属性，那么实例属性会覆盖（或称遮盖）类

属性——至少通过那个实例读取属性时是这样。示例 19-19 阐明了这一点。

示例 19-19 实例属性遮盖类的数据属性

\>>> class Class: # O

...    data = 'the class    data attr

...    @property

...    def prop(self):

...    return 'the prop value'

\>>> obj = Class()

\>>> vars(obj) # ©

{}

\>>> obj.data # ©

'the class data attr'

\>>> obj.data = 'bar' # ©

\>>> vars(obj) # ❺

{'data': 'bar'}

\>>> obj.data # ©

'bar'

\>>> Class.data # &

'the class data attr'

❶定义Class类，这个类有两个类属性：data数据属性和prop特性。

❷ vars 函数返回 obj 的 __dict__ 属性，表明没有实例属性。

❸读取obj.data，获取的是Class.data的值。

❹ 为 obj.data 赋值，创建一个实例属性。

❺ 审查实例，查看实例属性。

❻现在读取obj.data，获取的是实例属性的值。从obj实例中读取属性时，实例属性 data 会遮盖类属性 data。

❼ Class.data 属性的值完好无损。

下面尝试覆盖 obj 实例的 prop 特性。接着前面的控制台会话，输入示例 19-20 中的代

#### 码。

示例 19-20 实例属性不会遮盖类特性(接续示例 19-19)

\>>> Class.prop # O

<property object at 0x1072b7408>

\>>> obj.prop # ©

'the prop value'

\>>> obj.prop = 'foo'    # ©

Traceback (most recent call last):

AttributeError: can't set attribute >>> obj.__diet__['prop'] = 'foo'    # ©

\>>> vars(obj) # ©

{ 'data': 'bar','prop': 'foo'}

\>>> obj.prop # ©

'the prop value'

\>>> Class.prop = 'baz'    # ©

\>>> obj.prop # ©

'foo'

❶ 直接从 Class 中读取 prop 特性，获取的是特性对象本身，不会运行特性的读值方

法。

❷ 读取 obj.prop 会执行特性的读值方法。

❸ 尝试设置 prop 实例属性，结果失败。

❹ 但是可以直接把 'prop' 存入 obj.__dict__。

❺ 可以看到， obj 现在有两个实例属性: data 和 prop。

❻ 然而，读取 obj.prop 时仍会运行特性的读值方法。特性没被实例属性遮盖。

❼ 覆盖 Class.prop 特性，销毁特性对象。

❽ 现在， obj.prop 获取的是实例属性。 Class.prop 不是特性了，因此不会再覆盖 obj.prop。

最后再举一个例子，为 Class 类新添一个特性，覆盖实例属性。示例 19-21 接续示例 19-20。

示例 19-21 新添的类特性遮盖现有的实例属性(接续示例 19-20)

❶ obj.data 获取的是实例属性 data。

❷ Class.data 获取的是类属性 data。

❸ 使用新特性覆盖 Class.data。

❹ 现在， obj.data 被 Class.data 特性遮盖了。

❺ 删除特性。

❻ 现在恢复原样， obj.data 获取的是实例属性 data。

本节的主要观点是，obj.attr这样的表达式不会从obj开始寻找attr，而是从 obj.__class__ 开始，而且，仅当类中没有名为 attr 的特性时， Python 才会在 obj 实 例中寻找。这条规则不仅适用于特性，还适用于一整类描述符——覆盖型描述符

(overriding descriptor)。第20章会进一步讨论描述符，那时你会发现，特性其实是覆盖 型描述符。

现在回到特性。各种 Python 代码单元(模块、函数、类和方法)都可以有文档字符串。 下一节说明如何把文档依附到特性上。

19.3.2 特性的文档

控制台中的 help() 函数或 IDE 等工具需要显示特性的文档时，会从特性的 __doc__ 属 性中提取信息。

如果使用经典调用句法，为 property 对象设置文档字符串的方法是传入 doc 参数：

weight = property(get_weight, set_weight, doc='weight in kilograms')

使用装饰器创建 property 对象时，读值方法(有 @property 装饰器的方法)的文档字 符串作为一个整体，变成特性的文档。图 19-2 显示的是从示例 19-22 里的代码中生成的

帮助界面。

图 19-2：在 Python 控制台中执行 help(Foo.bar) 和 help(Foo) 命令时的截图；源码 在示例 19-22 中

示例 19-22 特性的文档

class Foo:

@property def bar(self):

'''The bar attribute''' return self.__dict__['bar']

@bar.setter

def bar(self, value):

self.__dict__['bar'] = value

至此，我们介绍了特性的重要知识。下面回过头来解决前面遇到的问题：保护 LineItem 对象的 weight 和 price 属性，只允许设为大于零的值；但是，不用手动实现两对几乎 一样的读值方法和设值方法。

### 19.4 定义一个特性工厂函数

我们将定义一个名为 quantity 的特性工厂函数，取这个名字是因为，在这个应用中要管

理的属性表示不能为负数或零的量。示例 19-23 是 LineItem 类的简洁版，用到了 quantity 特性的两个实例:一个用于管理 weight 属性，另一个用于管理 price 属性。

示例 19-23 bulkfood_v2prop.py：使用特性工厂函数 quantity

class LineItem:

weight = quantity('weight') O price = quantity('price') ©

def __init__(self, description, weight, price): self.description = description self.weight = weight © self.price = price

def subtotal(self):

return self.weight * self.price ©

❶ 使用工厂函数把第一个自定义的特性 weight 定义为类属性。

❷ 第二次调用，构建另一个自定义的特性， price。

❸ 这里，特性已经激活，确保不能把 weight 设为负数或零。

❹ 这里也用到了特性，使用特性获取实例中存储的值。

前文说过，特性是类属性。构建各个 quantity 特性对象时，要传入 LineItem 实例属性

的名称，让特性管理。可惜，这一行要两次输入单词 weight：

weight = quantity('weight')

这里很难避免重复输入，因为特性根本不知道要绑定哪个类属性名。记住，赋值语句的右 边先计算，因此调用 quantity() 时， weight 类属性还不存在。

如果想改进quantity特性，避免用户重复输入属性名，那么对元编程来说是

个挑战。第 20 章会介绍一种变通方法，真正的解决方法在第 21 章说明，因为要么得

使用类装饰器，要么得使用元类。

示例 19-24 列出 quantity 特性工厂函数的实现。 13

I 13这段代码改编自David Beazley与Brian K. Jones的《Python Cookbook (第3版)中文版》一书中的“9.21避免出现重 复的属性方法”一节。

示例 19-24 bulkfood_v2prop.py： quantity 特性工厂函数

def quantity(storage_name): O

def qty_getter(instance): ©

return instance._diet_[storage_name] ©

def qty_setter(instance, value): © if value > 0:

instance._diet_[storage_name] = value ❺ else:

raise ValueError('value must be > 0') return property(qty_getter, qty_setter) ©

❶ storage_name 参数确定各个特性的数据存储在哪儿；对 weight 特性来说，存储的名 称是 'weight'。

❷qty_getter函数的第一个参数可以命名为self，但是这么做很奇怪，因为 qty_getter函数不在类定义体中；instance指代要把属性存储其中的Lineltem实

例。

❸qty_getter引用了 storage_name，把它保存在这个函数的闭包里；值直接从 instance.__dict__ 中获取，为的是跳过特性，防止无限递归。

❹ 定义 qty_setter 函数，第一个参数也是 instance。

❺ 值直接存到 instance.__dict__ 中，这也是为了跳过特性。

❻ 构建一个自定义的特性对象，然后将其返回。

示例 19-24 中值得仔细分析的代码是与 storage_name 变量相关的部分。使用传统方式定 义特性时，用于存储值的属性名硬编码在读值方法和设值方法中。但是，这里的

qty_getter 和 qty_setter 函数是通用的，要依靠 storage_name 变量判断从 __dict__ 中获取哪个属性，或者设置哪个属性。每次调用 quantity 工厂函数构建属性 时，都要把 storage_name 参数设为独一无二的值。

在工厂函数的最后一行，我们使用 property 对象包装 qty_getter 和 qty_setter 函 数。需要运行这两个函数时，它们会从闭包中读取storage_name，确定从哪里获取属性 的值，或者在哪里存储属性的值。

在示例 19-25 中，我创建并审查了一个 LineItem 示例，说明存储值的是哪个属性。

示例 19-25 bulkfood_v2prop.py： quantity 特性工厂函数

O通过特性读取weight和price,这会遮盖同名实例属性。

©使用vars函数审查nutmeg实例，查看真正用于存储值的实例属性。

注意，工厂函数构建的特性利用了 19.3.1节所述的行为：weight特性覆盖了 weight实 例属性，因此对 self.weight 或 nutmeg.weight 的每个引用都由特性函数处理，只有

直接存取 __dict__ 属性才能跳过特性的处理逻辑。

示例 19-25 中的代码有点难理解，不过够简洁，与示例 19-17 中使用装饰器声明读值方法 和设值方法的代码行数一样，但是那里只定义了 weight 特性。示例 19-23 中定义的

LineItem 类没有干扰人的读值方法和设值方法，看起来舒服多了。

在真实的系统中，分散在多个类中的多个字段可能要做同样的验证，此时最好把 quantity 工厂函数放在实用工具模块中，以便重复使用。最终可能要重构那个简单的工 厂函数，改成更易扩展的描述符类，然后使用专门的子类执行不同的验证。在第 20 章 中，我们会这么做。

下面要分析删除属性的问题，以此结束对特性的讨论。

### 19.5 处理属性删除操作

学过 Python 教程，我们知道，对象的属性可以使用 del 语句删除

del my_object.an_attribute

#### 其实，使用 Python 编程时不常删除属性，通过特性删除属性更少见。但是， Python 支持 这么做，我可以虚构一个示例，演示这种处理方式。

定义特性时，可以使用 @my_propety.deleter 装饰器包装一个方法，负责删除特性管理 的属性。下面兑现承诺，虚构一个示例，说明如何定义特性删值方法，如示例 19-26 所

示。

#### 示例19-26 blackknight.py：灵感来自电影《巨蟒与圣杯》中的黑衣骑士角色

class BlackKnight:

def __init__(self):

self.members = ['an arm', 'another arm',

'a leg', 'another leg']

self.phrases = ["'Tis but a scratch.",

"It's just a flesh wound.",

"I'm invincible!",

"All right, we'll call it a draw."]

@property

def member(self):

print('next member is:') return self.members[0]

@member.deleter

def member(self):

text = 'BLACK KNIGHT (loses {})\n-- {}'

print(text.format(self.members.pop(0), self.phrases.pop(0)))

#### blackknight.py 脚本的 doctest 在示例 19-27 中。

#### 示例19-27 blackknight.py：示例19-26的doctest (黑衣骑士从不屈服)

\>>> knight = BlackKnight()

\>>> knight.member

next member is:

'an arm'

\>>> del knight.member

BLACK KNIGHT (loses an arm)

-- 'Tis but a scratch.

\>>> del knight.member

BLACK KNIGHT (loses another arm)

-- It's just a flesh wound.

\>>> del knight.member BLACK KNIGHT (loses a leg)

-- I'm invincible!

\>>> del knight.member BLACK KNIGHT (loses another leg)

-- All right, we'll call it a draw.

在不使用装饰器的经典调用句法中， fdel 参数用于设置删值函数。例如，在

BlackKnight 类的定义体中可以像下面这样创建 member 特性：

member = property(member_getter, fdel=member_deleter)

如果不使用特性，还可以实现低层特殊的 __delattr__ 方法处理删除属性的操作，参见 19.6.3 节。留给喜欢拖延的读者一个练习：虚构一个类，定义 __delattr__ 方法。

特性是个强大的功能，不过有时更适合使用简单的或底层的替代方案。在本章的最后一节 中，我们将回顾 Python 为动态属性编程提供的部分核心 API。

### 19.6 处理属性的重要属性和函数

本章及本书前面的章节多次用到 Python 为处理动态属性而提供的内置函数和特殊的方 法。这些函数和方法的文档散布在官方文档中，因此我专门写了一节集中介绍它们。

19.6.1 影响属性处理方式的特殊属性

后面几节中的很多函数和特殊方法，其行为受下述 3 个特殊属性的影响。

__class__

对象所属类的引用(即 obj.__class__ 与 type(obj) 的作用相同)。 Python 的某些 特殊方法，例如 __getattr__，只在对象的类中寻找，而不在实例中寻找。

__dict__

一个映射，存储对象或类的可写属性。有 __dict__ 属性的对象，任何时候都能随意

设置新属性。如果类有 __slots__ 属性，它的实例可能没有 __dict__ 属性。参见下面 对 __slots__ 属性的说明。

__slots__

类可以定义这个这属性，限制实例能有哪些属性。 __slots__ 属性的值是一个字符

串组成的元组，指明允许有的属性。 14 如果 __slots__ 中没有 '__dict__'，那么该类

的实例没有 __dict__ 属性，实例只允许有指定名称的属性。

14Alex Martelli指出，__slots__属性的值虽然可以是一个列表，但是最好始终使用元组，因为处理完类的定义体之后

再修改 __slots__ 列表没有任何作用，所以使用可变的序列容易让人误解。

19.6.2 处理属性的内置函数

下述 5 个内置函数对对象的属性做读、写和内省操作。

dir([object])

列出对象的大多数属性。官方文档

( [https://docs.python.org/3/library/functions.html#dir](https://docs.python.org/3/library/functions.html%23dir) )说， dir 函数的目的是交互式使用， 因此没有提供完整的属性列表，只列出一组“重要的”属性名。 dir 函数能审查有或没有

__dict__ 属性的对象。 dir 函数不会列出 __dict__ 属性本身，但会列出其中的 键。 dir 函数也不会列出类的几个特殊属性，例如 __mro__、__bases__ 和 __name__。 如果没有指定可选的 object 参数， dir 函数会列出当前作用域中的名称。 getattr(object, name[, default])

从 object 对象中获取 name 字符串对应的属性。获取的属性可能来自对象所属的类 或超类。如果没有指定的属性， getattr 函数抛出 AttributeError 异常，或者返回 default 参数的值(如果设定了这个参数的话)。

hasattr(object, name)

如果object对象中存在指定的属性，或者能以某种方式(例如继承)通过object 对象获取指定的属性，返回True。文档

( [https://docs.python.org/3/library/functions.html#hasattr](https://docs.python.org/3/library/functions.html%23hasattr) )说道： “这个函数的实现方法是调

用 getattr(object, name) 函数，看看是否抛出 AttributeError 异常。 ” setattr(object, name, value)

把object对象指定属性的值设为value，前提是object对象能接受那个值。这个 函数可能会创建一个新属性，或者覆盖现有的属性。

vars([object])

返回object对象的__dict__属性；如果实例所属的类定义了 __slots__属性， 实例没有 __dict__ 属性，那么 vars 函数不能处理那个实例(相反， dir 函数能处理这 样的实例)。如果没有指定参数，那么 vars() 函数的作用与 locals() 函数一样：返回

表示本地作用域的字典。

19.6.3处理属性的特殊方法

在用户自己定义的类中，下述特殊方法用于获取、设置、删除和列出属性。

使用点号或内置的 getattr、hasattr 和 setattr 函数存取属性都会触发下述列表中相 应的特殊方法。但是，直接通过实例的 __dict__ 属性读写属性不会触发这些特殊方法 ——如果需要，通常会使用这种方式跳过特殊方法。

Python 文档“Data model” 一章中的“3.3.9. Special method lookup”一节 ([https://docs.python.org/3/reference/datamodel.html#special-method-1 ookup](https://docs.python.org/3/reference/datamodel.html%23special-method-lookup))警告说：

对用户自己定义的类来说，如果隐式调用特殊方法，仅当特殊方法在对象所属的类型

上定义，而不是在对象的实例字典中定义时，才能确保调用成功。

也就是说，要假定特殊方法从类上获取，即便操作目标是实例也是如此。因此，特殊方法

不会被同名实例属性遮盖。

在下述示例中，假设有个名为 Class 的类， obj 是 Class 类的实例， attr 是 obj 的属 性。

不管是使用点号存取属性，还是使用 19.6.2 节列出的某个内置函数，都会触发下述特殊方 法中的一个。例如， obj.attr 和 getattr(obj, 'attr', 42) 都会触发 Class.__getattribute__(obj, 'attr') 方法。

__delattr__(self, name)

只要使用 del 语句删除属性，就会调用这个方法。例如， del obj.attr 语句触发 Class.__delattr__(obj, 'attr') 方法。

__dir__(self)

把对象传给 dir 函数时调用，列出属性。例如， dir(obj) 触发 Class.__dir__(obj) 方法。

__getattr__(self, name)

仅当获取指定的属性失败，搜索过 obj、Class 和超类之后调用。表达式 obj.no_such_attr、getattr(obj, 'no_such_attr') 和 hasattr(obj, 'no_such_attr') 可能会触发 Class.__getattr__(obj, 'no_such_attr') 方法，但 是，仅当在 obj、Class 和超类中找不到指定的属性时才会触发。

__getattribute__(self, name)

尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法 时除外。点号与 getattr 和 hasattr 内置函数会触发这个方法。调用 __getattribute__ 方法且抛出 AttributeError 异常时，才会调用 __getattr__ 方 法。为了在获取 obj 实例的属性时不导致无限递归， __getattribute__ 方法的实现要 使用 super().__getattribute__(obj, name)。

__setattr__(self, name, value)

尝试设置指定的属性时总会调用这个方法。点号和 setattr 内置函数会触发这个方 法。例如， obj.attr = 42 和 setattr(obj, 'attr', 42) 都会触发 Class.__setattr__(obj, ‘attr', 42) 方法。

其实，特殊方法__getattribute__和__setattr__不管怎样都会调用，几 乎会影响每一次属性存取，因此比 __getattr__ 方法(只处理不存在的属性名)更

难正确使用。与定义这些特殊方法相比，使用特性或描述符相对不易出错。

我们对特性、特殊方法和其他动态属性编程技术的讨论到此结束。

### 19.7 本章小结

本章的话题是动态属性编程。我们首先举了几个实例，定义了几个简单的类，简化处理 JSON 数据源的方式。第一个示例是 FrozenJSON 类，把嵌套的字典和列表转换成嵌套的 FrozenJSON 实例和实例列表。 FrozenJSON 类的代码展示了如何使用特殊的 __getattr__ 方法在读取属性时即时转换数据结构。 FrozenJSON 类的最后一版展示了 如何使用 __new__ 构造方法把一个类转换成一个灵活的对象工厂函数，不受实例本身的 限制。

然后，我们把 JSON 源转换成一个 shelve.Shelf 数据库，把序列化的 Record 实例存在 里面。第 1 版 Record 类只有几行代码，介绍了“集束”惯用法：使用传给 __init__ 方法

的关键字参数，调用 self.__dict__.update(**kwargs) 构建任意属性。这个示例的第 2 版对 Record 类做了扩展：一个是 DbRecord 类，集成数据库操作；另一个是 Event

类，通过特性自动获取所链接的记录。

接着，本章讨论了特性。我们定义的 LineItem 类中有个特性，确保 weight 属性的值不

能是对业务没有意义的负数或零。然后，我们深入说明了特性的句法和语义。随后，创建

了一个特性工厂函数，在不定义多个读值方法和设值方法的前提下，对 weight 和 price

属性做相同的验证。那个特性工厂函数用到了几个精妙的概念，例如闭包和被特性覆盖的

实例属性，提供了优雅的通用方案，代码行数与用手工编码的特性来验证单个属性的一样

多。

最后，我们简要说明了如何使用特性处理删除属性的操作，随后概览了 Python 核心语言 为支持属性元编程而提供的重要的特殊属性、内置函数和特殊方法。

### 19.8延伸阅读

属性处理和内置的内省函数的官方文档在Python标准库文档的第2章中，题为“Built-in Functions” （<https://docs.python.org/3/library/functions.html>） 。相关的特殊方法和特殊的 __slots__ 属性在 Python 语言参考手册中的“3.3.2. Customizing attribute access”一节

（[https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access](https://docs.python.org/3/reference/datamodel.html%23customizing-attribute-access)）里说明。调 用特殊方法会跳过实例的语意原因在“3.3.9. Special method lookup”一节    、

（[https://docs.python.org/3/reference/datamodel.html#special-method-lookup](https://docs.python.org/3/reference/datamodel.html%23special-method-lookup)）中说明。在 Python 标准库文档的第 4 章“Built-in Types”里，“4.13. Special Attributes”一节

（[https://docs.python.org/3/library/stdtypes.html#special-attributes](https://docs.python.org/3/library/stdtypes.html%23special-attributes)）说明了 __class__ 和 __dict__ 属性。

David Beazley与Brian K. Jones的《Python Cookbook （第3版）中文版》一书中有几个诀

窍涉及本章的话题，不过我要重点提出三个：“8.8 在子类中扩展属性”，解决了在继承自

超类的特性中覆盖方法这个棘手问题； “8.15 委托属性的访问”，实现了一个代理类，展示 了本书 19.6.3 节所列的大多数特殊方法；还有出色的“9.21 避免出现重复的属性方法”一 节，示例 19-24 中定义的特性工厂函数就以那一节为基础。

Alex Martelli写的《Python技术手册（第2版）》只涵盖了 Python 2.5，不过基础知识也适 用于 Python 3。他写书的风格严谨而客观，讲到特性时，只用了 3 页，但这是由于那本书 采用了符合逻辑的行文方式：之前的 15 页已经对 Python 的类做了详尽的说明，包括描述

符，而特性就是使用描述符实现的。因此讲到特性时，他可以在 3 页的篇幅中发表很多见 解，例如本章开篇引用的那句话。

本章开头引用的统一访问原则定义出自 Bertrand Meyer 的优秀著作 Object-Oriented Software Construction, Second Edition （Prentice-Hall 出版社）。这本书超过 1250 页，我承 认我没有读完，不过前六章对面向对象分析和设计相关概念的介绍是我见过最好的之一，

第11章介绍了契约式设计（Meyer发明了这种设计方法，创造了这个术语），第35章阐 述了他对重要的面向对象语言的评价，包括 Simula、Smalltalk、CLOS （Lisp 的面向对象 扩展）、Objective-C、C++和Java，还对其他语言做了简要评述。他还发明了伪伪代码

（pseudo- pseudocode），直到那本书的最后一页他才披露，全书用于编写伪代码的句法 其实出自 Eiffel 语言。

杂谈

站在美学的角度来看，Meyer提出的统一访问原则（Unifrom Access Principle，喜欢 简称的人有时称之为UAP）很吸引人。作为使用API的程序员，我不应该关心 coconut.price 只是获取数据属性还是执行计算。但是，作为消费者和公民，我应 该关心：在电子商务发达的今天， coconut.price 的值通常取决于这个问题由谁提 出，因此它绝不仅仅是个数据属性。其实，如果查询来自网店外部（例如比价引 擎），价格通常会低一些。显然，这对喜欢浏览特定网店的忠实消费者来说，利益受 到了损害。但是我不同意。

前一段离题了，可是却提出了与编程有关的问题：虽然统一访问原则在理想的世界中 完全合理，但在现实中， API 的用户可能需要知道读取 coconut.price 是否太耗资

源或时间。Ward Cunningham 的维基（http://c2.com/cgi/wiki7WelcomeVisitors）对软件

工程方面的话题有很多独到的见解，他对统一访问原则的功过也做了富有洞察力的论

述（http://c2.com/cgi/wiki7UniformAccessPrinciple）。

在面向对象编程语言中，是否遵守统一访问原则通常体现在句法上：究竟是读取公开

的数据属性，还是调用读值方法和设值方法。

Smalltalk 和 Ruby 使用简单而优雅的方式解决这个问题：根本不支持公开的数据属 性。在这两门语言中，所有实例属性都是私有的，因此必须通过方法来存取。不过， 这两门语言的句法把这个过程变得毫不费力：在 Ruby 中， coconut.price 会调用读

值方法 price;在 Smalltalk 中，只需使用 coconut price。

Java 采用的是另一种方式，让程序员在四种访问级别修饰符中选择。 [1](#bookmark27) 不过，普通 大众并不认同 Java 设计者制定的这种句法。 Java 世界的人都认为，属性应该是私有

的，但是每一次都要写出private，因为这不是默认的访问级别。如果所有属性都

是私有的，那么从类外部访问属性就必须使用存取方法。 Java IDE 提供了自动生成存 取方法的快捷方式。但是，六个月后不得不阅读代码时， IDE 没有多大帮助。我们要 在众多什么也没做的存取方法中找出所需的那一个，添加实现某些业务逻辑所需的

值。

Alex Martelli 把存取方法称为“愚蠢的惯用法”，这道出了 Python 社区中大多数人的心

声。他举了下面两个例子，外观差异很大，但是作用相同： [2](#bookmark28)

someInstance.widgetCounter += 1 # 而不用……

someInstance.setWidgetCounter(someInstance.getWidgetCounter() + 1)

设计API时，我有时会想，能否把没有参数（除了 self）、返回一个值（除了 None）的纯函数（即没有副作用）替换成只读特性。在本章 中， LineItem.subtotal 方法（如示例 19-23 所示）就可以替换成只读特性。当 然，用于修改对象的方法（如my_list.clear（））不在此列。把这样的方法变成特 性是个糟糕的想法，因为直接访问 my_list.clear 就会删除列表中的内容。

在 GPIO 库 Pingo.io （<http://www.pingo.io/docs/>， 3.4.2 节提过）中，多数用户级别的 API 都基于特性实现。例如，为了读取模拟针脚的当前值，用户要编写 pin.value； 为了设置数字针脚的模式，要写成pin.mode = OUT。在背后，读取模拟针脚的值或 设置数字针脚的模式可能涉及大量代码，这取决于具体的主板驱动。我们决定在

Pingo 中使用特性，是因为我们想让 API 用起来舒服，即便是在 iPython

Notebook （<http://ipython.org/notebook.html>）等交互环境中也是如此，而且我们觉得

pin.mode = OUT 看起来和输入起来都比 pin.set_mode（OUT） 容易。

我觉得 Smalltalk 和 Ruby 的处理方式很简洁，但也认为 Python 的处理方式比 Java 更

合理。一开始，我们可以从简单的方式入手，把数据成员定义为公开的属性，因为我

们知道这些属性可以使用特性（或下一章讨论的描述符）来包装。

__new__ 方法比 new 运算符好

在 Python 中还有一处体现了统一访问原则(或者它的变体)：函数调用和对象实例

化使用相同的句法-my_obj = foo()，其中foo是类或其他可调用的对象。

受 C++ 句法影响的其他语言提供了 new 运算符，致使实例化不像是调用。大多数时 候， API 的用户不关心 foo 是函数还是类。直到最近，我才意识到， property 是个 函数。在常规的用法中，这没什么区别。

把构造方法替换成工厂方法有很多充足的理由。 [1](#bookmark27) [2](#bookmark28) [3](#bookmark29) 一个重要的原因是，通过返回之

前构建的实例，限制实例的数量(体现了单例模式)。有个相关的功能是，缓存构建

过程开销大的对象。此外，有时便于根据指定的参数返回不同类型的对象。

定义构造方法较为简单；提供工厂方法虽然增加了灵活性，但是要编写更多的代码。 在有 new 运算符的语言中， API 的设计者必须提前决定：究竟是坚持使用简单的构造 方法，还是投入工厂方法的怀抱。如果一开始选择错了，那么修正的代价可能很大 ——这一切都因为 new 是运算符。

有时可能更适合走另一条路，把简单的函数换成类。

在 Python 中，很多情况下类和函数可以互换。这不仅是因为 Python 没有 new 运算

符，还因为有特殊的 __new__ 方法，可以把类变成工厂方法，生成不同类型的对象

(如 19.1.3 节所述)，或者返回事先构建好的实例，而不是每次都创建一个新实例。

[如果](https://www.python.org/dev/peps/pep-0008/%23class-names)[“PEP 8—Style Guide for Python Code” (https://www.python.org/dev/peps/pep-](https://www.python.org/dev/peps/pep-0008/%23class-names)0008/#class-names)不推荐类名使用驼峰式(CamelCase)，那么函数与类的对偶性

更易于使用。不过，标准库中有很多类的名称是小写的(例如

property、str、defaultdict，等等)。因此，使用小写的类名可能是个特色， 而不是缺陷。但是，不管怎么看， Python 标准库在类名大小写上的不一致会导致可用 性问题。

虽然调用函数与调用类没有区别，但是最好知道哪个是哪个，因为类还有一个功能： 子类化。因此，我编写的每个类都使用驼峰式名称，而且希望 Python 标准库中的所 有类也使用这一约定。我在盯着你呢， collections.OrderedDict 和 collections.defaultdict。

[1](#footnote1)

包括没有名称的默认级别，Java 教程(<http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html>)称其为“包级

私有”。

[2](#footnote2)

《Python技术手册(第2版)》第101页。

[3](#footnote3)

我将要提到的原因出自Jonathan Amsterdam发布在Dr. Dobbs Journal中的一篇文章，题为“Java's new Considered Harmful” ( [http://www. drdobbs. com/javas-new-considered-harmful/184405016](http://www.drdobbs.com/javas-new-considered-harmful/184405016))，以及 Joshua Bloch 写的获奖图书 Effective

Java 中的第一条， “考虑用静态工厂方法代替构造函数”。
