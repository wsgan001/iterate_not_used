据库编程

![img](07Python38c3160b-3002.jpg)



本章主题

•介绍

•数据库和 Python RDBMSs, ORMs, and Python • Python数据库应用程序程序员接口(DB-API)

•关系数据库(RDBMSs)

•对象-关系管理器(ORMs)

•关系模块

•练习

![img](07Python38c3160b-3003.jpg)



![img](07Python38c3160b-3004.jpg)



![img](07Python38c3160b-3005.jpg)



![img](07Python38c3160b-3006.jpg)



![img](07Python38c3160b-3007.jpg)



![img](07Python38c3160b-3008.jpg)



![img](07Python38c3160b-3009.jpg)



![img](07Python38c3160b-3010.png)



本章的主题是如何通过Python访问数据库。前面我们已经了解了简单持久存储，但是在更多场 合下，我们的应用程序需要的是一个功能齐全的关系型数据库。

### 21.1 介绍

![img](07Python38c3160b-3011.jpg)



![img](07Python38c3160b-3012.jpg)



### 21.1.1 持久存储

在任何的应用程序中，都需要持久存储。一般说来，有三种基本的存储机制：文件、关系型数 据库或其它的一些变种，例如现有系统的API，0RM、文件管理器、电子表格、配置文件等等。

在前面的章节中，我们研宄了通过基于常规文件的 Python 和 DBM 接口来实现持久存储, 比如 *dbm, dbhas/bsddb文件，shelve（pickle和DBM的结合）.这些接口都提供了类似字典的对象接口。 本章的主题是如何在中大型项目中使用关系型数据库.（对这些项目而言, 那些接口力不从心）

### 21.1.2基本的数据库操作和SQL语言

在深入主题之前，下面先简单介绍一下基本的数据库概念和结构化查询语言（SQL）。如果你有 足够的经验, 可以跳过, 也可以通过阅读正文来复习一下.

#### 底层存储

数据库的底层存储通常使用文件系统, 它可以是普通操作系统文件、专用操作系统文件,甚至有 可能是磁盘分区。

#### 用户界面

![img](07Python38c3160b-3013.jpg)



大部分的数据库系统会提供一个命令行工具来执行 SQL 命令和查询，当然也有一些使用图形界 面的漂漂亮亮的客户端程序来干同样的事。

#### 数据库

关系型数据库管理系统通常通常都支持多个数据库，例如销售库、市场库、客户支持库等等. 如 果你使用的关系数据库管理系统是基于服务器的，这些数据库就都在同一台服务器上 （一些简单的

关系型数据库没有服务器，如sqlite）.本章的例子中，MySQL是一种基于服务器的关系数据库管 理系统（只要服务器在运行，它就一直在等待运行指令），SQLite和Gadfly则是另一种轻量型的基 于文件的关系数据库（它们没有服务器）。

#### 组件

你可以将数据库存储想像为一个表格， 每行数据都有一个或多个字段对应着数据库中的列. 每 个表每个列及其数据类型的集合构成数据库结构的定义. 数据库能够被创建， 也可以被删除. 表也

一样.往数据库里增加一条记录称为插入（inserting） —条记录，修改库中一条已有的记录则称 为更新（updating），删除表中已经有的数据行称为删除（deleting）.这些操作通常作为数据库操 作命令来提交.从一个数据库中请求符合条件的数据称为查询（querying）.当你对一个数据库进行

查询时， 你可以一步取回所有符合条件的数据， 也可以循环逐条取出每一行. 有些数据库使用游标 的概念来表示 SQL 命令， 查询， 取回结果集等等.

#### SQL

数据库命令和查询操作需要通过SQL语句来执行.不是所有的数据库都使用SQL，但所有主流 的关系型数据库都使用SQL.下面是一些SQL命令的例子.绝大多数数据库被配置为大小写不敏感， 除了数据库操作命令以外.被广为接受的书写SQL的基本风格是关键字大写.绝大多数命令行程序

要求用一个分号来结束一条SQL语句.

#### 创建数据库

CREATE DATABASE test;

GRANT ALL ON test.* to user（s）;

第一行创建一个名为“test”的数据库，第二行将该数据库的权限赋给具体的用户（或者全部 用户），以便它们可以执行下面的数据库操作。

#### 选择要使用的数据库

USE test;

如果在登录数据库时没有指定要使用那个数据库，这条简单的语句就可以指定你打算访问的数

据库.

删除数据库

DROP DATABASE test;

这条短短的语句具有极大的威力. 它用来删除数据库(包括数据库中所有的表及表中的数据).

在输入完这条语句按下回车之前, 好好想想你是否真的打算这么做.

#### 创建表

CREATE TABLE users (login VARCHAR(8), uid INT, prid INT);

这个语句用于创建表users，它有一个类型为字符串的列login和两个类型为整数的字段uid 和 prid。

#### 删除表

DROP TABLE users;

这个简单的语句删除数据库中的一个表和它的所有数据。

#### 插入行

INSERT INTO users VALUES('leanna', 311, 1);

INSERT语句用来向数据库中添加新的数据行.语句中必须指定要插入的表及该表中各个字段的 值。上例中，表名是users,字符串’leanna'对应着login字段，311和1分别对应着uid和 prid。

#### 更新行

UPDATE users SET prid=4 WHERE prid=2;

UPDATE users SET prid=1 WHERE uid=311;

UPDATE 语句用来改变数据库中的已有记录. 使用 SET 关键字来指定你要修改的字段及新值, 你可以指定条件来筛选出需要更新的记录.在第一个例子中, 所有 prid 字段值为 2 的记录, 其 prid 字段的值都变更为 4. 在第二个例子里, uid 字段值为 311 的用户, 其 prid 字段的新值被 置为 1.

#### 删除行

DELETE FROM users WHERE prid=%d;

DELETE FROM users;

DELETE FROM 命令用来删除数据. 必须指定你要删除的数据所在表名, 如果未提供(可选的)筛 选条件, 就象第二个例子一样, 表中所有的数据都会被删除.

现在你已经了解数据库的基本概念, 有了这些基础, 本章余下的部分学起来会更加容易. 如果 需要进一步了解数据库知识, 市面是有数不清的数据库书籍可以选择.

### 21.1.3 数据库 和 Python

下面我们要详细了解Python数据库API. Python能够直接通过数据库接口，也可以通过ORM

（不需要自己书写SQL）来访问关系数据库.

类似数据库原理, 并发能力, 视图, 原子性, 数据完整性, 数据可恢复性, 还有左连接, 触发 器, 查询优化, 事务支持, 及存储过程等等, 这些东西, （市面上）有数不清的资源可供参考. 本章 不讨论这些主题, 我们将从一个 python 应用程序开始, 了解在 python 框架下如何将数据保存到 数据库, 如果将数据从数据库中取出来. 之后你就可以决定哪种方式适用于你手头的项目. 通过学 习示例代码，你可以立马动手把某种数据库整合到你的python应用程序当中.

在python世界里，无需怀疑，与数据库协同工作已经是几乎所有应用程序的核心部分.在本 章中，我们将不仅仅使用"万能"的Python标准库.尽管我们需要从标准库开始.

作为一个软件工程师, 在你的职业生涯中, 你可能永远不需要学习数据库知识: 如何使用命令 行工具，如何使用SQL?如何添加和更新数据？等等等等.如果python是你的编程工具，为你的 python应用添加数据库支持易如反掌.下面我们先来介绍一下Python DB-API,然后给出使用这个 标准的例子.

我们的例子会使用开源的数据库系统. 不过我们不会去讨论开源产品好还是商业产品更好. 要 适应其它的数据库也相当容易, 需要特别提到的是 Aaron Watter 的 Gadfly 数据库, 一个完全由 Python代码写成的数据库系统.

从python中访问数据库需要接口程序.接口程序是一个python模块，它提供数据库客户端 库（通常是C语言写成的）的接口供你访问.需要提到一点，所有Python接口程序都一定程度上遵

守 Python DB-API 规范. 这也是本章的第一个主要主题.

图21.1 演绎了 Python 数据库应用程序的结构（包括使用和不使用 ORM）. 你可以看到 DB-API 是数据库客户端 C 库的接口.

图 21-1 数据库和应用程序之间的多层通讯.第一个盒子一般是 C/C++ 程序, 你的程序通过 DB-API兼容接口程序访问数据库.0RM通过程序处理数据库细节来简化数据库开发.

![img](07Python38c3160b-3021.jpg)



![img](07Python38c3160b-3022.jpg)



![img](07Python38c3160b-3023.jpg)



![img](07Python38c3160b-3024.jpg)



![img](07Python38c3160b-3025.jpg)



### 21.2 Python数据库应用程序 程序员接口（DB-API）

去哪儿找一个合适的接口访问数据库? 很简单， 去 python.org 找到数据库主题那一节， 你会 发现所有支持DB-API 2.0的各种数据库模块，文档，SIG等等.从那时起，DB-API被移到PEP 249 中（这个PEP废弃了老的DB-API 1.0，也就是PEP248标准）.那么，什么是DB-API ?

DB-API是一个规范.它定义了一系列必须的对象和数据库存取方式，以便为各种各样的底层数 据库系统和多种多样的数据库接口程序提供一致的访问接口.象绝大多数社区成果一样，这个API 的产生来自于强烈的需求.

在"旧社会"， 不同的人为各种各样的数据库实现了各种各样的数据库接口程序. 同一个轮子被 不同的人一遍又一遍的重复发明. 这些接口由不同的人在不同的时间实现， 功能接口各不兼容. 这 意味着使用这些接口的程序必须自定义他们选择的接口模块. 当这个接口模块变化时， 应用程序的 代码也必须随之更新.

一个处理Python数据库事务的特殊事物小组（SIG，special interest group）因此诞生，

最后.DB-API 1.0问世.DB-API为不同的数据库提供了一致的访问接口，在不同的数据库之间移

H植代码成为一件轻松的事情（一般来说，只修要修改几行代码）.接下来你会看到这样的例子.    H

### 21.2.1模块属性

DB-API规范里的以下特性和属性必须提供.一个DB-API兼容的模块必须定义下表Table 21.1 中定义的所有全局属性.

#### 数据属性

apilevel

apilevel这个字符串（不是浮点数）表示这个DB-API模块所兼容的DB-API最高版本号.如果 "1.0"， "2.0"， 如果未定义， 则默认是 "1.0";

表21.1 DB-API模块属性



属性名

apilevel

threadsafety

paramstyle

connect()



描述

DB-API模块兼容的DB-API版本号 线程安全级别

该模块支持的SQL语句参数风格 连接函数

异常（参见表21.4）



![img](07Python38c3160b-3027.jpg)



![img](07Python38c3160b-3028.jpg)



![img](07Python38c3160b-3029.jpg)



![img](07Python38c3160b-3030.jpg)



![img](07Python38c3160b-3031.jpg)



#### threadsafety

threadsafety 这是一个整数， 取值范围如下

•    0:不支持线程安全，多个线程不能共享此模块

•    1:初级线程安全支持：线程可以共享模块，但不能共享连接

•    2:中级线程安全支持线程可以共享模块和连接，但不能共享游标

•    3:完全线程安全支持线程可以共享模块，连接及游标.

如果一个资源被共享， 就必需使用自旋锁或者是信号量这样的同步原语对其进行原子目标锁定 对这个目标来说， 磁盘文件和全局变量都不可靠， 并且有可能妨碍 .

mutex（互斥量）的操作.参阅threading模块或第16章（多线程编程）来了解如何使用锁.

#### paramstyle

DB-API支持多种方式的SQL参数风格.这个参数是一个字符串，表明SQL语句中字符串替代的 方式. （参阅表21.2）

#### 函数属性

![img](07Python38c3160b-3032.jpg)



connect 方法生成一个 connect 对象， 我们通过这个对象来访问数据库. 符合标准的模块都 会实现 connect 方法. 表21.3列出了 connect 函数的参数.



![img](07Python38c3160b-3033.jpg)



![img](07Python38c3160b-3034.jpg)



表21.2 数据库参数风格

| Patameter |                      |                    |
| --------- | -------------------- | ------------------ |
| 凤格      | 描述                 | 示例               |
| 数字      | 数字位置成格         | WHERE name=:1      |
| 命名      | 命名参数成格         | VJHERE name=: name |
| pyformat  | pyAhon字典格式转换   | WHERE name=%(name  |
| 问号      | 问号成格             | WHERE name=?       |
| format    | 标准ABSI    格式转换 | VJHERE name=%s     |

数据库连接参数可以以一个 DSN 字符串的形式提供， 也可以以多个位置相关参数的形式提供 （如果你明确知道参数的顺序的话）， 也可以以关键字参数的形式提供. 下面是一个来自 PEP 249 的 使用 connect（） 的例子:

connect（dsn='myhost:MYDB'，user='guido'，password='234$'）

使用DSN字符串还是独立参数？这要看你连接的是哪种数据库.举例来说，如果你使用类似



![img](07Python38c3160b-3036.jpg)



ODBC 或 JDBC 的 API, 你就应该使用 DSN 字符串. 如果你直接访问数据库, 你就会更倾向于使用 独立参数. 另一个使用独立参数的原因是, 很多数据库接口程序还不支持 DSN 参数. 下面是一个 非 DSN 的例子.

表 21.3 connect() 函数 属性



参数

user

password

host

database

dsn



描述

Username Password Hostname Database name Data source name



connect()调用.注意不是所有的接口程序都是严格按照规范实现的.MySQLdb就使用了 db参 数而不是规范推荐的 database 参数来表示要访问的数据库.

•    MySQLdb.connect(host二'dbserv'，db二'inv'，user二'smith')

•    PgSQL.connect(database二'sales')

•    psycopg.connect(database二'template1'，user二'pgsql')

•    gadfly.dbapi20.connect('csrDB'，'/usr/local/database')

•    sqlite3.connect('marketing/test')

#### 异常

兼容标准的模块也应该提供这些异常类. 见表 21.4

### 21.2.2 连接对象

要与数据库进行通信, 必须先和数据库建立连接. 连接对象处理命令如何送往服务器, 以及如 何从服务器接收数据等基础功能. 连接成功(或一个连接池)后你就能够向数据库服务器发送请求, 得到响应.



![img](07Python38c3160b-3038.jpg)



表21.4 DB-API 异常类



异常

Warning

Error

InterfaceError

DatabaseError

DataError

OperationalError

IntegrityError

InternalError

ProgrammingError



描述

警告异常基类

错误异常基类

数据库接口错误

数据库错误

理数据时出错

数据库执行命令时出错

数据完整性错误

数据库内部出错 SQL 执行失败



![img](07Python38c3160b-3039.jpg)



NotSupportedError 试图执行数据库不支持的特性



#### 方法

连接对象没有必须定义的数据属性， 但是它至少应该定义表21.5中的这些方法.

一旦执行了 close() 方法， 再试图使用连接对象的方法将会导致异常.

对不支持事务的数据库或者虽然支持事务，但设置了自动提交(auto-commit)的数据库系统来 说，commitO方法什么也不做.如果你确实需要，可以实现一个自定义方法来关闭自动提交行为. 由于 DB-API 要求必须实现此方法， 对那些没有事务概念的数据库来说， 这个方法只需要有一条 pass 语句就可以了.

类似commitO，rollback()方法仅对支持事务的数据库有意义.执行完rollback()，数据库 将恢复到提交事务前的状态.根据PEP249，在提交commitO之前关闭数据库连接将会自动调用 rollbackO方法.

对不支持游标的数据库来说，cursorO方法仍然会返回一个尽量模仿游标对象的对象.这些是 最低要求. 特定数据库接口程序的开发者可以任意为他们的接口程序添加额外的属性， 只要他们愿

意.

![img](07Python38c3160b-3041.jpg)



DB-API 规范建议但不强制接口程序的开发者为所有数据库接口模块编写异常类. 如果没有提 供异常类， 则假定该连接对象会引发一致的模块级异常. 一旦你完成了数据库连接， 并且关闭了 游标对象， 你应该执行 commit() 提交你的操作， 然后关闭这个连接.

![img](07Python38c3160b-3042.jpg)



![img](07Python38c3160b-3043.jpg)



表 21.5 连接对象方法



Method Name close()



Description

关闭数据库连接



commit()

rollback()

cursor()

errorhandler



errcls， errval)



提交当前事务

取消当前事务

使用这个连接创建并返回一个游标或类游标的对象 (cxn， cur，

 21.2.3 游标对象

当你建立连接之后， 就可以与数据库进行交互. 我们在前面那一小节提交， 一个游标允许用户 执行数据库命令和得到查询结果. 一个 Python DB-API 游标对象总是扮演游标的角色， 无论数据库 是否真正支持游标. 从这一点讲， 数据库接口程序必须实现游标对象. 只有这样， 才能保证无论使 用何种后端数据库你的代码都不需要做任何改变.

创建游标对象之后， 你就可以执行查询或其它命令(或者多个查询和多个命令)， 也可以从结果



![img](07Python38c3160b-3045.jpg)



集中取出一条或多条记录. 表 21.6 列举了游标对象拥有的属性和方法.



表 21.6 游标对象的属性 对象属性 arraysize connectionn description



描述



使用fechmanyO方法一次取出多少条记录，默认值为1 创建此游标对象的连接(可选)

返回游标活动状态(一个包含七个元素的元组): (name， type_code， display_size， internal_ size， precision， scale， null_ok); 只有 name 和 type_code 是必须提供的.

lastrowid    返回最后更新行的 id (可选)， 如果数据库不支持行 id， 默认返回 None)

rowcount    最后一次 execute() 操作返回或影响的行数.

callproc(func[，args]) 调用一个存储过程

close()    关闭游标对象

execute(op[，args]) 执行一个数据库查询或命令

executemany(op，args) 类似 execute() 和 map() 的结合， 为给定的每一个参数准备并执行 一个数据库查询/命令

表 21.6 游标对象属性(续)

对象属性    描述

fetchone()    得到结果集的下一行

fetchmany([size=cursor. arraysize])

fetchall()

__iter__() messages next() nextset() rownumber



得到结果集的下几行 (几 = size)

返回结果集中剩下的所有行 创建一个迭代对象 (可选; 参阅 next())

游标执行后数据库返回的信息列表 (元组集合) (可选) 使用迭代对象得到结果集的下一行(可选; 类似 fetchone()， 参阅 __iter__()) 移到下一个结果集 (如果支持的话)

当前结果集中游标的索引 (以行为单位， 从0开始) (可选)



![img](07Python38c3160b-3047.jpg)



setinput- sizes(sizes) 设置输入最大值 (必须有， 但具体实现是可选的) setoutput- size(size[，col]) 设置大列的缓冲区大写(必须有， 但具体实现是可选的)



游标对象最重要的属性是 execute*() 和 fetch*() 方法. 所有对数据库服务器的请求都由它 们来完成.对fetchmanyO方法来说，设置一个合理的arraysize属性会很有用.当然，在不需要时 关掉游标对象也是个好主意.如果你的数据库支持存储过程，你就可以使用callprocO方法.



### 21.2.4 类型对象和构造器



通常两个不同系统的接口要求的参数类型是不一致的，譬如python调用c函数时Python对象和 C类型之间就需要数据格式的转换，反之亦然.类似的，在Python对象和原生数据库对象之间也是 如此. 对于 Python DB-API 的开发者来说， 你传递给数据库的参数是字符串形式的， 但数据库会根



据需要将它转换为多种不同的形式. 以确保每次查询能被正确执行.



举例来说，一个Python字符串可能被转换为一个VARCHAR,或一个TEXT,或一个BLOB,或一 个原生BINARY对象，或一个DATE或TIME对象.一个字符串到底会被转换成什么类型？必须小心 的尽可能以数据库期望的数据类型来提供输入，因此另一个DB-API的需求是创建一个构造器以生成 特殊的对象，以便能够方便的将Python对象转换为合适的数据库对象.表21.7描述了可以用于此 目的的类.SQL的NULL值被映射为Pyhton的NULL对象，也就是None.

表21.7 类型对象和构造器

类型对象    描述

Date(yr,mo,dy)    日期值对象

Time(hr,min,sec) 时间值对象

Timestamp(yr,mo,dy,

hr, min,sec)    时间戳对象

DateFromTicks(ticks)通过自 1970-01-01 00:00:01 utc 以来的 ticks 秒数得到日期 TimeFromTicks(ticks)通过自 1970-01-01 00:00:01 utc 以来的 ticks 秒数得到时间值对象 TimestampFromTicks(ticks)通过自 1970-01-01 00:00:01 utc 以来的 ticks 秒数得到时间戳

对象

![img](07Python38c3160b-3050.jpg)



Binary(string) 对应二进制长字符串值的对象 STRING    描述字符串列的对象, 比如    VARCHAR

BINARY    描述二进制长列的对象 比如    RAW,    BLOB

NUMBER    描述数字列的对象

DATETIME 描述日期时间列的对象

ROWID    描述 “row ID” 列的对象

#### DB-API版本变更

有几个重要的变更发生在 DB-API 从1.0(1996)升级到2.0(1999)时:

•从API中移除了原来必须的dbi模块

•更新了类型对象

•增加了新的属性以提供更易用的数据库绑定

•变更了 callproc()的语义及重定义了 execute()的返回值

•基于异常的错误处理

自从DB-API 2.0发布以来，曾经在2002年加入了一些可选的DB- API扩展，但一直没有什么 重大的变更.在DB-SIG邮件列表中一直在讨论DB-API的未来版本--暂时命名为DB-API 3.0.它 将包括以下特性:

当有一个新的结果集时nextsetO会有一个更合适的返回值 • float 变更为 Decimal



![img](07Python38c3160b-3052.jpg)



•支持更灵活的参数风格

•预备语句或语句缓存

•优化事务模型

•确定DB-API可移值性的角色

•增加单元测试

如果你对这些API特别感兴趣，欢迎积极参与.下面有一些手边的资源.

•    <http://python.org/topics/database>

•    <http://www.linuxjournal.com/article/2605>

•    <http://wiki.python.org/moin/DbApi3>

21.2.5 关系数据库

现在我们准备开始，一个问题摆在面前，在Pyhton里我可以使用哪种数据库接口？换言之， Python支持哪些平台？答案是几乎所有的平台.下面是一个不怎么完整的数据库支持列表：

![img](07Python38c3160b-3053.jpg)



商业关系数据库管理系统

![img](07Python38c3160b-3054.jpg)



參 Informix

•    Sybase

參 Oracle

•    MS SQL Server

•    DB/2

參 SAP

•    Interbase

參 Ingres

开源关系数据库管理系统

•    MySQL

•    PostgreSQL 參 SQLite

參 Gadfly

数据库APIs

•    JDBC

•    ODBC



![img](07Python38c3160b-3056.jpg)



![img](07Python38c3160b-3057.jpg)



![img](07Python38c3160b-3058.jpg)



![img](07Python38c3160b-3059.jpg)



![img](07Python38c3160b-3060.jpg)



要知道 Python 支持哪些数据库， 请参阅下面网址:

<http://python.org/topics/database/modules.html>

### 21.2.6数据库和Python:接口程序

对每一种支持的数据库，都有一个或多个Python接口程序允许你连接到目标数据库系统.某些 数据库，比如Sybase， SAP， Oracle和SQLServer，都有两个或更多个接口程序可供选择.你要做 的就是挑选一个最能满足你需求的接口程序. 你挑选接口程序的标准可以是: 性能如何? 文档或 WEB 站点的质量如何? 是否有一个活跃的用户或开发社区? 接口程序的质量和稳定性如何? 等等等 等. 记住绝大多数接口程序只提供基本的连接功能， 你可能需要一些额外的特性. 高级应用代码如 线程和线程管理以及数据库连接池的管理等等， 需要你自己来完成.

如果你不想处理这些， 比方你不喜欢自己写 SQL， 也不想参与数据库管理的细节--那么本章后 面讲到的 ORM 应该可以满足你的要求. 现在来看一些使用接口程序访问数据库的例子， 关键之处在 于设置数据库连接.在建立连接之后， 不管后端是何种数据库， 对 DB-API 对象的属性和方法进行

操作都是一样的.

### 21.2.7 使用数据库接口程序举例

首先， 我们来看一下例子代码， 创建数据库， 创建表， 使用表. 我们分别提供了使用 MySQL， PostgreSQL， SQLite 的例子.

#### MySQL

这里我们以 MySQL 数据库为例， 使用唯一的 MySQL 接口程序: MySQLdb， 这个接口程序又名 MySQL-python. 在这部分代码里， 我们故意在例子里埋下一个错误

首先我们以管理员身份登录， 创建一个数据库， 并赋予相应权限， 之后我们再以普通用户身份

登录数据库. 以便你能了解你希望得到什么， 这样你会想到为它创建一个事件处理程序.

\>>> import MySQLdb

\>>> cxn = MySQLdb.connect(user='root')

\>>> cxn.query('DROP DATABASE test') Traceback (most recent call last):

File "<stdin>"， line 1， in ?

_mysql_exceptions.OperationalError: (1008， "Can't drop database 'test'; database doesn't exist")

\>>> cxn.query('CREATE DATABASE test')

![img](07Python38c3160b-3061.jpg)



\>>> cxn.query("GRANT ALL ON test.* to ''@'localhost'") >>> cxn.commit()

\>>> cxn.close()



在上面的代码中，我们没有使用cursor对象。某些(但不是所有的)接口程序拥有连接对象， 这些连接对象拥有query()方法，可以执行SQL查询。我们建议你不要使用这个方法，或者事先检 查该方法在当前接口程序当中是否可用。之后我们以普通用户身份再次连接这个新数据， 创建表， 然后通过Python执行SQL查询和命令，来完成我们的工作。这次我们使用游标对象(cursors)和它 们的execute()方法，下一个交互集演示了创建表。

下面的代码演示了如何创建一个表. 在删除一个表之前如果试图重建这个表将产生错误.

\>>> cxn = MySQLdb.connect(db='test')

\>>> cur = cxn.cursor()

\>>> cur.execute('CREATE TABLE users(login VARCHAR(8), uid INT)') 0L

现在我们来插入几行数据到数据库, 然后再将它们取出来.

\>>> cur.execute("INSERT INTO users VALUES('john', 7000)")

![img](07Python38c3160b-3063.jpg)



1L

\>>> cur.execute("INSERT INTO users VALUES('jane', 7001)")

1L

\>>> cur.execute("INSERT INTO users VALUES('bob', 7200)")

1L

\>>> cur.execute("SELECT * FROM users WHERE login LIKE 'j%'")

2L

\>>> for data in cur.fetchall():

... print '%s\t%s' % data

john 7000

jane 7001

最后一个特性是更新表, 包括更新或删除数据.

\>>> cur.execute("UPDATE users SET uid=7100 WHERE uid=7001")

1L

\>>> cur.execute("SELECT * FROM users")

3L

\>>> for data in cur.fetchall():

![img](07Python38c3160b-3064.jpg)



print '%s\t%s' % data



john 7000 jane    7100

bob    7200

\>>> cur.execute('DELETE FROM users WHERE login="bob"')

1L

\>>> cur.execute('DROP TABLE users')

0L

\>>> cur.close()

\>>> cxn.commit()

\>>> cxn.close()

Mysql是最流行的开源数据库之一.毫无疑问会有一个针对MySQL的Python接口程序.不过 Python标准库中并没有集成这个接口程序，这是一个第三方包，你需要单独下载并安装它.在本章 的末尾的索引页， 你可以找到如何下载它.

#### PostgreSQL

![img](07Python38c3160b-3066.jpg)



![img](07Python38c3160b-3067.jpg)



另一个著名的开源数据库是 PostgreSQL. 与 MySQL 不同， 有至少 3 个 Python 接口程序可 以访问 PosgreSQL: psycopg， PyPgSQL 和 PyGreSQL. 第四个， PoPy， 现在已经被废弃(2003年， 它 贡献出自己的代码，与PygreSQL整合在一起).这三个接口程序各有长处，各有缺点，根据实践结

果选择使用哪个接口是个好主意.

多亏他们都支持 DB-API， 所以他们的接口基本一致， 你只需要写一个应用程序， 然后分别测 试这三个接口的性能(如果性能对你的程序很重要的化). 下面我给出这三个接口的连接代码:

psycopg

\>>> import psycopg

\>>> cxn = psycopg.connect(user='pgsql')

#### PyPgSQL

\>>> from pyPgSQL import PgSQL >>> cxn = PgSQL.connect(user='pgsql')

#### PyGreSQL

\>>> import pgdb

\>>> cxn = pgdb.connect(user='pgsql')



![img](07Python38c3160b-3069.jpg)



好， 下面的代码就能够在所有接口程序下工作了.

\>>> cur = cxn.cursor()

\>>> cur.execute('SELECT * FROM pg_database') >>> rows = cur.fetchall()

\>>> for i in rows:

... print i >>> cur.close()

\>>> cxn.commit()

\>>> cxn.close()

最后， 你会发现他们的输出有一点点轻微的不同.

#### PyPgSQL

sales

template1

![img](07Python38c3160b-3070.jpg)



template0

psycopg



![img](07Python38c3160b-3071.jpg)



('sales'， 1， 0， 0， 1， 17140， '140626'， '3221366099'， ''， None， None)

('template1'， 1， 0， 1， 1， 17140， '462'， '462'， ''， None '{pgsql=C*T*/pgsql}')

('template0'， 1， 0， 1， 0， 17140， '462'， '462'， ''， None '{pgsql=C*T*/pgsql}')

#### PyGreSQL

['sales'， 1， 0， False， True， 17140L， '140626'， '3221366099'， ''， None， None]

['template1'， 1， 0， True， True， 17140L， '462'， '462'， ''， None， '{pgsql=C*T*/pgsql}']

['template0'， 1， 0， True， False， 17140L， '462'，

'462'， ''， None， '{pgsql=C*T*/pgsql}']

SQLite



对非常简单的应用来说, 使用文件进行持久存储通常就足够了. 但对于绝大多数数据驱动的应 用程序必须使用全功能的关系数据库. SQLite 介于二者之间, 它定位于中小规模的应用.它是相当

轻量级的全功能关系型数据库, 速度很快, 几乎不用配置, 并且不需要服务器.



SQLite 正在快速的流行. 并且在各个平台上都能用. 在 python2.5 集成了前面介绍的 pysqlite数据库接口程序，作为python2.5的sqlite3模块.这是Python标准库第一次将一个 数据库接口程序纳入标准库, 也许这标志着一个新的开始.

它被打包到 Python 当中并不是因为他比其它的数据库接口程序更优秀, 而是因为他足够简单, 使用文件（或内存）作为它的后端存储, 就象 DBM 模块做的那样, 不需要服务器, 而且也不存在授 权问题.它是Python中其它的持久存储解决方案的一个替代品，一个拥有SQL访问界面的优秀替 代品. 在标准库中有这么一个模块, 就能方便用户使用 Python 和 SQLite 进行软件开发, 等到软 件产品正式上市发布时, 只要需要, 就能够很容易的将产品使用的数据库后端变更为一个全功能的, 更强大的类似 MySQL, PostgreSQL, Oracle 或 SQL Server 那样的数据库. 当然, 对那些不需要那 么大马力的应用程序来说, SQLite 已经足够使用. :）

尽管标准库已经提供了数据库接口程序, 你仍然需要自己下载真正的数据库软件.(作者好像此 处犯糊涂了. sqlite 是不需要额外下载东西的, 只要有接口程序就可以工作). 一旦你安装好之后, 你只需要打开 Python 解释器, 下面是一个例子:

![img](07Python38c3160b-3074.jpg)



\>>> import sqlite3

\>>> cxn = sqlite3.connect('sqlite_test/test')

\>>> cur = cxn.cursor()

\>>> cur.execute('CREATE TABLE users(login VARCHAR(8), uid

INTEGER)')

\>>> cur.execute('INSERT INTO users VALUES("john", 100)')

\>>> cur.execute('INSERT INTO users VALUES("jane", 110)')

\>>> cur.execute('SELECT * FROM users')

\>>> for eachUser in cur.fetchall():

... print eachUser

(u'john', 100)

(u'jane', 110)

\>>> cur.execute('DROP TABLE users') <sqlite3.Cursor object at 0x3d4320> >>> cur.close()

\>>> cxn.commit()

\>>> cxn.close()

OK, 这个小例子已经足够了. 接下来, 我们来看一个小程序, 它类似前面使用 MySQL 的例子,



不过更简单一些.

•创建数据库（如果成功）

•创建表

•从表中增加行

•从表中修改行

•从表中删除行

•删除表

对这个例子来说中， 我们仍然使用两个其它的开源数据库. SQLite 现如今已经相当流行. 它体 积小， 而且足够快， 是一个几乎拥有全部功能的相当轻量级的数据库. 这个例子中用到的另一个数 据库是 Gadfly， 一个基本兼容 SQL 的纯 Python 写成的关系数据库. （某些关键的数据库结构有一 个C模块，不过Gadfly没有它也一样可以运行［当然，会慢不少，嘿嘿］）.

在进入代码之前，有几个提醒.SQLite和Gadfly需要用户指定保存数据库文件的位置（Mysql 有一个默认区域保存数据，在使用Mysql数据库时无需指定这个）.另外，Gadfly目前的版本还不 兼容 DB-API 2.0， 也就是说， 它缺失一些功能， 尤其是缺少我们例子中用到的 cursor 属性 rowcount.

#### 数据库接口程序应用程序举例    I

在下面这个例子里，我们演示了 Python如何访问数据库.事实上，我们的程序支持三种不 同的数据库系统: Gadfly， SQLite 和 MySQL. 我们将要创建一个数据库（如果它不存在的话）. 然后 进行多种数据库操作， 比如创建表， 删除表， 插入数据， 更新数据， 删除数据等等.

在下一小节中的 ORM 中我们将重复例子21.1 的这些功能.

逐行解释

#### 第1-18行

脚本的第一部分导入必须的模块， 创建一些"全局常量"（列的显示大小及我们的程序支持的数 据库）. 其中 setup（） 函数， 提供一个简单界面让用户选择使用哪种数据库.

值得留意的是 DB_EXC 常量， 它代表数据库异常. 他最终的值由用户最终选择使用的数据库 决定. 也就是说， 如果用户选择 MySQL， DB_EXC 将是 _mysql_exceptions， 以此类推... 如果我们 用流行的面向对象的方式来开发这个应用， 它将会以一个实例属性的方式表示， 比如 self.db_exc_module 或者什么别的名字.

#### 第20-75行

表现数据库存取一致性本质的connectO函数在这一段.在每一小节的开头，我们尝试载入需 要的数据库模块. 如果找不到合适的模块， None 值被返回， 表示这个数据库系统暂不支持.

在数据库连接建立以后， 其余的代码对数据库和接口程序来说都是透明的（不区分哪种数据库， 哪种接口程序，代码都可以工作）.有一个唯一的例外，就是脚本的insertO函数.在所有三个 小节的这段代码里， 数据库连接成功后会返回一个连接对象 cxn.



如果选中了 SQLite（24行-36行），我们尝试载入一个数据库接口程序.我们首先尝试载入标准 库模块 sqlite3（Python2.5 及更高版本支持）， 如果载入失败， 就会去寻找第三方 pysqlite2 包. 这个包支持 Python 2.4.x 或更老些的系统.

如果成功导入合适的接口程序， 由于 SQLite 是基于文件的数据库系统，同我们需要确认一下数 据库文件所在的目录是否存在.（当然， 你也可以选择在内存里创建一个数据库）. 当调用 connect（） 函数时， 如果这个数据库文件已经存在， SQLite 会使用这个数据库， 如果文件不存， 它就会创建一

个新文件.

例子21.1 数据库接口程序示例

这段脚本使用同样的接口对多种数据库执行了一些数据库基本操作.

I    #!/usr/bin/env python

2

![img](07Python38c3160b-3079.jpg)



3    import os

4    from random import randrange as rrange

5

6    COLSIZ = 10

7    RDBMSs = {'s': 'sqlite'， 'm': 'mysql'， 'g': 'gadfly'}

8    DB_EXC = None

9

10 def setup():

II    return RDBMSs[raw_input('''

12    Choose a database system:

13

14    (M)ySQL

15    (G)adfly

16    (S)QLite

17

18    Enter choice: ''').strip().lower()[0]]

19

20    def connect(db， dbName):

21    global DB_EXC

22    dbDir = '%s_%s' % (db， dbName)

23

![img](07Python38c3160b-3080.jpg)



![img](07Python38c3160b-3081.jpg)



24    if db == 'sqlite':

25    try:

26    import sqlite3

27    except ImportError， e:

28    try:

29    from pysqlite2 import dbapi2 as sqlite3

30    except ImportError， e:

31    return None

32

33    DB_EXC = sqlite3

34    if not os.path.isdir(dbDir):

35    os.mkdir(dbDir)

36    cxn = sqlite.connect(os.path.join(dbDir， dbName))

37

38    elif db == 'mysql':

39    try:

40    import MySQLdb

41    import _mysql_exceptions as DB_EXC

![img](07Python38c3160b-3082.jpg)



42    except ImportError， e:

![img](07Python38c3160b-3083.jpg)



43    return None

44

45    try:

46    cxn = MySQLdb.connect(db=dbName)

47    except _mysql_exceptions.OperationalError， e:

48    cxn = MySQLdb.connect(user='root')

49    try:

50    cxn.query('DROP DATABASE %s' % dbName)

51    except DB_EXC.OperationalError， e:

52    pass

53    cxn.query('CREATE DATABASE %s' % dbName)

54    cxn.query("GRANT ALL ON %s.* to ''@'localhost'" % dbName)

55    cxn.commit()

56    cxn.close()

57    cxn = MySQLdb.connect(db=dbName)

58

59    elif db == 'gadfly':

60    try:

61    from gadfly import gadfly

62    DB_EXC = gadfly

63 except ImportError， e:

![img](07Python38c3160b-3084.jpg)



![img](07Python38c3160b-3085.jpg)



![img](07Python38c3160b-3086.jpg)



![img](07Python38c3160b-3087.jpg)



![img](07Python38c3160b-3088.jpg)



64    return None

65

66    try:

67    cxn = gadfly(dbName, dbDir)

68    except IOError, e:

69    cxn = gadfly()

70    if not os.path.isdir(dbDir):

71    os.mkdir(dbDir)

72    cxn.startup(dbName, dbDir)

73    else:

74    return None

75    return cxn

76

77    def create(cur):

78    try:

79    cur.execute('''

80    CREATE TABLE users (

81    login VARCHAR(8),

82    uid INTEGER,

![img](07Python38c3160b-3089.jpg)



83    prid INTEGER)

84    ''')

85 except DB_EXC.OperationalError, e:

86    drop(cur)

87    create(cur)

88

89    drop = lambda cur: cur.execute('DROP TABLE users')

90

91    NAMES = (

92    ('aaron', 8312), ('angela', 7603), ('dave', 7306),

93    ('davina',7902), ('elliot', 7911), ('ernie', 7410)

94    ('jess', 7912), ('jim', 7512), ('larry', 7311),

95    ('leslie', 7808), ('melissa', 8602), ('pat', 7711)

96    ('serena', 7003), ('stan', 7607), ('faye', 6812),

97    ('amy', 7209),

98    )

99

100    def randName():

101    pick = list(NAMES)

102    while len(pick) > 0:

103    yield pick.pop(rrange(len(pick)))

![img](07Python38c3160b-3090.jpg)



![img](07Python38c3160b-3091.jpg)



104

105    def insert(cur， db):

106    if db == 'sqlite':

107    cur.executemany("INSERT INTO users VALUES(?， ?， ?)"，

108    [(who， uid， rrange(1，5)) for who， uid in randName()])

109    elif db == 'gadfly':

110    for who， uid in randName():

111    cur.execute("INSERT INTO users VALUES(?， ?， ?)"，

112    (who， uid， rrange(1，5)))

113    elif db == 'mysql':

114    cur.executemany("INSERT INTO users VALUES(%s， %s， %s)"

115    [(who， uid， rrange(1，5)) for who， uid in randName()])

116

117    getRC = lambda cur: cur.rowcount if hasattr(cur， 'rowcount') else -1

118

119    def update(cur):

120    fr = rrange(1，5)

121    to = rrange(1，5)

![img](07Python38c3160b-3092.jpg)



122    cur.execute(

123    "UPDATE users SET prid=%d WHERE prid=%d" % (to， fr))

124    return fr， to， getRC(cur)

125

126    def delete(cur):

127    rm = rrange(1，5)

128    cur.execute('DELETE FROM users WHERE prid=%d' % rm)

129    return rm， getRC(cur)

130

131    def dbDump(cur):

132    cur.execute('SELECT * FROM users')

133    print '\n%s%s%s' % ('LOGIN'.ljust(COLSIZ)，

134    'USERID'.ljust(COLSIZ)， 'PROJ#'.ljust(COLSIZ))

135    for data in cur.fetchall():

136    print '%s%s%s' % tuple([str(s).title().ljust(COLSIZ) \

137    for s in data])

138

139    def main():

140    db = setup()

141    print '*** Connecting to %r database' % db

142    cxn = connect(db， 'test')

![img](07Python38c3160b-3093.jpg)



![img](07Python38c3160b-3094.jpg)



![img](07Python38c3160b-3095.jpg)



![img](07Python38c3160b-3096.jpg)



![img](07Python38c3160b-3097.jpg)



![img](07Python38c3160b-3098.jpg)



143    if not cxn:

144    print 'ERROR: %r not supported， exiting' % db

145    return

146    cur = cxn.cursor()

147

148    print '\n*** Creating users table'

149    create(cur)

150

151    print '\n*** Inserting names into table'

152    insert(cur， db)

153    dbDump(cur)

154

155    print '\n*** Randomly moving folks'，

156    fr， to， num = update(cur)

157    print 'from one group (%d) to another (%d)' % (fr， to)

158    print '\t(%d users moved)' % num

159    dbDump(cur)

160

161    print '\n*** Randomly choosing group'，

![img](07Python38c3160b-3099.jpg)



162    rm， num = delete(cur)

163    print '(%d) to delete' % rm

164    print '\t(%d users removed)' % num

165    dbDump(cur)

166

167    print '\n*** Dropping users table'

168    drop(cur)

169    cur.close()

170    cxn.commit()

171    cxn.close()

172

173    if __name__ == '__main__':

174    main()

例子21.1 数据库接口程序示例

MySQL（38-57 行）的数据文件会存保在默认的数据存储区域， 所以不需要用户指定存储位置. 我

们的代码尝试连接指定的数据库. 如果发生错误， 有可能是数据库不存在或者虽然数据库存在但我

们没有权限访问它. 由于这仅仅是一个测试应用程序， 我们选择完全先删掉这个数据库（忽略掉如 果数据库不存在可能引发的错误）， 然后重建该库， 然后给访问它的用户赋予权限.

![img](07Python38c3160b-3100.jpg)



我们的应用程序支持的最后一个数据库是Gadfly （第59-75行）.在本书写作的时候，这个数据 库已经几乎但还没有完全兼容DB-API，你也会在这个程序里看到这一点.）它使用类似SQLite的启

动机制: 它的启动目录是数据文件所在的目录. 如果数据文件在那儿， OK， 如果那儿没有数据文件，

你必须重新启动一个新的数据库.（为什么非要这样， 我们也不十分清楚. 我们认为 startup（） 函 数应该被合并到构造器函数gadfly.gadflyO当中去）.

#### 第77-89行

create（） 函数在数据库中创建一个新的 users 表， 如果中间产生问题， 几乎肯定是因为这个 表已经存在.如果正是这个原因的话，删掉这个表，然后递归调用createO函数来重新创建它.这 个代码有一个缺陷， 就是当重建表仍然失败的话， 你将陷入死循环， 直至内存耗尽.在本章最后有 一道习题就是这个问题，你可以试着修复这个潜在的bug.

#### 91-103行

这可能是除了数据库操作之外最有趣的代码部分了.它由一组固定用户名及ID值的集合及一个 生成器函数 randName（） 构成. 这个函数的代码也可以在第11章的11.10小节找到. NAMES 常量是 一个元组，因为我们在randNameO这个生成器里需要改变它的值，所以我们必须在randNameO里 先将它转换为一个列表. 我们一次随机的移除一个名字， 直到列表为空为止. 如果 NAMES 本身是 一个列表， 我们只能使用它一次（它就被消耗光了）. 我们将它设计成为一个元组， 这样我们就可以 多次从这个元组生成一个列表供生成器使用.

#### 105-115行

由于各种数据库之间有一些细微差别，insertO函数里的代码是依赖具体数据库的.举例来说， SQLite和MySQL的接口程序都是DB-API兼容的，所以它们的游标对象都拥有executemany（）方 法， 可是是 Gadfly 没有这个方法， 因此它只能一次插入一行.

另一个不同之处在于 SQLite 和 Gadfly 的参数风格是 qmark， 而 MySQL 的参数风格是 format.

由于这些原因， 格式字符串必须不同. 如果你比较细心的话， 你会看到他们的参数创建过程非 常相似.

这段代码的功能是：对每个name-userID数据对，随机分配一个项目小组id（，然后存入数据 库）.

#### 第117行

这独立的一行是有一个条件表达式（读作， Python 3目操作符）， 它返回最后一步操作所影响的 行数，如果游标对象不支持这个属性（也就是说这个接口程序不兼容DB-API）的话，它返回-1.

python 2.5中新增了条件表达式，如果你使用的是python 2.4.x或更老版本，你可能需要将 它转换为老风格的方式， 如下:

getRC = lambda cur: (hasattr(cur， 'rowcount') \

and [cur.rowcount] or [-1])[0]



如果你对这行代码看不太明白， 不用着急. 看看 FAQ 就能知道为什么最终 Python 2.5 中加入 了条件表达式.如果你能弄明白，你就彻底搞明白了 python对象以及他们的布尔值.

#### 第119-129行

update() 和 delete() 函数随机从一个组里选择了几条记录， 如果是 update 操作， 就将他 们从当前小组移到另一个小组(也是随机选择的). 如果是 delete 操作， 则删除它们.

#### 第131-137行

dbDumpO函数从数据库中读取所有数据，并将数据进行格式化，然后显示给用户看.print语 句显示每个用户不够清晰， 所以我们将它分开显示.

首先，通过fetchall()方法读取数据，然后迭代遍历每个用户，将三列数据(login，uid， prid)转换为字符串(如果它们还不是的话)，并将姓和名的首字母大写，再格式化整个字符为左对 齐的 COLSIZ 列.(右边留白) . 由代码生成的字符串是一个列表(通过列表解析， list comprehension)， 我们需要将它们转换成一个元组以支持 % 运算符.

#### 第 139-174 行

![img](07Python38c3160b-3104.jpg)



本部影片的导演main()出场.它将上面定义的这些函数组织起来，让他们尽情发挥.(假定 它们没有因为找不到数据库接口程序或者不能得到有效连接对象而中途退出［第143-145行］).它 的大部分代码都是能够自我解释的print语句.最后main()关闭游标对象，提交操作，然后关 闭数据库连接. 脚本的最后几行代码用来启动脚本的执行.

Edit By Vheavens21.3对象-关系管理器(ORMs)

通过前一节我们知道，如今有很多种数据库系统，他们中的绝大多数都有Python接口，以方便 你驾驭他们的能量.这些系统唯一的缺点是需要你懂得SQL.如果你是一个喜欢折腾Python对象 却讨厌 SQL 查询的家伙， 又想使用关系型数据库做为你的数据存储的后端， 你就完全具备成为一 个 ORM 用户的天资.

### 21.3.1考虑对象，而不是SQL

这些系统的创建者将绝大多数纯SQL层功能抽象为Python对象，这样你就无需编写SQL也能够 完成同样的任务. 如果你在某些情况下实在需要 SQL， 有些系统也允许你拥有这种灵活性. 但绝大 多数情况下，你应该尽量避免进行直接的SQL查询.

数据库的表被转换为 Python 类， 它具有列属性和操作数据库的方法. 让你的应用程序支持

![img](07Python38c3160b-3105.jpg)



ORM 非常类似使用那些标准的数据库接口程序. 由于大部分工作由 ORM 代为处理, 相比直接使用 接口程序来说, 一些事情可能实际需要更多的代码. 另人欣慰的是, 一点点额外的付出会回报你更 高的生产率.



### 21.3.2 Python 和 ORM

如今最知名的Python ORM模块是SQLAlchemy和SQLObject.由于二者有着不同的设计哲学， 我们会分别给出SQLAlchemy和SQLObject的例子.只要你能搞清楚这两种ORM的使用，转到其它 的 ORM 将是相当简单的事.

其它的 Python ORM 包括 PyDO/PyDO2，PDO，Dejavu，Durus，QLime 和 ForgetSQL. 一些大型 的Web开发工具/框架也可以有自己的ORM组件，如WebWare MiddleKit和Django的数据库API. 需要指出的是，知名的0RM并不意味着就是最适合你的应用程序的0RM.那些其它的0RM虽然没 有纳入我们的讨论范围， 但一样有可能是适合你的应用程序的选择.

### 21.3.3 雇员数据库举例

![img](07Python38c3160b-3107.jpg)



现在我们将shuffle应用程序ushuffle_db.py改造为使用SQLAlchemy和SQLObject实 现.数据库后端仍然是MySQL.相对于直接使用原始SQL来讲，我们使用0RM时用类代替了函数， 这样会更有对象的感觉.两个例子都使用了 ushuffle_db.py中的NAMES集合和随机名字选择 函数.这是为了避免将同样的代码到处复制-粘贴，代码能够被有效重用是件好事情.

#### SQLAlchemy

与SQLObject相比，SQLAlchemy的接口在某种程度上更接近SQL，所以我们先从SQLAlchemy 开始.SQLAlchemy的抽象层确实相当完美，而且在你必须使用SQL完成某些功能时，它提供了足够 的灵活性.你会发现这两个0RM模块在设置及存取数据时使用的术语非常相似，代码长度也很接近， 都比ushuffle_db.py少.（包括共享的names列表和随机名字生成器）.

逐行解释

#### 第1-10行

和前面一样，第一件事是导入相关的模块和常量.我们倡导首先导入Python标准库模块，然后 再导入第三方或扩展模块， 最后导入本地模块这种风格. 这些常量都是自解释的， 所以无需废话.

#### 第12-31行

是类的构造器， 类似 ushuffle_db.connect（）. 它确保数据库可用并返回一个有效连接（第

18-31行）.这也是唯一能看到原始SQL的地方.这是一种典型的操作任务，不是面向应用的任务.

![img](07Python38c3160b-3108.jpg)



第33-44行

这个 try-except 子句（第33-40行）用来重新载入一个已有的表， 或者在表不存在的情况下创



建一个新表. 最终我们得到一个合适的对象实例.

例子21.2 SQLAlchemy ORM 例子

这个user shuffle程序的主角是SQLAlchemy前端和MySQL数据库后端

1    #!/usr/bin/env python

2

3    import os

4    from random import randrange as rrange

5    from sqlalchemy import *

6    from ushuffle_db import NAMES， randName

7

8    FIELDS = ('login'， 'uid'， 'prid')

9    DBNAME = 'test'

10    COLSIZ = 10

11

12    class MySQLAlchemy(object):

![img](07Python38c3160b-3110.jpg)



13    def __init__(self， db， dbName):

14    import MySQLdb

15    import _mysql_exceptions

16    MySQLdb = pool.manage(MySQLdb)

17    url = 'mysql://db=%s' % DBNAME

18    eng = create_engine(url)

19    try:

20    cxn = eng.connection()

21    except _mysql_exceptions.OperationalError， e:

22    eng1 = create_engine('mysql://user=root')

23    try:

24    eng1.execute('DROP DATABASE %s' % DBNAME)

25    except _mysql_exceptions.OperationalError， e:

26    pass

27    eng1.execute('CREATE DATABASE %s' % DBNAME)

28    eng1.execute(

29    "GRANT ALL ON %s.* TO ''@'localhost'" % DBNAME)

30    eng1.commit()

31    cxn = eng.connection()

32

33 try:

![img](07Python38c3160b-3111.jpg)



![img](07Python38c3160b-3112.jpg)



![img](07Python38c3160b-3113.jpg)



34    users = Table('users'， eng， autoload=True)

35    except exceptions.SQLError， e:

36    users = Table('users'， eng，

37    Column('login'， String(8))，

38    Column('uid'， Integer)，

39    Column('prid'， Integer)，

40    redefine=True)

41

42    self.eng = eng

43    self.cxn = cxn

44    self.users = users

45

46    def create(self):

47    users = self.users

48    try:

49    users.drop()

50    except exceptions.SQLError， e:

51    pass

![img](07Python38c3160b-3114.jpg)



52    users.create()

![img](07Python38c3160b-3115.jpg)



![img](07Python38c3160b-3116.jpg)



53

54    def insert(self):

55    d = [dict(zip(FIELDS，

56    [who， uid， rrange(1，5)])) for who，uid in randName()]

57    return self.users.insert().execute(*d).rowcount

58

59    def update(self):

60    users = self.users

61    fr = rrange(1，5)

62    to = rrange(1，5)

63    return fr， to， \

64    users.update(users.c.prid==fr).execute(prid=to).rowcount

65

66    def delete(self):

67    users = self.users

68    rm = rrange(1，5)

69    return rm， \

70    users.delete(users.c.prid==rm).execute().rowcount

71

72    def dbDump(self):

73    res = self.users.select().execute()



![img](07Python38c3160b-3118.jpg)



74    print '\n%s%s%s' % ('LOGIN'.ljust(COLSIZ)，

75    'USERID'.ljust(COLSIZ)， 'PROJ#'.ljust(COLSIZ))

76    for data in res.fetchall():

77    print '%s%s%s' % tuple([str(s).title().ljust (COLSIZ) for s in data])

78

79    def __getattr__(self， attr):

80    return getattr(self.users， attr)

81

82    def finish(self):

83    self.cxn.commit()

84    self.eng.commit()

85

86    def main():

87    print '*** Connecting to %r database' % DBNAME

88    orm = MySQLAlchemy('mysql'， DBNAME)

89

90    print '\n*** Creating users table'

![img](07Python38c3160b-3119.jpg)



91    orm.create()

![img](07Python38c3160b-3120.jpg)



92

93    print '\n*** Inserting names into table'

94    orm.insert()

95    orm.dbDump()

96

97    print '\n*** Randomly moving folks'，

98    fr， to， num = orm.update()

99    print 'from one group (%d) to another (%d)' % (fr， to)

100    print '\t(%d users moved)' % num

101    orm.dbDump()

102

103    print '\n*** Randomly choosing group'，

104    rm， num = orm.delete()

105    print '(%d) to delete' % rm

106    print '\t(%d users removed)' % num

107    orm.dbDump()

108

109    print '\n*** Dropping users table'

110    orm.drop()

111    orm.finish()

112

![img](07Python38c3160b-3121.jpg)



113    if __name__ == '__main__':

114    main()

例子 21.2 SQLAlchemy ORM 示例(ushuffle_sa.py)

#### 第46-70行

这四个方法处理数据库核心功能: 创建表(46-52行)， 插入数据(54-57 行)， 更新数据(59-64 行)， 删除数据(66-70行). 我们也有一个方法用来删除表.

def drop(self):

self.users.drop()

or

drop = lambda self: self.users.drop()

不过， 我们还是决定提供另一种委托处理方式(曾在第13章， 面向对象编程中介绍). 委托处理 就是指一个方法调用不存在时， 转交给另一个拥有此方法的对象去处理. 参见第79-80行的解释.

#### 第72-77行

输出内容由dbDump()方法完成.它从数据库中得到数据，就象ushuffle_db.py中那样对数 据进行美化，事实上，这部分代码几乎完全相同.

#### Lines 79-80

应该尽量避免为一个表创建一个 drop() 方法， 因为这总是会调用 table 自身的 drop() 方 法. 同样， 既然没有新增功能， 那我们有什么必要要创建另一个函数?无论属性查找是否成功特殊 方法 __getattr__() 总是会被调用. 如果调用 orm.drop() 却发现这个对象并没有 drop() 方法， getattr(orm，’drop')就会被调用.发生这种情况时，_getattr_()被调用，之后将这个属性名委 托给 self.users. 解释器会发现 self.users 有一个 drop 属性并执行.

Example 21.3 SQLObject ORM Example (ushuffle_so.py)

这个user shuffle应用程序的主角前端是SQLObject，后端是MySQL数据库.

1    #!/usr/bin/env python

2

3    import os

4    from random import randrange as rrange

5    from sqlobject import *

6    from ushuffle_db import NAMES， randName

7

8    DBNAME = 'test'

9    COLSIZ = 10

![img](07Python38c3160b-3124.jpg)



10    FIELDS = ('login'， 'uid'， 'prid')

11

12    class MySQLObject(object):

13    def __init__(self， db， dbName):

14    import MySQLdb

15    import _mysql_exceptions

16    url = 'mysql://localhost/%s' % DBNAME

17

18    while True:

19    cxn = connectionForURI(url)

20    sqlhub.processConnection = cxn

21    #cxn.debug = True

22    try:

23    class Users(SQLObject):

24    class sqlmeta:

25    fromDatabase = True

26    login = StringCol(length=8)

27    uid = IntCol()

![img](07Python38c3160b-3125.jpg)



28    prid = IntCol()

![img](07Python38c3160b-3126.jpg)



29    break

30    except _mysql_exceptions.ProgrammingError， e:

31    class Users(SQLObject):

32    login = StringCol(length=8)

33    uid = IntCol()

34    prid = IntCol()

35    break

36    except _mysql_exceptions.OperationalError， e:

37    cxn1 = sqlhub.processConnection= connectionForURI('mysql://root@localhost')

38    cxn1.query("CREATE DATABASE %s" % DBNAME)

39    cxn1.query("GRANT ALL ON %s.* TO ''@' localhost'" % DBNAME)

40    cxn1.close()

41    self.users = Users

42    self.cxn = cxn

43

44    def create(self):

45    Users = self.users

46    Users.dropTable(True)

47    Users.createTable()

![img](07Python38c3160b-3127.jpg)



![img](07Python38c3160b-3128.jpg)



48

49    def insert(self):

50    for who， uid in randName():

51    self.users(**dict(zip(FIELDS，

52    [who， uid， rrange(1，5)])))

53

54    def update(self):

55    fr = rrange(1，5)

56    to = rrange(1，5)

57    users = self.users.selectBy(prid=fr)

58    for i， user in enumerate(users):

59    user.prid = to

60    return fr， to， i+1

61

62    def delete(self):

63    rm = rrange(1，5)

64    users = self.users.selectBy(prid=rm)

65    for i， user in enumerate(users):

66    user.destroySelf()

![img](07Python38c3160b-3129.jpg)



67    return rm， i+1

68

69    def dbDump(self):

70    print '\n%s%s%s' % ('LOGIN'.ljust(COLSIZ)，

71    'USERID'.ljust(COLSIZ)， 'PROJ#'.ljust(COLSIZ))

72    for usr in self.users.select():

73    print '%s%s%s' % (tuple([str(getattr(usr，

74    field)).title().ljust(COLSIZ) \

75    for field in FIELDS]))

76

77    drop = lambda self: self.users.dropTable()

78    finish = lambda self: self.cxn.close()

79

80    def main():

81    print '*** Connecting to %r database' % DBNAME

82    orm = MySQLObject('mysql'， DBNAME)

83

84    print '\n*** Creating users table'

85    orm.create()

86

87 print '\n*** Inserting names into table'

![img](07Python38c3160b-3130.jpg)



![img](07Python38c3160b-3131.jpg)



88    orm.insert()

89    orm.dbDump()

90

91    print '\n*** Randomly moving folks',

92    fr, to, num = orm.update()

93    print 'from one group (%d) to another (%d)' % (fr, to)

94    print '\t(%d users moved)' % num

95    orm.dbDump()

96

97    print '\n*** Randomly choosing group',

98    rm, num = orm.delete()

99    print '(%d) to delete' % rm

100    print '\t(%d users removed)' % num

101    orm.dbDump()

102

103    print '\n*** Dropping users table'

104    orm.drop()

105    orm.finish()

![img](07Python38c3160b-3132.jpg)



106

![img](07Python38c3160b-3133.jpg)



107    if __name__ == '__main__':

108    main()

#### Lines 82-84

最后一个方法是 finish, 它来提交整个事务.

#### 第86-114行

main() 函数是整个应用程序的入口, 它创建了一个 MySQLAlchemy 对象并通过它完成所有的 数据库操作. 这段脚本和 ushuffle_db.py 功能一样. 你会注意到数据库参数 db 是可选的,而且

在ushuffle_sa.py和即将碰到的ushuffle_so.py中，它不起任何作用.它只是一个占位符以方

便你对这个应用程序添加其它的数据库支持.(参见本章后面的习题)

运行这段脚本， 你会看到类似下面的输出:

![img](07Python38c3160b-3134.jpg)



![img](07Python38c3160b-3135.jpg)



$ ushuffle_sa.py

*** Connecting to 'test' database

*** Creating users table

*** Inserting names into table

![img](07Python38c3160b-3136.jpg)



| LOGIN   | USERID | PROJit |
| ------- | ------ | ------ |
| Serena  | 7003   | 4      |
| Faye    | 6812   | 4      |
| Leslie  | 7808   | 3      |
| Ernie   | 7410   | 1      |
| Dave    | 7306   | 2      |
| Melissa | 8602   | 1      |
| Amy     | 7209   | 3      |
| Angela  | 7603   | 4      |
| Jess    | 7912   | 2      |
| Larry   | 7311   | 1      |
| Jin     | 7512   | 2      |
| Davina  | 7902   | 3      |
| Stan    | 7607   | 4      |
| Pat     | 7711   | 2      |
| Aaron   | 8312   | 2      |
| Elliot  | 7911   | 3      |



*** Randomly moving folks from one group (1) to another (3) (3 users moved)

![img](07Python38c3160b-3137.jpg)



| LOGIN   | USERID | PROJ# |
| ------- | ------ | ----- |
| Serena  | 7003   | 4     |
| Faye    | 6812   | 4     |
| Leslie  | 7808   | 3     |
| Ernie   | 7410   | 3     |
| Dave    | 7306   | 2     |
| Melissa | 8602   | 3     |
| Amy     | 7209   | 3     |
| Angela  | 7603   | 4     |
| Jess    | 7912   | 2     |
| Larry   | 7311   | 3     |
| Jim     | 7512   | 2     |
| Davina  | 7902   | 3     |
| Stan    | 7607   | 4     |
| Pat     | 7711   | 2     |
| Aaron   | 8312   | 2     |
| Elliot  | 7911   | 3     |

![img](07Python38c3160b-3138.jpg)



*** Randomly choosing group (2) to delete (5 users removed)



![img](07Python38c3160b-3140.jpg)



![img](07Python38c3160b-3141.jpg)



![img](07Python38c3160b-3142.jpg)



| LOGIN              | USERID | PROJ# |
| ------------------ | ------ | ----- |
| Serena             | 7003   | 4     |
| Faye               | 6812   | 4     |
| Leslie             | 7808   | 3     |
| Ernie              | 7410   | 3     |
| Melissa            | 8602   | 3     |
| Am/                | 7209   | 3     |
| Angela             | 7603   | 4     |
| Larry              | 7311   | 3     |
| Davina             | 7902   | 3     |
| Stan               | 7607   | 4     |
| Elliot             | 7911   | 3     |
| *** Dropping users | table  |       |

$

逐行解释

#### 第1-10行

除了我们使用的是 SQLObject 而不是 SQLAlchemy 以外， 导入模块和常量声明几乎与 ushuffle_sa.py 相同.

#### 12-42 行

类似我们的SQLAlchemy例子，类的构造器做大量工作以确保有一个数据库可用，然后返回一 个连接.同样的，这也是你能在程序里看到SQL语句的唯一位置.我们这个程序，如果因为某种原 因造成SQLObject无法成功创建用户表，就会陷入无限循环当中.

我们尝试能够聪明的处理错误， 解决掉这个重建表的问题. 因为 SQLObject 使用元类， 我们 知道类的创建幕后发生特殊事件， 所以我们不得不定义两个不同的类， 一个用于表已经存在的情况， 一个用于表不存的情况. 代码工作原理如下:

\1.    尝试建立一个连接到一个已经存在的表. 如果正常工作， OK. （第23-29行）

\2.    如果第一步不成功， 则从零开始为这个表创建一个类， 如果成功， OK. （第31-36行）

\3.    如果第二步仍不成功， 我们的数据库可能遇到麻烦， 那就重新创建一个新的数据库（第

37-40行）

\4.    重新开始新的循环.

希望程序最终能在第一步或第二步成功完成.当循环结束时，类似ushuffle_sa.py，我们得到 合适的对象实例.

#### 第44-67行， 77-78行

这些行处理数据库操作. 我们在 44-47行创建了表， 并在77行删掉了表. 在49-52行插入数据，

在54-60行更新数据，在62-67行删除了数据.78行调用了 finishO方法来关闭数据库连接.我们



不能象SQLAlchemy那样使用删表代理，因为SQLObject的删表代理名为dropTableO而不是

drop().

#### 第69-75行

使用dbDumpO方法，我们从数据库中得到数据，并将它显示在屏幕上.

#### 第80-108行

又到了 main() 函数. 它工作的方式非常类似 ushuffle_sa.py . 同样的， 构造器的 db 参数 仅仅是一个占位符， 用以支持其它的数据库系统(参阅本章最后的习题)

当你运行这段脚本时， 你的输出可能类似这样:

![img](07Python38c3160b-3145.jpg)



$ ushuffle_so.py

| *** Connecting to r | test1  | database |      |
| ------------------- | ------ | -------- | ---- |
| *** Creating users  | table  |          |      |
| *** Inserting names | into   | table    |      |
| LOGIN               | USERID | PRCXT#   |      |
| Jess                | 7912   | 1        |      |
| Amy                 | 7209   | 4        |      |
| Melissa             | 8602   | 2        |      |
| Dave                | 7306   | 4        |      |
| Angela              | 7603   | 4        |      |
| Serena              | 7003   | 2        |      |
| Aaron               | 8312   | 1        |      |
| Leslie              | 7808   | 1        |      |
| Stan                | 7607   | 3        |      |
| Pat                 | 7711   | 3        |      |
| Jim                 | 7512   | 4        |      |
| Larry               | 7311   | 3        |      |
| Ernie               | 7410   | 2        |      |

4



![img](07Python38c3160b-3146.jpg)



Faye 6812 Davina 7902 Elliot 7911



*** Randomly moving folks from one group (2) (3 users moved)



to another (3)



![img](07Python38c3160b-3147.jpg)



| LOGIN   | USERID | PROJ# |
| ------- | ------ | ----- |
| Jess    | 7912   | 1     |
| Amy     | 7209   | 4     |
| Melissa | 8602   | 3     |
| Dave    | 7306   | 4     |
| Angela  | 7603   | 4     |
| Serena  | 700S   | 3     |
| Aaron   | 8312   | 1     |
| Leslie  | 7803   | 1     |
| Stan    | 7607   | 3     |
| Pat     | 7711   | 3     |
| Jim     | 7512   | 4     |
| Larry   | 7311   | 3     |
| Ernie   | 7 410  | 3     |
| Faye    | 6812   | 4     |
| Davina  | 7902   | 1     |
| Elliot  | 7911   | 4     |

![img](07Python38c3160b-3148.jpg)



\* * * Randomly choosing group (6 users removed)

(3) to delete



![img](07Python38c3160b-3149.jpg)



| LOGIN  | USERID | PROJ# |
| ------ | ------ | ----- |
| Jess   | 7912   | 1     |
| Amy    | 7209   | 4     |
| Dave   | 7306   | 4     |
| Angela | 7603   | 4     |
| Aaron  | 8312   | 1     |
| Leslie | 7808   | 1     |
| Jim    | 7512   | 4     |
| Faye   | 6812   | 4     |
| Davina | 7902   | 1     |
| Elliot | 7911   | 4     |



![img](07Python38c3160b-3150.jpg)



*** Dropping users table S

Edit By Vheavens

### 21.3.4 总结

关于如何在python中使用关系型数据库，希望我们前面介绍的东西对你有用.当你应用程序的 需求超出纯文本或类似DBM等特殊文件的能力时，有多种数据库可以选择，别忘了还有一个完全由 Python实现的真正的免安装维护和管理的真实数据库系统.你能在下面找到多种Python数据库接口 程序和0RM系统.我们也建议你研宄一下互联网上的DB-SIG的网页和邮件列表.类似其它的软件 开发领域， 只不过 Python 更简单易学， 用户体验更好.

### 21.4 相关模块

![img](07Python38c3160b-3151.jpg)



表21.8列出了常见的Python数据库接口程序，注意不是所有的接口程序都是DB-API兼容



的.



表 21.8 数据库相关模块及其站点

名字

数据库

Gadfly

MySQL



网站 参考或描述

<http://gadfly.sf.net>

<http://mysql.com> or <http://mysql.org>

MySQLdb a.k.a. MySQL-

Python    <http://sf.net/projects/mysql-python>

PostgreSQL <http://postgresql.org> Psycopg    <http://initd.org/projects/psycopg1>

psycopg2    <http://initd.org/software/initd/psycopg/>

PyPgSQL    <http://pypgsql.sf.net>

PyGreSQL    <http://pygresql.org>

PoPy 已废弃， 与 PyGreSQL 项目合并 SQLite    <http://sqlite.org>

![img](07Python38c3160b-3153.jpg)



pysqlite    <http://initd.org/projects/pysqlite>

![img](07Python38c3160b-3154.jpg)



sqlite3a    pysqlite已经整合到Python标准库；除非你要下载最新的补丁，否则建议

使用标准库

APSW <http://rogerbinns.com/apsw.html> 表 21.8 数据库相关模块及其站点(续)

名字 网站 参考或描述

数据库

MaxDB (SAP) <http://mysql.com/products/maxdb>

sdb [http://dev.mysql.com/downloads/maxdb/7.6.00.html#Python](http://dev.mysql.com/downloads/maxdb/7.6.00.html%23Python)

sapdb <http://sapdb.org/sapdbPython.html>

Firebird (InterBase) <http://firebird.sf.net>

KInterbasDB <http://kinterbasdb.sf.net>

SQL Server    <http://microsoft.com/sql>

pymssql    <http://pymssql.sf.net> (requires FreeTDS [<http://freetds.org>])

adodbapi    <http://adodbapi.sf.net>

Sybase <http://sybase.com>

sybase <http://object-craft.com.au/projects/sybase>

Oracle <http://oracle.com>

cx_Oracle    <http://starship.python.net/crew/atuining/cx_Oracle>

DCOracle2    <http://zope.org/Members/matt/dco2>

(older， for Oracle8 only)

![img](07Python38c3160b-3155.jpg)



Ingres <http://ingres.com>

Ingres DBI <http://ingres.com/products/Prod_Download_Python_DBI.html> ingmod <http://www.informatik.uni-rostock.de/~hme/software/>



![img](07Python38c3160b-3157.jpg)



![img](07Python38c3160b-3158.jpg)



![img](07Python38c3160b-3159.jpg)



ORMs

SQLObject

SQLAlchemy

PyDO/PyDO2



<http://sqlobject.org>

<http://sqlalchemy.org>

<http://skunkweb.sf.net/pydo.html>



a.    pysqlite已经添加到python2.5中，作为它的sqlite3模块

### 21.5 练习

21-1. 什么是 Python DB-API? 它是一个好东西么? 为什么是?(或为什么不是?)

21-2. 描述一下数据库模块参数风格之间的不同在哪儿?

21-3. 游标对象的 execute*() 系列方法有何区别?

21-4. 游标对象的 fetch*() 系列方法有何区别?

21-5.    研宄一下你使用的数据库及相应的python模块.它是否与DB-API兼容？该模块是

否提供了 DB-API必须功能之外的更多特性？

21-6.针对你使用的数据库和DB-API接口程序，学习使用Type对象写一段小的脚本，至 -少要用到其中的一个对象.

![img](07Python38c3160b-3160.jpg)



21 - 7. 重构例子21.1(ushuffle_db.py)中的create()函数，一个table会先被删除， 然后递归调用create()函数重建这个table.如果在重建这个table时失败，就会陷入无限循 环之中.通过在异常处理中不再调用create命令(cur.executeO)修复这个问题，搞一个更实用 的解决方案出来. 附加题： 实现如果创建 table 失败， 在返回失败之前最多重试三次.

21-8.

数据库和html利用现有数据库的一个表和你在第20章学到的开发知识，读出数据库表的内容， 将它放到一个 html table 中去.

21-9. 数据库网站开发给我们的user shuffle例子写一个网页界面.

21-10. 数据库界面编程 给我们的 user shuffle 例子写一个图形界面.

21-11. 股票投资组合类 修改第十三章股票数据的例子， 将它改造为使用某一种关系数据库

保存数据.

21-12. 切换 ORM 后端为其它的数据库. 将 SQLAlchemy(ushuffle_sa.py) 或 SQLObject(ushuffle_so.py) 应用程序后端数据库由 MySQL 切换为另一种数据库系统.

![img](07Python38c3160b-3161.jpg)
