形用户界面编程



![img](07Python38c3160b-2613.jpg)



本章主题

*引言

•    Tkinter 与 Python 编程

•    Tkinter 模块

•    Tk组件库

•    Tkinter使用举例

•标签、按钮与进度条组件

•    一个使用Tk的中级范例

•其他GUI简介(Tix，Pmw, wxPython, PyGTK) •相关模块和其他GUI

![img](07Python38c3160b-2614.jpg)



![img](07Python38c3160b-2615.jpg)



![img](07Python38c3160b-2616.jpg)



![img](07Python38c3160b-2617.jpg)



![img](07Python38c3160b-2618.jpg)



![img](07Python38c3160b-2619.jpg)



![img](07Python38c3160b-2620.jpg)



![img](07Python38c3160b-2621.png)



本章我们将对图形用户界面(GUI)进行简介。不论您是初次涉及该领域还是想学到更多，抑或 只是想看看Python是如何做的，这一章都会适合您。在这短短的一章里我们无法对GUI程序开发介 绍得面面俱到，但我们将给您讲解最核心的内容。Python的默认GUI工具集是Tk，它也是我们将使 用的最基本的GUI工具集，我们可以通过Python接口 Tkinter来使用TkCTkinter正是“Tk接口”

![img](07Python38c3160b-2622.jpg)



Tk并非“最强、最新”也不是包含GUI构建模块最多的工具集，但它非常简单，并且可以开发 出能运行于大多数平台的GUI程序。我们将用Tkinter举几个例子其中包括一个中级范例，随后我 们还将给出几个其他工具集的例子。一旦完成了本章的学习，您将掌握构建复杂应用程序的技巧， 也有能力转向那些更流行的图形工具集。Python有许多对主流工具集的绑定(Binding)或转接 (Adaptor)，其中不乏对商业系统的，这里就不多介绍了。

### 19.1 简介

### 19.1.1 什么是 Tcl、Tk 和 Tkinter?

Tkinter是Python的默认GUI库，它基于Tk工具集，后者最初是为工具命令语言(Tcl)设计 的。Tk流行后被移植到许多其他脚本语言中，包括Perl(Perl/Tk)、Ruby(Ruby/Tk)和Python (Tkinter)。借助于Tk开发GUI的可移植性和灵活性，加上脚本语言的简洁和系统语言的强劲，我 们得到了一件可与商业软件相匹敌的利器，它可以用于快速开发各种GUI程序。

如果是初涉GUI编程，您会惊喜地发现一切竟如此简单。您也会发现Python搭配Tkinter提供 了一种高效的、激动人心的应用程序构建方式，可以用来开发出有趣(并且往往还有用)的程序。

![img](07Python38c3160b-2623.jpg)



而同样的程序如果直接使用C/C++，基于本地窗口系统库开发将多花很长的时间。一旦设计好了程序

及相应外观，您接下来要做的只是用那些被称作组件的基本构造块去搭建想要的模块，最终再赋予

其功能就能让一切“活起来”。



如果您是个Tk老手，不论是使用过Tcl还是Perl，都会发现Python提供了一种进行GUI编程 的全新方式。Python基于Tk提供了一种更高效的快速原型系统用以创建应用。别忘了您同时还享有 Python的系统访问、网络操作、XML、数字可视化、数据库访问、以及所有其他标准库和第三方模块。

一旦您在自己的系统中装好了 Tkinter，用不了 15分钟就可以让您的第一个GUI程序运行起来！

### 19.1.2安装和使用Tkinter

类似于线程模块，您系统中的Tkinter未必是默认开启的。您可以通过尝试导入Tkinter模块 来判断它是否能被Python解释器使用。如果Tkinter是可用的，不会出现任何错误：

\>>> import Tkinter >>>

而如果您的Python解释器在编译时没有启用Tkinter，导入过程将失败。

![img](07Python38c3160b-2625.jpg)



\>>> import Tkinter

Traceback (innermost last):

File "<stdin>", line 1, in ?

File "/usr/lib/python1.5/lib-tk/Tkinter.py", line 8, in ?

import _tkinter # If this fails your Python may not be configured for Tk

ImportError: No module named _tkinter

这时您不得不重编译Python解释器来访问Tkinter。这通常会涉及编辑Modules/Setup文件和 启用所有正确选项来编译您的Python解释器，以确保Tkinter能被选择安装在系统中。请检查您 Python发行包中的README文件，里面有把Tkinter编译进系统的操作说明。请确定您编译完后启动 的是刚刚创建的新Python解释器，否则它会像那个旧的不含Tkinter的解释器一样工作（实际上， 它就是您那个旧解释器）。

### 19.1.3 客户端/服务器架构

在之前介绍的网络编程中，我们介绍了客户端/服务器计算模式的概念。窗口系统就是软件服务 器的另一个例子，它们运行在一个有显示设备的机器上，比如带有一个某种类型的显示器。当然还 有客户端（那些需要窗口环境来运行的程序，也就是我们所说的GUI程序），这些程序无法脱离窗口

![img](07Python38c3160b-2626.jpg)



系统单独运行。



这种架构混合网络应用将显得更加有趣。通常一个GUI程序被执行时会在启动它的机器上显示

（通过窗口服务器），但也可以在一些网络化的窗口环境中（例如Unix的X Window系统）选择其它 机器的窗口服务器去显示。这样，您就可以在一台机器上运行GUI程序而在另一台机器上显示它！

### 19.2 Tkinter 与 Python 编程

### 19.2.1 Tkinter模块：把Tk引入您的程序

为了让Tkinter成为您程序的一部分，应该怎么做呢？这并不是说您一定要先有一个应用程序。 只有您愿意，当然可以创建一个纯粹的GUI程序，但如果没有让人感兴趣的功能的话，这个程序也 许不会很有用。

要创建并运行您的GUI程序，下面五步是基本的：

1.

2.



导入 Tkinter 模块（import Tkinter，或者，from Tkinter import *）。

创建一个顶层窗口对象，来容纳您的整个GUI程序。

![img](07Python38c3160b-2628.jpg)



3.

\4. 5.



在您的顶层窗口对象上（或者说在“其中”创建所有的GUI模块（以及功能）。

把这些GUI模块与底层程序代码相连接。

进入主事件循环。

第一步很明显：所有使用Tkinter的GUI程序必须先导入Tkinter模块。第一步就是为了获得 Tkinter的访问权（参加19.1.1小节）。

### 19.2.2 GUI程序开发简介

在举例之前，我们将先从宏观上来给您简单介绍一下GUI程序开发。这将给您以后的学习提供 一些必要的背景知识。

创建GUI程序与画家作画有些相似。通常画家只会在一块画布上开展自己的创作。工作步骤或 许是这样的：首先要找来一块干净的石板，您将在这个“顶层”窗口对象上创建所有其他模块。可 以把这一步想象成一座房屋的地基或者某个画家的画架。换言之，在搭建各实物或展开画布之前， 您必须先给地基浇灌好混凝土或者架好画架。对Tkinter而言，这个基础被称为顶层窗口对象。

在GUI程序中，会有一个顶层根窗口对象，它包含着所有小窗口对象，它们共同组成一个完整 的GUI程序。这些小窗口对象可以是文字标签、按钮、列表框等等。这些独立的GUI构件就是所谓 的组件。所以当我们说创建一个顶层窗口的时候，我们实际上是指您需要一个放置所有组件的地方。

![img](07Python38c3160b-2629.jpg)



典型的Python语句如下行:

top = Tkinter. Tk（） # 如果上文是 “from Tkinter import *"，Tk（）就够了

Tkinter.TkO返回的对象通常被称作根窗口，正因为如此，有些程序用root来指示它，而非top。 顶层窗口是指那些在您的程序中独立显示的部分。您可以在GUI程序中创建多个顶层窗口，但它们 中只能有一个是根窗口。您可以采用先完全设计好组件再添加实际功能的开发方式，也可以二者同 时进行。（这意味着交替执行上述五步中的第三步和第四步。）

组件既可以是独立的也可以作为容器存在。如果一个组件“包含”其他组件，它就被认为是这

些组件的父组件。相应地，如果一个组件被“包含”在其他组件中，它就被认为是父组件的孩子，

父组件则是直接包围其外的那个容器组件。

通常，组件会有一些相应的行为，例如按钮被按下，或者文本框被写入。这种形式的用户行为 被称为事件，而GUI程序对事件所采取的响应动作被称为回调。

用户操作包括按下（以及释放）按钮、移动鼠标、按下RETURN或Enter键等等，所有的这些从 系统角度都被看作事件。GUI程序正是由这伴随其始末的整套事件体系所驱动的。这个过程被称作事

件驱动处理。

一个事件及其回调的例子是鼠标移动。我们假设鼠标指针停在您GUI程序的某处。如果鼠标被 移到了程序的别处，一定是有什么东西引起了屏幕上指针的移动，从而表现这种位置的转移。系统 必须处理这些鼠标移动事件才能展现（并实现）鼠标在窗口上的移动。一旦您释放了鼠标，就不再

会有事件需要处理，相应地，屏幕上的一切又复归平静。

⑶I程序的事件驱动特性恰好体现出它的客户端/服务器架构。当您启动一个GUI程序时，它必 须执行一些初始化例程来为核心功能的运行做准备，正如启动一个网络服务器时必须先申请一个套 接字并把它绑定在一个本地地址上一样。Tk有两个坐标管理器用来协助把组件放在正确的位置上； 您将经常用到的一个称为“包”亦即packer。另一个坐标管理器是网格（Grid）--您可以用它来把 ⑶I组件放在网格坐标系中，Grid将依据GUI中的网格坐标来生成每个对象。我们将紧扣packer讲 解。

一旦packer决定好您所有组件的尺寸和对齐方式，它将为您在屏幕上放置它们。当所有这些组 件，包括顶层窗口，最终显示在您屏幕上时，⑶I程序就会进入一个“服务器式”的无限循环。这个 无限循环包括等待⑶I事件、处理事件、然后返回等待模式，等待下一个事件。

上述最后一步说明所有组件就绪后立即进入主循环。这正是我们提及的“服务器式”无限循环。 对Tkinter而言，相应代码如下：

Tkinter.mainloop()

这通常是您程序执行的最后一段代码。一旦进入主循环，⑶I便从此掌握控制权。所有其他动作

都来自回调函数，包括程序退出。当您拉下文件菜单点击“退出”菜单项或直接关闭窗口时，必须

要唤起一个回调来结束您的程序。

Edit By Vheavens

### 19.2.3 顶层窗口： Tkinter.TkO

我们前面提到所有的主要组件都建立在顶层窗口对象内。这个对象是由Tkinter中的Tk类创建 的，并且是由普通构造函数创建的：

\>>> import Tkinter >>> top = Tkinter.Tk（）

在这个窗口中，您可以放置独立组件或集成的模块来构建您的⑶I。那么，都有哪些组件可用呢？ 我们下面就来介绍Tk组件。

### 19.2.4 Tk 组件

Tk目前有15种组件。我们在表19.1中列出了它们。

我们不准备对所有Tk组件都一一详细讲解，因为已经有许多关于它们的很好的文章可供参考--不论是从Python网站的Tkinter主题页面还是数量可观的Tcl/Tk印刷品，抑或是在线资源（其中 一些可以在附录B中找到）。然而，我们将讲解一些例子来帮您启航。

核心注释：缺省参数是您的朋友

GUI开发从Python的缺省参数机制获益匪浅,因为Tkinter组件有大量的默认动作。除非您熟

知自己使用的每一个组件的每一个可用选项，否则最好只设置您关心的参数而把其他的交由系统处

理。这些缺省值是精心选出的。

如果您没有提供这些值也不必担心程序会在屏幕上表现怪异。作为一条基本规则，程序都由一

系列经优化的缺省值创建，并且只有当您明确知道如何配置您的组件时，才有必要用自己的值替换

这些缺省值。

组件 描述

Button 按钮。类似标签，但提供额外的功能，例如鼠标掠过、按下、释放以及键盘操作/事件

Canvas 画布。提供绘图功能（直线、椭圆、多边形、矩形）；可以包含图形或位图

Checkbutton选择按钮。一组方框，可以选择其中的任意个（类似HTML中的checkbox）

Entry 文本框。单行文字域，用来收集键盘输入（类似HTML中的text）

Frame 框架。包含其他组件的纯容器

![img](07Python38c3160b-2634.jpg)



Label 标签。用来显示文字或图片

Listbox 列表框。一个选项列表，用户可以从中选择

Menu 菜单。点下菜单按钮后弹出的一个选项列表，用户可以从中选择

Menubutton 菜单按钮。用来包含菜单的组件（有下拉式、层叠式等等）

Message 消息框。类似于标签，但可以显示多行文本

Radiobutton单选按钮。一组按钮，其中只有一个可被“按下”（类似HTML中的radio）

Scale 进度条。线性“滑块”组件，可设定起始值和结束值，会显示当前位置的精确值 Scrollbar 滚动条。对其支持的组件（文本域、画布、列表框、文本框）提供滚动功能 Text    文本域。多行文字区域，可用来收集（或显示）用户输入的文字（类似HTML中的textarea）

Toplevel 顶级。类似框架，但提供一个独立的窗口容器。

<------------------------------------------------------------------------------

例19.1标签组件演示(tkhello1.py)

我们的第一个Tkinter例子是......还能是什么呢？ “Hello World!”具体地说，是介绍我们

的第一个组件：标签。

1    #!/usr/bin/env python

2

![img](07Python38c3160b-2635.jpg)



3    import Tkinter

4

5 top = Tkinter.Tk()

6    label = Tkinter.Label(top, text='Hello World!')

7    label.pack()

8    Tkinter.mainloop()

------------------------------------------------------------------------------>

### 19.3 Tkinter 举例

### 19.3.1标签组件

在例19.1中，我们展示了 Tkinter版的“Hello World!" -- tkhello1.py。实际上，它利用组 件向您展示了如何创建一个Tkinter应用程序。

第一行，我们先创建了一个顶层窗口。随后是写着那串举世闻名的字符的标签组件。我们指明 用packer来管理和显示组件，并最终调用mainloopO来运行GUI程序。图19-1展示了运行该GUI 程序后，您将会看到的效果。

![img](07Python38c3160b-2636.jpg)



![img](07Python38c3160b-2637.jpg)



### 19.3.2 按钮组件

第二个例子和第一个很相似。但我们这次将创建一个按钮而不只是显示一个简单的文字标签。 例 19.2 是 tkhello2.py 的源码。

<-

Unix (twm)

Windows



图 19-1 Tkinter Label widget (tkhello1.py)

例19.2按钮组件演示(tkhello2.py)

本例和tkhello1.py完全相同，除了我们创建的是按钮组件而非标签组件。

![img](07Python38c3160b-2639.jpg)



1    #!/usr/bin/env python

![img](07Python38c3160b-2640.jpg)



2

3    import Tkinter

4

5    top = Tkinter.Tk()

6    quit = Tkinter.Button(top, text='Hello World!',

7    command=top.quit)

8    quit.pack()

9    Tkinter.mainloop()

------------------------------------------------------------------------------>

前面几行是相同的。不同的只是我们创建的是按钮组件。我们的按钮有一个额外的参数， Tkinter.quitO方法。这将给我们的按钮安装一个回调函数，在按钮按下(并释放)后让整个程序 退出。最后的两行是通常的pack()和进入mainloopO。这个简单的按钮应用程序展示在图19-2中。

### 19.3.3 标签和按钮组件

我们把tkhello1.py和tkhello2.py组合到tkhello3.py中，得到一个同时包含标签和按钮的 脚本。另外，我们现在还使用了更多的参数，而不再满足于完全使用那些自动添入的缺省参数。例

![img](07Python38c3160b-2641.jpg)



19.3 给出了 tkhello3.py 的源码。



除了对组件新加的参数，我们还看到对packer的一些参数。fill参数告诉packer让QUIT按钮 填充水平方向的剩余空间，而expand参数则引导packer填充了水平方向的所有可视空间，并拉伸 按钮到达窗口的左右边界。

Unix    Windows

图 19-2Tkinter Label widget (tkhello1.py)



例19.3标签和按钮组件演示（tkhello3.py）

本例同时展示了标签和按钮组件。既然我们已经了解了按钮组件和如何配置它，我们就可以设

置的更多一些，而不必像以前那样大都使用缺省参数。

1    #!/usr/bin/env python

![img](07Python38c3160b-2644.jpg)



2

3 import Tkinter

4    top = Tkinter.Tk()

5

6    hello = Tkinter.Label(top, text='Hello World!')

7    hello.pack()

8

9    quit = Tkinter.Button(top, text='QUIT',

10    command=top.quit, bg='red', fg='white')

11    quit.pack(fill=Tkinter.X, expand=1)

12

13 Tkinter.mainloop()

------------------------------------------------------------------------------>

正如您在图19-3中看到的，对packer没有其他指令时，组件是按垂直顺序放置的（依次放在 其他组件的上面）。要水平放置则需要创建一个框架对象，再用它来添加按钮。作为父对象的唯一子 对象，框架将占据父对象的空间（参见19.3.6小节例19.6中listdir.py模块对按钮的处理）。

![img](07Python38c3160b-2645.jpg)



<





Hello Wbrid!



Hello World!



QUIT



Windows



Unix

图 19-3 Tkinter Label and Button widgets (tkhello3.py)

### 19.3.4 标签、按钮和进度条组件

我们的最后一个小例子tkhello4.py，增加了一个进度条组件。具体来说，这个进度条是用来和 标签组件交互的。进度条的滑块被用作控制标签组件文本大小的工具。滑块的位置值越大字体就越

大，反之亦然，越小的位置值意味着越小的字体。例19.4展示了 tkhello4.py的源码。

![img](07Python38c3160b-2648.jpg)



<------------------------------------------------

例19.4标签，按钮和进度条组件演示(tkhello4.py)

我们最后一个组件例子介绍了进度条组件，重点放在组件间通过回调函数的交互［诸如 resize()］。您对进度条组件的动作将影响标签组件上的文字。

1    #!/usr/bin/env python

2

3    from Tkinter import *

4

5    def resize(ev=None):

6    label.config(font='Helvetica -%d bold' % \

7    scale.get())

8

9    top = Tk()

10    top.geometry('250x150')

11

12    label = Label(top, text='Hello World!',

13    font='Helvetica -12 bold')

![img](07Python38c3160b-2649.jpg)



![img](07Python38c3160b-2650.jpg)



14    label.pack(fill=Y, expand=1)

15 16 17 18

19

20 21 22

23

24 25



scale = Scale(top, from_=10, to=40, orient=HORIZONTAL, command=resize)

scale.set(12)

scale.pack(fill=X, expand=1)

quit = Button(top, text="QUIT",

command=top.quit, activeforeground='white', activebackground='red')

quit.pack()



26 mainloop()



这段脚本新增加的resizing（）回调函数（5-7行）附加在进度条组件上。这段代码在进度条的 滑块被移动时激活，调整标签里文字的大小。



![img](07Python38c3160b-2651.jpg)



我们还限定了顶层窗口的尺寸（250X 150）（第10行）。这段脚本和前3段的最后一个不同点 是用“from Tkinter import *”把Tkinter模块的属性引入我们的名字空间。虽然不建议这样做， 因为这会“污染”您的名字空间，但这个程序涉及大量对Tkinter属性的引用，这正是我们这样做 的主要原因。这种方式（译者注：原文这里表达的不够清晰，本意是指import Tkinter的方式）

要求访问每个属性时都使用它们的全部限定性名称。而通过这种不被推荐的快捷方式，我们可以在

访问属性时减少输入并且让代码易于理解，但同时也付出了一些代价。



![img](07Python38c3160b-2652.jpg)



正如您在图19-4所看到的，滑块装置及当前位置值都显示在窗口的显著位置 用户把进度条/滑块移动到36时的⑶I程序状态。



图19-4展示了



<-

Unix



![img](07Python38c3160b-2654.jpg)



![img](07Python38c3160b-2655.jpg)



![img](07Python38c3160b-2656.jpg)



![img](07Python38c3160b-2657.jpg)



![img](07Python38c3160b-2658.jpg)



![img](07Python38c3160b-2659.jpg)



Hello World!

36

JJ

QUIT

Windows



图 19-4 Tkinter Label, Button, and Scale

widgets (tkhello4.py)

------------------------------------------------------------------------------>

从代码中可以看出，进度条的初始值在程序启动时被设置为12（第18行）。

### 19.3.5偏函数应用举例

在看更大的GUI程序之前，我们先回顾一下第11章11.7.3节介绍的偏函数应用（PFA）。

Python2.5新增了 PFA等一系列新特性，它们显著提高了 Python对函数编程的支持。

偏函数允许您“预存”一些函数变量并有效的“冻结”了这些预定参数，在运行时您获得了所

需的其他变量后再把它们“解冻”出来，用这些最终确定的参数去调用函数。

最妙的是，PFA不仅仅局限于函数。它们对任何“可调用”的东西都有效，任何有函数接口的对 象，比如类、方法、或可调用对象，只要是有括号的。对于有许多待调对象并且许多调用都反复使 用相同参数的情况，用PFA是最合适不过的。

⑶I编程有很好的操作环境，因为很有可能您需要GUI组件有某些一致的外观和体验，而这些一 致性表现在可以使用相同的参数创建相似的对象。我们现在要展示的应用程序中，将有多个按钮有 着相同的前景色和背景色。对这些仅有细小差别的按钮，每次调相同的构造函数作初始化时都输入 些相同的参数实在是一种浪费：前景和背景色都一样，只是文字有细小差别。

我们将用交通指示牌作为例子，程序中尝试创造一种文字型的交通指示牌，并且把它们分成如 下几类：危急、警告、通知（正好和日志信息级别相）。指示牌的类型决定了它们在创建时的颜色格 局。例如，危急指示牌使用亮红文字和白色背景，警告指示牌使用黑色文字和金色背景，通知也就 是普通指示牌使用黑色文字和白色背景。我们约定“Do Not Enter”和“Wrong Way”标识为危急， “Merging Traffic” 和 “Railroad Crossinig” 标识为警告，“Speed Limit” 和 “One Way” 标识

![img](07Python38c3160b-2661.jpg)



为通知。该程序创造‘‘指示牌”它们都只是些按钮。当用户点下按钮时，将简单的弹出一个Tk响 应对话框，显示危急/错误、警告、通知。这的确不够好玩，但如何创建这些按钮却很有趣。您将在 例19.5看到这里所描述的程序。



<------------------------------------------------------------------------------

例19.5运用PFA的路灯指示牌GUI程序(pfaGUI2.py)

按照指示类型创建适当前景、背景色的路灯指示牌。使用PFA帮助“模板化”常用⑶I参数。

1    #!/usr/bin/env python

2

3    from functools import partial as pto

4    from Tkinter import Tk, Button, X

5    from tkMessageBox import showinfo, showwarning, showerror

6

7    WARN = 'warn'

8    CRIT = 'crit'

9    REGU = 'regu'

10

![img](07Python38c3160b-2663.jpg)



11    SIGNS = {

12    'do not enter': CRIT,

13    'railroad crossing': WARN,

14    '55\nspeed limit': REGU,

15    'wrong way': CRIT,

16    'merging traffic': WARN,

17    'one way': REGU,

18    }

19

20    critCB = lambda: showerror('Error', 'Error Button Pressed!')

21    warnCB = lambda: showwarning('Warning',

22    'Warning Button Pressed!')

23    infoCB = lambda: showinfo('Info', 'Info Button Pressed!')

24

25    top = Tk()

26    top.title('Road Signs')

27    Button(top, text='QUIT', command=top.quit,

28    bg='red', fg='white').pack()

29

30    MyButton = pto(Button, top)

31    CritButton = pto(MyButton, command=critCB, bg='white', fg='red')

![img](07Python38c3160b-2664.jpg)



| 32   | WarnButton = pto(MyButton, command=warnCB, bg='goldenrod1') |
| ---- | ----------------------------------------------------------- |
| 33   | ReguButton = pto(MyButton, command=infoCB, bg='white')      |
| 3435 | for eachSign in SIGNS:                                      |
| 36   | signType = SIGNS[eachSign]                                  |
| 37   | cmd = '%sButton(text=%r%s).pack(fill=X, expand=True)' % (   |
| 38   | signType.title(), eachSign,                                 |
| 39   | '.upper()' if signType == CRIT else '.title()')             |
| 40   | eval(cmd)                                                   |
| 4142 | top.mainloop()                                              |

图 19-5Road signs PFA GUI application on XDarwin in

MacOS X (pfaGUI2.py)

------------------------------------------------------------------------------>

当您执行这个程序时，会看到一个类似图19.5的⑶I。

逐行注解

#### 1-18行

作为开始，我们导入了 functional.partial（）、一些Tkinter属性以及Tk对话框（1-5行）。 然后，我们定义了一些标识及其相应类型。

#### 20-28行

Tk对话框被关联到按钮回调函数，我们将在创建按钮时使用它们（20-23行）。然后加载Tk，设 置标题，并创建了一个QUIT按钮（25-28行）。

![img](07Python38c3160b-2665.jpg)



One Way

55    (|

Speed Limit    |

Merging Traffic



![img](07Python38c3160b-2667.jpg)



30-33行



这些行展示了 PFA的魔力。我们通过两个步骤实现PFA。第一步是模板化的按钮类及根窗口 top。 这样当每次我们调用MyButton时，它会转而调用Button (Tkinter.ButtonO创建了一个按钮)并使 用top作为其第一个参数。我们把这一切“冻结”在了 MyButton里。

PFA的第二步使用了第一步的结果--MyButton--并再次对它模板化。我们对每个不同的指示类型 都创建了单独类型的按钮。当用户创建一个危急按钮CritButton时(通过调用CritButtonO)，它 会转而调用MyButton并使用恰当的按钮回调和前景、背景色参数，这意味着用top、按钮回调、前 景、后景去调用Button。您看出它是如何展开并逐步调用低层直到按钮组件了吗？如果没有PFA这 个特性，它执行的那些调用本该由您自己执行。我们把同样的步骤应用到WarnButton和ReguButton 上。

#### 35-42行

按钮类创建过程结束后，我们遍历了指示列表并创建出指示牌。我们使用了一个Python求值字 串，它由正确的按钮名字、作为按钮标签传入的text参数组成，然后再pack()—下。如果这是个危 急指示牌，我们就把按钮文字全转成大写，否则的话就以标题形式显示。最后一步在第 39 行完成， 同时也展示了 Python2.5引入的另一个特性，临时操作符。随后我们对每一个按钮创建字串施以 eval()，每次创建一个按钮，最终形成了前面看到的图形。最后我们进入主事件循环，启动GUI。

这个应用程序使用了一些Python2.5的新特性，所以您不能在旧版上运行它。

### 19.3.6 中级 Tkinter 范例

我们以一个比较大型的例子来总结本节，listdir.py。这个应用程序是一个目录树遍历工具。 它从当前目录开始并提供文件列表功能。双击列表中的任意其他目录都会让该工具转向这个新的目 录，同时用新目录中的文件列表替换原有的文件列表。源码作为例19.6给出。

<------------------------------------------------------------------------------

例19.6⑶I文件遍历系统(listdir.py)

这个稍高级一些的GUI程序扩大了组建的使用范围，演员名单里新增了列表框、文本框、和滚 动条。而且还有大量的回调函数，例如鼠标点击、键盘输入、和滚动条操作。

1    #!/usr/bin/env python

2

3    import os

4    from time import sleep

5    from Tkinter import *

6

7 class DirList(object):

8

9



10

11

12

13

14

15

16

17

18

19

20 21 22

23

24

25 26

27

28 29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47



![img](07Python38c3160b-2672.jpg)



def __init__(self, initdir=None): self.top = Tk() self.label = Label(self.top,

text='Directory Lister v1.1')

self.label.pack()

self.cwd = StringVar(self.top)

self.dirl = Label(self.top, fg='blue',

font=('Helvetica', 12, 'bold'))

self.dirl.pack()

self.dirfm = Frame(self.top) self.dirsb = Scrollbar(self.dirfm) self.dirsb.pack(side=RIGHT, fill=Y) self.dirs = Listbox(self.dirfm, height=15,

width=50, yscrollcommand=self.dirsb.set) self.dirs.bind('<Double-1>', self.setDirAndGo) self.dirsb.config(command=self.dirs.yview) self.dirs.pack(side=LEFT, fill=BOTH) self.dirfm.pack()

self.dirn = Entry(self.top, width=50, textvariable=self.cwd) self.dirn.bind('<Return>', self.doLS) self.dirn.pack()

self.bfm = Frame(self.top)

self.clr = Button(self.bfm, text='Clear', command=self.clrDir, activeforeground='white', activebackground='blue')

self.ls = Button(self.bfm,

text='List Directory', command=self.doLS, activeforeground='white', activebackground='green')

self.quit = Button(self.bfm, text='Quit', command=self.top.quit,

![img](07Python38c3160b-2673.jpg)



![img](07Python38c3160b-2674.jpg)



![img](07Python38c3160b-2676.jpg)



| 48   | activeforeground='white',                       |
| ---- | ----------------------------------------------- |
| 49   | activebackground='red')                         |
| 50   | self.clr.pack(side=LEFT)                        |
| 51   | self.ls.pack(side=LEFT)                         |
| 52   | self.quit.pack(side=LEFT)                       |
| 53   | self.bfm.pack()                                 |
| 54   |                                                 |
| 55   | if initdir:                                     |
| 56   | self.cwd.set(os.curdir)                         |
| 57   | self.doLS()                                     |
| 58   |                                                 |
| 59   | def clrDir(self, ev=None):                      |
| 60   | self.cwd.set('')                                |
| 61   |                                                 |
| 62   | def setDirAndGo(self, ev=None):                 |
| 63   | self.last = self.cwd.get()                      |
| 64   | self.dirs.config(selectbackground='red')        |
| 65   | check = self.dirs.get(self.dirs.curselection()) |
| 66   | if not check:                                   |
| 67   | check = os.curdir                               |
| 68   | self.cwd.set(check)                             |
| 69   | self.doLS()                                     |
| 70   |                                                 |
| 71   | def doLS(self, ev=None):                        |
| 72   | error = ''                                      |
| 73   | tdir = self.cwd.get()                           |
| 74   | if not tdir: tdir = os.curdir                   |
| 75   |                                                 |
| 76   | if not os.path.exists(tdir):                    |
| 77   | error = tdir + ': no such file'                 |
| 78   | elif not os.path.isdir(tdir):                   |
| 79   | error = tdir + ': not a directory'              |
| 80   |                                                 |
| 81   | if error:                                       |
| 82   | self.cwd.set(error)                             |
| 83   | self.top.update()                               |
| 84   | sleep(2)                                        |
| 85   | if not (hasattr(self, 'last') \                 |
| 86   | and self.last):                                 |
| 87   | self.last = os.curdir                           |



![img](07Python38c3160b-2677.jpg)



![img](07Python38c3160b-2678.jpg)



![img](07Python38c3160b-2679.jpg)



| 8889 | self.cwd.set(self.last)self.dirs.config(\ |
| ---- | ----------------------------------------- |
| 90   | selectbackground='LightSkyBlue')          |
| 91   | self.top.update()                         |
| 92   | return                                    |
| 93   |                                           |
| 94   | self.cwd.set(\                            |
| 95   | 'FETCHING DIRECTORY CONTENTS...')         |
| 96   | self.top.update()                         |
| 97   | dirlist = os.listdir(tdir)                |
| 98   | dirlist.sort()                            |
| 99   | os.chdir(tdir)                            |
| 100  | self.dirl.config(text=os.getcwd())        |
| 101  | self.dirs.delete(0, END)                  |
| 102  | self.dirs.insert(END, os.curdir)          |
| 103  | self.dirs.insert(END, os.pardir)          |
| 104  | for eachFile in dirlist:                  |
| 105  | self.dirs.insert(END, eachFile)           |
| 106  | self.cwd.set(os.curdir)                   |
| 107  | self.dirs.config(\                        |
| 108  | selectbackground='LightSkyBlue')          |
| 109  |                                           |
| 110  | def main():                               |
| 111  | d = DirList(os.curdir)                    |
| 112  | mainloop()                                |
| 113  |                                           |
| 114  | •    ，    •夕if __name__ == '__main__':  |
| 115  | main()                                    |



![img](07Python38c3160b-2680.jpg)



![img](07Python38c3160b-2681.jpg)



Windows

图 19-6List directory GUI application in Windows (listdir.py)

------------------------------------------------------------------------------>

在图19-6中，我们展示了 Windows环境中的GUI外观。    —

这个程序的Unix版本在图19-7中展示。

逐行注解

#### 1-5行

开始的几行包括通常的Unix启动行和导入os模块、time.sleep函数、及Tkinter模块的所有 属性。

#### 9-13行

这些行定义了 DirList类的构造函数，以及一个代表我们程序的对象。我们创建的第一个标签 包含了应用程序的主标题和它的版本号。

![img](07Python38c3160b-2685.jpg)



![img](07Python38c3160b-2686.jpg)



![img](07Python38c3160b-2687.jpg)



![img](07Python38c3160b-2688.jpg)



![img](07Python38c3160b-2689.jpg)



<



![img](07Python38c3160b-2691.jpg)



图 19-7 List directory GUI application in Unix

![img](07Python38c3160b-2692.jpg)



(listdir.py)

------------------------------------------------------------------------------>

#### 15-19行

我们声明了一个名为cwd的Tk变量来保存当前所在目录的名字--我们马上就会看到这个值从哪

来。还创建了另一个标签来显示当前目录的名字。

#### 21-29行

这段代码定义了我们这个GUI程序的核心，dirs (列表框)包含了被列目录的文件列表。使用

一个滚动条以便用户在文件数目超过列表框窗口尺寸时移动列表。这两个组件都被包含在一个框架

组件中。列表框用bind()方法把回调函数(setDirAndGo)和列表项绑定起来。

绑定意味着把一个回调函数连接在键盘输入、鼠标动作、或其他什么事件上，当这个事件被用 户触发时就会执行这个回调函数。当列表框中的任一项被双击时setDirAndGoO函数就会被调用。滚 动条被Scrollbar.configO方法贴附在列表框上。

#### 31-34行

随后我们创建了一个文本框让用户输入目录名，以便转到他/她想去的目录，并在列表框中显示 该目录中的文件。我们为该文字输入区加入了一个RETURN或Enter键的绑定，这样用户就能用敲 RETURN的方法代替按钮点击，同样的事也会发生在上面提到的列表框中。当用户双击列表项时，效

![img](07Python38c3160b-2693.jpg)



果等同于用户在文本框中输入目录名然后点击“go”按钮。

#### 36-53行

接下来我们定义了一个按钮框架(bfm)来保管这三个按钮：一个“clear”按钮(clr)，一个 “go”按钮(ls)，和一个“quit”按钮(quite)。每一个按钮都有各自不同的配置和点击时的回调 函数。

#### 55-57行

构造函数的最后一部分初始化了这个GUI程序，程序将从当前工作目录开始。

#### 59-60行

clrDirO方法清空Tk字符串变量cwd，其中保存着当前的“活动”目录。这个变量用来跟踪我 们当前所处的目录，更重要的是，在错误发生时协助返回上一个目录。您一定注意到了回调函数中 的ev参数的缺省值是None。这样的任意值都可能由窗口系统传回，它们在您的回调函数里可以用也 可以不用。

#### 62-69行

setDirAndGoO方法设置了要到达的目录并产生一个对doLS()方法的调用，后者负责实现其余的

一切。

#### 71-108行

现在看来，doLSO是整个GUI程序的关键。它负责所有的安全性检查(目标是否是一个目录以 及它是否存在？)如果有错误发生，最终目录会被设置为当前目录。如果一切正确，它调用 os.listdirO来取得新的文件集合并替换列表框中的列表。当后台忙于获取新目录信息时，高亮的 蓝色条会变成亮红色。当新目录设置完毕，它会恢复蓝色。

#### 110-115行

listdir.py中的最后一段代码明显是代码的主体。main()函数只有在该脚本被直接调用时才会 执行，并且当它执行时会创建GUI程序，后者随之掌控该程序。

我们把该程序的所有其他方面都留给读者作为练习，再次提醒您，把整个程序看成是一系列组

件和功能的组合，一切就都会简单起来。如果您清楚的知道每个单独程序段的意思，那么整个脚本

就不会再显得可怕了。

但愿我们给了您一个够好的关于Python和Tkinter的GUI编程介绍。请记住熟悉Tkinter编程 最好的方法就是实践和模仿一些例子！ Python发行包附带了很多可供您学习的应用程序范例。

如果您下载了源码包，就会在Lib/lib-tk、Lib/idlelib、和Demo/tkinter下发现Tkinter的 演示代码。如果您把Win32版本的Python安装在C:\Python2.x，那么可以在Lib\lib-tk和 Lib\idlelib下找到这些演示代码。最后那个目录包含了最出名的Tkinter例子程序：IDLE

Edit By Vheavens

Edit By Vheavens

IDE本身。还有一些关于Tk编程的书籍供进一步参考，其中一本是专为Tkinter编写的。



### 19.4其他GUI简介

我们期望最终能编写出独立的一章来对GUI编程作总体介绍，Python拥有的大量图形工具集中 有很多内容值得一讲，然而，这只能是以后的事了。作为替代，我们将使用其中4种比较流行且可

用的工具集来编写同一个 GUI 程序示例：Tix （Tk Interface extensions）、Pmw （Python MegaWidgets 的 Tkinter 扩展）、wxPython（wxWidgets 的 Python 绑定）、和 PyGTK（GTK+的 Python 绑定）。您可 以在本章末尾参考部分获取更多信息和下载这些工具集的地方。

Tix模块包含在Python标准库中，已经可用了。其他工具集是第三方的，你必须自己下载。因 为Pmw只是对Tkinter的一个扩展，它的安装是最简便的（只需解压到您的网络包目录下）。wxPython 和PyGTK涉及下载多个文件并编译（除非您使用的是Win32版本，这样的话通常有安装包可用）。一 旦这些工具集安装好并通过证，我们就能开始了。我们不打算局限在本章已经讲过的那些组件上， 我们准备在后面的例子中介绍一些更复杂的组件。

除过我们已经看到过的标签和按钮组件，我们准备介绍控制按钮（Control,又叫微调按钮， SpinButton、和组合框组件（ComboBox、。控制组件是一个文本组件和一对箭头按钮的组合，文本 值受旁边按钮的“控制”或者说“旋上、旋下”，而组合框则通常包括一个文本组件和一个下拉菜

H单，菜单项列表中当前激活或选中的项目将显示在文本组件中。

我们的应用程序相当简单：成对的动物要被搬走，动物的总数在从一对到一打（译者注：12只） 的范围内。用控制组件来显示总数，用组合框显示动物种类列表菜单供用户选择。注意默认的动物 数量是2，且没有选择动物类型。

一旦我们开始执行这个程序，事物就变得不同了，图19-9就是例证，它显示的是在Tix程序中

改变一些元素后的结果。

下面，您将看到所有4个版本的GUI程序代码。您会发现尽管它们有些相似，但每一个都有自 己的特别之处。而且我们使用.pyw作为文件后缀，这样可以防止弹出Dos命令窗口或终端窗口。

<------------------------------------------------------------------------------

![img](07Python38c3160b-2697.jpg)



pygtk



Tix



Pmw    wxPython

图 19-8 Application using various GUIs under Win32 (animal*.pyw)

Tix

图 19-9 After modifying the Tix GUI version of our application (animalTix.pyw) ------------------------------------------------------------------------------>

### 19.4.1 Tk Interface eXtensions （Tix）

我们从一个使用Tix模块的例子（19.7）开始。Tix是对Td八（译者注：应该是Tcl/Tk）的一 个扩展库，其中增加了许多新的组件、图像类型和其它一些命令，提高Tk作为GUI开发工具集的可 用性。我们现在来看看如何在Python中使用Tix。

<---------------------------------------------------------

Tix GUI 编程演示(animalTix.pyw)

我们的第一个例子使用Tix模块。Tix已经是Python的一部分了!

1    #!/usr/bin/env python

2

3    from Tkinter import Label, Button, END

4    from Tix import Tk, Control, ComboBox

5

6    top = Tk()

7    top.tk.eval('package require Tix')

8

9    lb = Label(top,

10    text='Animals (in pairs; min: pair, max: dozen)')

11    lb.pack()

12

13    ct = Control(top, label='Number:',

14    integer=True, max=12, min=2, value=2, step=2)

15    ct.label.config(font='Helvetica -14 bold')

16    ct.pack()

17

18    cb = ComboBox(top, label='Type:', editable=True)

19    for animal in ('dog', 'cat', 'hamster', 'python'):

20    cb.insert(END, animal)

21    cb.pack()

22

23    qb = Button(top, text='QUIT',

24    command=top.quit, bg='red', fg='white')

25    qb.pack()

26

27 top.mainloop()

------------------------------------------------------------------------------>

逐行注解    I

#### 1-7行

这里都是些初始化代码，模块导入操作，以及基本的⑶I操作。第7行的断言要求程序可以使 用Tix模块。

#### 8-27行

这些行创建了所有的组件：标签（9-11行）、控制（13-16行）、组合框（18-21行）、以及退出 按钮（23-25行）。组件构造函数里的参数都很浅显明了无需更多解释。最后，我们在第27行进入 ⑶I主事件循环。

### 19.4.2 Python MegaWidgets （PMW）

下面通过例19.8让我们来看看Python MegaWidgets。这个模块体现了 Tkinter悠久的历史。它 基本上是通过在GUI工具集中添加一些新式的组件来延长Tkinter的寿命。

这个Pmw的例子和上面Tix的例子是如此的相似，以致我们不准备对读者逐行注解它。代码中 区别最大的一行是控制组件的构造函数，那个Pmw的控制组件。它提供了验证函数的入口。不同于 直接在组件构造函数中以关键字参数的形式传入最大、最小值，Pmw使用“验证器”来确保值不会超

出我们可接受的范围。



现在我们终于要离开Tk的世界了。Tix和Pmw分别扩展了 Tk和Tkinter，然而我们现在将改变 方向去看看完全不同的工具集，wxWidgets和GTK+。在使用这些现代的、健壮的GUI工具集时，您 将发现代码的行数增加了，这是因为我们使用了更多的面向对象特性。

### 19.4.3 wxWidgets 和 wxPython

wxWidgets （以前称作wxWindows、是一个跨平台的工具集，用来构建图像用户程序。它用C++ 实现并在各种平台上广泛使用，wxWidgets为这些平台定义了一致、通用的APRwxWidgets最大的 优点它在每个平台上都使用原生GUI，所以您的程序将和所有其它桌面程序有相同的外观和用户体验。 另一个特点是您不会被局限于使用C++开发wxWidgets应用程序。它有对Python和Perl的接口。例 19.9使用wxPython展示了我们那个动物应用程序。

<-----------------------------------------

Pmw GUI 程序演示（animalPmw.pyw、

我们的第二个例子使用Python MegaWidgets包。

1    #!/usr/bin/env python

![img](07Python38c3160b-2706.jpg)



2

3 from Tkinter import Button, END, Label, W

4    from Pmw import initialise, ComboBox, Counter

5

6    top = initialise()

7

8    lb = Label(top,

9    text='Animals (in pairs; min: pair, max: dozen)')

10    lb.pack()

11

12    ct = Counter(top, labelpos=W, label_text='Number:',

13    datatype='integer', entryfield_value=2,

14    increment=2, entryfield_validate={'validator':

15    'integer', 'min': 2, 'max': 12})

16    ct.pack()

17

18    cb = ComboBox(top, labelpos=W, label_text='Type:')

19    for animal in ('dog', 'cat', 'hamster', 'python'):

20    cb.insert(end, animal)

21    cb.pack()

![img](07Python38c3160b-2707.jpg)



22

23    qb = Button(top, text='QUIT',

24    command=top.quit, bg='red', fg='white')

25    qb.pack()

26

27 top.mainloop()

------------------------------------------------------------------------------>

逐行注解

#### 5-37行

这里我们先编写了一个框架类（5-8行），它的唯一成员即其构造函数。这个方法的唯一实用目 的就是创建我们的组件。在框架组件中，我们创建了一个画板组件（panel）。在画板中我们用BoxSizer 来包含所有其他组件并对其布局（第10、 36行），这些组件是标签（12-14行）、微调按钮（16-20 行）、列表框（22-27行）和退出按钮（29-34行）。

<------------------------------------------------------------------------------

wxPython GUI 程序演示（animalWx.pyw）

我们的第三个例子使用wxPython （以及wxWidgets）。注意我们把所有的组件都放在一个布局 管理器里，以及该程序中更多的面向对象本质。

1 林！/usr/bin/env python

2

3    import wx

4

5    class MyFrame（wx.Frame）:

6    def __init__（self, parent=None, id=-1, title=''）:

| 7    | wx.Frame.__init__(self, parent,               | id, title,          |
| ---- | --------------------------------------------- | ------------------- |
| 8    | size=(200, 140))                              |                     |
| 9    | top = wx.Panel(self)                          |                     |
| 10   | sizer = wx.BoxSizer(wx.VERTICAL)              |                     |
| 11   | font = wx.Font(9, wx.SWISS,                   | wx.NORMAL, wx.BOLD) |
| 12   | lb = wx.StaticText(top, -1,                   |                     |
| 13   | 'Animals (in pairs; min:                      | pair, max: dozen)') |
| 14   | sizer.Add(lb)                                 |                     |
| 15   |                                               |                     |
| 16   | c1 = wx.StaticText(top, -1,                   | 'Number:')          |
| 17   | c1.SetFont(font)                              |                     |
| 18   | ct = wx.SpinCtrl(top, -1, '2', min=2, max=12) |                     |
| 19   | sizer.Add(c1)                                 |                     |

![img](07Python38c3160b-2710.jpg)



![img](07Python38c3160b-2711.jpg)



| 20                                                           | sizer.Add(ct)                                          |                      |
| ------------------------------------------------------------ | ------------------------------------------------------ | -------------------- |
| 21                                                           |                                                        |                      |
| 22                                                           | c2 = wx.StaticText(top, -1, 'Type:')                   |                      |
| 23                                                           | c2.SetFont(font)                                       |                      |
| 24                                                           | cb = wx.ComboBox(top, -1, '',                          |                      |
| 25                                                           | choices=('dog', 'cat', 'hamster','python'))            |                      |
| 26                                                           | sizer.Add(c2)                                          |                      |
| 27                                                           | sizer.Add(cb)                                          |                      |
| 28                                                           |                                                        |                      |
| 29                                                           | qb = wx.Button(top, -1, "QUIT")                        |                      |
| 30                                                           | qb.SetBackgroundColour('red')                          |                      |
| 31                                                           | qb.SetForegroundColour('white')                        |                      |
| 32                                                           | self.Bind(wx.EVT_BUTTON,                               |                      |
| 33                                                           | lambda e: self.Close(True), qb)                        |                      |
| 34                                                           | sizer.Add(qb)                                          |                      |
| 35                                                           |                                                        |                      |
| 36                                                           | top.SetSizer(sizer)                                    |                      |
| 37                                                           | self.Layout()                                          |                      |
| 38                                                           |                                                        |                      |
| 39                                                           | class MyApp(wx.App):                                   |                      |
| 40                                                           | def OnInit(self):                                      |                      |
| 41                                                           | frame = MyFrame(title="wxWidgets")                     |                      |
| 42                                                           | frame.Show(True)                                       |                      |
| 43                                                           | self.SetTopWindow(frame)                               |                      |
| 44                                                           | return True                                            |                      |
| 45                                                           |                                                        |                      |
| 46                                                           | def main():                                            |                      |
| 47                                                           | app = MyApp()                                          |                      |
| 48                                                           | app.MainLoop()                                         |                      |
| 49                                                           |                                                        |                      |
| 50                                                           | •    ，    •夕if __name__ == '__main__':               |                      |
| 51                                                           | main()                                                 | ---------------->    |
| 我们不得不手工为微调按钮和组合框组件添加标签，因为它们看起来并不包含标签。一旦我们 |                                                        |                      |
| 建好这些，                                                   | 就把他们加到布局管理器中，再把布局管理器交给画板组件， | 并确定其中每个组件的 |

布局。您会注意到第10行说布局管理器是垂直走向的，这表明我们所有的组件都会按从上到下的顺

序排列。



![img](07Python38c3160b-2712.jpg)



微调按钮组件有一个弱点，它不支持“步进”功能。在其他3个例子中，我们可以点箭头按钮



![img](07Python38c3160b-2713.jpg)



让控制组件每次增加或减少2，但对这个组件却不行。

#### 39-51行

我们的应用程序类实例化了一个刚才设计的框架对象，把它绘制在屏幕上，并设置成程序的顶 层窗口。最后，几行安装代码实例化了 GUI应用程序对象并启动之。

### 19.4.4 GTK+ 和 PyGTK

最后是PyGTK版的例子，它和wxPython⑶I程序非常相似（见例19.10、。最大的不同是我们只 用一个类，还有那些设置对象--实际上就是按钮--前景、背景色的代码实在是很冗长。

逐行注解

#### 1-6行

我们导入了 3个不同的模块和包，PyGTK、GTK和PangooPango是一个用来布局和生成文本的库， 专用于实现I18N。这里需要这个库是因为它体现了GTK+（2.x、对文字和字体处理的核心思想。

<------------------------------------------------------------------------------

PyGTK GUI 程序演示（animalGtk.pyw、

我们最后一个例子使用PyGTK （和GTK+、。类似wxPython的例子，这里对应用程序也用了一个 类。对比一下这两个GUI程序例子的相似和不同点是很有趣的。这种现象并不奇怪，它使得开发者 可以比较容易的转用其他工具集。

1    #!/usr/bin/env python

2

3    import pygtk

4    pygtk.require('2.0')

5    import gtk

6    import pango

7

8    class GTKapp(object):

9    def __init__(self):

10    top = gtk.Window(gtk.WINDOW_TOPLEVEL)

11    top.connect("delete_event", gtk.main_quit)

12    top.connect("destroy", gtk.main_quit)

13    box = gtk.VBox(False, 0)

14    lb = gtk.Label(

15    'Animals (in pairs; min: pair, max: dozen)')

![img](07Python38c3160b-2716.jpg)



![img](07Python38c3160b-2717.jpg)



| 16    | box.pack_start(lb)                               |
| ----- | ------------------------------------------------ |
| 17    |                                                  |
| 18    | sb = gtk.HBox(False, 0)                          |
| 19    | adj = gtk.Adjustment(2, 2, 12, 2, 4, 0)          |
| 20    | sl = gtk.Label('Number:')                        |
| 21    | sl.modify_font(                                  |
| 22    | pango.FontDescription("Arial Bold 10"))          |
| 23    | sb.pack_start(sl)                                |
| 24    | ct = gtk.SpinButton(adj, 0, 0)                   |
| 25    | sb.pack_start(ct)                                |
| 26    |                                                  |
| 27    |                                                  |
| 28    | cb = gtk.HBox(False, 0)                          |
| 29    | c2 = gtk.Label('Type:')                          |
| 30    | cb.pack_start(c2)                                |
| 31    | ce = gtk.combo_box_entry_new_text()              |
| 32    | for animal in ('dog', 'cat','hamster', 'python') |
| 33    | ce.append_text(animal)                           |
| 34    | cb.pack_start(ce)                                |
| 35    | box.pack_start(cb)                               |
| 36    |                                                  |
| 37    | qb = gtk.Button("")                              |
| 38    | red = gtk.gdk.color_parse('red')                 |
| 39    | sty = qb.get_style()                             |
| 40    | for st in (gtk.STATE_NORMAL,                     |
| 41    | gtk.STATE_PRELIGHT, gtk.STATE_ACTIVE):           |
| 42    | sty.bg[st] = red                                 |
| 43    | qb.set_style(sty)                                |
| 44    | ql = qb.child                                    |
| 45    | ql.set_markup('<span color="white">QUIT</span>') |
| 46    | qb.connect_object("clicked",                     |
| 47    | gtk.Widget.destroy, top)                         |
| 48    | box.pack_start(qb)                               |
| 49    | top.add(box)                                     |
| 50    | top.show_all()                                   |
| 51    |                                                  |
| 52 if | __name__ == '__main__':                          |
| 53    | animal = GTKapp()                                |
| 54    | gtk.main()                                       |



![img](07Python38c3160b-2718.jpg)



\>



![img](07Python38c3160b-2720.jpg)



![img](07Python38c3160b-2721.jpg)



![img](07Python38c3160b-2722.jpg)



![img](07Python38c3160b-2723.jpg)



![img](07Python38c3160b-2724.jpg)



#### 8-15行

GTKapp类反应了本程序中所有的组件。顶层窗口在这里创建（窗口管理器负责关闭它），而且还 创建了一个垂直走向的布局管理器（VBox）来掌管我们的主要组件。这些实际上和我们在wxPython GUI 程序中作的一样。

然而，为了让微调按钮和组合框的静态文本能出现它们的左侧（wxPython例子中出现在上方）， 我们创建了小型的水平走向的方框来包括标签组件对（18-36行），而且还把这些HBox完全置于VBox 的掌控之下。

接下来我们创建了退出按钮并把VBox添加到顶层窗口中，然后把一切绘制到屏幕上。您一定注 意到我们刚开始用空标题创建了按钮。我们这样做是为了让标签（子）对象能作为按钮的一部分被 创建。在45-46行，我们取得标签的访问权并用白色字体设置了文字。

我们这样做的原因是如果您直接设置前景风格--通过41-44行的循环和辅助代码--那么前景只 会对按钮起作用而对其它--例如标签--却是无效的，假如您把前景设为白色并把焦点置在按钮上（通 过按TAB键可以“选中”它），您将看到用来标识选中组件的内点画线是白色的，而标签文字却依然 是黑色的，除非您像我们在第45行那样改一下。

#### 53-55行

我们在这里创建了应用程序并进入主事件循环。

### 19.5相关模块和其他GUI

Python还有一些其他的GUI开发系统。我们在表19.2中列出适当的模块及其对应的窗口系统。

表19.2 Python可用的GUI系统 GUI模块或系统    描述

Tk相关模块

Tkinter    TK INTERface: Python 的默认 GUI 工具集

<http://wiki.python.org/moin/TkInter> Pmw    Python MegaWidgets （Tkinter 扩展）

<http://pmw.sf.net>

Tix    Tk Interface eXtension （Tk 扩展）

<http://tix.sf.net>

Extended Tk canvas type （Tk 扩展） <http://www.tkzinc.org>

非常简单的非事件驱动GUI （Tkinter扩展） <http://ferg.org/easygui>



TkZinc （Zinc）

EasyGUI （easygui）

![img](07Python38c3160b-2726.jpg)



![img](07Python38c3160b-2727.jpg)



![img](07Python38c3160b-2728.jpg)



![img](07Python38c3160b-2729.jpg)



![img](07Python38c3160b-2730.jpg)



TIDE + (IDE Studio) Tix集成开发环境(包括IDE Studio, —个Tix加强版的标准IDLE IDE) <http://starship.python.net/crew/mike>

wxWidgets相关模块

wxPython



Boa Constructor



PythonCard



wxGlade



Python对wxWidgets的绑定，一个跨平台的GUI框架库（早期称为wxWindows、 <http://wxpython.org>

Python集成开发环境兼wxPython⑶I构造工具 <http://boa-constructor.sf.net>

基于wxPython的⑶I桌面应用程序工具集（从HyperCard获得灵感） <http://pythoncard.sf.net>

另一个wxPython⑶I设计工具（从Glade（GTK+/GNOME的GUI构建 工具、受到启发）http://wxglade.sf.net

表19.2 Python可用的GUI系统（续）

GUI模块或系统 GTK+/GNOME相关模块



描述



![img](07Python38c3160b-2731.jpg)



PyGTK

GNOME-Python



Glade



PyGUI (GUI)



Qt/KDE相关模块 PyQt

PyKDE

eric Python



PyQtGPL



其他开源⑶I工具集 FXPy



Python 对 GIMP 工具集(GTK+)的封装库 <http://pygtk.org> Python对GNOME桌面开发库的绑定 <http://gnome.org/start/unstable/bindings>

<http://download.gnome.org/sources/gnome-python> 一个针对GTK+和GNOME的GUI构建工具 <http://glade.gnome.org>

“Pythonic”式的跨平台GUI程序编程接口 (MacOS X中基于Cocoa，

POSIX/X11 和 Win32 中 基 于 GTK+ 、 <http://www.cosc.canterbury.ac.nz/~greg/python_gui>

Trolltech开发的Python对Qt⑶I/XML/SQL工具集的绑定(双协议，部

分开源) <http://riverbankcomputing.co.uk/pyqt>

Python对KDE桌面环境的绑定 <http://riverbankcomputing.co.uk/pykde> 使用QScintilla editor组件编写的PyQt集成开发环境

<http://die-offenbachs.de/detlev/eric3>

<http://ericide.python-hosting.com/>

包括Qt(Win32 Cygwin移植版、、Sip、QScintilla和PyQt 的工具包 <http://pythonqt.vanrietpaap.nl>



(http://fox-toolkit.org、



![img](07Python38c3160b-2732.jpg)



Python对FOX工具集的绑定 <http://fxpy.sf.net>



pyFLTK (fltk)

Python 对 FLTK 工具集的绑定(<http://fltk.org>) <http://pyfltk.sf.net>

Python 对 OpenGL 的绑定(<http://opengl.org>) <http://pyopengl.sf.net>



PyOpenGL (OpenGL)

表19.2 Python可用的GUI系统（续）

GUI模块或系统

商业软件

win32ui



描述



Python 版的 Microsoft MFC (基于 Python 的 Windows 扩展)

<http://starship.python.net/crew/mhammond/win32> swing    Python 片反的 Sun Microsystems Java/Swing (基于 Jython)

<http://jython.org>

您还能从Python 的GUI 编程简介wiki 页面 <http://wiki.python.org/moin/GuiProgramming> 上 找到更多有关Python GUI编程的东西。

Edit By Vheavens

### 19.6 练习

19-1.    客户端/服务器架构。请描述窗口服务器的角色和窗口客户端的角色。

19-2.面向对象编程。请描述子窗口和父窗口的关系。

19-3.标签组件。请修改tkhello1.py脚本，让它显示您自定义的消息而非“Hello World!”

19-4.    标签和按钮组件。请修改tkhello3.py脚本，除了 QUIT按钮以外再新增3个按钮。

按下这3个按钮中的任意一个都将改变标签文字，显示被按下的按钮（组件）上的文字。

19-5. 标签、按钮和单选按钮组件。请对您上一问题的答案作修改，用3个单选按钮实现对 标签文字的选择。现在有两个按钮：QUIT按钮和“更新”按钮。当更新按钮被按下时，标签里的文 字变成选中的单项按钮上的文字。如果没有选中任何单选按钮，则标签内容保持不变。

19-6. 标签、按钮和文本框组件。请对您上一问题的答案作修改，用一个单行的文本框组件 替换那3个单选按钮，文本框的默认值为“Hello World!” （和标签的初始字符串保持一致）。用户 可以编辑文本框，输入新的字符串，标签组件会在更新按钮被按下时显示这个新的字符串。

19-7.标签、文本框组件及Python I/O。创建包含一个文本框的GUI程序，用户可以在其中 输入一个文本文件名。打开该文件并读取，把其中的内容显示在标签组件上。附加题（菜单）：把文 本框换成一个包含文件打开选项的菜单，它会弹出一个窗口供用户选择要读取的文件。再给菜单加 上一个Exit或Quit选项，这样就用不着QUIT按钮了。

![img](07Python38c3160b-2735.jpg)



![img](07Python38c3160b-2736.jpg)



19-8. 简单的文本编辑器。在您上一题答案的基础上创建一个简单的文本编辑器。可以用剪 贴板或读文件的方式在一个文本域里显示一些文字供用户编辑。当用户退出程序时（通过QUIT按钮 或Quit/Exit菜单项）会询问用户是否保存所作的修改。附加题：给您的脚本添加一个拼写检查接 口，增加一个按钮或菜单项来对文件进行拼写检查。拼写错误的词句应在文本域组件中用不同的背 景或前景色高亮显示出来。

19-9. 多线程聊天应用程序。第13、16、17章讲到的聊天程序可以完成了。创建一个全功 能的多线程聊天服务器。这个服务器其实并不需要有GUI，除非您想给它创建一个前端配置界面，配 置诸如端口号、名称、到域名服务器的连接等。创建一个多线程的聊天客户端，使用单独的线程监 视用户输入（并以广播方式给服务器发送消息），另一个线程用来接收消息并显示给用户。客户端的 GUI聊天窗口应当由两部分组成：较大的部分用来多行显示所有的对话，较小的文本域用来接收用户 输入。

19-10.    使用其他⑶R19.4中的例子使用到了各种各样的工具集，这些GUI程序看起来很

相似；然而，它们并不完全一样。尽管不可能让所有的例子看起来完全一样，但请尽量调整它们， 让它们比现在看起来更一致些。

![img](07Python38c3160b-2737.jpg)



19-11. 使用 GUI 构建工具。下载 Boa Constructor （wxWidgets 平台）或 Glade （GTK+平台） ［或者都下载！］，然后实现那个“动物” GUI程序，只用从相应的工具栏拖拽一些组件就好了。给 您的新GUI加上回调函数，让它能有本章例子程序中我们所看到的那些行为。

![img](07Python38c3160b-2738.jpg)



![img](07Python38c3160b-2739.jpg)
