---
author: evo
comments: true
date: 2018-05-19 10:03:52+00:00
layout: post
link: http://106.15.37.116/2018/05/19/%e7%ae%97%e6%b3%95%ef%bc%9a%e5%af%bb%e6%89%be%e6%9c%80%e5%a4%a7%e7%9a%84-k-%e4%b8%aa%e6%95%b0/
slug: '%e7%ae%97%e6%b3%95%ef%bc%9a%e5%af%bb%e6%89%be%e6%9c%80%e5%a4%a7%e7%9a%84-k-%e4%b8%aa%e6%95%b0'
title: 算法：寻找最大的 K 个数
wordpress_id: 6037
categories:
- 基础程序设计
tags:
- ordinary algorithm
---

<!-- more -->

[mathjax]

**注：非原创，只是按照自己的思路做了整合，修改。推荐直接看 ORIGINAL 中所列的原文。**


# ORIGINAL





 	
  1. [【编程之美】读书笔记：寻找最大的K个数](http://blog.csdn.net/xiaoding133/article/details/8037086)

 	
  2. [寻找第K大的数](http://blog.chinaunix.net/uid-20196318-id-189514.html)

 	
  3. [O(N)的时间寻找最大的K个数](http://www.cnblogs.com/luxiaoxun/archive/2012/08/06/2624799.html)




# TODO





 	
  * **还没有仔细整理，要整理下。**





* * *





# INTRODUCTION





 	
  * aaa




# 问题


查找大量无序元素中最大的K个数。




# 方法汇总





 	
  * 方法一：常规解法，先排序 (时间复杂度为 O(N*logN) )

 	
  * 方法二：利用快速排序原理 (时间复杂度 O(N*logK) ) (掌握)

 	
  * 方法三：利用最小堆的原理 (时间复杂度为 O(N*logK) )  (掌握)

 	
  * 方法四：二分法 (在实际应用中效果不佳)

 	
  * 方法五：用空间换取时间的方法





# 方法一：常规解法，先排序


首先，我们看看方法1：

该解法是大部分能想到的，也是第一想到的方法。

假设数据量不大，可以先用快速排序或堆排序，他们的平均时间复杂度为 O(N*logN)，然后取出前 K 个，时间复杂度为 O(K) ，总的时间复杂度为 O(N*logN)+O(K)。

当K=1时，上面的算法的时间复杂度也是O(N*logN)。

上面的算法是把整个数组都进行了排序，而原题目只要求最大的K个数，并不需要前 K 个数有限，也不需要后 N-K 个数有序。可以通过部分排序算法如选择排序和交换排序，把 N 个数中的前 K 个数排序出来，复杂度为 O(N*K)，选择哪一个，取决于 K 的大小，在 K (K<logN) 较小的情况下，选择部分排序。




# **方法二：（掌握）**避免对前 K 个数进行排序来获取更好的性能（利用快速排序的原理）。


假设 N 个数存储在数组 S 中，从数组中随机找一个元素 X ，将数组分成两部分 Sa 和 Sb 。Sa中的元素大于等于 X，Sb 中的元素小于 X 。

出现如下两种情况：



 	
  * **若 Sa 组的个数大于或等于K，则继续在sa分组中找取最大的 K 个数字 。**

 	
  * **若 Sa 组中的数字小于K ，其个数为T，则继续在sb中找取 K-T个数字 。**


一直这样递归下去，不断把问题分解成小问题，平均时间复杂度为 O(N*logK) 。**厉害呀**

代码如下：



















* * *





# COMMENT



