本章内容

□使用对象 □创建并操作数组

□理解基本的JavaScript类型 口使用基本类型和基本包装类型

P 1用类型的值(对象)是引用类型的一个实例。在ECMAScript中，引用类型是--种数据结构， J I用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript

从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引

用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。

虽然引用类型与类看起来相似，但它们并不是相同的概念。为避免混淆，本书将 不使用类这个概念。

如前所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。 构造函数本身就个函数，只不过该函数是出F创建新对象的目的而定义的。请看F面这行代码：

var person = new Object();

这行代码创建了 Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用 的构造函数是Object,它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类 型(例如Object),以便开发人员用以实现常见的计算任务。

5.1 Object 类型

到S前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object也是 ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于在应用程序中存储 和传输数据而言，它们确实是非常理想的选择。

创建Object实例的方式有两种。第一种是使用new操作符后跟Object构造函数，如下所示：

var person = new Object(); person.name = "Nicholas"； person.age = 29;

ObjectTypeExampleOJ.htm

另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建 包含大tt屈性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的 person 对象：

var person = {

name : ，Nicholas", age : 29

}?

ObjectjypeExample02.htm

在这个例子中，左边的花括号（｛）表示对象字面量的开始，因为它出现在了表达式上下文 （expression context）中。ECMAScript中的表达式上下文指的是能够返回一个值（表达式）。麽值操作 符表示后面是一个值，所以左花括号在这里表示_个表达式的开始。同样的花括号，如果出现在一个 语句上下文（statementcontext）巾，例如跟在if语句条件的后面，则表示一个语句块的开始。

然后，我们定义了 name属性，之后是一个胃号，再后面是这个属性的值。在对象字面量中，使用 逗号来分隔不同的属性，因此’’Nicholas•后面是一个逗号。但是，在age属性的值29的后面不能添 加逗号，因为age是这个对象的最后一个属性。在最后一个属性后面添加逗号，会在IE7及更早版本和 Opera中导致错误。

在使用对象字面景语法时，属性名也可以使用字符申，如下面这个例子所示。

var person 亡｛

”naae*1 : "Nicholno",

"age" : 29,

5 : true

｝；

这个例子会创建一个对象，包含三个属性：name, age和5。徂这里的数值属性名会自动转换为字 符串。

另外，使用对象字面量语法时，如果留交其花括号，则可以定义只包含默认属性和方法的对象，如 下所示：

var person - ｛｝;    ✓/与 new Object。相円

person.name = "Nicholas"； person.age = 29;

这个例子与本节前面的例子是等价的，只不过看起来似乎有点奇怪。关于对象字面量语法，我们推 荐只在考虑对象属性名的可读性时使用。

在通过对象字面量定义对象时，实际上不会调用Object构造函数（Fiiefox2及 更早版本会调用object构造函数；但Firefox 3之后就不会了）。

虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种 语法要求的代码量少，而且能够给人封装数据的感觉。实际上，对象字面量也是向函数传递大量可选参 数的首选方式，例如：

function displayInfo(args) { var output = *•;

if (typeof args.name == "string"){

output += "Name： " + args.name + *\n"；

}

if (typeof args,age == "number") {

output += "Age： ■ + args.age + "\n";

}

alert(output);

displaylnfo({

name: "Nicholas", age: 29

))；

displaylnfo({ name: "Greg

))；

ObjectTypeExample04. htm

在这个例子中，函数displaylnfo ()接受一个名为args的参数。这个参数可能带有一个名为name 或age的属性，也可能这两个屈性都有或者都没有。在这个函数内部，我们通过typeof操作符来检测 每个属性是否存在，然后再基于相应的屈性来构建一条要显示的消息。然后，我们调用了两次这个函数. 每次都使用一个对象字面量来指定不同的数据。这两次调用传递的参数虽然不同，但函数都能正常执行。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-22.jpg)

 

这种侍递参数的模式最适合需要向函数传入大量可选参数的情形。一般来讲，命 名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法 是对那些必需值使用命名参教，而使用对象字面量来封装多个可选参数。

一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过， 在JavaScript也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性 以字符串的形式放在方括号中，如下面的例子所示。

alert(person["name"]);    //"Nicholas"

alert(person.name)?    //"Nicholas"

从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量 来访问属性，例如：

var propertyName = "name"；

alert(personTpropertyName]);    //"Nicholas"

如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括 号表示法。例如：

person!•first name"] = "Nicholas";

由于-first name”中包含一个空格，所以不能使用点表示法来访问它。然而，属性名中是可以包 含非字母非数字的，这时候就可以使用方括号表示法来访问它们。

通常，除非必须使用变量来访问域性，否则我们建议使用点表示法。

5.2 Array 类型

除了 Object之外，Array类型恐怕是ECMAScript中最常用的类型了。而且，ECMAScript中 的数组与其他多数语言中的数组冇着相当大的区别。虽然ECMAScript数组与其他语言中的数组都是 数据的有序列表，但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。也 就是说，可以用数组的第一个位置来保存字符中，用第二位置来保存数值，用第三个位置来保存对象, 以此类推。而且，ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加3动增长以容 纳新增数据。

创建数组的基本方式有两种。第一种是使用Array构造函数，如下面的代码所示。 var colors = new Array();

如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量,而该数fi会自动变成length 属性的值。例如，下面的代码将创建length值为20的数组。

var colors = new Array(20);

也可以向Array构造函数传递数组中应该包含的项。以下代码创建T一个包含3个字符串值的数组: var colors = new Array(’red*, "blue", "green")；

当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数 值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值 的只有一项的数组。T面就两个倒子：

var colors = new Array (3);    //创建一个包含3项的數组

var names = new Array ("Greg") ；    //创建一个包含1项，即字符串”Greg"的数组

ArrayTypeExampleOl. htm

另外，在使用Array构造函数时也可以省略new操作符。如下面的例子所示，省略new操作符的 结果相同：

var colors = Array (3》；    //创建一个包含3项的数组

var names = Array ("Greg") ;    //创建一个包含1噴，即字符亊"Greg”的数组

创建数组的第二种基本方式是使用数组字面fi表示法。数组字面fi由一对包含数组项的方括号表

示，多个数组项之间以逗号隔开，如下所示：

var colors = ["red*, *blue"z "green"]; // var names = ()； // var values = [1,2,]； // var options = I:,//

创建一个包含3个字符亊的数组

韵建一个空数组

不要这样！这样会创建一个&含2或3項的数纽 不要这样！这样会创建一个包含5或6项的数组

 

ArrayTypeExampleO2. htm

以上代码的第一行创建了--个包含3个字符串的数组。第二行使用一对空方栝号创建了一个空数组。 第三行展示:T在数组字面量的最后一项添加逗号的结果：在IE中，values会成为一个包含3个项且毎 项的值分别为1、2和undefined的数组；在其他浏览器中，values会成为一个包含2项且值分别为 1和2的数组。原㈥是IE8及之前版本中的ECMAScript实现在数组字面量方面存在bug。由于这个bug

导致的另一种情况如最后一行代码所示，该行代码可能会创建包含5项的数组（在IE9+、Firefox、Opera, Safari和Chrome中）,也可能会创建包含6项的数组（在1E8及更早版本中）。在像这种省略值的情况下， 每一项都将获得undefined值；这个结果与调用Array构造函数时传递项数在逻辑上是相同的。但是 由于IE的实现与其他浏览器不一致，因此我们强烈建议不要使用这种语法。

与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数（Firefox3 及更早版本除外）。

在读取和设迓数组的值时，要使用方括号并提供相应值的基于0的数字索引，如下所示:

var colors = [”red", alert(colors[0]); colors[21 = "black"； colors[3] = "brown*；

 

blue"/ "green"];

 

//定义一个字符申数组 //里示第一項 //修改第三項 //新墳第四项

 

方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值，就像这个例子 中的colorstOl会显示—样。设置数组的值也使用相同的语法，但会替换指定位置的值。如果设 置某个值的索引超过了数组现有项数，如这个例子中的colors [3】所东，数组就会自动增加到该索引 值加1的长度（就这个例子而言，索引是3,因此数组长度就是4）。

数组的项数保存在其length属性中，这个属性始终会返回0或更大的值，如下面这个例子所示：

//创建一个包含3个字符串的数纽 //创建一个空数组

 

var colors = f"red"z "blue", *green"]; var names =[]；

alert（colors.length）;    //3

alert（names.length）；    //0

数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移 除项或向数组中添加新项。请看下面的例子：

var colors = I "red", "blue*, "green" ] ；    // 创建一个包念 3 个字符争的数组

colors.length 酿 2;

alert(colors[2]);    //undefined

ArrayTypeExampleO3. htm

这个例子中的数组colors —开始有3个值。将其length属性设置为2会移除最后一项（位置为 2的那一项），结果再访问colors [2]就会显求undefined 了。如果将其length属性设置为大于数组 项数的值，则新增的每一项都会取得undefined值，如下所示：

var colors = [*redu, "blue", "green" ] ；    // 创建一个包含 3 个字并串的数組

colors.length = 4;

alert（colors[3]）;    //undefined

ArrayTypeExampleO4.htm

在此，甩然colors数组包含3个项，但把它的length属性设置成了 4。这个数组不存在位置3, 所以访问这个位置的值就得到了特殊值undefined。

利用length属性也可以方便地在数组末尾添加新项，如下所示：

var colors = [ "red", "blue1*, "green”；

//创建一个包含3个字符串的数组 // (在位置3)添加一种顏色 // (在位置4)再添加一种顏色

 

colors【colors.length] = "black"t colors【colors.length】="brown",

d rrayTypeExampleO5. htm

由于数组敁后-项的索引始终是length-L,因此下一个新项的位置就是length。每当在数组末 尾添加--项后，其length属性都会自动更新以反应这一变化。换句话说，上面例子第二行中的 colors [colors. length]为位置 3 添加了一个值，最后一行的 colors [colors. length]则为位置 4 添加了一个值。当把一个值放在超出当前数组大小的位置上时，数组就会重新il賀其长度值，即长度值 等于最后一项的索引加1,如下面的例子所示：

var colors = ["red", "blue", "green" ];    II 创建一个包含 3 个字符亊的数组

colors [99] = "black" /    // (在位置 99)添加一■种扇色

alert(colors.length); // 100

ArrayTypeExampleO6. htm

在这个例子中，我们向colors数组的位置99插人了一个值，结果数组新长度(length)就是100 (99+1 )o而位置3到位置98实际上都是不存在的，所以访问它们都将返回undefined。

数组最多可以包含4294967295个项，这几乎已经能够满足任何编程需求了。如 果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值 接近的数组，则可能会导致运行时间超长的脚本错误。

5.2.1检测数组

自从ECMAScript3做出规定以后，就出现了确定某个对象是不是数组的经典问题。对于一个网页, 或者一个全局作用域而言，使用instanceof操作符就能得到满意的结果：

if (value instanceof Array)(

//对数组执行某些操作

)

instanceof操作符的问题在于，它假定单一的全局执行环境。如果网贞中包含多个框架，那实际 上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一 个框架向另一个框架传入一个数组，那么传人的数组与在第二个框架中原生创建的数组分别具有各自不 同的构造函数。

为丫解决这个问题，ECMAScript5新增了 Array. isArray (}方法。这个方法的H的是最终确定某 个值到底是不是数组，而不管它是在哪个全W执行环境中创建的。这个方法的用法如下。

if (Array.isArray(value)){

//对数组执行臬癸操作

}

支持 Array, is Array ()方法的浏览器冇 IE9+、Firefox 4+、Safari 5+、Opera 10.54•和 Chrome。要 在尚未实现这个方法中的浏览器巾准确检测数组，请参考22.1.1节。

5.2.2转换方法

如前所述，所有对象都具有toLocaleString( ＞、toString ()和valueOf (＞方法。其中，调用 数组的toStringU方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而 调用valueOfU返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的toStringU方 法。来看下面这个例子。

var colors = [Bred"z "blue",

alert(colors.toString()); alert(colors.valueOf(>); alert(colors);

 

■green")； //创建一个包舍3个字符争的数组

// red,blue,green // red,blue,green // red,blue,green

Arrc^iypeExampleOy.htm

在这里，我们首先显式地调用了 toStringG和valUeOf()方法，以便返回数组的字符串表示， 每个值的字符串表示拼接成了一个字符牢，中间以逗号分隔。最后_行代码直接将数组传递给了 alert ()o由于alert ()要接收字符串参数，所以它会在后台调用toString()方法，由此会得到与直 接调用toString ()方法相同的结果。

另外，toLocaleString＜)方法经常也会返回与toString()和valueOf (＞方法相同的值，但也 不总是如此。当调用数组的toLocaleStringO方法时，它也会创建-•个数组值的以逗号分隔的字符 串。而与前两个方法唯一的不同之处在于，这一次为了取得毎一项的值，调用的是毎一项的101＜0＜^16-String()方法，而不是toString (＞方法。请看下面这个例

var personl = {

toLocaleString : function () { return *Nikolaos";

}，

toString : function() { return "Nicholas";

}

)；

var person2 = {

toLocaleString : function {) { return "Grigorios*；

b

toString : function() { return. "Greg";

}

};

var people = [personl, person2J； alert(people); alert(people.toString()); alert (people. toLocaleString ⑴；

//Nicholas,Greg //Nicholas,Greg Z/Nikolaos,Grigorios

 

Array TypeExampleO8. htm

我们在这里定义了两个对象:personl和person2。而i还分别为毎个对象定义了一个toString () 方法和一个toLocaleStringU方法，这两个方法返回不同的值。然后，创建一个包含前面定义的两 个对象的数组。在将数组传递给alert <)时，输出结果是“Nicholas, Greg”，因为调用了数组每一项 的toStringO方法(同样，这与下一行44式调用tostring()方法得到的结果相同)。而当调用数组 的toLocaleString ()方法时，输出结果是"虹1^01&03,01?;1.9037；105"，原因是调用了数组每一项的 toLocaleString ()方法 o

数组继承的toLocaleString ()、toString ()和valueOf ()方法，在默认情况下都会以逗号•分隔的字 符串的形式返回数组项o而如雑用扣in()方法，则可以使用不同的分隔符來构建这个字符串„ join()方 法只接收一^参数，即用作分隔符的字符串，然后返回包含所有麵项的字符串。箭看下面的例子：

var colors - [’red", "green", "blue"];

alert(colors.join(","))；    //red,green,blue

alert(colors.join("II"));    //red I I green| |blue

ArrayT^peJoinExampleOI .htm

在这里，我们使用:join ()方法重现了 toString ()方法的输出。在传递逗号的情况下，得到了以 逗号分隔的数组值。而在最后一行代码中，我们传递了双竖线符号，结果就得到了字符串，，redl I green I i blue11。如果不给join ()方法传入任何值，或者给它传人undefined,则使用逗号作为分隔 符。IE7及更早版本会错误的使用字符串-undefined”作为分隔符。

如果数组中的某一项的值是null或者undefined,那么该值在join(｝、 toLocale- String()、toString()和valueOf ()方法返回的结果中以空字符串表示。

5.2.3栈方法

ECMAScript数组也提供了 •种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表 现得就像栈一样，后者是一种町以限制插人和删除项的数据结构。栈是一种LIFO (Last-In-First-Out, 后进先出)的数据结构，也就是最新添加的项最早被移除。而栈中项的插人(叫做推入)和移除(叫做 弹出)，只发生在一个位置一栈的顶部。ECMAScript为数组专门提供了 pUSh<)和pop(>方法，以便 实现类似栈的行为。

push ()方法可以接收任意数ft的参数，把它们逐个添加到数组末尾，并返冋修改后数组的长度。而 pop (>方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。箭看下面的例子：

var colors = new Array () ；    // 创建一个数组

var count = colors.push("red* z "green") ；    // 推入两项

A rray TypeExampleO9. htm

以上代码屮的数组可以看成是栈(代码本身没有任何区别，而push()和pop()都是数组默认的方 法)。首先，我们使用pushU将两个字符串推人数组的末尾，并将返回的结果保存在变tt count中(值 为2)。然后，冉推入一个值，而结果仍然保存在count中。因为此时数组中包含3项，所以pushU 返回3。在调用pop()时，它会返回数组的最后一项，即字符串•black。。此后，数组中仅剰两项。

可以将栈方法与其他数组方法连用，像下面这个例子一样。 var colors = ["red", "blue"];

colors .push ("brown") ；    // 添加另一項

colors [3 J = "black" ；    // 添加一呼

alert(colors.length);    // 4

var item = colors.pop () ；    // 取得裘后一喷

alert(item); //"black"

ArrayTj/peExample 10. htm

在此，我们首先用两个值来初始化-个数组。然后，使用push (＞添加第三个值，冉通过i接在位 置3上赋值来添加第四个值。而在调用pop(＞时，该方法返回了字符串-black-，即最后一个添加到数 组的值。

5.2.4队列方法

栈数据结构的访问规则是LIFO(后进先出),而队列数据结构的访问规则是FIFO( First-In-First-Out, 先进先出)。队列在列表的末端添加项，从列衣的前端移除项。由T- push (＞是向数组末端添加项的方法， 因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是shift (),它能够移 除数组中的第•^项并返回该项，同时将数组长度减1。错合使用shift(＞和push＜)方法，可以像使

| 用队列一样使用数组。                                         |           |                           |
| ------------------------------------------------------------ | --------- | ------------------------- |
| var colors = new Array(); var count = colors.push("red", alert (count) ；    "2 | •green")? | //创建一个数组 //推入两項 |
| count = colors.push(*black"}; alert(count);    //3           |           | //推入另一项              |
| var item = colors.shift();alert{item);    //"red"alert(colors.length); //2 |           | //取得第一項              |

d rray TypeExamplelL htm

这个例子首先使用push U方法创建了一个毡含3种颜色名称的数组。代码中加粗的那一行使用 shift ()方法从数组中取得了第一项，即**red"。在移除第一项之后，•green"就变成了第一项，而 "black-则变成了第二项，数组也只包含两项了。

ECMAScript还为数组提供了一个unshift ()方法。顾名思义，unshift ()与shift ()的用途相反： 它能在数组前端添加任意个项并返冋新数组的长度。因此，同时使用unshift()和popU方法，可以 从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项，如下面的例子所示。

var colors = new Array {) ；    //創建一个数組

var count = colors.unsbift ("red", "green" ) ;    //推入两項

alert (count) ；    "2

count « colora .unshift ("black1') t

//推入另一項

 

//取得最后一項

 

alert(count);    //3

vox item - colors.pop()j

alert(item); //"green" alert(colors.length); //2

ArrayTypeExamplel2.htm

这个例子创建了一个数组并使用unshift ()方法先后推入了 3个值。首先是*red"和"green”，然 后是"black"，数组中各项的顺序为-black”、"red"、”green”。在调用pop(｝方法时，移除并返回 的是最后一项，即-green"。

IE7及更早版本对JavaScript的实现中存在一个偏差，其unshift ()方法总是返 回undefined而不是数组的新长度。IE8在非兼容模式下会返回正确的长度值。

5.2.5重排序方法

数组中已经存在两个可以直接用来重排序的方法：reversed和sorU)。有读者可能猜到了, reverse ()方法会对反转数组项的顺序。请看下面这个例子„

var values = [1, 2, 3, 4, 5];

values.reverse();

alert(values);    //5,4t3,2,1

A rray TypeExample 13. htm

这里数组的初始值及顺序是1、2、3、4、5。而调用数组的reverse ()方法后，其值的顺序变成了 5、4、3、2、1。这个方法的作用相当直观明了，但不够灵活，因此才有了 sort ＜＞方法。

在默认情况下，sort ()方法按升序排列数组项一即最小的值位于最前面，最大的值排在圾后面。 为了实现排序，sort (＞方法会调用每个数组项的toStringO转型方法，然后比较得到的字符串，以 确定如何排序。即使数组中的每一项都是数值，sort ()方法比较的也是字符串，如下所示。

var values = [0, 1, 5, 10, 15]； values.sort()?

alert(values)?    //0,1,10,15,5

ArrayTypeExamplel 4.htm

可见，即使例子中值的顺序没有问题，但 sort ()方法也会根据測试字符串的结果改变原来的顺序。 因为数值5虽然小于10,但在进行字符串比较时，-10•则位于”5•的前面，于是数组的顺序就被修改了。 不用说，这种排序方式在很多情况下都不是最佳方案。W此sort ()方法可以接收一个比较函数作为参 数，以便我们指定哪个值位于哪个值的前面。

比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等 则返回0,如果第一个参数成该位于第二个之后则返冋一个正数。以下就是一个简单的比较函数：

function compare(valuel, value2) { if (valuel < value2) {

return -1；

} else if (valuel > value2) { return 1;

} else {

return 0?

}

} _

d rrayl^peExample 15. htm

这个比较函数可以适ffl于大多数数据类型，只要将其作为参数传递给sort ()方法即可，如下面这 个例子所示。

var values = 10, 1, 5, 10, 15】；

values.sort(compare)t

 

alert(values)；    //0,1,5,10,15

在将比较函数传递到sort (＞方法之后，数值仍然保持了正确的升序。当然，也可以通过比较函数 产生降序排序的结果，只要交换比较函数返回的值即可、

function compare(valuel, value2) { if (valuel < value2) {

return 1;

} else if (valuel > value2) {

return -1;

} else {

return 0;

}

var values = [0, 1, 5, 10, 15】；

values.sort(compare);

alert(values);    // 15,10,5,1,0

A rrayTypeExamplel 6. htm

在这个修改后的例子中，比较函数在第一个值应该位于第二个之后的情况下返回1，而在第一个值 应该在第二个之前的情况下返冋-1。交换返网值的意思是让更大的值排位更靠前，也就是对数组按照降 序排序。当然，如果只想反转数组原来的顺序，使用reverse G方法要更快一些。

reverse 和sort {}方法的送回值是经过排序之后的数组c

对于数值类型或者其valueOf ()方法会返回数值类型的对象类型，可以使用一个更简单的比较函 数。这个函数只要用第二个值减第一个值即可、

function compare(valuel, value2){ return value2 - valuel;

}

①如果想要按照升级排序，则compare ()函数中的return语句成该返回value2-valuelo

由于比较函数通过返回一个小于零、等丁•零或大于芩的值来影响排坪结果，因此减法操作就可以适 当地处理所有这些情况。

5.2.6操作方法

ECMAScript为操作已经包含在数组中的项提供了很多方法。其中，concatO方法可以基于当前数 组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数 添加到这个副本的末尾，最后返回新构建的数组。在没有给concatO方法传递参数的情况下，它只是 复制当前数组并返回副本。如果传递给concatO方法的是一或多个数组，则该方法会将这些数组中的 每一项都添加到结果数组中=如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。下 面来看一个例子。

var colors = ["red", "green", "blue"];

var colors2 = colors.concat("yellow", [•black", "brown*I);

alert(colors);    //red,green,blue

alert(colors2)； //red,green,blue,yellow,black,brown

Array TypeConcatExampleOl. htm

以上代码开始定义了一个包含3个值的数组colors。然后，基于colors调用了 concat()方法， 并传人字符牢"yellow”和一个包含"black"和"brown”的数组。最终，结果数组colors2中包含了 "red"、’green"、"blue"、"yellow"、"black"和’brown"。至于原来的数组 colors,其值仍然 保持不变。

下一个方法是sliced,它能够基于当前数组中的一或多个项创建一个新数组。sliceU方法可以 接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该 参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项一 一(B不包括结束位置的项。注意，slice ()方法不会影响原始数组。请看下面的例子。

var colors = [ "red*, "green", "blue", "yellow" # "purple*1】； var colors2 = colors.slice《1}; var colors3 = colors.slice(1,4};

alert(colors2)； //green,blue,yellow,purple alert(colors3); //green,blue,yellow

ArrayTypeSliceExampleO 1 .htm

在这个例子中，开始定义的数组colors包含5项。调用sliced并传人1会得到一个包含4项的 新数组；因为是从位R 1开始复制，所以会包含-green•而不会包含-red，。这个新数组colorS2中 包含的是"green"、"blue"、-yellow"和1’purple”。接着，我们再次调用slice ()并传人了 1和4, 表示复制从位置1开始，到位置3结束。结果数组colors3中包含了 "green"、"blue"和"yellow"。

如果slice 0方法的参数中有一个负数，则用，数组长度加上该数来确定相应的位 置。例如，在一个包含5项的数组上调用slice(^2,-l)与调用slice(3,4)得到的 结果相同。如果结東位置小于起始位置，则返回空数组。'

下面我们来介绍sPiice()方法，这个方法恐怕要算是磁强大的数组方法r,它有很多种用法。 splice ()的主要用途是向数组的中部插人项，但使用这种方法的方式则有如K3种。

□删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。 例如，splice (0,2)会删除数组中的前两项。

□插入：可以向指定位置插入任意数M的项，只需提供3个参数：起始位置，0(要删除的项数) 和要插人的项。如果要插人多个项，可以再传人第四、第五，以至任意多个项。例如， splice (2,0, "red", "green")会从当前数组的位置2开始插人字符串"red"和■ green"。

□替换：可以向指定位置插人任意数ft的项，且同时删除任意数ft的项，只需指定3个参数：起 始位置、要删除的项数和要插人的任意数tt的项。插人的项数不必与删除的项数相等。例如， splice {2,1, "red", "green-)会删除当前数组位贸2的项，然后再从位置2开始插人字符串 •red"和"green"。

splice ()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何 项，则返回一个空数组)。下面的代码展示了上述3种使用splice＜)方法的方式。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-23.jpg)

 

var colors = [■red1*, "green", ■blue"];

//刪除第一项

 

var removed = colors.splice(0,1);

alert(colors):    // green,blue

alert (removed) ;    // red,返回的数组中只包食一项

removed = colors.splice{l, 0, "yellow", "orange");    // 从位置 1 开始插人两喟

alert(colors);    // green,yellow,orange,blue

alert (removed) ；    //返回的是一个空数组

removed = colors .spliced, 1, " red ■, "purple") ;    // 插入两项，刪除一項

alert(colors)；    // green,red,purple,orange,blue

alert (removed) ；    // yellow,返回的致组中只包合一项

d rrayTypeSpliceExampleO 1. htm

上面的例子首先定义丁一含3项的数组colors。第一次调用splice ()方法只是删除了这个数组的 第一项，之后colors还包含"green"和-blue”两项。第二次调用spliceO方法时在位置1插人了两项， 结果colors中包含-green-、"yellow""orange1^"blue”。这一次操作没有删除项，因此返回了一个 空数组。最后一次调用splice()方法删除了位置1处的一项，然后又插人了"red"和"purple"。在完成以 上操作之后，数组 colors 中包含的是"green"、"red"、"purple1"、"orange"和"blue"。

5.2.7位置方法

ECMAScript5为数组实例添加了两个位置方法：indexOf (＞和lastlndexOf (＞。这两个方法都接收 两个参数：要査找的项和(可选的)表示査找起点位置的索引。其中，indexOf (＞方法从数组的开头(位 置0)开始向后査找，lastlxidexOfO方法则从数组的末尾开始向前査找„

这两个方法都返回要査找的项在数组中的位置，或者在没找到的情况下返冋-1。在比较第一个参数 与数组中的毎•-项时，会使用全等操作符；也就是说，要求査找的项必须严格相等(就像使用=一样)。 以下是几个例子。

var numbers s [1,2,3,4,5,4,3,2,1];

alert(numbers.indexOf(4)}；

//3

 

alert (numbers, lastIndexOf (4)) ;    "5

alert(numbers.indexOf(4/ 4)》；    //5

alert(numbers.lastlndexOf(4, 4)); //3

var person = { name： "Nicholas" }; var people = [ { name: "Nicholas'* });

var morePeople = [person]；

alert(people.indexOf(person))?    //-I

alert(morePeople.indexOf(person)); //0

ArrayIndexOfExampleOl. htm

使用indexOf《)和lastlndexOf ()方法査找特定项在数组中的位置非常简单，支持它们的浏览器包 括 IE9+、Firefox 2十、Safari 3+、Opera 9.5十和 Chrome。

5.2.8迭代方法

ECMAScript5为数组定义了 5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和 (可选的)运行该函数的作用域对象——影响this的值。传人这些方法屮的函数会接收三个参数：数 组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返冋值可能 会也可能不会影响访问的返回值。以下是这5个迭代方法的作用。

□    every ():对数组中的每一项运行给定函数，如果该函数对每一项都返间true,则返回true。

□    filter!)：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。

□    forEachO：对数组中的每一项运行给定函数。这个方法没有返凹值。

□    map():对数组中的每一项运行给定函数，返冋每次函数调用的结果组成的数组。

□    someO：对数组中的每一项运行给定函数，如果该函数对任一项返回true,则返回true。

以上方法都不会修改数组中的包含的值。

在这些方法中，最相似的是every ()和some <),它们都用于查询数组中的项是否满足某个条件。 对everyO来说，传入的函数必须对毎-项都返回true,这个方法才返网true;否则，它就返冋 false。而some ()方法则是只要传人的兩数对数组中的某一项返四true,就会返回true。请看以下 例子。

var numbers = [1,2,3,4,5,4,3,2,1];

var everyResult = numbers.every (function{item, index, array){ return (item > 2)?

}) ?

alert(everyResult};    //false

var someResult = numbers.some(function{item, index, array){ return (item >2);

});

alert(someResult)?

 

//true

 

ArrayEveryAndSomeExampleOl. htm

以上代码调用丁 every (＞和some (＞，传人的函数只要给定项大于2就会返冋true。对于every (＞， 它返回的是false,因为只有部分数组项符合条件。对于someO,结果就是true,因为至少有一项 是大于2的。

下面再看一看filter (＞函数，它利用指定的函数确定是否在返回的数组中包含的某一项。例如， 要返回一个所有数值都大于2的数组，可以使用以下代码。

var numbers = [1,2'3,4,5,4,3,2,1];

var filterResult = numbers.filter(function(item, index, array){ return, (item ＞ 2) ,•

)＞?

alert(filterResult);

 

//[3r4,5#4#3]

 

ArrayFilterExampleOl. htm

这里，通过调用filters)方法创建并返回了包含3、4、5、4、3的数组，因为传入的函数对它们 每一项都返回true。这个方法对查询符合某些条件的所有数组项非常有用。

map()也返回一个数组，而这个数组的每一项都是在原始数组中的对应项t运行传人函数的结果。 例如，可以给数组中的每一项乘以2,然后返冋这些乘积组成的数组，如下所示。

var numbers = [1,2,3,4,5,4,3,2,1】；

var mapResult = numbers.map(function(item, index, array){ return item * 2；

}) ?

alert(mapResult)?    //[2,4r6#8#10,8r6,4#2]

ArrayMapExampleO I. htm

以上代码返回的数组中包含给每个数乘以2之后的结果。这个方法适合创建包含的项与另一个数组 一一对应的数组。

最后一个方法是forEachO,它只是对数组中的每一项运行传入的函数。这个方法没有返回值， 本质上与使用for循环迭代数组一样。来看一个例子。

var nuinbers = [1,2'3,4'5,4,3,2,1];

numbers.forEach(function(item, index, array){

//执行某些操作

})?

这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。支持这些迭代方法的浏览器有 IE9+、Firefox2+、Safari 3+、Opera 9.5+和 Chrome。

5.2.9缩小方法

ECMAScript 5还新增了两个缩小数组的方法：reduce ()和reduceRight () o这两个方法都会迭 代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历 到最S。而reduceRight ()则从数组的最后一项开始，向前遍历到第一项。

这两个方法都接收两个参数：一个在每一项上调用的函数和(可选的)作为缩小基础的初始值。传 给reduced和reduceRighU)的函数接收4个参数：前•个值、当前值、项的索引和数组对象。这 个函数返回的任何值都会作为第一个参数fl动传给下•项。第一次迭代发生在数组的第二项上，因此第 一个参数是数组的第一项，第二个参数就是数组的第二项。

使用reduce!)方法>4以执行求数组中所有值之和的操作，比如： var values = [1'2'3'4,5];

var sum = values.reduce{function(prev, cur, indexz array){ return prev + cur；

alert(sum)； //15

A rrayReductionExampleOl. htm

第一次执行回调闲数，prev是1, cur是2。第二次，prev是3 ( 1加2的结果)，cur是3 (数组 的第三项)。这个过程会持续到把数组中的每一项都访问--遍，最后返回结果。

reduceRightU的作用类似，只不过方向相反而已。来看下面这个例子。 var values = [1^2,3,4,51;

var sum = values.reduceRight(function(prev, cur, index, array){ return prev > cur;

});

alert(sum); //15

在这个例子中，第一次执行回调函数，prev是5, cur是4。当然，最终结果相同，因为执行的都 是简单相加的操作。

使用reduce ()还是reduceRight (),主要取决于要从哪头开始遍历数组。除此之外，它们完全 相同。

支持这两个缩小涵数的浏览器有IE9+> Firefox 3+、Safari 4+、Opera 10.5和Chrome。

5.3 Date 类型

ECMAScript中的Date类型是在早期Java中的java.util.Date类基础.k构建的。为此，Date 类型使用自UTC (Coordinated Universal Time,国际协调时间)1970年I月1日午夜(零吋)开始经过 的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到1970年1 月1 U之前或之后的285 616年。

要创建--个日期对象，使用new操作符和Date构造函数即可，如下所示。 var now = new Date()；

DateTypeExampleOl .him

在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和吋间。如果想根 据特定的H期和时间创建H期对象，必须传人表示该H期的毫秒数(即从UTC时间1970年1月1 H午 夜起至该日期止经过的毫秒数)。为了简化这一计算过程，ECMAScript提供了两个方法：Date.parse() 和 Date.UTCU。

其中，Date.parse()方法接收一个表示日期的字符串参数，然后尝W根据这个字符串返回相应日 期的毫秒数。ECMA-262没有定义Date.parseG应该支持哪种口期格式，因此这个方法的行为因实现 而异，而H.通常是因地区而异。将地区设置为美国的浏览器通常都接受下列H期格式：

□    “；i/日 /年”，如 6/13/2004;

□"英文月名日，年”，如January 12,2004;

□    “英文星期几英文月名日年时:分:秒时区"，如Tue May 25 2004 00:00:00 GMT-0700。

□    iso 8601 扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ (例如 2004-05-25100:00:00 )o 只有兼容 ECMAScript 5的实现支持这种格式。

例如，要为2004年5月25日创建-个H期对象，可以使用卜■■面的代码：

var someDare = new Date(Date.parse{*May 25, 2004”})?

DateTypeExampleO I. htm

如果传入Date.parse(>方法的字符串不能表示FI期，那么它会返冋NaN。实际t,如果宜接将表 示日期的字符串传递给Date构造函数，也会在后台调用Date.parseU。换句话说，下面的代码与前 面的例子是等价的：

var someDate = new Date("May 25, 2004"); 这行代码将会得到与前面相同的日期对象。

曰期对象及其在不同浏览器中的实现有许多奇怪的行为。其中有一种倾向是将超 出范围的值替换成当前的值，以便生成输出。例如，在解析"January 32, 2007" 时，有的浏览器会将其解释为"February 1, 2007*。而Opera则倾向于插入当前月 份的当前日期，返回”January当前日期，2007%也就是说，如果在2007年9月 21日运行前面的代码，将会得到"January 21, 2007-(都是21日)。

Date.UTC()方法同样也返回表示日期的奄秒数，但它与Date.parseO在构建值时使用不同的信 息。Date.OTCO的参数分别是年份、基于0的月份(一月是0,二月是1,以此类推)、月中的哪一天 (1到31 )、小时数(0到23)、分钟、秒以及毫秒数。在这些参数中，只有前两个参数(年和月)是必 需的。如果没有提供月中的天数，则假设天数为丨；如果铒略其他参数，则统统假设为0。以下是两个 使用Date.UTCO方法的例子：

// GMT时间2000年1珂1曰午夜零时

var y2k = new Date(Date.UTC(2000, 0));

// GMT时间2005年5月5日下午5:55:55

var allFives = new Date(Dace.UTC(2005, 4, 5, 17, 55, 55)};

DateTypeUTCExampleOl. htm

这个例子创建r两个H期对象。第一个对象表示GMT时间2000年1月1曰午夜零时，传人的值一 个是表示年份的2000, 一个是表示月份的0 (即一月份)。因为其他参数是自动填充的(即月中的天数 为丨，其他所有参数均为0),所以结果就是该月第一天的午夜零时。第二个对象表示GMT时间2005 年5月5日下午5:55:55,即使日期和时间中只包含5,也需要传人不一样的参数：月份必须是4(因为 月份是基于0的)、小时必须设寶为17 (因为小时以0到23表示)，剩下的参数就很直观了。

如同模仿Date.parse(>—样，Date构造困数也会模仿Date.UTC(>.但有一点明显不同：日期 和时间都基于本地吋区而非GMT来创建。不过，Date构造函数接收的参数仍然与Date.UTCO相同。

因此，如果第一个参数是数值，Date构造函数就会假设该值是日期中的年份，而第二个参数是月份, 以此类推。据此，可以将前面的例子重写如下。

//本地时间2000年1月1日午夜零时 var y2k = new Date(2000z 0);

//本地时间2005年5月5日下午5:55:55

var allFives = new Date(2005, 4, 5Z 17, 55z 55);

DateTypeConstructorExampleO 1 .htm

以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时 区创建的。

ECMAScript5添加了 Data.now(＞方法，返回表示调用这个方法时的日期和时间的毫抄数。这个方 法简化了使用Data对象分析代码的工作。例如：

//取碍开始时间

var start = Date.now()；

//调用由数

doSomething()；

//取稃停止时间

var stop = Date.nowO r

result = stop - start；

支持 Data.now()方法的浏览器包括 IE9+、Firefox 3+、Safari 3+、Opera 10.5 和 Chrome。在不支 持它的浏览器巾，使用十操作符把Data对象转换成字符串，也可以达到同样的目的。

//舣得开始时间

var start : +new Date()/

//诮用函数

doSomething();

//取得停止时间

var stop « +new Date(),

result = stop start;

5.3.1继承的方法

与其他引用类型一样，Date类型也電写了 toLocaleString (＞、toString ()和valueOf ()方法； 但这些方法返回的值与其他类型中的方法不同。Date类型的toLocaleStringO方法会按照与浏览器 设置的地区相适应的格式返回日期和时间。这大致意味着吋间格式中会包含AM或PM,但不会包含时 区信息(当然，具体的格式会因浏览器而异)。而toStringO方法则通常返回带有时区信息的日期和 时间，其中时间一般以军用时间(即小时的范围是0到23)表示。下面给出了在不同浏览器中调用 toLocaleString ()和 toString ()方法，输出 PST( Pacific Standard Time,太平洋标准时间)时间 2007 年2月1H午夜零时的结果。

Internet Explorer 8

toLocaleString{) — Thursday, February 01, 2007 12:00:00 AM toString{) — Thu Feb 1 00:00:00 PST 2007

Firefox 3.5

toLocaleStringO 一 Thursday, February 01 x 2007 toString{) 一 Thu Feb 01 2007 00:00:00 GMT-0800

12:00:00 AM

(Pacific Standard Time)

 

00:00:00

(Pacific Standard Time)

 

Safari 4

toLocaleStringO — Thursday, February 01, 2007 toStringO — Thu Feb 01 2007 00:00:00 GMT-0800

Chrome 4

toLocaleStringO — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time) toStringO — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)

Opera 10

toLocaleStringO _ 2/1/2007 12:00:00 AM

toStringU — Thu, 01 Feb 2007 00:00:00 GMT-0800

显然，这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上， toLocaleString ()和toString ()的这-‘養别仅在调试代码时比较有用，而在显示日期和时间时没有 什么价值。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-24.jpg)

 

至于Date类型的valueOf<)方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以 方便使用比较操作符(小于或大下)来比较日期值。请看下面的例子。

var datel = new Date(2007, 0, 1); var date2 = new Date(2007, 1, 1);

//•January 1, 2007• //"February 1, 2007-

 

alert(datel < date2)； //true alert{datel > date2); //false

DateType ValueOJExampleO 1 .htm

从逻辑上讲，2007年1月1 口要早于2007年2月1日，此时如果我们说前者小于后者比较符合常 理。而表示2007年丨月1 口的毫秒值小于表示2007年2月1 口的毫秒值，因此在首先使用小于操作符 比较H期时，返冋的结果是true。这样，就为我们比较日期提供了极大方便。



5.3.2日期格式化方法

Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。

□    toDateStringO——以特定于实现的格式显示星期几、月、日和年；

□    toTimeStringO——以特定于实现的格式显示时、分、秒和时区；

□    toLocaleDateStringO——以特定于地区的格式显示星期几、月、日和年；

□    toLocaleTimeString ()-以特定于实现的格式显示时、分、秒；

□    toUTCStringO—以特定于实现的格式完整的UTC日期。

与toLocaleString (>和toString ()方法一样，以上这些字符串格式方法的输出也是因浏览器 而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。

除了角■面介绍的方法之外，还有一个名叫toGMTString()的方法，这是一个与 toUTCStringO等价的方法，其存在目的在于确保向后兼容，不过，ECMAScript推 荐现在编写的代码--律使用toUTCStringO方法。

5.3.3日期/时间组件方法

到目前为止，剩下还未介绍的Date类遨的方法（如下表所示），都是直接取得和设S日期值中特 定部分的方法了。需要注意的是，UTC H期指的是在没有时区偏差的情况下（将日期转换为GMT时间） 的日期值„

| 方    法                                            | 说    明                                                     |
| --------------------------------------------------- | ------------------------------------------------------------ |
| getTime{)                                           | 返［H1表示Lf期的奄秒数；与valueOf （）方法返luJ的值相同      |
| set Time (毫秒)getFullYear()                        | 以毫秒数设SH期，会改变整个H期取得4位数的年份（如200*7而非仅07 ） |
| get CTTCFull Year ()                                | 返回UTC日期的4位数年份                                       |
| setFullYear (年}setUTCFullYear (年)gecKonth()       | 没置H期的年份。传人的年份值必须是4位数字（如2007而非仅07）设SUTC3期的年份。传人的年份值必须是4位数字（如2007而非仅07）返问日期屮的月份，其中0表示一月，11表示卜二月 |
| getUTCMonth(}                                       | 返回UTCH期中的月份，其中0表示一月，11表示十二月              |
| setftonth<A }setUTCMonth()getDateO                  | 没置H期的月份。传入的月份值必须大于超过11则增加年份 设贤UTC日期的月份。传人的月份值必须大于0,超过11则增加年份 返回日期月份中的天数（1到31） |
| getUTCDate(}                                        | 返回UTCR期月份中的天数（1到31 ）                             |
| setDate (曰}                                        | 设置n期月份中的天数。如果传人的值超过了该月中应有的天数，则增加月份 |
| setUTCDate( 9 )getDay()                             | 设背UTC日期月份中的天数。如果传人的值超过了该月中应有的天数，则增加月份 返回日期中星期的星期几（其中0^表示星期H , 6表术星期六） |
| getCJTCDay ()                                       | 返冋UTC日期中M期的星期几（其中0表示星期U, 6表示星期六）      |
| getHours()                                          | 返回日期屮的小时数（0到23）                                  |
| getUTCHours()                                       | 返回UTC U期中的小时数（0到23 ）                              |
| set Hours【时)setUTCHours (时〉getMinutesO          | 设置U期屮的小时数。传人的值超过了23则增加月份中的天数设置UTCF1期中的小时数。传人的值超过了23则增加月份中的天数返回日期中的分钟数（0到59） |
| getUTCMinutesf)                                     | 返阅UTC日期中的分钟数（0到59 ）                              |
| setMinutes (^)setUTCMinutes(分}getSecondsO          | 设货日期中的分钟数。传人的值超过59则增加小时数 没SUTC日期中的分钟数。传人的值超过59则增加小时数 返回日期中的秒数（0到59） |
| getUTCSeconds()                                     | 返回UTCR期屮的秒数（0到59）                                  |
| setSeconds (秒)setUTCSeconds (秒)get Milliseconds() | 没貲日期中的秒数、传入的值超过了5岭埔加分钟数 设晋UTC日期中的秒数。传人的值超过09^增加分钟数 返回日期中的毫秒数 |
| getUTCMilliseconds()                                | 返回UTC日期中的奄秒数                                        |
| setMilliseconds (毫秒)                              | 设置n期中的奄秒数                                            |

| （续）                                            |                                                              |      |
| ------------------------------------------------- | ------------------------------------------------------------ | ---- |
| 方    法                                          | 说    明                                                     |      |
| setUTCMi Hi seconds （毫秒）getTimezoneOffset｛） | 设置UTC日期中的毫秒数返冋本地时间与UTC时间相差的分钟数。例如，荚国东部标准时间返冋300。在某 地进人复令时的悄况下，这个值会有所变化 |      |

5.4 RegExp 类型

ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正 则表达式。

var expression = / pattern / flags ；

其中的模式（pattern）部分fl]•以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、 向前査找以及反向引用。每个正则表达式都可带有一或多个标志（flags）,用以标明正则表达式的行为。 正则表达式的匹配模式支持下列3个标志。

□    g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即 停止；

□    i：衷示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；

□    m:表示多行（multiline）模式，即在到达一行文本末尾吋还会继续査找下一行中是否存在与模 式匹配的项。

因此，一个正则表达式就是一个模式与上述3个标志的组合体。不同组合产生不同结果，如下面的 例子所示。

/[1](#bookmark3)

*匹K字符串中所有-at•的实例 */

var patternl = /at/g;

I[1](#bookmark3)

*匹fc第一个-bat[1](#bookmark3)或"cat[1](#bookmark3),不区分大小写 */

var pattern2 = /[be]at/i；

*匹fc所有以-at[1](#bookmark3)結尾的3个字符的組合，不区分大小写 */

var pattern3 = /.at/gi；

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括: （I { \ " $ I ）? [1](#bookmark3) | . ]}

这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符， 就必须对它们进行转义。下面给出几个例子。

var pacternl = /[bc]at/i;

/*

*匹釔第一个胃[bc]at•‘，不区分大小写 */

var pactem2 = /\[bc\]at/i；

/*

*匹fc所有以-at，结尾的3个字符的组合，不区分大小写 */

var pattem3 = / .at/gi;

/*

*匹配所有11-at*,不区分大小写 */

var pattern4 = /\.at/gi;

在上面的例子中,patternl匹配第一个11 bat"或"cat"，不区分大小写。而要想直接匹配•' [bc]at * 的话，就需要像定义pattern —样，对其中的两个方括号进行转义。对于pattern3来说，句点表示 位于-at”之前的任意一个可以构成匹配项的字符。但如果想匹配则必须对句点本身进行转义， 如pattern4所不0

前面举的这些例了-都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用 RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以 使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示C

/*

*匹K第一个"bat-或"cat-,不区分大小写 */

var patternl = /[be]at/i;

/*

*与patternl相R,只不过是使用构速A数创建的 */

var pattern?. = new RegExp （" [be] at", "i"）;

在此，patternl和pattern2是两个完全等价的正则表达式。要注意的是，传递给RegExp构造 函数的两个参数都是字符申（不能把正则表达式字面量传递给RegExp构造函数）。由于RegExp构造 函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那 些已经转义过的字符也是如此，例如\n（字符\在字符串中通常被转义为\\,而在正则表达式字符串中就 会变成\\\\）。下表给出了一些模式，左边是这些模式的7-面贵形式，右边是使用RegExp构造函数定义 相同模式时使用的字符串。

| 字面遣横式       | 等价的字符串          |
| ---------------- | --------------------- |
| /\(bc\]at/       | •\\[bc\\]at-          |
| 八.at/           |                       |
| /name\/age/      | "naweW/age"           |
|                  | n\\d.\\d{lz2}-        |
| /\w\\hello\\123/ | "\\w\\\\hello\\\\123" |

使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript 3中， 正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是

一个新实例。来看下面的例子。

var re = null.

for (i=0; i < 10; i++){ re = /cat/g; re.test("catastrophe");

for (i=0; i < 10? i++){

re = new RegExp{"cat", "g")； re.test("catastrophe*);

}

在第一个循环中，即使是循环体中指定的，但实际上只为/cat/创建了一个RegExp实例。由于实 例属性(下一节介绍实例属性)不会重置，所以在循环中再次调用test ()方法会失败。这是因为第一

次调用test ()找到了但第二次调用是从索引为3的字符(上一次匹配的末尾)开始的，所以 就找不到它了。由于会测试到字符串末尾，所以下一次再调用test ()就又从开头开始了。

第二个循环使用RegExp构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的 RegExp实例，所以每次调用test (＞都会返因true。

ECMAScript5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创 建新的RegExp实例。IE9+、Firefox4+和Chrome都据此做出了修改;，

5.4.1 RegExp实例属性

RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。

□    global:布尔值，表示是否设置了 g标志。

□    ignoreCase:布尔值，表示是否设置了 i标志。

□    laetlndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。

□    multiline：布尔值，表示是否设置了 m标志。

□    source：正则表达式的字符串表示，按照字面量形式而非传人构造函数中的字符串模式返回。 通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含

在模式声明中。

 

例如：

 

var patternl =八[bc\】at/i;

//false

//true

//false

"0

//"\[bc\]at" 、\[bc\\]at”，"i")；

 

alert(patternl.global)； alert(patternl.ignoreCase) alert(patternl.multiline)； alert(patternl.lastlndex)； alert(patternl.source)； var pattern2 = new RegExp( alert(pattern2.global); alert(pattern2.ignoreCase)； alert(pattern2.multiline)? alert(pattern2.lastlndex)； alert(pattern2.source);

//false

//true

//false

//0

//•\[bc\)at*

 

RegExpInstancePropertiesExampleOl .htm

我们注意到，尽管第一个模式使用的是字面tt,第二个模式使用了 RegExp构造函数，但它们的 source属性是相同的。可见，source屈性保存的是规范形式的字符串，即字面M形式所用的字符串。

5.4.2 RegExp实例方法

KegExp对象的主要方法是exec U，该方法是专门为捕获组而设计的。exec ()接受一个参数，即 要应用模式的字符串，然后返回包含第一个匹紀项信息的数组；或者在没有匹配项的情况下返回null。 返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配 项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配 的字符串，其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项)。 请看下面的例子。

var text = "mom and dad and baby"；

var pattern = /mom( and dad( and baby)?)?/gi；

var matches = pattern.exec(text)；

alert(matches.index); alert(matches.input); alert(matches[0])； alert(matches[1]); alert(matches[2]);

// 0

// "mom and dad and baby" // "mom and dad and baby" // " and dad and baby"

// " and baby"

 

RegExpExecExampleOl. htm

这个例子中的模式包含两个捕获组。最内部的捕获组匹配-and baby-,而包含它的捕获组匹配-and dad-或者"and dad and baby-。当把字符串传人exec()方法中之后，发现了一个匹配项。因为整个 字符串本身与模式匹配，所以返回的数组matchs的index属性值为0。数组中的第一项是匹配的整个 字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。

对于exec <)方法而言，即使在模式中设置了全局标志(g),它毎次也只会返回一个匹配项。在不 设置全局标志的情况下，在同一个字符串上多次调用exec <)将始终返回第一个匹配项的信息。而在设 置全局标志的情况下，每次调用exec ()则都会在字符串中继续査找新匹配项，如下面的例子所示。

var text = "cat, bat, sat, fat"; var patteml = /.at/;

matches = pattern2.exec(text); alert (matches. index) ;    "5

alert(matches[0]);    //bat

alert(pattern2.lastlndex)?    Z/8

RegExpExecExampleO2.htm

这个例子中的第一个模式patternl不是全局模式，因此每次调用exec{)返M的都是第一个匹配 项(-cat")o而第二个模式pattern2是全局模式，因此每次调用exec (＞都会返回字符串中的下一个 匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的lastlndex «性的变化情况。在全局 匹配模式下，lastlndex的值在每次调用exec (＞后都会增加，而在非全局模式下则始终保持不变。

IE的JavaScript实现在lastlndex属性上存在偏差，即使在非全局模式下， lastlndex展性每次也会变化。

正则表达式的第二个方法是test ()，它接受-个字符串参数。在模式与该参数匹配的悄况下返回 true;否则，返冋false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文木内容的 情况下，使用这个方法非常方便。因此，test ()方法经常被用在if语句中，如下面的例子所示。

var text = "000-00-0000";

var pattern = /\d{3}-\d{2}-\d{4}/;

if (pattern，test(text＞){

alert("The pattern was matched.");

}

在这个例子中，我们使用正则表达式来测试了一个数字序列。如果输人的文本与模式匹配，则显示 一条消息。这种用法经常出现在验证用户输人的情况下，因为我们只想知道输入是不是有效，至于它为 什么无效就无关紧要了。

RegExp实例继承的toLocaleString (＞和toStringO方法都会返回正则表达式的字面量，与创 建正则表达式的方式无关。例如：

var pattern = new RegExp(*\\[bc\\]at"r "gi");

\* alert(pattern.toString()}；    // 八[bc\]at/gi

alert(pattern.toLocaleString())；    // 八[bc\]at/gi

RegExpToStringExampleOl .htm

即使上例中的模式足通过调用RegExp构造兩数创建的，但toLocaleString ＜)和toString () 方法仍然会像它是以字面量形式创建的一样显示其字符串表示。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-25.jpg)

 

正则表达式的valueOf ()方法返回正则表达式本身。

5.4.3 RegExp构造函数属性

RegExp构造函数包含一些属性(这些属性在其他语言中被看成是静态属性)。这些属性适用于作用

域中的所有正则表达式，并ii基于所执行的最近-次正则表达式操作而变化。关于这些属性的另一个独 特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有-个长属性名和一个短屑性名 (Opera是例外，它不支持短属性名)。下表列出了 RegExp构造函数的属性。

| 长厲性名     | 短厲性名 | 说    明                                                     |
| ------------ | -------- | ------------------------------------------------------------ |
| input        | $_       | 最近一次要匹配的字符串。Opera未实现此诫性                    |
| lastMatch    | S&       | 最近一次的匹配项。Opera未实现此厲性                          |
| lastParen    | $+       | 嚴近一次匹配的捕获组。Opera未实现此属性                      |
| leftContext  | $'       | input字符串中lastMatch之前的文本                             |
| multiline    | $*       | 布尔值，表示是否所存表达式都使用多行模式。正和Opera未实现此厲性 |
| rightContext | $■       | Input宇符串中lastMatch之后的文本                             |

使用这些属性可以从exec (＞或teatO执行的操作中提取出更具体的信息。请看下面的例子。

var text = "this has been a short suinmerw ； var pattern = /(.)hort/g?

\*    注意：Opera 不支神 input、lastMatch、lastparen 和即ltiline 属性

\*    Internet Explorer 不支持multiline 属性

*/

 

if (pattern.test(text)){ alert(RegExp.input)； alert(RegExp-lefLContext); alert(RegExp.rightContext); alert(RegExp.lastMatch)； alert(RegExp.lastParen)/ alert(RegExp.multiline);

}

 

| // this has been e                                 | i short summer |
| -------------------------------------------------- | -------------- |
| If this has been c // summer // short // s// false | L              |

 

RegExpConstructorPropertiesExampleO 1 .htm

以上代码创建了一个模式，匹配任何一个字符后跟hort,而且把第一个字符放在了一个捕获组中。 RegExp构造函数的各个属性返回了下列值：

□    input届性返问了原始字符串；

□    leftContext属性返回了单词short之前的字符串，而rightContext属性则返回了 short 之后的字符串；

□    lastMatch属性返回最近一次与整个正则表达式匹配的字符串，即short;

□    lastParen属性返回最近一次匹配的捕获组，即例子中的s。

如前所述，例子使用的长属性名都可以用相应的短属性名來代替。只不过，由于这些短属性名大都 不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们，如下所示。

var text = "this has been a short summer"； var pattern = /(.)horc/g;

注意：Opera 不支持 input、lastMatch, lastParen 和 multiline 爲性 Internet Explorer 不支4 multiline 属性

if {pattern.test(text)){

// this has been a short summer // this has been a // summer // short // b

// false

 

alert(RegExp.$_)； alert(BegExp["$'n]>; alert(RegExp["$•■]); alert (RegExp[■•$&••】)； alert(RegExp["$+"])/ alert(RegExp["$*M]);

}

RegExpConstructorPropertiesExample02. htm

除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语

法是RegExp. $1、RegExp.$2•■•RegExp. $9,分别用于存储第一、第二......第九个匹配的捕获组。在

调用exec（）或test（）方法时，这些属性会被肖动填充。然后，我们就可以像下面这样來使用它们。

var text = "this has been a short summer"； var pattern = /(..)or(.)/g;

if (pattern.test(textJ)<

alert(RegExp.$1)；    Z/sh

alert(RegExp.$2)；    //t

}

RegExgConstructorPropertiesExample03.htm

这里创建了一个包含两个捕获组的模式，并用该模式测试了一个字符串。即使test （）方法只返回 ~个布尔值，但RegExp构造函数的属性$1和$2也会被K配相应捕获组的字符串自动填充。

5.4.4模式的局限性

尽管ECMAScript中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是Perl）所支 持的髙级正则表达式特性。下面列出了 ECMAScript正则表达式不支持的特性（要了解更多相关信息， 请访问 [www.regular-expressions.info](http://www.regular-expressions.info) ）o

□匹配字符串开始和结尾的\A和\2锚®

□向后査找（lookbehind） ®

□并集和效类

□原子组（atomic grouping ）

□    Unicode支持（单个字符除外，）

□命名的捕获组3

□    s （single,单行）和 x （free-spacing,无间隔）K 配模式

□条件匹配

□正则表达式注释

即使存在这控限制，ECMAScript正则表达式仍然是非常强大的，能够帮我们完成绝大多数模式匹 配任务。

①    支持以插人符圩（△）和美元符兮（$）来匹配字符串的开始和结足a

②    但完全支持向前査找（lookahead）。

③    但支持编号的捕获组。

5.5 Function 类型

说起来ECMAScript中什么最有意思，我想那莫过于函数了——而有意思的根源，则在F函数实际 是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有屁性和方法。由于函 数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函

数声明语法定义的，如下面的例子所示。

function sum (numl, num2) { return numl + num2;

}

这与下面使用函数表达式定义函数的方式几乎相差无几。

var sum = function(numl, nun2){ return numl + num2；

};

以上代码定义了变量sum并将其初始化为一个函数c耵读者可能会注意到，function关键字后面 没肴函数名。这是因为在使用函数表达式定义函数时，没有必要使用函数名一通过变址sum即可以引 用函数。另外，还耍注意函数末尾有一个分号，就像卢明其他变贵时一样。

最后一种定义函数的方式是使用Function构造函数。Function构造函数可以接收任意数量的参数， 但最后一个参数始终都被看成是函数体，而前而的参数则枚举出了新函数的参数。来看下面的例子：

var sum = new Function (n numl ’, M num2" z * return numl + num2 *) ? // 不推其

从技术角度讲，这是一个函数表达式。但是，我们不推荐读者使用这种方法定义函数，因为这种语 法会导致解析两次代码(第一次是解析常规ECMAScript代码，第二次是解析传人构造函数屮的字符串), 从而影响性能=不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。

由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话 说，一个函数可能会有多个名字，如下面的例子所示。

function sum(numl, num2){ return numl + num2；

)

alert(sum(10,10)) ；    //20

var anotherSum = sum;

alert(anotherSum(10,10}); //20

sum = null;

alert(anotherSum(10,10)); //20

FunctionTypeExampleO 1. htm

以上代码首先定义了一^名为sum ()的函数，用于求两个悄的和。然后，又声明了变错anotherSum, 并将其设置为与sum相等(将sum的值赋给anothersum)。注意，使用不带阆括号的函数名是访问函 数指针，而非调用兩数。此时，anotherSum和sum就都指向了同一个函数，因此anotherSum()也 可以被调用井返回结果。即使将sum设置为null,让它与函数“断绝关系”，但仍然可以正常调用 anotherSum {} O

5.5.1没有重载(深入理解)

将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载的概念。以下是曾在第3

章使用过的例子。

function addSomeNumber(num){ return num + 100;

)

function addSomeNumber(num) { return num + 200；

}

var result = addSomeNumber (100) ; "300

显然，这个例+中卢明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际 上与下面的代码没有什么区别。

var addSomeNumber = function (num){

return num + 100;

addSomeNumber » function (num) {

return num + 200；

var result = addSomeNumber(100)； "300

通过观察重写之后的代码，很容易看清楚到底是怎么回事儿——在创建第二个函数时，实际上覆盖 了引用第一个函数的变量addSomeNumber。

5.5.2函数声明与函数表达式

本节到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环 境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行 任何代码之前可用(可以访问)；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真 正被解释执行。请看齐面的例子。

alert(sum(10,10)); f function sum(numl, num2){

return numl + num2；

}

以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升 (function declaration hoisting)的过程，读取并将函数声明添加到执行坏境中。对代砰求値时，JavaScript 引擎在第一遍会声明函数并将它们放到源代两树的顶部。所以，即使卉明函数的代码在调用它的代码后 面，JavaScript引擎也能把函数声明提升到顶部。如果像下面例子所示的，把上面的函数声明改为等价 的函数表达式，就会4:执行期间导致错误。

alert{sum(10,10));

var sum = function (nuxnl, nuxn2) {

return numl + num2;

\>; _

FunctionlrtitializationExampleOl. htm

以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声 明。换句话说，在执行到函数所在的语句之前，变ft sum中不会保存有对函数的引用；而且，由于第一 行代码就会导致“unexpected identifier"(意外标识符)错误，实际上也不会执行到下一行。

除了什么时候对以通过变厫访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-26.jpg)

 

也可以同时使用涵数声明和函数表达式，倒如var sum.= function suiaf) {}o 不过，这种语法在Safari中会导致姥误。

5.5.3作为值的函数

因为ECMAScript中的函数名本身就是变所以函数也可以作为值来使用。也就是说，不仅可以 像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看 一看下面的函数。

function callSomeFunction(someFunction, someArgument){ return someFunction(someArgument)?

}

这个函数接受两个参数。第一个参数应该是一个函数,第二个参数应该是要传递给该函数的一个值。 然后，就可以像下面的例子一样传递函数了=

function addlO(num){ return num + 10；

var resultl = callSomeFunction(addlO, 10}; alert(resultl);    //20

function getGreeting(name){ return **Hello, " + name;

var result2 = callSomeFunction(getGreeting, "Nicholas")；

alert(results)； //"Hello, NicholasB

FunctionAsAnA rgumentExampleOl. htm

这里的callSomeFunction ()函数是通用的，即无论第--个参数中传递进来的是什么函数，它都 公返冋执行第一个参数后的结果。还记得吧，要访问函数的指针而不执行函数的话，必须去掉函数名后 面的那对圆括号。闪此上面例子中传递给callSomeFunction()的是addlO和getGreeting,而不 足执行它们之后的结果。

当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个 对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort ()方法的比较函数要接收 两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题， 可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函 数的定义。

function createComparisonFunction(propertyName) {

return function(objectl, object2){

var valuel = objectl[propertyName]; var value2 = object2[propertyName]?

if (valuel < value2){ return -1;

} else if (valuel > value2){ return 1；

} else {

return 0;

FunctionRetumingFunctionExample01.htm

这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数 前面加了一个return操作符。在内部函数接收到propertyName参数后，它会使用方括号表示法来 取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下 面例子中这样使用。

var data = [{name： "Zachary", age： 28}, {name： "Nicholas", age： 29}];

data.sort(createComparisonFunction{"name")); alert(data[0].name); //Nicholas

data.sort(createComparisonFunction("age"))； alert(data[0].name); //Zachary

这里，我们创建了一个包含两个对象的数组data。其中，毎个对象都包含一个 name属性和一■个 age属性。在默认情况下，sort ()方法会调用每个对象的toString<)方法以确定它们的次序；但得 到的结果往往并不符合人类的思维^惯。因此，我们调用createComparisonFunction ("name")方 法创建了一个比较函数，以便按照每个对象的name属性值进行排序。而结果排在前面的第一项是name 为”Nicholas"，age 是 29 的对象。然后，我们又使用了 createComparisonFunction{ "age")返回 的比较函数，这次是按照对象的age属性排序。得到的结果是name值为” Zachary", age值是28的 对象排在了第一位。

5.5.4函数内部属性

在困数内部，有两个特殊的对象：arguments和this。其中，arguments在第3盘曾经介绍过, 它是一个类数组对象，包含着传人函数中的所有参数。虽然arguments的主要用途是保存函数参数， 但这个对象还存一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。 请看下面这个非常经典的阶乘函数。

function factorial(num){ if (num <=1) {

return 1；

} else {

return num * factorial(num-1)

}

}

定义阶乘函数一般都耍用到递！f」算法；如t:面的代码所示，在函数有名字，而且名字以后也不会变 的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为 了消除这种紧密稱合的现象，可以像下面这样使用arguments.callee。

function factorial(num){ if (num <=1)    {

return 1;

} else {

return num * arguments.callee(num-1)

)

Functio”TypeArgumentsExample01.hfm

在这个重写后的factorial ()函数的函数体内，没有再引用函数名factorial。这样，无论引用 函数时使用的是什么名字，都可以保证正常完成递归调用。例如：

var trueFactorial = factorial;

factorial = function(){ return 0 ?

};

alert(trueFactorial(5));    //120

alert {factorial (5) } ;    "0

在此，变量trueFactorial获得了 factorial的值，实际上是在另一个位置上保存了一个函数 的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变嬡。如果像原来的factorial () 刃P样不使用arguments .callee，调用trueFactorial <)就会返回0。可是，在解除了函数体内的代 码与函数名的耦合状态之后，trueFactorial ()仍然能够正常地计算阶乘；至于factorial <),它现 在只是一个返回0的函数。

函数内部的另一个特殊对象是this,其行为与Java和C#中的this大致类似。换句话说，this

引用的是函数据以执行的环境对象一或者也可以说是this值(当在网页的全局作用域中调用函数时，

this对象引用的就是window)。来看下面的例子。

window.color = "red"； var o = { color： "blue" }；

function sayColor(){ alert(this.color)；

}

sayColor(}；    //"red"

o.sayColor = sayColor； o.sayColor(); //“blue"

Function TypeThisExampleOLhtm

上面这个函数saycoloru是在全局作用域中定义的，它引用了 this对象。由丁•在调用函数之前, this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用 sayCoLor<)时，this引用的是全局对象window;换句话说，对this.color求值会转换成对 window.color求值，于是结果就返回了"red"。而当把这个闲数赋给对象o并调用o.sayColor(} 时，this引用的是对象0,因此对this.color求值会转换成对o.color求值，结果就返回了-blue"o

请读者一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是 在不同的杯境中执行，全局的sayColor () &数与o.sayColor G指向的仍然是同一 个函数。

ECMAScript 5也规范化了另一个函数对象的属性：caller。除了 Opera的早期版本不支持，其他

浏览器都支持这个ECMAScript 3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用， 如果是在全局作用域中调用当前函数，它的值为null。例如：

function outer(){

inner U;

function inner(){

alert(inner.caller):

}

outer()；

Function TypeA rgumentsCallerExampleOl .him

以上代码会导致警告框中显示outer ()函数的源代码。因为outer()调用丫 inter (),所以 inner .caller就指向outer <)。为了实现更松散的耦合，也可以通过arguments, cal lee. caller 来访问相同的信息u

function outer(){ inner();

}

function inner(){

alert(arguments.callee.caller)；

}

outer()；

Function TypeA rgumentsCaHerExampleO2. htm

IE、Firefox、Chrome和Safari的所有版本以及Opera 9.6都支持caller属性。

当函数在严格模式下运行时，访问arguments. callee会导致错误D ECMAScript 5还定义了

arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是 undefined。定义这个属性是为了分清arguments. caller和兩数的caller属性。以上变化都是为 了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。

严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。

5.5.5函数属性和方法

前面曾经提到过，ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个 属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数，如下面的例 子所示。

function sayName(name){ alert(name);

}

function sum(numl, num2){ return numl + num2；

}

function sayHi(){ alert("hi*);

}

Function TypeLengthPropertyExampleO 1. htm

以上代码定义了 3个函数，但每个函数接收的命名参数个数不同。首先，sayuamef)函数定义了_ 个参数，因此其length属性的值为1。类似地，Sum()函数定义了两个参数，结果其length属性中 保存的值为2。而sayHi ()没有命名参数，所以其length值为0。

在ECMAScript核心所定义的全部属性中，最耐人寻味的就要数prototype属性了。对于 ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如 toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访 问罢了。在创建fl定义引用类型以及实现继承时，prototype属性的作用是极为重要的(第6章将详 细介绍)。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。

毎个函数都包含两个非继承而来的方法：apply ()和call (>。这两个方法的用途都是在特定的作 用域巾调用闲数，实际上等于设置网数体内this对象的值。首先，apply <)方法接收两个参数：一个 是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是 arguments对象例如：

function sum(numl, num2}{ return numl + num2；

}

function callSuml (numl r num2){

return sum. apply (this, arguments);    // 传入 arguments 对象

}

function callSum2(numl, num2)(

return sum.apply(this, [numl, num2]);

}

alert(callSuml(10,10))；    Z/20

alert (callSum2 (10,10) ) ；    "20

 

//传入数纽

FunctionT^peApplyMethodExampleOl. htm

 

在上面这个例子中，callSuml ()在执行sum(}函数时传人了 this作为this值(因为是在全馬 作用域中调用的，所以传入的就是window对象)和arguments对象。而callSum2同样也调用了 sum《)函数，但它传人的则是this和一个参数数组。这两个函数都会正常执行并返回正确的结果。

![img](E:/11.ProgramFiles/Typora/JavaScriptd8a70b8fbea1082c34809-27.jpg)

 

在严格模式下，未指定环境对象而调用函数，则this值不会特型为window。 除非明确把函数添加到某个对象或者调用apply (}或call (),否则this值将是 undefinedo

call()方法与apply ()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call() 方法而言，第一个参数是this值没有变化，变化的是K佘参数都直接传递给函数。换句话说，在使用 call ()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。

function sum(auralz num2){ return numl + num2；

}

function callSum(numl, num2){

return awn.call (this, numl, nxu*2) /

alert (calXSumdO, 10)) ；    //20

Function TypeCallMethodExampleO 1. htm

在使用call ()方法的情况下，callSumG必须明确地传人每--个参.数。结果与使用apply (＞没有 什么不同。至于是使用apply ()还是callO,完全取决于你采取哪种给函数传递参数的方式最方便。 如果你打算直接传人arguments对象，或者包含函数屮先接收到的也是~个数组，那么使用apply () 肯定更方便；否则，选择call (＞可能更合适。(在不给函数传递参数的情况下，使用哪个方法都无所 谓。)

事实上，传递参数并非apply ＜)和call ()真正的用武之地；它们真正强大的地方是能够扩充函数 赖以运行的作用域。下面来看一个例子。

window.color = "red"； var o = { color： "blue")；

function sayColor(){ alert(this.color)；

)

| sayColor():                                                  | //red            |
| ------------------------------------------------------------ | ---------------- |
| sayColor.call(this); sayColor.call(window)s sayColor.call(o); | //red//red//blue |

FunctionTypeCallExampleOi .htm

这个例子是在前面说明this对象的示例基础上修改而成的。这一次，BayColorU也是作为全局 函数定义的，而且当在全局作用域中调用它时，它确实会显示-red”——因为对this.color的求值会

转换成对 window.color 的求值。而 sayColor.call (this)和 sayColor.call (window)，则是两 种ffl式地在全局作用域中调用函数的方式，结果当然都会显示"red”。但是，当运行sayColor.call (o) 时，函数的执行环境就不一样了，因为此时函数体内的this对象指向了 o,于是结果显示的是-blue-。

使用call (> (或apply (>)来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。 在前面例子的第一个版本中,我们是先将sayColor ()函数放到了对象。中,然后再通过o来调用它的; 而在这里重写的例子中，就不需要先前那个多余的步骤了 =

ECMAScript 5还定义了一个方法：bind(}。这个方法会创建一个函数的实例，其this值会被绑 定到传给bind (>函数的值。例如：

window.color =： "red";

I var o = { color： "blue" }；

function sayColor(){ alert{this.color)；

)

var objectSayColor * sayColor.bind(o)/ objectSayColor();    //blue

FunctionTypeBindMethodExampleO i. htm

在这里，sayColor<)调用 bind (> 并传人对象 o,创建了 objectSayColor (> 兩数。object -SayColor (>函数的this值等于o,因此即使是在全局作用域中调用这个函数，也会看到-blue”。这 种技巧的优点请参考第22章。

支持 bindG 方法的浏览器有 IE9+、Firefox 4+x Safari 5.1+、Opera 12+和 Chrome。

每个函数继承的toLocaleStringO和toString ()方法始终都返回函数的代码。返回代码的格 式则因浏览器而异一有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表 示，即由解析器删除了注释并对某些代碎作了改动后的代码。由于存在这些差异，我们无法根据这两个 方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的 valueOf 0方法同样也只返冋函数代码。

5.6基本包装类型

为了便于操作基本类型值，ECMAScript还提供了 3个特殊的引用类型：Boolean, Nu她er和 String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 实际上，每当读取一个基本类型值的时候，后台就会创建一个对的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。来看下面的例子。

var si = "some text"; var s2 = si.substring{2);

这个例子中的变量sl包含一个字符串，字符串当然是基本类型值。而下一行调用了 si的 substring (>方法，并将返冋的结果保存在了 s2中。我们知道，基本类瑠值不是对象，因而从逻辑上 讲它们不应该存方法(尽管如我们所思，它们确实有方法)。其实，为了让我们实现这种直观的操作， 后台已经自动完成了一系列的处理。当第二行代码访问si时，访问过程处于一种读取模式，也就是要 从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。

(1)    创建String类型的一^实例；

(2)    在实例上调用指定的方法；

(3)    销毁这个实例。

可以将以上三个步骤想象成是执行了下列ECMAScript代码。

var si = new String ("some text”； var s2 = si.substring(2); si - null;

经过此番处理，基本的字符串值就变得跟对象一样丁。而且，上面这三个步骤也分别适用于Boolean 和Number类型对应的布尔值和数宇值。

引川类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例， 在执行流离开当前作用域之前都--直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一 行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。来看 下面的例子：

alert(si.color)； //undefined

在此，第二行代码试图为字符串si添加一个color属性。但是，当第三行代码再次访问si时， 其color属性不见了。问题的原㈥就是第二行创建的String对象在执行第三行代码时已经被销毁了。 第三行代码又创建自己的String对象，而该对象没有color属性。

当然，可以.S式地调用Boolean、Number和String来创建基本包装类型的对象。不过，庞该在 绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的 值。对基本包装类型的实例调用typeof会返回，object'而且所有基本包装类型的对象都会被转换 为布尔使true。

Object构造函数也会像工厂方法一样，根据传人值的类型返冋相应基本包装类型的实例。例如：

var obj = new Object("some text"); alert(obj instanceof String)； //true

把字符串传给Object构造函数，就会创建String的实例；而传人数值参数会得到Number的实 例，传人布尔值参数就会得到Boolean的实例。

要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。 例如：

var value = *25";

var number = Number (value)；"转免 A敦 alert(typeof number)；    //"number"

var obj = new Number (value) ； //构速為数 alert(typeof obj);    //"object"

在这个例子中，变量number中保存的是基本类型的值25,而变景obj中保存的是Number的实 例。要了解有关转型函数的更多信息，请参考第3章。

尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。 而每个基本包装类型都提供了操作相应值的便捷方法。

5.6.1 Boolean 类型

Boolean类型是与布尔值对应的引用类型。要创建Boolean对象，可以像下面这样调用Boolean 构造闲数并传人true或false值0

var booleanObject = new Boolean(true)；

Boolean类型的实例重写了 valueOf {)方法，返回基本类型值true或false;重写了 toString () 方法，返回字符串"true’,nfalse"。可是，Boolean对象在ECMAScript中的用处不大，因为它经 常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用Boolean对象，例如：

var falseObject = new Boolean(false)；

' var result = CalseObject && true;

alert(result)； //true

var falseValue = false； result = falseValue && true； alert(result)； //false

Boolean TypeExampleOl. htm

在这个例子中，我们使用false值创建了一个Boolean对象。然后，将这个对象与基本类型值true 构成了逻辑与表达式。在布尔运算中，false && true等于false。可是，示例中的这行代码是对 falseObject而不是对它的值(false )进行求值。前面讨论过，布尔表达式中的所有对象都会被转 换为true,因此falseObject对象在布尔表达式中代表的是true。结果，true && true当然就等 于 true To

基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回，boolean”， 而对引用类型返回"object "。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof 操作符测试Boolean对象会返回true,而测试基本类型的布尔值则返回false。例如：

alert(typeof falseObject); //object alert(typeof falseValue)? //boolean alert(falseObject instanceof Boolean)； //true alert(falseValue instanceof Boolean)； //false

理解基本类型的布尔值与Boolean对象之间的区别非常重要——当然，我们的建议是永远不要使 用Boolean对象。

5.6.2 Number 类型

Number是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其 中传递相应的数值。下面是一个例子。

var numberObj ect = new Number(10);

NumberT^peExampleOl .htm

与 Boolean 类型一样，Number 类型也重写了 valueOf ()、toLocaleString <)和 toString () 方法。重写后的valueOf ()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的

数值。我们在第3章还介绍过，可以为toStringt)方法传递一个表示基数的参数，告诉它返回几进制 数值的字符串形式，如下面的例子所示。

var num = 10；

alert(num.toString()); alert(num.toString(2)): alert(num.toString(8)); alert(num.toString(10))； alert{num.toString(16));

//*10B

//-1010-

//"12*

//■io-

//"aM

 

NumberTypeExample01.htm

 

除了继承的方法之外，Nujrtoer类型还提供了一些用于将数值格式化为字符串的方法。 其中，toFixedG方法会按照指定的小数位返冋数值的字符串表示，例如： var num = 10；

alert(nun.toFixed<2)>;    //"10.00"

 

NumberTypeExampleOl. htm

这里给匕oFixedO方法传人了数值2,意思是显示几位小数o于是，这个方法返回了”10.00■，即 以0填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值 就会舍人，如下面的例子所示。

var num = 10.005;

alert(nua.toFlxed(2));    //"10.01"

能够自动舍人的特性，使得toWxedO方法很适合处理货币值。但需要注意的是，不同浏览器给 这个方法设定的舍人规则可能会有所不同。在给toFixed<)传人0的情况下，IE8及之前版木不能正确 舍入范围在«-0.94H).5］，［0.5,0.94)｝之间的值。对于这个范围内的值，ffi会返冋0,而不是-1或1;其他 浏览器都能返回正确的值。IE9修复了这个问题。

围，

 

toFixed(>方法可以表示带有0到20个小数位的数值。怛这只是标准实现的范 有些浏览器也可能支持更多位数。

另外可用于格式化数值的方法是toExponentialO,该方法返回以指数表示法(也称e表示法) 表示的数值的字符串形式。与toFixed()--样，toExponential <)也接收一个参数，而且该参数同样 也是指定输出结果中的小数位数。看下面的例子。

var num = 10;

alert (num. toSxponential(l)) t //•!.. Oe+1"

以上代码输出了 ••1.0e+l-;不过，这么小的数值一般不必使用e表示法。如果你想得到表示某个 数值的最合适的格式，就应该使用toPrecision<)方法。

对于一个数值来说，toPrecisionf)方法可能会返回固定大小(fixed)格式，也可能返冋指数 (exponential)格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的 位数(不包括指数部分)。请看下面的例子。

var nun = 99；

Z/-le+2M

//"99"

//"99.0"

 

alert(num.toPrecision(l)); alert (nu2&.toPrecision(2)) t alert(num.toPrecision<3));

NumberTypeExampleOl. htm

以上代码首先完成的任务是以--位数来表示99,结果是》le+2•，即100。因为一位数无法准确地 表示99,因此toPrecisionO就将它向上舍人为100,这样就可以使用一位数来表示它了。而接下来的 用两位数表示99,当然还是’99’。最后，在想以三位数表示99时，toPrecision<)方法返回了"99.0"。 实际上,toPrecision ()会根据要处理的数值决定到底是调川toFixed()还是调用toExponential ()。 而这三个方法都可以通过向上或向下舍人，做到以最准确的形式来表示带有正确小数位的值。

toPrecision (｝方法可以表现1到21位小数。 这是典型实现的范围。

某些浏览器支持的范围更大，但

 

与Boolean对象类似，Number对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍 然不建议直接实例化Number类型，而原因与显式创建Boolean对象一样。具体来讲，就是在使用 typeof和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同，如下面的 例子所示。

var numbcrObject = new Number(10)； var numberValue = 10;

alert(typeof numberObject)；    //"object"

alert(typeof numberValue)?    //"number"

alert(numberObject instanceof Number); //true alert(numberValue instanceof Number)； //false

在使用typeof操作符测试基本类型数值时，始终会返回"number",而在测试Number对象时, 则会返回"object**。类似地，Number对象是Number•类型的实例，而基本类型的数值则不是。

5.6.3 String 类型

String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建。

var 8tring0bject =： new String("hello world" >;

StringTypeExampleOl .htm

String对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf () .toLocale-String()和toString()方法，都返回对象所表示的基本字符串值。

String类型的每个实例都有一个length属性，表示字符串中包含多个字符。来看下面的例子。

var stringValue = "hello world"；

alert(stringValue.length)；    //"ll"

这个例子输出了宇符串-hello world■■中的字符数量，即-11-。应该注意的是，即使字符串中包 含双字节字符(不是占一个字节的ASCII字符)，每个字符也仍然算一个字符。

String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。

1.字符方法

两个用于访问字符申中特定字符的方法是：charAt (＞和charCodeAt ＜ ＞。这两个方法都接收一个 参数，即基于0的字符位置。其中，charAtU方法以单字符字符串的形式返回给定位置的那个字符 (ECMAScript中没有字符类型)。例如：

var stringValue = "hello world"；

alert(stringValue.charAt(1));    //"e"

字符串-hello world’•位置1处的字符是-e'因此调用charAt⑴就返回了4”。如果你想得到 的不是字符而是字符编码，那么就要像下面这样使用charCodeAt () 了。

var stringValue = "hello world*;

alert(8tringValue.charCodeAt(1));    //*出"101"

这个例子输出的是•10V,也就是小写字母的字符编码。

ECMAScript 5还定义了另一个访问个别字符的方法。在支持浏览器中，可以使用方括号加数字索弓I来 访问字符串中的特定字符，如下面的例子所示。

var stringValue = "hello world"；

alert(stringValue[1]);    //Me"

使用方括号表示法访问个別字符的语法得到了 IE8及Firefox、Safari、Chrome和Opera所有版本的 支持。如果是在IE7及更早版本中使用这种语法，会返回undefined值(尽管根本不是特殊的 undefined 值)o

2.字符串操作方法

下面介绍与操作字符串有关的几个方法。第一个就是concatO,用于将-或多个字符串拼接起来， 返回拼接得到的新字符串。先来看一个例子。

var stringValue = "hello "； var result = stringValue.concat("world")j alert(result);    //"hello world-

alert(stringValue)；    //"hello*

在这个例子中，通过stringValue调用concat {)方法返[nl的结果是"hello world"-但

stringValue的值则保持不变。实际上，concatO方法可以接受任意多个参数，也就是说可以通过它 拼接任意多个字符串。再看一个例子：

var stringValue = "hello ";

var result ■ stringValue.concat("world*, "i");

alert(result);    //"hello world!"

alert(stringValue)；    //"hello”

这个例子将”world•和”！ •拼接到了》hello••的末尾。虽然concat ＜)是专门用来拼接字符串的方 法，但实践中使用更多的还是加号操作符{ + )。而且，使用加号操作符在大多数情况下都比使用concatO 方法要简便易行(特别是在拼接多个字符串的情况下)。

ECMAScript还提供了三个基于子字符申创建新字符申的方法：slice() substr()和substring()。 这三个方法都会返凹被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字 符串的开始位置，第二个参数(在指定的情况下)表示子字符串到哪里结束。具体来说，Slice(＞和 substring ()的第二个参数指定的是子字符串最后一个字符后面的位置。而substrO的第二个参数指

定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与

concat()方法一样，slice(｝、substr()和substring()也不会修改字符串本身的值-它们只是

返回一个基本类型的字符串值，对原始字符串没有任何影响。请看下面的例子。

var stringValue = "hello world-；

alert(strin^Value.slice(3)); // alert(stringValue.substring(3))i // alert(stringValue.substr(3)); // alert(stringValue.slice(3, 7)); // alert(stringValue.substring(3,7}); // alert(stringValue.subatr(3, 7)); //

lo world" lo world" lo world" lo w" lo w" lo worl"

 

StringljfpeManipulationMethodsExampleO! .htm

这个例子比较了以相同方式调用slice () x substr()和substring <)得到的结果，而且多数情 况下的结果是相同的。在只指定一个参数3的情况下，这三个方法都返回，lo world-,因为-hello。 中的第二个■'处于位置3。而在指定两个参数3和7的情况下，slice()和substrings)返回-1OW> ("world■中的，o•处于位置7，因此结果中不包含"o')，但substr<)返冋•lo worl*，闲为它的第二 个参数指定的是要返回的字符个数。

在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传 人的负值与字符串的长度相加，substrO方法将负的第一个参数加上字符串的长度，而将负的第二个 参数转换为0。最后，substring <>方法会把所布负值参数都转换为0。下面来着例子。

var stringValue = "hello world";

Z/"rld-

//"hello world" //”rW //"lo w"

//"hel-//"•(空字符事)

 

alert(stringValue.slice(-3)); alert(BtringValue.substring(-3))/ alert(stringValue.subatrC-3))t alert(stringValue.slice(3, -4))j alert(stringValue.substring(3, -4)); alert(stringValue.aubstr(3, -4));

StringTypeManipulationMethodsExampleO 1 .htm

这个例子清晰地展示了上述三个方法之间的不同行为。在给slice ()和substrO传递一个负值 参数时，它们的行为相同。这是因为-3会被转换为8 (字符串长度加参数11+<-3)=8 ),实际上相当 于调用了 slice<8)和substr(8>。但substring ()方法则返回了全部字符串，因为它将-3转换 成了 0。

IE的JavaScript实现在处理向substr (>方法传递负值的情况时存在问题，它会 返回原始的字符串。正9修复了这个问题。

当第二个参数是负值时，这三个方法的行为各不相同。slice ()方法会把第二个参数转换为7,这 就相当于调用了 slice(3,7),因此返回-lo w-。substring<)方法会把第二个参数转换为0,使调 用变成了 substring(3,0>,而由于这个方法会将较小的数作为开始位置，将较大的数作为结束位置， 因此最终相当于调用了 substring <0,3)。substr ()也会将第二个参数转换为0,这也就意味着返回 包含零个字符的宇符串，也就是--个空字符串。

3.宇符串位置方法

有两个可以从字符串中査找子字符串的方法：indexof ()和lastlndexOf (＞。这两个方法都是从 一个字符串中搜索给定的子字符串，然后返子字符串的位置(如果没有找到该子字符串，则返回-1)。 这两个方法的区别在于：indexOf (＞方法从字符串的开头向后搜索子字符串，而lastlndexOf (＞方法 是从字符串的末尾向前搜索子字符串。还是来看一个例子吧。

var stringValue = *hello world"；

alert (stringValue. iz&dexOf ("o") ＞ ；    Z/4

alert(stri&gValue«lastlndexOf("o"));    //7

StringT^peLocationMetkodsExampleO 1 .htm

子字符串》O”第一次出现的位罝是4,即”hello••巾的最后一次出现的位置是7,即■world■中的 •O-。如果在这个字符串中仅出现了一’次，那么indexOf (＞和lastlndexOf ()会返囬相同的位置值。

这两个方法都可以接收可选的第二个参数.表示从字符申中的哪个位置开始搜索。换句话说， indexOf ()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而lastlndexOf 0则会从 指定的位置向前搜索，忽略该位置之后的所有字符。看下面的例子。

var stringValue = "hello world"；

alert＜atringValue.indexof(woa, 6));    //7

alert(stringValue.lastlndexOf(HoN, $)＞;    //＜

在将第二个参数6传递给这两个方法之后，得到了与前面例子相反的结果。这一次，由于 indexof ()是从位置6(字母)开始向后搜索，结果在位置7找到了‘’o'因此它返回7。而lastlndexOf () 是从位置 6 开始向前搜索。 结果找到了”hello”中的因此它返回4。在使用第二个 参数的情况下，可以通过術环调用indexOfO或lastlndexOH)来找到所有匹配的子字符串，如下 面的例子所示：

var stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit"；

var positions = new Array()；

var pos = stringValue.indexof(■e")；

while(pos > -1){

positions.push(pos)；

pos = stringValue.indexOf("e", pos + 1);

}

alert(positions);    //"3f24,32,35,52"

StringTypeLocationMethodsExample02 .htm

这个例子通过不断增加indexof (＞方法开始査找的位置，遍历了一个长字符串。在循环之外，首 先找到T»e»在字符串中的初始位置;而进人循环后，则每次都给indexOf ()传递上一次的位置加1。 这样，就确保了每次新搜索都从上一次找到的子字符串的后面开始。每次捜索返回的位置依次被保存在 数组positions中，以便将来使用。

\4.    方法

ECMAScript5为所有字符串定义了 trimU方法。这个方法会创建•个字符串的副本，删除前置及 后缀的所有空格，然后返回结果。例如：

var stringValue = " hello world ";

var trimmedStringValue = stringValue.trim()； alert(stringValue)；    //" hello world

alert(trimmedStringValue);    //"hello world"

由于trim(＞返冋的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。支持这个 方法的浏览器有 IE9+、Firefox3.5+、Safari 5+、Opera 10.5+和 Chrome。此外，Firefox3.5+, Safari 5+ 和Chrome 84■还支持非标准的trimLeft ＜)和trimRight ()方法，分别用于删除字符串开头和末尾的 空格。

5.宇符串大小写转换方法

接下来我们要介绍的是一组与大小写转换有关的方法。ECMAScript中涉及字符串大小写转换的方 法有 4个：toLowerCase()、toLocaleLowerCase(＞、toUpperCase(＞ 和 toLocaleUpperCase()o 其中，toLowerCase＜)和toUpperCase (＞是两个经典的方法，借鉴自java.lang.String中的同名 方法。而toLocaleLowerCase (＞和toLocaleUpperCase (＞方法则是针对特定地区的实现。对有啤地 区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言(如土耳其语)会为Unicode大小 写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。以下是几个例子。

var stringValue = "hello world"；

alert(stringValue.toLocaleUpperCase()); alert (strincfValue. toUpperCase ()); alert(stringValue.toLocaleLowerCase()); alert(stringValue.toLowerCase())/

//"HELLO WORLD" //"HELLO WORLD" //"hello world" //•hello world"

 

StringTypeCaseMethodExampleOl. htm

以上代码调用的 toLocaleUpperCase ＜)和 coUpperCase ()都返回了-HELLO WORLD",就像调用 toLocaleLowerCase (＞ 和 toLowerCase ()都返同"hello world"—样。一般来说，在不知道自己的 代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。

6.字符串的模式匹配方法

String类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是match(),在字符串上 调用这个方法，本质上与调用RegExp的exec (＞方法相同。match ＜)方法只接受一个参数，要么是一 个正则表达式，要么是一个RegExp对象。来看下面的例子。

var text = "cat# bat, sat# fat"; var pattern = /.at/；

//与 pattern.exec (text)相同 var matches = text.match(pattern); alert(matches.index)；    //0

[1](#footnote1)

匹肥第一个”bat■或-cat",不区分大小写





alert (matches【0] } ;    /"cat，

alert(pattern.lastIndex)；    //0

StringTypePatternMatehingExampleO L htm

本例中的match ()方法返回了一个数组；如果是调用RegExp对象的exec (＞方法并传递本例中的 字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每 一项(如果有)保存着与正则表达式中的捕获组匹配的字符串。

另一个用于査找模式的方法是search^。这个方法的唯一参数与match ()方法的参数相同：由字 符串或RegExp对象指定的一^正则表达式。search(＞方法返回字符串中第-个匹配项的索引；如果没 有找到匹配项，则返回-1。而且，search ()方法始终是从字符串开头向后査找模式。看下面的例

var text = "cat, bat, sat, fat";

var pos » text.search(/at/); alert(pos)t //I

StnngTypePattemMatchingExample01.htm

这个例子中的search ()方法返回1,即”at»在字符串中第一次出现的位置。

为了简化替换子字符串的操作，ECMAScript提供了 replace 0方法。这个方法接受两个参数：第

一个参数可以是一个RegExp对象或者一个字符串(这个字符串不会被转换成正则表达式)，第二个参 数可以是一个字符串或者一个函数。如果第•个参数是字符串，那么只会替换第一个子字符串。要想替

换所有子字符串，唯一的办法就是提供一个正则表达式, var text = "cat, bat, sat, fat";

而且要指定全局(g)标志，如下所示。

 

var result » text.replace("at", "ond"); alert(result)/ //"cond, bat, sat, fatn

result s text. replace (/at/g, "ond**) t alert(result); //"cond, bond, sond, fond"

StringTypePattemMatchingExampleOl. htm

在这个例子中，首先传人replaced方法的是字符串••和替换用的字符串Mnd-。替换的结果 足把-cat•变成了-cond-,但字符串中的其他字符并没存受到影响。然后，通过将第一个参数修改为带 宥全局标志的正则表达式，就将全部，at ••都替换成了》ond •。

如果第二个参数是7符串，那么还可以使用•些特殊的字符序列，将正则表达式操作得到的值插人 到结果字符串中。下表列出了 ECMAScript提供的这些特殊的字符序列。

字符序列    替换文本

~'SS    $~

匹配整个模式的子字符串。与RegExp.lastMatch的值相同 $1    匹配的子字符串之前的子字符串5与RegExp, leftContext的值相同

$'    匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同

&    匹配第zi个捕获组的子字符串，其中《等于0~9。例如，$1是匹配第一个捕获组的子字符申，$2是匹配第

二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串

闪配第卿^捕获组的子字符串，其中„„等于01-99。例如，$01是匹配第一个捕获组的子字符串，$02 是匹配第二个捕获组的子字符串，以此类推、如果正则表达式中没有定义捕获组，则使用空字符串

通过这些特殊的字符序列，可以使用最近一次匹配结果中的内容，如下面的例子所示。

var text = "cat, batr satz fat"；

result = text.replace(/(.at)/g, "word ($1)")；

alert(result); //word (cat), word {bat), word (sat), word (fat)

StringTypePattemMatchingExample01.htm

在此，每个以》at•结尾的单词都被替换了，替换结果是^word•后跟一对岡括号，而圆括号中是被 字符序列$1所替换的单同。

replace ()方法的第二个参数也可以是一个函数。在只有一个匹配项(即与模式匹配的字符串)的 情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在 正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的阅 配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始 字符串。这个函数应该返冋一个字符串，表示应该被替换的匹配项使用函数作为replaced方法的第 二个参数可以实现更加精细的替换操作，请看下面这个例子。

function htmlEscape(text){

return text. replace {/ To"&.] /g, function (match, pos, originalText) { switch(match){

| case      |          |
| --------- | -------- |
| return    |          |
| case      |          |
| return    | "&gt;    |
| case ™&": |          |
| return    | "&amp；" |
| case "\:  |          |
| return    | "&quot;  |

 

}

});

}

alert ihtmlEscape("<p class=\"greeting\">Hello world!</p>"))； //&lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt;

StringT\pePatternMatchingExampleO 1. htm

这里，我们为插人HTML代码定义了函数htmlESCape()，这个函数能够转义4个字符：小于号、 大于号、和号以及双引号。实现这种转义的最简单方式，就是使用正则表达式査找这几个字符，然后定 义一个能够针对每个叩配的字符返回特定HTML实体的函数。

最P—个与模式匹配有关的方法是split (),这个方法可以基于指定的分隔符将一个字符串分割成 多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象(这个方 法不会将字符串看成正则表达式)。split (＞方法可以接受可选的第二个参数，用于指定数组的大小， 以便确保返冋的数组不会超过既定大小。清看下面的例子。

| var colorText | ="red,blue,green,yellow"; |                          |           |                                                 |
| ------------- | ------------------------- | ------------------------ | --------- | ----------------------------------------------- |
| var           | colorsl =                 | colorText.split(",H >;   | //["red"z | "blue”， "green"# "yellow                       |
| var           | colors2 =                 | colorText.split(",", 2); | //[-red-, | "blue"]                                         |
| var           | colors3 =                 | colorText.split(ZJ +/)； | //[■",、  | Il    mu    N n    n ii 1•    •    •    it    J |

StringTypePatternMatchingExampleO】.htm

在这个例子中，colorText是逗号分隔的颜色名字符串。基于该字符串调用split ( ”，■)会得到 一个包含其中颜色名的数组，用于分割字符串的分隔符是逗号。为了将数组截短，让它只包含两项，可 以为split ()方法传递第二个参数2。最后，通过使用正则表达式，还可以取得包含逗号字符的数组。 需要注意的是，在最后一次调用splits)返回的数组中，第一项和最后-项是两个空字符串。之所以会

这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头（即子字符串•red”）和末尾（即子 字符串••yellow"）。

对split ｛）中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现 匹配项以及带有捕获组的模式，匹配的行为就不大相同了。以下是几种常见的差别。

□    IE8及之前版本会忽略捕获组。ECMA-262规定应该把捕获组拼接到结果数组中。IE9能正确地 在结果中包含捕获组。

□    Firefox3.6及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262规 定没有匹配项的捕获组在结果数组中应该用undefined表示。

在正则表达式中使用捕获组时还有冗他微妙的差别。在使川这种正则表达式时，一定要在各种浏览 器下多做一些测试。

(^\ 要了解关于spliU)方法以及捕获组的跨浏览器问題的更多讨论,请参考Steven

X Levithan 的文章 “JavaScript split bugs: Fixed!" (<http://blog.stevenlevithan.com/archives/> J cross-browser-split)。

\7. localeCompare （）方法

与操作字符串有关的最订一个方法是localeCompareO,这个方法比较两个字符串，并返凹下列 值中的•一个：

□如果字符串在字母表中应该排在字符中参数之前，则返间一个负数（大多数情况下是-1,具体 的值要视文现而定）；

□如果字符串等于字符中参数，则返回0;

□如果宇符串在字母表中应该排在字符串参数之后，则返回一个正数（大麥数情况下是1,具体的 值同样要视实现而定）。

下面是几个例子。

var scringValue = "yellow";

StringTypeLocaleCompareExampleQ I .htm

这个例子比较J*字符串"yellow”和另外几个慣："brick"、"yellow••和”zoo"。因为"brick*在 字母表中排在"yellow"之前，所以localeCompare ()返回了 1;而"yellow■等于"yellow"，所以 localeCompare ()返回了 0;最G, "zoo•*在字母表中排在-yellow"后面，所以 localeCompare (} 返回了-1。再强调一次，因为localeCompare《)返回的数值取决于实现，所以最好是像下面例了-所示 的这样使用这个方法。

function determineOrder(value) {

var result = stringValue.localeCompare(value)； if (result < 0){

alert("The string 'yellow' comes before the string *■ + value +

} else if (result > 0) {

alert("The string •yellow' comes after the string '" + value + •'.")；

} else {

alert("The string ，yellow， is equal to the string ■" + value +

}

determineOrder{"brick");

determineOrder("yellow");

determineOrder("zoo”)；

StringTypeLocaleCompareExampleOl. htm

使用这种结构，就可以确保自己的代码在任何实现中都可以正确地运行了。 localeCompareG方法比较与众不同的地方，就是实现所支持的地区(国家和语言)决定了这个

方法的行为。比如，美国以英语作为ECMAScript实现的标准语言，因此localeCompareO就是区分 大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。不过，在其他 地区恐怕就不是这种悄况了。

\8. fromCharCode (｝方法

另外，String构造函数本身还有一个静态方法：fromCharCode ()。这个方法的任务是接收一或 多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法charCodeAt () 执行的是相反的操作。来看一个例子：

alert(String.fromCharCode(104, 101, 108, 108, 111)); //’hello"

StringTypeFromCharCodeExampleO! .htm

在这里，我们给fromCharCode ()传递的是字符串-hello”中毎个字母的字符编码。

\9. HTML方法

旱期的Web浏览器提供商觉察到了使用JavaScript动态格式化HTML的需求。于是，这些提供商就 扩展了标准，实现了一些专门用于简化常见HTML格式化任务的方法。下表列出了这些HTML方法。 不过，需要请读者注意的是，应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。

| 方    法         | 瑜出结果                          |
| ---------------- | --------------------------------- |
| anchor{name)     | <a name= " name*>string</a>       |
| big{)            | <big>string</big>                 |
| boldO            | <b>string</b>                     |
| fixed ()         | <tt>scring</tt>                   |
| fontcolor(color) | <font color=■color">string</tont> |
| fontsize(size)   | <font size="size">string</font>   |
| italics{)        |                                   |
| link(url)        | <a href =" url" >st:ring</a>      |
| small()          | <small>string<Zsmall>             |
| strike()         | <strike>string</strike>           |
| sub()            | <sub>string</sub>                 |
| sup()            | <sup>string</sup>                 |

5.7单体内置对象

ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对 象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因

为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如Object, Array和String。 ECMA-262还定义了两个单体内置对象：Global和Math。

5.7.1 Global 对象

Global (全局)对象可以说足ECMAScript中最特別的一个对象了，因为不管你从什么角度t看， 这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象” 来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全 局变fl或全局函数；所有在全局作用域中定义的域性和函数，都是Global对象的属性。本书前而介绍 过的那些函数，诸如 isNaN (>、isFinite()、parselnt (> 以及 parseFloat (>,实际上全都是 Global 对象的方法。除此之外，Global对象还包含其他一些方法。

1.URI编码方法

Global 对象的 encodeURI (> 和 encodeURIComponent (> 方法可以对 URI ( Uniform Resource Identifiers,通用资源标识符)进行编码，以便发送给浏览器。冇效的URI中不能包含某些字符，例如 空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符, 从而让浏览器能够接受和理解。

其中，encodeURI ()主要用于整个 URI(例如，http://www.wrox.com/illegal value.htm ),而 encode -URIComponent ()主要用于对URI中的某一段(例如前面URI中的illegal value.htm)进行编码。 它们的主要区别在于，encodeURI (>不会对本身属于URI的特殊字符进行编砰，例如冒号、正斜杠、 问号和井字号；而encodeURIComponentf)则会对它发现的任何非标准字符进行编码。来看下面的例子。

var uri = "<http://www.wrox.com/illegal> value.htm#start";

//"[http://www.wrox.com/illegal%20value.htm#start](http://www.wrox.com/illegal%20value.htm%23start)" alert (encodeURI (uri” ；

// "http%3 A% 2F%2Fwvzw.wrox. coin%2Fil legal %20 value. htm%2 3 start ■ alert(encodeURIComponent(uri));

GlobalObjectURlEncodingExample01.htm

使用.encodeURI ()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了 M0。而encodeURIComponent (>方法则会使用对应的编码替换所有非字母数字字符。这也正是可以 对整个URI使用encodeURI ()，而只能对附加在现有URI后面的字符串使用encodeURIComponent () 的原因所在。

一般来说，我们使用encodeURIComponent ()方法的时候要比使用 encodeURI ()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI ? 进行编码。

与encodeURI ()和encodeURIComponent ()方法对应的两个方法分别是decodeURI ()和 decodeURIComponent () o其中，decodeURI ()只能对使用encodeURI ()替换的字符进行解码。例如， 它可将%2Q替换成一个空格，但不会对%23作任何处理，因为％23表示井字号(# ),而井字号不是使用 encodeURI ()替换的。同样地，decodeURIComponent ()能够解码使用 encodeURIComponent ()编码

的所有字符，即它可以解码任何特殊字符的编码=来看下面的例子：

var uri = uhttp%3A%2F%2Fwww.wrox.com%2Fillegal%20value-htni%23sta:rf 7

//http%3A%2F%2BVww.wrox.com%2Fillegal value.htm%23start alerc(decodeURI{uri));

"<http://www.wrox.com/illegal> value.htm#start alert(decodeURIComponent(uri));

GlobalObjectURJDecodingExample01.htm

这里，变墅uri.包含着一个由encodeUR I Component ()编码的字符申。在第一次调用decodeURI () 输出的结果中，只有％20被替换成了空格。而在第一.次调用decodeURIComponent(＞输出的结果中， 所有特殊字符的编码都被替换成了原来的宇符，得到了 •个未经转义的字符串(但这个字符串并不是一 个有效的URt )。

URI 方法 encodeURl ()、encodeURIComponent (＞、decodeURI。和 decode-URIComponent (＞ 用于替代已经枝ECMA-262 第 3 版废弃的 escape (＞ 和 unescape () 方法。URI方法能够编码所有Unicode字符，而原来的方法只能正确地编码ASCII字符。 因此在开发实践中,特别是在产品级的代码中,一定要使用URI方法，不要使用escape() 和 unescape ()方法。

\2. eval()方法

现在，我们介绍最后一个一大概也是整个ECMAScript语言中最强大的一个方法:eval () oeval () 方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript) 字符申。看下而的例子：

eval('alert{'hi')•)；

这行代码的作用等价于下面这行代码： alert("hi");

当解析器发现代码中调用eval()方法时，它会将传人的参数当作实际的ECMAScript语句来解析，

然后把执行结果插人到原位置=通过eval (＞执行的代码被认为是包含该次调用的执行环境的一部分，

因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval (＞执行的代R可以引用在包

含环境中定义的变量，举个例子：

var msg = "hello world"；

eval ("alert (msg) ■) ?    // "hello world1*

可见，变错msg是在evalO调用的环境之外定义的,但其中调用的alert {)仍然能够显示•hello world%这是因为k面第二行代码敁终被替换成了一行真正的代码。同样地，我们也可以在evalO 调用中定义一个函数，然后再在该调用的外部代码中引用这个函数：

eval (■ function sayHi {) { alert {'hi1) ； } ”； sayHi()；

显然，函数sayHi ()是在eval G内部定义的。但由于对eval (＞的调用最终会被替换成定义函数 的实际代码，因此可以在下一行调用sayHi ()。对于变tt也一样：

eval("var msg = 'hello world *;"); alert(msg);    //"hello world"

在eval U中创建的任何变tf或函数都不会被提升，因为在解析代码的时候，它们被包含在一1"字 符串中；它们只在eval ()执行的时候创建。

严格模式下，在外部访问不到eval ()中创建的任何变量或函数，因此前面两个例子都会导致错误。 同样，在严格模式下，为eval赋值也会导致错误：

"use strict*；

eval = "hi"7 //causes error

能够解释代码字W的能力非大，但也非常危险。因此在使用eval ()时必

须极为谨後，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输 入成胁你的站点或应用租序安全的代码(即所谓的代码注入)。

\3. Global对象的属性

Global对象还包含一些属性，其中--部分属性已经在本书前面介绍过了。例如，特殊的值 undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类塑的构造函数，像 Object和Function,也都是Global对象的属性。下表列出了 Global对象的所有属性。

| 属    性  | 说    明         | 属    性       | 说    明                |
| --------- | ---------------- | -------------- | ----------------------- |
| undefined | 特殊值undefined  | Date           | 构造涵数Date            |
| NaN       | 特殊值NaN        | RegExp         | 构造函数RegExp          |
| infinity  | 特殊值infinity   | Error          | 构造闲数Error           |
| Object    | 构造涵数Object   | EvalError      | 构造函数EvalError       |
| Array     | 构选函数Array    | RangeError     | 构造函数RangeError      |
| Function  | 构造兩数Function | ReferenceError | 构造函    f erenceError |
| Boolean   | 构造函数Boolean  | SyntaxError    | 构造函数SyntaxError     |
| String    | 构造函数String   | TypeError      | 构造函数TypeError       |
| Number    | 构造兩数Number   | URIError       | 构造函数URIError        |

ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会 导致错误。

\4. window 对象

ECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为 window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window 对象的属性。来看下面的例子。

var color = "red1*;

function sayColor(){

alert(window.color);

} *

window.sayColor() ； /"red

GlobalObjectWindowExampleOLhtm

这里定义了一个名为color的全局变董和•-个名为sayColor ()的全局函数。在sayColor ()内部， 我们通过window.color来访问color变景，以说明全局變量是window对象的属性。然后，又使用 window. sayColor ()来亢接通过window对象调用这个函数，结果M戏在了臀吿框中。

JavaScript中的window对象除了扮演ECMAScript规定的Global对象的角色外， 还承担了很多别的任务。第8章在讨论浏览器对象模型时将详细介紹window对象。

另一种取得Global对象的方法是使用以下代码:

var global = function(){ return this;

} 0 ;

以上代码创建了一个立即调用的函数表达式，返回this的值。如前所述，在没有给函数明确携定 this值的情况下(无论是通过将函数添加为对象的方法，还是通过调用call()或apply () ), this 值等于Global对象。而像这样通过简单地返回this来取得Global对象，在任何执行环境下都是可 行的。第7章将深人讨论函数表达式。

5.7.2 Math 对象

ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。与我们在JavaScript直 接编写的计算功能相比，Math对象提供的计算功能执行起来要快得多。Math对象中还提供了辅助完成 这些计算的屈性和方法。

\1. Math对象的属性

Math对象包含的屑性大都是数学计箅中可能会用到的一典特殊值。下表列出了这些属性。

| 属    性       | 说    明                       |
| -------------- | ------------------------------ |
| Math.E         | 自然对数的底数，即常蛍e的值    |
| Math.LNlO      | 10的A然对数                    |
| Math.LN2       | 2的A然对数                     |
| Math.LOG2E     | 以2为底e的对数                 |
| Math.LOGlOE    | 以10为底e的对数                |
| Math.PI        | 71的值                         |
| Math.SQRTl一 2 | 1/2的平方根(即2的平方根的倒数) |
| Math.£fQRT2    | 2的平方根                      |

虽然讨论这®值的含义和用途超出了本书范围，但你确实可以随时便用它们。

2. 和方法

Math对象还包含许多方法，用于辅助完成简单和复杂的数学计算。

其中，mint)和max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多 个数值参数，如下面的例子所示。

var max = Math.max(3, 54, 32, 16}; alert(max)；    //54

var min = Math.min(3, 54, 32, 16}; alert(min)；    //3

MathObjectMinMaxExampleOl. htm

对于3、54、32和16, Math.max()返回54,而Math.min ()返冋3。这两个方法经常用于避免多 余的循环和在if语句中确定一组数的最大值。

要找到数组中的最大或最小值，可以像下面这样使用apply!)方法。

var values = [1, 2, 3, 4, 5, 6, 7, 8]; var max = Math.max.apply(Math, values);

这个技巧的关键是把Math对象作为apply ()的第一个参数，从而正确地设置this值。然后，可 以将任何数组作为第二个参数。

下面来介绍将小数值舍人为整数的几个方法：Math,ceil(｝、Math, floor (｝和Math.round()。 这三个方法分别遵循下列舍人规则：

□    Math.ceil (》执行向上舍入，即它总是将数值向上舍人为最接近的整数；

□    Math.flooH)执行向下舍人，即它总是将数值向下舍入为最接近的整数；

□    Math.round()执行标准舍入，即它总是将数值冈舍五人为最接近的整数(这也是我们在数学课 上学到的舍人规则)。

下面是使用这些方法的示例：

alert(Math.round(25.9)); //26 alert (Math.round(25.5) } ； "26 alert(Math.round(25.1)); //25

alert(Math.floor(25.9)); //25 alert(Math.floor{25.5)); //25 alert(Math.floor(25.1)); //25

MathObjectRoundingExampleOl .him

对于所有介于25和26 (不包括26)之间的数值，Math.ceilU始终返回26,因为它执行的是向 上舍人。Math.round方法只在数值大于等于25.5时返回26;否则返问25。最后，Math.floor() 对所有介于25和26 (不包括26)之间的数值都返冋25。

\4. random ()方法

Math.random()方法返回介于0和1之间一个随机数，不包括0和1。对于某些站点来说，这个方 法非常实用，因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利川 Math.random()从某个整数范围内随机选择--个值。

值：Math, floor (Math, random () * 了能值的总数+第一个可能的值)

公式中用到了 Math.floor ()方法，这是因为Math.random()总返回一^小数值。而用这个小数 值乘以一个整数，然后再加上一个整数，最终结果仍然还是斗小数。举例来说，如果你想选择•-个I 到10之间的数值，可以豫下面这样编每代码：

var nam = Math.floor(Math.random{) * 10 + 1)；

MathObjectRandomExampleQ /.办加

总共有10个可能的值(1到10)，而第一个可能的值是U而如果想要选择一个介于2到10之间的 值，就应该将h面的代砰改成这样：

var mun =? Math, floor (Math.random() * 9 + 2};

MathQbjectRandomExample02. htm

从2数到10要数9个数，因此可能值的总数就是9,而第一个可能的值就是2。多数情况下，其实 都可以通过一个函数来计算可能值的总数和第一个可能的值，例如：

function aelectFrom(lowervalue, uppervalue) { var choices = uppervalue - lowerValue + 1; return Math.floor(Math.random(} * choices + lowerVaiue)；

}

var num - selectFrom(2, 10};

alert (num) ;    //介于2和10之间(包括2和10)的一个数值

MathObjectRandomExample03. hjm

函数selectFrom()接受两个参数：应该返回的最小值和最大值。而用最大值减最小值再加1得到 了可能值的总数，然后它又把这些数值套用到了前面的公式中。这样，通过调用selectFrom(2,-,0) 就口1以得到~个介于2和10之间(包招2和10)的数倚了。利用这个函数，可以方便地从数组中随机 取出一项，例如：

var colors = [*redn f Bgreen", "blue", "yellow*, "black"r ffpurplen z "brown"3; var color = colorstBelectFroin<0# colors. Length-1)]； aLert (color) ； If可能是数组中包念的任何一个字符率

MathObjectRandomExample03 .him

在这个例子中，传递给geiectFromO的第二个参改是数组的长度减1,也就是数组中最后一项的位置：，

5.其他方法

Math对象中还包含其他一些与完成各种简单或复杂计算有关的方法，但详细讨论其中每一个方法 的细节及适用情形超出了本书的范阑。下面我们就给出一个表格，苒中列出了这些没有介绍到的Math 对象的方法。

| 方    法                | 说    明             | 方法              | 说    明           |
| ----------------------- | -------------------- | ----------------- | ------------------ |
| Math.abs                | 返回num的绝对值      | !4ath.asin(jf)    | 返回X的反正弦值    |
| Math, exp (num)         | 返回船th.五的nwn次幕 | Math.atan(x)      | 返间X的反正切值    |
| Math, log (num)         | 返回卯m的自然对数    | Mac'n.atan2 (yzx) | 返回y/x•的反正切值 |
| Math. pow(n urn, power) | 返间nu/n的power次搏  | Math, cos (x)     | 返回x的余弦僚      |
| Math.sqrt               | 返问num的平方根      | Math, sin (x)     | 返回X的正弦值      |
| Math. acos (x)          | 返回X■的反余弦值     | Math.can(x)       | 返回x的正切值      |

虽然ECMA-262规定了这些方法，但不同实现可能会对这些方法采用不同的箅法。毕竞，计算某个 值的正弦、余弦和正切的方式多种多样，也正因为如此，这些方法在不同的实现中可能会有不同的精度。

5.8小结

对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创逮特定的对象， 现简要总结如下：

□引用类型与传统面向对象程序设计中的类相似，但实现不同；

□    Object是一个基础类型，其他所有类型都从Object继承了基本的行为；

□    Array类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；

□    Date类型提供了有关H期和时间的信息，&柄当前日期和时间以及相关的计算功能；

□    RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些髙级的正则表 达式功能。

函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地 方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。

因为有了基本包装类型，所以JavaScript屮的基本类型值可以被当作对象来访问。三种基本包装类 型分别是：Boolean、Number和String。以下是它们共同的特征：

□每个包装类型都映射到同名的基本类型；

□在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据 操作；

□操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。

在所有代码执行之前，作用域中就已经存在两个内置对象:Global和Math。在大多数ECMAScript

实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变 量和函窣都是Global对象的属性。Math对象提供r很多属性和方法，用于辅助完成复杂的数学计算 任务。