ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES



![img](09Effective C++（中文版第3版）_files/09Effective C++082d87482c34809-2.jpg)



Broadview



![img](09Effective C++（中文版第3版）_files/09Effective C++082d87482c34809-3.jpg)



r.- ' i' Pxi 19 ar.r iPj *

[lei e /p    n >kc](http://www.linuxidc.com)



irr广 'ge ti luting



Effective C++ 屮义版，第_2版，

P $业人 I ffiU;起这代 4^ (£j^7»:vC++：'    嬰汄ft以 C♦，从 ini 发 I

作的人rtlJf.这水绝<4必洵阅it的t to!果你不《读过(Effective OO WuK^IIlIx-1 C -疋所小tt.恐怕你枸：思."

一 Steve Schirripa. Coogle 软朽 I •.



“0+和C"什群近15 0内成來.{Effectivec^i 坂反映山这个屮文水 f5iA«hifu严说的K格W小HiScoii对i中费如iU的深钊押解和特殊掌択能力"

—-Gerhard Kreuzer, Siemens AC ' < fV

(£/Mt*C*+> ift两个版本抓U I*令世界 A；数IVWW的l!/t l*-itW I 分 W明:Scon Mcycn 极/A

••义戎£，.义的研穴.描述岀t ¥川以，•■•出H d:确.•••••!效代Pi的行聆iJ.则和h‘Ki•人则 ——也就坫他们儿乎总玷做或个做的坫此‘1«.



4*15共泔织55个准则.喊条准W摘述•个編写出®好的C♦+的7/式网个条放的fUMff II休范例Vi fM T以I.的》抽坫嶄析内样•包坫卜1论资淞竹押和校板< templates 1运 HJ的两个斷氓.为反映出熳代设H考虑，对讲:版论囲做了f泛的修订，包括异》(exceptions). 没il 校八 <design patterns) 4•衫线& • multithreading >

{Effective C++)的 + 驳?5 W:包括:

•二1 2!(的 classes, funciums. templates inhentanve hierarchies，：休今：，h II. 'I (r    -

• —    vtri •槺嘴函轉國9(9 RffiHRmiBmM

. ,, ^

化吸收C++式的各种Ifi人.



![img](09Effective C++（中文版第3版）_files/09Effective C++082d87482c34809-4.jpg)



-汴/J简介

Scott Meyers込令I什界W知名的C+♦软fl什发V i•:之    他足'，钔15 < EfTfctive

C++）系列 < C和rfhv C++, Murr fj^irhiv （?♦♦. £和i-hi*r STT > 的ft ZT. 乂!Z&J功 ，••• ,《, {Effective C++ CD）的没il >!和打乃•也众 Addison-Wesley 的TjpfHV J Softumre Dcivh）pnieitt Serio    .以及 S ^ftuxirc Darh^nienl

1    他也XP: I新公id的仆水芥洵板仪供服务.Mexen J 1993 ：| II Brown人

_J    WWW    他的M址记 iru»uMirjsffw.a»w .



i爭汽简介》侯ttliil W机技术抟鷂的作家.if #» Bif人X7j <i«入浅出MFC>、、衫中1j M 拟>、<STL源码剖析》，< tJHf 15if> fc. iff!众杉d、KHITK:,阶技术 151,.. Mcym所符的"E#Th’PeC>+•系列仗Ul*K教职j儿智人同济人亇.山识火卞 他的个人M址紀 hijjhou.com （屮义策休）和    1 屮义油体）



ffl书分类：程序语言



ISBN 7-121-02909-X



Pcanan I ducsiMm



_ .圓-www dearbook oo« cn



"787121"0290



本书貼有激光防伪标志.凡没有防伪标志者.属盗版囝书 ISBN 7-121-02909-X    定价：58.00元



# Effective C++ 中文版，第三版

Effective C++, Third Edition

［美］Scott Meyers 著

侯捷译

常孑i f出麻 Publishing House of Electronics Industry

北京.BEIJING

内容简介

有人说C++程序员可以分成两类，读过Effective O+的和没读过的。世界顶级C++大师Scott Meyers成名之作的第三版 的确当得起这样的评价。当您读过这本书之后，就获得了迅速提升自己C++功力的一个契机。

在国际上，本书所引起的反响，波及整个计算技术出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，本 书都会位于前三名。作者髙超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇 和仿效。这种奇特的现象，只能解释为人们对这本书衷心的赞美和推崇。

这本书不是读完一遍就可以束之髙阁的快餐读物，也不是用以解决手边问题的参考手册，而是需要您去反复阅读体会 的，Oh■是真正程序员的语言，背后有着精深的思想与无与伦比的表达能力，这使得它具有类似宗教般的魅力。希望这本书 能够帮助您跨越C++的重重险阻，领略髙处才有的壮美风光，做一个成功而快乐的C++程序员。

Authorized translation from the English language edition, entitled Effective C++:55 Specific Ways to Improve Your Programs and Designs, 3rd edition, 0321334876 by Meyers,Scott，published by Pearson Education, Inc, publishing as Addison Wesley Professional, Copyright©2005 Pearson Education, Inc。

All rights reserved. No part of this book maybe reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording or by any information storage retrieval system, without permission from Pearson Education, Inc.

CHINESE SIMPLIFIED language edition published by PEARSON EDUCATION ASIA LTD., and PUBLISHING HOUSE OF ELECTORNICS INDUSTRY Copyright ©2006.

本书简体中文版由电子工业出版社和Pearson Education培生教育出版亚洲有限公司合作出版。未经出版者预先书面许 可，不得以任何方式复制或抄袭本书的任何部分。

本书简体中文版贴有Pearson Education培生教育出版集团激光防伪标签，无标签者不得销售。

版权贸易合同登记号：图字：01»2005-3583

图书在版编目（CIP）数据

Effective C++中文版，第3版/ （美）梅耶（Meyers,S.）著；侯捷译.~北京：电子工业出版社，2006.7

书名原文：Effective C++, Third Edition

ISBN7-121-02909-X

I.E... II.①梅...②侯…III.C语言一程序设计IV.TP312 中国版本图书馆CIP数据核字（2006）第081253号

责任编辑：周筠

印 刷：北京智力达印刷有限公司

出版发行：电子工业出版社

北京市海淀区万寿路173信箱邮编100036

经 销：各地新华书店

开 本：787X980 1/16印张：21 字数：380千字

印 次：2006年7月第1次印刷

定 价：58.00元

凡购买电子工业出版社的图书，如有缺损问题，请向购买书店调换。若书店售缺，请与本社发行部联系联系电话：(010) 68279077o质量投诉请发邮件至zks@phei.com.cn，盗版侵权举报请发邮件至[dbqq@phei.com.ciu](mailto:dbqq@phei.com.ciu)

Effective C++第三版赢得的赞誉

Scott Meyers的《E步cfiwC++》第三版萃取了原本必须历经艰辛才能学到的编程经 验。这本书是一份很棒的资源，我推荐给每一位专业C++程序员。

-Peter Dulimov, ME, Engineer, Ranges and Assessing Unit, NA VSYSCOM, Australia

第三版仍然是"如何将C++各部件以髙效、高凝聚方式结合起来”的最佳书籍。 声称自己是个C++程序员之前，你一定得读过这本书。

-Eric Nagler, Consultant, Instructor, and author of Learning C++

本书第一版被我归类为少数(真的非常少数)在我成长为一个专业软件开发人员的 过程中有重大意义的书籍之一。它很实用又易阅读，却又装载着重要的忠告。 《E步cfipe C++》第三版延续这项传统。C++是个威力十足的编程语言，如果C带 给你足够绞死自己的绳索，C++就是间五金店，挤满了许多准备为你绑绳结的人。 只要精通本书讨论的重点，便可明确增加高效运用C++的能力并减缓压力。

-Jack W. Reeves, Chief Executive Officer, B leading Edge Software Technologies

每一位参与我的开发团队的新手，都有一份功课要做：读这本书。

-Michael Lanzetta, Senior Software Engineer

九年前我读了 (Effective C++》第一版，它立刻成为我最喜爱的一本C++书籍。 我认为第三版对于那些希望以C++进行高效编程的人仍然是必备读物。如果每一位 C++程序员着手写下他们的第一行C++专业代码之前都先读过这本书，我们的世 界会变得更好一些。

-Danny Rabbani, Software Development Engineer

当我还是个在第一线战场上努力搏斗的程序员，尝试怎么做比较好时，偶然机会遇 上了Scott Meyers的《Ej^ecfive C++》第一版。多美好的救星呀！我发现Meyers的忠 告很实际、有用，并且有效，百分之百履行了标题上的承诺。第三版带来在严肃开 发项目中使用C++的最新实用事物，并针对语言的最新发展和特性增加了新的篇 章。我很高兴发现，从一本我原本以为自己已有很好体验的书籍的新版中，仍然学 到一些有趣而新奇的东西。

-Michael Topic, Technical Program Manager

对于想要安全并高效使用C++，或打算从其它OO语言移转到C++阵营的任何人 而言，这一本来自著名C++导师Scott Meyers的书籍，是最可靠的指引。本书以 清晰、简洁、有娱乐效果、见解深刻的方式，表现出极具价值的信息。

-Siddhartha Karan Singh, Software Developer

于一般性入门教科书之外，这应该是第二本任何C++开发者应该阅读的书籍了。 它超越了 C++语言“如何做”以及“是什么”的范畴，直指C++的“为什么”。 它帮助我对C++的理解层次从语法晋升至编程哲学。

-Timothy Knox, Software Developer

这是一本C++经典书籍的惊人更新版本。Meyers在这一版本中涵盖了许多新领域， 每一位认真的C++程序员都应该拥有这一新版。

-Jejfrey Somers，Game Programmer

Effective C++》第三版涵盖编写程序时该做的事，并很好地解释了为什么那些事 情重要。把它视为编写C++程序的最佳训练吧。

-Jeff Scherpelz, Software Development Engineer

当C++拥抱改变，Scott Meyers的《E步冰peC++》第三版也昂扬出发，对语言保持 完美的密集跟踪。C++领域有许多优秀的导入性书籍，而“第二本书”应该站在它 们的肩膀上，你手上这本就是。跟随Scott指出的方向，让自己也昂扬高飞吧！

-Leor Zolman, C++ Trainer and Pundit, BD Software

这是一本必须拥有的书籍，对C++老手和新手都是。读过本书之后，它一定不会 在你的书架上吃灰尘，因为你会持续地参考它、引用它。

-Sam Lee, Software Developer

阅读本书，一步一步地运用55个可轻松阅读并各自描述某项技术或某个告诫的条 款，普通的C++程序员也可以摇身一变成为专家级C++程序员。

-Jeffrey D. Oldham, Ph.D” Software Engineer, Google

Scott Meyers的《E#ectoeC++》各个版本长期受到C++编程新手和老手的需要。这 本新版并入近十年来的C++发展价值，是截至目前最高密度的书籍，作者不仅描述 语言上的问题，也提出毫不模糊又容易奉行的忠告，用以避免陷阱并写出高效的 C++。我真希望每一位C++程序员都能读过它。

-Philipp K. Janert, Ph.D” Software Development Manager

对那些使用C++的时间长得足以被这一丰富语言内的潜伏圈套绊倒的开发人员而 言，《E#eCh‘i；e C++》的每个版本都是必须拥有的书籍。第三版大面积补充了新世 代的语言和程序库特性，以及为运用那些特性而进化的编程风格。Scott极具魅力的 写作风格使其所整理的准则容易被消化吸收，协助你成为高效的C++开发者。

-David Smallberg, Instructor, DevelopMentor; Lecturer, Computer Science, UCLA

《Effective C++》己针对21世纪的C++实务做出全面更新，因此得以继续声称其 为所有C++从业人员的首选“第二本书”。

-Matthew Wilson, Ph.D” author of Imperfect C++

°鸦凼桊I与xnun尝祕孩II摧曹，本组asns它opWmunqnSf每音(raoo-3cnxnun)^^xnun



SJQ人8 ㈧ 1JOOS



suSiseg pue stuejBoJd jno人 9AOjduj| 0} sXe/v\ oijpsds gg



uo!!!p彐 pjiqi ++0 3八!p即彐



UUOO'OpiXnUll'MMM



Brian W. Kemighan, Consulting Editor

Matthew H. Austem, Generic Programming and the STL: Using and Extending the C++ Standard Template Library David R. Butenhof, Programming with POSIX⑧ Threads    .

Brent Callaghan, NFS Illustrated

Tom Cargill, C++ Programming Style

William R. Cheswick/Steven M. Bellovin/Aviel D. Rubin, Firewalls and Internet Security, Second Edition: Repelling the Wf/y Hacker

David A. Curry, UNIX9 System Security: A Guide for Users and System Administrators

Stephen C. Dewhurst, C++ Gotchas: Avoiding Common Problems in Coding and Design

Dan Farmer/Wietse Venema, Forensic Discovery

Erich Gamma/Richard Helm/Ralph Johnson/John Vlissides, Design Patterns: Elements of Reusable Object-Oriented Software

Erich Gamma / Richard Helm/Ralph Johnson/John Vlissides, Design Patterns CD: Elements of Reusable Object-Oriented Software

Peter Haggar, Practical Java1" Programming Language Guide

David R. Hanson, C Interfaces and Implementations: Techniques for Creating Reusable Software

Mark Harrison / Michael McLennan, Effective Tcl/Tk Programming: Writing Better Programs with Tel and Tk Michi Henning/Steve Vinoski, Advanced CORBA^ Programming with C++

Brian W. Kemighan/Rob Pike, The Practice of Programming

S. Keshav, An Engineering Approach to Computer Networking: ATM Networks, the Internet, and the Telq)hone Network John Lakos, Large-Scale C++ Software Design

Scott Meyers, Effective C++ CD: 85 Specific Ways to Improve Your Programs and Designs

Scott Meyers, Effective C++, Third Edition: 55 Specific Ways to Improve Your Programs and Designs

Scott Meyers, More Effective C++; 35 New Ways to Improve Your Programs and Designs

Scott Meyers, Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library

Robert B. Murray; C++ Strategies and Tactics

David R, Musser/Gillmer J. Derge/Atul Saini, STL Tutorial and Reference Guide, Second Edition:

C++ Programming with the Standard Template Library

John K. Ousterhout, Tel and the Tk Toolkit

Craig Partridge, Gigabit Networking

Radia Perlman, Interconnections, Second Edition: Bridges, Routers, Switches, and Internetworking Protocols

Stephen A. Rago, UNIX* System V Network Programming

Eric S. Raymond, The Art of UNIX Programming

Marc J. Rochkind, Advanced UNIX Programming, Second Edition

Curt Schimmel, UNIX® Systems for Modem Architectures: Symmetric Multiprocessing and Caching for Kernel Programmers W. Richard Stevens, TCP/IP Illustrated, Volume 1: The Protocols

W. Richard Stevens, TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX*

Domain Protocols

W. Richard Stevens/Bill Fenner / Andrew M, Rudoff, UNIX Network Programming Volume 1, Third Edition: The Sockets Networking API

W. Richard Stevens/Stephen A. Rago, Advanced Programming in the UNIX* Environment, Second Edition W. Richard Stevens/Gary R. Wright, TCP/IP Illustrated Volumes 1-3 Boxed Set John Viega/Gary McGraw, Building Secure Software: How to Avoid Security Problems the Right Way Gary R. Wright/W. Richard Stevens, TCP/IP Illustrated, Volume 2: The Implementation Ruixi Yuan/W. Timothy Strayer, Virtual Private Networks: Technologies and Solutions

VWt [www.awprofeMional.com/Mries/professionalcomputing](http://www.awprofeMional.com/Mries/professionalcomputing) for more information about these titles.

Effective C++ e

### 中文版

改善程序与设计的55个具体做法 55 Specific Ways to Improve Your Programs and Designs

［美］Scott Meyers 著 侯捷译

AIDX luoouXjBS 邱qjy smuojpd -

'uoi^uiqutoj AjdA o ui^oj    ptw Mops!M

9uiop qyoM qonui oq pjnoM Sujipou uioqM inoqjTM 'Aoubn ioj

UJOOOpiXnUll'MMM

And in memory of Persephone 1995-2004



![img](09Effective C++（中文版第3版）_files/09Effective C++082d87482c34809-6.jpg)



#### 译序

按孙中山先生的说法，这个世界依聪明才智的先天高下得三种人：先知先觉得 发明家，后知后觉得宣传家，不知不觉得实践家。三者之中发明家最少最稀珍，最 具创造力。正是匠心独具的发明家创造了这个花花绿绿的计算机世界。

以文字、图书、授课形式来讲解、宣扬、引导技术的人，一般被视为宣传家而 非发明家。然而，有一类最高等级的技术作家，不但能将精辟独到的见解诉诸文字， 又能创造新的教学形式，引领风骚，对技术的影响和对产业的贡献不亚于技术或开 发工具的创造者。这种人当之发明家亦无愧矣。

Scott Meyers就是这一等级的技术作家!

自从1991年出版《£#ech'ue C++》之后，Meyers声名大噪。1996年的《More Effective C++》和 1997 年的(Effective C++》2/e 以及 2001 年的《Effective STL》让 他更上高楼。Meyers擅长探索编程语言的极限，穷尽其理，再以一支生花妙笔将复 杂的探索过程和前因后果写成环环相扣故事性甚强的文字。他的幽默文风也让读者 在高张力的技术学习过程中犹能享受“阅读的乐趣"——这是我对技术作家的最髙 礼赞。

以条款(items)传递专家经验，这种写作形式是否为Meyers首创我不确定， 但的确是他造成了这种形式的计算机书籍写作风潮。影响所及，《Exceptional C++》、《More Exceptional C++》、《C++ Gotchas^ > 《C++ Coding Standards》、

《E价cteeCOM》、lEffective'javaJ、《Practical Java》纷纷在书名或形式上“向 大师致敬”。

睽违8年之后(Effective C++》第三版面世了。我很开心继第二版再次受邀翻 译。Meyers在自序中对新版已有介绍，此处不待赘言。在此我适度修改第二版部分 译序，援引于下，协助读者迅速认识本书定位。

Effective C++中文版，第三版

C++是一个难学易用的语言！

C++的难学，不仅在其广博的语法，以及语法背后的语义，以及语义背后的深 层思维，以及深层思维背后的对象模型；C++的难学还在于它提供了四种不同而又 相辅相成的编程范型(programming paradigms) : procedural-based, object-based, object-oriented, generics。

世上没有白吃的午餐！又要有效率，又要有弹性，又要前瞻望远，又要回溯相 容，又要治大国，又要烹小鲜，学习起来当然就不可能太简单。在庞大复杂的机制 下，万千使用者前仆后继的动力是：一旦学成，妙用无穷。

C++相关书籍车载斗量，如天上繁星，如过江之鲫。广博如四库全书者有之(The C++ Programming Language^ C++ Primer> Thinking in C++)，深奧如重山复水者 有之(The Annotated C++ Reference Manual, Inside the C++ Object ModeZ)，细说历 史者有之(The Design and Euo^fion o/C++, RwmiTiflfioMs om C++)，独沾一味者有 之 CPolymorphism in C++)，独树一帜者有之(Design Patterns, Large Scale C++ Software Design, C++ FAQs),另辟躁径者有之(Generic Programming and the STL), 程序库大全有之(The C++ Standard Library)，专家经验之累积亦有之C++, Afore £#ectoe C++)。这其中“专家经验之累积”对已具C++相当基础的程序员 有着立竿见影的帮助，其特色是轻薄短小，高密度纳入作者浸淫C++/OOP多年的 广泛经验。它们不但开展读者的视野，也为读者提供各种C++/OOP常见问题的解 决模型。某些主题虽然在百科型C++语言书中也可能提过，但此类书籍以深度探 索的方式让我们了解问题背后的成因、最佳解法，以及其他可能的牵扯，这些都是 经验的累积和心血的结晶，十分珍贵。

《£#echieC++》就是这样一本轻薄短小高密度的“专家经验累积”。

本中译版与英文版页页对译，保留索引，偶尔加上小量译注；愿能提供您一个 愉快的学习。千里之行始于足下，祝愿您从声名崇隆的本书展开一段新里程。同时, 我也向您推荐本书之兄弟《More Ej^ectoe C++》，那是Meyers的另一本同样盛名 远播的书籍。

侯捷2006/02/15于台湾新竹 [jjhou@jjhou.com](mailto:jjhou@jjhou.com)

hflp7Avww.jjhou.com （繁体）<http://jjhou.csdnjiet> （简体）

Effective C++中文版，第三版

英中简繁术语对照

这里列出本书出现之编程术语的英中对照，本中文版在海峡两岸同步发行，因 此我也列出本书简繁两版的术语对照，方便某些读者从中一窥两岸计算机用语。

表中带有*者表示本书对该词条大多直接采用英文术语。中英术语的选择系 由以下众多考虑中取其平衡：

■业界和学界习惯。即便是学生读者，终也要离开学校进入职场；熟悉业界和学 界的习惯用语（许多为英文），避免二次转换，很有必要。

■这是一本中文版，需顾及中文阅读的感觉和顺畅性。过多保留英文术语会造成 版面的破砕与杂乱！然若适度保留英文术语，可避免某些望之不似术语的中文 出现于字里行间造成阅读的困扰和停顿，有助于流畅的思考和留下深刻印象。

■凡涉及C++语言关键字之相关术语皆保留。例如class, struct, template, public, private, protected, static, inline, const, namespace ......

■以上术语可能衍生复合术语，例如与class相关的复合米语有base class, derived

class, super class, subclass, class template ......此类复合木语如果不长i尽皆保留

原文；若太长则视情况另作处理（也许中英并陈，也许赋予特殊字体）。

■凡计算机科学所称之数据结构名称，塚皆保留。例如stack, queue, tree, hashtable， map, set, deque, list, vector, array ......偶尔将 array 译为数组》

■某些流通但不被我认为足够理想之中译词，保留原文不译。例如reference，

■某些英文术语被我刻意以特殊字体表现并保留，例如pass fc/reference、pass by

value' copy构造函数、ass/gMweMt操炸符、placementnew»

■少量术语为顾及词性平衡，时而采用中文（如指针、类型）时而采用英文（如 pointer、type） •,

■索引之于科技书籍非常重要》本书与英文版页页对译，因此原封不动保留所有 英文索引。

过去以来我~直不甚满意object和type两个术语的中译词：“对象”和“类型”， 认为它们缺乏术语突出性（前者正确性甚至有待商榷），却又频繁出现影响阅读， 因此常在我的著作或译作中保留其英文词或偶尔采用繁体版术语：“物件"和“型 别”。但现在我想，既然大家己经很习惯这两个中文术语，也许我只是杞人忧天。 因此本书采用大陆读者普遍习惯的译法。不过我仍要提醒您，"object”在Object Oriented技术中的真正意义是“物体、物件"而非“对象、目标”。

Effective C++中文版，第三版

以下带有*者表示本书对该词条采英文词，不译为中文

| 英文术语            | 简体版译词            | 繁体版译词     |
| ------------------- | --------------------- | -------------- |
| abstract            | 抽象的                | 抽象的         |
| abstraction         | 抽象性、抽象件        | 抽象性、抽象件 |
| access              | 访问                  | 存取、取用     |
| access level        | 访问级别              | 存取級別       |
| access function     | 访问函数              | 存取函式       |
| adapter             | 适配器                | 配接器         |
| address             | 地址                  | 地址           |
| address-of operator | 取地址操作符          | 取址運算子     |
| aggregation         | 聚合                  | 聚合           |
| algorithm           | 算法                  | 演算法         |
| allocate            | 分配                  | 配置           |
| allocator           | 分配器                | 配置器         |
| application         | 应用程序              | 1應用程式      |
| architecture        | 体系结构              | 體系結構       |
| argument            | 实参                  | 引數           |
| * array             | 数组                  | 陣列           |
| arrow operator      | 箭头操作符            | 箭頭運算子     |
| assembly language   | 汇编语言              | 組合語言       |
| *assert(-ion)       | 断言                  | 隊T旨"         |
| assign(-ment)       | 赋值                  | 賦値           |
| assignment operator | 赋值操作符            | 賦値運算子     |
| *base class         | 基类                  | 基礎類別       |
| *base type          | 基类型                | 基礎型別       |
| binary search       | 二分査找              | 二分捜尋       |
| ★binary tree        | 二叉树                | 二元樹         |
| binary operator     | 二元操作符            | 二元運算子     |
| binding             | 绑定                  | 綁定、繫結     |
| ★bit                | 位                    | 位元           |
| ★bitwise            | （以bit为单元逐一……） |                |
| block               | 区块                  | 區塊           |
| boolean             | 布尔值                | 布林値         |
| breakpoint          | 断点                  | 中斷點         |
| build               | 建罝                  | 建置           |
| build-in            | 内置                  | 內建           |
| bus                 | 总线                  | 匯流排         |
| ★byte               | 字节                  | 位元組         |
| cache               | 髙速缓存（区）        | 快取（區）     |
| call                | 调用                  | 呼叫           |
| callback            | 回调                  | 回呼           |
| call operator       | can操作符             | ca/Z運算子     |

Effective C++中文版，第三版

| 英文术语        | 简体版译词                  | 繁体版译词      |
| --------------- | --------------------------- | --------------- |
| character       | 字符                        | 字元            |
| * chi Id class  | 子类                        | 子類別          |
| *c!ass          | 类                          | 類別            |
| ★class template | 类模板                      | 類別模板        |
| client          | 客户                        | 客戶            |
| code            | 代码                        | 程式碼          |
| compatible      | 兼容                        | 相容            |
| compile time    | 编译期                      | 編譯期          |
| compiler        | 编译器                      | 編譯器          |
| component       | 组件                        | 組件            |
| composition     | 复合                        | 複合            |
| concrete        | 具象的                      | 具象的          |
| concurrent      | 并发                        | 並行            |
| configuration   | 配置                        | 組態            |
| connection      | 连接                        | 連接，連線      |
| constraint      | 约束（条件）                | 約束（條件）    |
| construct       | 构件                        | 構件            |
| container       | 容器                        | 容器            |
| *const          | （C++关键字，代表constant） |                 |
| constant        | 常量                        | 常數            |
| constructor     | 构造函数                    | 建構式          |
| ★copy （动词）  | 拷贝                        | 拷貝、複製      |
| copy （名词）   | fi件、副本                  | 複件、副本      |
| create          | 创建                        | 產生、建立'生成 |
| custom          | 定制                        | 訂制、自定      |
| data            | 数据                        | 資料            |
| database        | 数据库                      | 資料庫          |
| data member     | 成员变贵                    | 成員變數        |
| data structure  | 数据结构                    | 資料結構        |
| debug           | 调试                        | 關              |
| debugger        | 调试器                      | 除錯器          |
| declaration     | 声明式                      | 宣吿式          |
| default         | 缺省                        | 預設            |
| definition      | 定义式                      | 定義式          |
| delegate        | 委托                        | 委託            |
| dereference     | 提领（解参考）              | 提領            |
| * derived class | 派生类                      | 衍生類別        |
| design pattern  | 设计模式                    | 設計範式        |
| destroy         | 销毁                        | 銷毀            |
| destructor      | 析构函数                    | 解構式          |
| directive       | 指示符                      | 指令            |
| document        | 文档                        | 文件            |
| dynamic binding | 动态绑定                    | 動態綁定        |

E加:toe C++中文阪第三版

xii

| 英文术语                 | 简体版译词           | 繁体版译词           |
| ------------------------ | -------------------- | -------------------- |
| entity                   | 物体                 | 物體                 |
| encapsulation            | 封装                 | 封裝                 |
| *enum(-eration)          | 枚举                 | 列奉                 |
| equality                 | 相等                 | 相等                 |
| equivalence              | 等价                 | 等價                 |
| evaluate                 | 核定、核算           | 核定、核算           |
| exception                | 异常                 | 異常                 |
| explicit                 | 显式                 | 顯式、明白的         |
| expression               | 表达式               | 算式                 |
| file                     | 文件                 | 檔案                 |
| framework                | 框架                 | 框架                 |
| full specialization      | 全特化               | 全特化               |
| function                 | 函数                 | 函式                 |
| function object          | 函数对象             | 函式物件             |
| * function template      | 函数模板             | 函式模板             |
| generic                  | 泛型、泛化、一般化   | 泛型、泛化、一般化   |
| * getter (相对于 setter) | 取值函数             | 取値函式             |
| ♦global                  | 全局的               | 全域的               |
| * handle                 | 句柄                 | 識別號、權柄         |
| ★handler                 | 处理函数             | 處理函式             |
| *hash table              | 哈希表、散列表       | 雜湊表               |
| header (file)            | 头文件               | 表頭檔               |
| ★heap                    | 堆                   | 堆積                 |
| hierarchy                | 继承体系（层次结构） | 組承體系（階層體系） |
| identifier               | 标识符               | 識別字、識別符號     |
| implement(-ation)        | 实现                 | 實作                 |
| implicit                 | 隐喻的、暗自的、隐式 | 隱喻的、暗自的、隱式 |
| information              | 信息                 | 資訊                 |
| inheritance              | 继承                 | 繼承                 |
| ★inline                  | 内联                 | 行內                 |
| initialization list      | 初值列               | 初値列               |
| initialize               | 初始化               | 初始化               |
| instance                 | 实体                 | 實體                 |
| instantiate              | 具现化、实体化       | 具現化、實體化       |
| interface                | 接口                 | 介面                 |
| Internet                 | 互联网               | 網際網路             |
| interpreter              | 解释器               | 直譯器               |
| invariants               | 恒常性               | 恒常性               |
| invoke                   | 调用                 | 喚起                 |
| iterator                 | 迭代器               | 迭代器               |
| library                  | 程序库               | 程式庫               |
| linker                   | 连接器               | 連結器               |
| literal                  | 字面常最             | 字面常數             |

Effective C++中文版，第三版

| 英文术语               | 简体版译词                        | 繁体版译词               |
| ---------------------- | --------------------------------- | ------------------------ |
| ★list                  | 链表                              | 串列                     |
| load                   | 装载                              | 載入                     |
| ★ local                | 局部的                            | 區域的                   |
| lock                   | 机锁                              | 機鎖                     |
| loop                   | 循环                              | 迴圈                     |
| lvalue                 | 左值                              | 左値                     |
| macro                  | 宏                                | 巨集                     |
| member                 | 成员                              | 成員                     |
| member function        | 成员函数                          | 成員函式                 |
| memory                 | 内存                              | 記憶體                   |
| memory leak            | 内存泄漏                          | 記億體洩漏               |
| meta-                  | 元-                               | 超                       |
| * meta-programming     | 元编程                            | 超編程                   |
| modeling               | 槊模                              |                          |
| module                 | 模块                              | 模組                     |
| modifier               | 修饰符                            | 飾詞                     |
| multi-tasking          | 多任务                            | 多工                     |
| * namespace            | 命名空间                          | 命名空間                 |
| native                 | 固有的                            | 原生的                   |
| nested                 | 嵌套                              | 嵌套、巢狀               |
| object                 | 对象                              | 物件                     |
| object based           | 基于对象的                        | 植基於物件、以物件爲基礎 |
| object model           | 对象模型                          | 物件模型                 |
| object oriented        | 面向对象                          | 物件導向                 |
| operand                | 操作数                            | 運算元                   |
| operating system       | 操作系统                          | 作業系統                 |
| operator               | 操作符                            | 運算子                   |
| overflow               | 溢出                              | 上限溢位                 |
| overhead               | 额外开销                          | 額外開銷                 |
| overload               | 重载                              | 重載                     |
| override               | 覆写                              | 覆寫                     |
| package                | 包                                | 套件                     |
| parallel               | 并行                              | 平行                     |
| parameter              | 参数、形参                        | 參數                     |
| * parent class         | 父类                              | 父删                     |
| parse                  | 解析                              | 解析                     |
| partial specialization | 偏特化                            | 偏特化                   |
| * pass by reference    | 按址传递                          | 傳址                     |
| ★pass by value         | 按值传递                          | 傳値                     |
| pattern                | 模式                              | 範式                     |
| * placement delete     | （某种特殊形式的delete operator） |                          |
| * placement new        | （某种特殊形式的new operator）    |                          |
| pointer                | 指针                              |                          |

Effective C++中文版，第三版

| 英文术语                  | 简体版译词         | 繁体版译词         |
| ------------------------- | ------------------ | ------------------ |
| polymorphism              | 多态               | 多型               |
| preprocessor              | 预处理器           | 前處理器           |
| print                     | 打印               | 列印               |
| printer                   | 打印机             | 印表機             |
| process                   | 进程               | 行程               |
| program                   | 程序               | 程式               |
| programmer                | 程序员             | 程式員             |
| programming               | 编程               | 編程               |
| project                   | 项目               | 專案               |
| pseudo code               | 伪码               | 觀                 |
| quality                   | 质量               | 品質               |
| *queue                    | 队列               | 佇列               |
| raw                       | 原始的、未经处理的 | 原始的、未經處理的 |
| recursive                 | 递归               | 遞迴               |
| refer to                  | 指涉、指称、指向   | 指涉、指稱、指向   |
| * reference               | 引用               | 參考、引用         |
| regular expression        | 正则表达式         | 正則算式           |
| resolve                   | 解析               | 決議               |
| return                    | 返回               | 回返、傳回         |
| return type               | 返回类型           | 回返型別           |
| return value              | 返回值             | 回返値             |
| runtime                   | 运行期             | 執行期             |
| rvalue                    | 右值               | 右値               |
| save                      | 存储               | 儲存               |
| schedule                  | 调度               | S嘏                |
| scheduler                 | 调度器             | 有哨器             |
| scope                     | 作用域             | 作用域             |
| search                    | 査找               | 搜尋               |
| semantics                 | 语义               | 語意               |
| ★setter （相对于 getter） | 设值函数           | 設値函式           |
| signature                 | 签名（式）         | 簽名（式）         |
| smart pointer             | 智能指针           | 智慧型指標         |
| specialization            | 特化               | 特化               |
| source                    | 源码               | 源碼               |
| * stack                   | 栈                 | 堆叠               |
| standard library          | 标准程序库         | 標準程式庫         |
| statement                 | 语句               | 述句               |
| * static                  | 静态的             | 靜態的             |
| string                    | 字符串             | 字串               |
| ♦subtype                  | 子类型             | 子型別             |
| support                   | 支持               | 支援               |
| ★template                 | 模板               | 範本               |
| temporary object          | 临时对象           | 暫時物件           |

Effective C++中文版，第三版

| 英文术语         | 简体版译词   | 繁体版译词   |
| ---------------- | ------------ | ------------ |
| text             | 文本         | 文字         |
| thread           | 线程         | 緒程         |
| thread safe      | 多线程安全   | 多緒安全     |
| throw            | 抛、掷       | 拋、擲       |
| token            | 语汇单元     | 語彙單元     |
| type             | 类型         | 型別         |
| unary function   | 单参函数     | 一元函式     |
| underflow        | 下溢         | 下限溢位     |
| unqualified      | 未经资格修饰 | 未經資格修飾 |
| user             | 用户         | 用戶         |
| user interface   | 用户界面     | 用戶介面     |
| * value          | 值、数值     | 値、數値     |
| variable         | 变景         | 變數         |
| ★vector          | 矢量         | 向量         |
| virtual function | virtual 函数 | virtual 函式 |
| virtual machine  | 虚拟机       | 虛擬機器     |

Effective C++中文版，第三版



#### 序言

Preface

1991年我写下《E#ectii;e C++》第一版。1997年撰写第二版时我更新了许多重 要内容，但为了不让熟悉第一版的读者感到困惑，我竭尽所能保留原始结构：原先 50个条款中的48个标题基本没变。如果把书籍视为一栋房屋，第二版只是更换地 毯灯饰，重新粉刷一遍而已。

到了第三版，修缮工作进一步深入壁骨墙筋(好几次我甚至希望能够翻新地 基)。1991年起C++世界经历了巨大变革，而本书目标——在一本小而有趣的书 中确认最重要的一些C++编程准则——却己不再能够由15年前建立的那些条款体 现出来。“C++程序员拥有C背景”这句话在1991年是个合理假设，如今C++程 序员却很可能来自Java或C#阵营。继承(inheritance)和面向对象编程 (object-orientedprogramming)在1991年对大多数程序员都很新鲜，如今程序员已 经建立良好概念，异常(exceptions)、模板(templates)和泛型编程(generic programming)才是需要更多引导的领域。1991年没人听过所谓设计模式(design patterns)，如今少了它很难讨论软件系统。1991年C++正式标准才刚要上路，如

今C++标准规范已经8岁，新版规范蓄势待发。

为了对付这些改变，我把所有条款抹得一干二净，然后问自己“2005年什么是 对C++程序员最重要的忠告？ ”答案便是第三版中的这些条款。本书有两个新章， —是资源管理(resource management), 一个是模板编程(programming with templates)。实际上template (模板)这东西遍布全书，因为它们几乎影响了 C++的 每个角落。本书新素材还包括在exceptions (异常)概念下编程、套用设计模式、

Effective C++中文版，第三版

以及运用新的TRI程序库设施(TR1于条款54描述)。本书也告诉大家在单线程 系统(single-threaded systems)中运作良好但可能不适用于多线程系统(multithreaded systems)的某些技术和做法。本书半数以上内容是新的。在此同时第二版大部分基 础信息仍然很重要，所以我找出一个保留它们的办法：你可以在附录B找到第二、 第三两版的条款对应表。

我努力让本书达到我所能够达到的最佳状态，但这并不表示它已臻完美。如果 你认为某些条款不适合作为一般性忠告，或你有更好的办法完成本书所谈的某件工 作，或书中某些技术讨论不够清楚不够完全，甚或有所误导，请告诉我。如果你找 出任何错误——技术上的、文法上的、排版印刷上的，不论哪一种一也请告诉我。 我很乐意将第一位提出问题并吸引我注意的朋友加入下次印刷的致谢名单中。

即使本书条款个数扩充为55,这一整组编程准则还谈不上完备。然而毕竟整理 出优良准则——几乎任何时间适用于任何应用程序的准则——比想象中困难得多。 如果你有其他编程准则的想法或建议，我将乐以与闻。

我手上维护本书第一刷以来的变化清单，其中包括错误修订、进一步说明和技 术更新。这份清单放在网址为 <http://aristeia.com/BookErrata/ec++3e-errata.html> 的 ''Effective C++ Errata"网页上。如果你希望在这份清单更新时获得通知，请加入我 的邮件列表。这份列表用来发布消息给可能对我的专业工作感兴趣的人士，详情请 见 [http://aristeia.com/MailingList/](http://aristeia.com/MailingList/%e3%80%82)[。](http://aristeia.com/MailingList/%e3%80%82)

Scott Douglas Meyers    Stafford.Oregon

<http://aristeia.com/>    April 2005

Effective C++中文版，第三版

#### 致谢

Acknowledge

C++》已经面世15年了，我开始学习C++则是在书写此书的前5 年。也就是说项目”己经发展两个年代了。此期间我得益于数百(数 千？)人的深刻知识、对我的建议与修正，以及偶发的一些目瞪口呆的事绩。这些 人帮助我更加完善《£#ecHveC++》，我要对他们全体表示感谢。

我己经放弃追踪“在哪儿学到什么”的历史，但永远记得有个公众信息来源不 断带给我帮助：Usenet C++ newsgroups,特别是 comp.lang.c++.moderated 和 COmp.std.C++。本书许多——也许是大多数——条款得益于这些讨论群所突出的若 干技术想法和后续调查与诊疗。

关于第三版新内容，Steve Dewhurst和我一起讨论了最初的条款名单。条款11 中关于“藉由copy-and-swap实现operator=”的构想来自Herb Sutter在此主题的 作品，像是《ExcepHonflZ C++》(Addison-Wesley, 2000)条款 13。RAII (见条款 13)源自 Bjame Stroustrup 的《The C++ Programming Langwage》(Addison-Wesley， 2000)。条款17背后的想法来自Boost shared_j)tr网页上的“Best Practices”节 区([http://boost.OTg/libs/smart_ptr/shared_ptr.htm#BestPractices)](http://boost.OTg/libs/smart_ptr/shared_ptr.htm%23BestPractices)%ef%bc%8c%e5%8f%88%e5%be%97%e5%88%b0)[，又得到](http://boost.OTg/libs/smart_ptr/shared_ptr.htm%23BestPractices)%ef%bc%8c%e5%8f%88%e5%be%97%e5%88%b0) Herb Sutter 的《More Exceptional C++》(Addison-Wesley, 2002)条款 21 的琢磨。条款 29 强 烈受到Herb Sutter在此主题上的广泛作品的影响，像是《ExcepHcmfl! C++》条款 8〜19，《More Exceptional C++》条款 17-23,以及《Exceptional C++ Styled

(Addison-Wesley, 2005)条款11〜13; David Abrahams帮助我更好地了解三个异常 安全性保证。条款35的NVI手法来自Herb Sutter写于《C/C++ Users Journal))2001 年9月份的"Virtuality”专栏。同一条款中的Temp/ate Mef/iorf和Sfrafegy设计模 式来自《Design Patterns》(Addison-Wesley，1995)，作者是 Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides。条款37所说的NVI使用手法，概念来自 Effective C++中文版，第三版

Hendrik Schober。David Smallberg给了我动机在条款38写出一个定制型set实现 品。条款39提到EBO通常只在多重继承中才可用，这个构想源自David Vandevoorde 和 Nicolai M. Josuttis 合著的《C++reznp/flfes》(Addison-Wesley，2003)。条款 42 中我对typenarne的最初理解来自Greg Comeau主持的nC++ and C FAQ"

([http://www.comeaucomputing.eom/techtalk/#typename)](http://www.comeaucomputing.eom/techtalk/%23typename)%ef%bc%8cLeor)[，Leor](http://www.comeaucomputing.eom/techtalk/%23typename)%ef%bc%8cLeor) Zolman 则帮助我认 知我的最初了解并不正确(是我的错，和Greg无关)。条款46的本质源自于Dan Sak的谈话，"Making New Friends"。条款52末尾的那个想法“如果你声明一版 operator new,你也应该声明其对应的delete伙伴”源自Herb Sutter的《ExcephcnmZ C++ Style》条款22。我从David Abrahams身上更多了解了 Boost的检评过程(条 款55有一份摘要)。

上面所说关于我向谁或从某处学习某一技术，并不必然表示谁或某处就是该技 术的发明人或发表处。

我的笔记还告诉我，我也使用了来自Steve damage, Antoine Trux, Timothy

Knox和Mike Kaelbling的信息，可惜这份笔记没有提到如何以及在哪儿学到什么。

第一版草稿由 Tom Cargill, Glenn Carroll, Tony Davis, Brian Kemighan, Jak

Kirman, Doug Lea, Moises Lejter, Eugene Santos, Jr” John Shewchuk, John Stasko, Bjame Stroustrup, Barbara Tilly 和 Nancy L. Urbano 共同检阅。我收到了一些改善建 议并纳入后来刷次，这些建议来自Nancy L. Urbano, Chris Treichel, David Corbin, Paul Gibson, Steve Vinoski, Tom Cargill, Neil Rhodes, David Bern, Russ Williams, Robert Brazile, Doug Morgan, Uwe Steinmiiller, Mark Somer, Doug Moore, David Smallberg, Seth Meltzer, Oleg Shteynbuk, David Papurt, Tony Hansen, Peter McCluskey, Stefan Kuhlins, David Braunegg, Paul Chisholm, Adam Zell, Clovis Tondo, Mike Kaelbling, Natraj Kini, Lars Nyman, Greg Lutz, Tim Johnson, John Lakos, Roger Scott, Scott Frohman, Alan Rooks, Robert Poor, Eric Nagler, Antoine Trux, Cade Roux, Chandrika Gokul, Randy Mangoba 和 Glenn Teitelbaum。

第二版草稿由以下人士共同检阅：Derek Bosch, Tim Johnson, Brian Kemighan,

Junichi Kimura, Scott Lewandowski, Laura Michaels, David Smallberg, Clovis Tondo,

Chris Van Wyk和Oleg Zabluda。我收到来自以下人士的意见并因此对新刷有所帮

助：Daniel Steinberg, Arunprasad Marathe, Doug Stapp, Robert Hall, Cheryl Ferguson,

Gary Bartlett, Michael Tamm, Kendall Beaman, Eric Nagler, Max Hailperin, Joe

Effective C++中文版，第三版

致谢

Gottman, Richard Weeks, Valentin Bonnard, Jun He, Tim King, Don Maier, Ted Hill, Mark Harrison, Michael Rubenstein, Mark Rodgers, David Goh, Brenton Cooper, Andy Thomas-Cramer, Antoine Trux, John Wait, Brian Sharon, Liam Fitzpatrick, Bemd Mohr, Gary Yee, John O'Hanley, Brady Patterson, Christopher Peterson, Feliks Kluzniak, Isi Dunietz, Christopher Creutzi, Ian Cooper, Carl Harris, Mark Stickel, Clay Budin, Panayotis Matsinopoulos, David Smallberg, Herb Sutter, Pajo Misljencevic, Giulio Agostini, Fredrik Blomqvist, Jimmy Snyder, Byrial Jensen, Witold Kuzminski, Kazunobu Kuriyama, Michael Christensen, Jorge Yaftez Teruel, Mark Davis, Marty Rabinowitz, Ares Lagae 和 Alexander Medvedev.

第三版早期部分草稿由以下人士共同检阅：Brian Kemighan, Angelika Langer, Jesse Laeuchli, Roger E. Pedersen, Chris Van Wyk, Nicholas Stroustrup 和 Hendrik Schober。完整草稿由以下人士共同检阅：Leor Zolman, Mike Tsao, Eric Nagler, Gene Gutnik, David Abrahams, Gerhard Kreuzer, Drosos Kourounis, Brian Kemighan, Andrew Kirmse, Balog Pal, Emily Jagdhar, Eugene Kalenkovich, Mike Roze, Enrico Carrara, Benjamin Berck, Jack Reeves, Steve Schirripa, Martin Fallenstedt, Timothy Knox, Yun Bai, Michael Lanzetta, Philipp Janert, Guido Bartolucci, Michael Topic, Jeff Scherpelz, Chris Nauroth, Nishant Mittal, Jeff Somers, Hal Moroff, Vincent Manis, Brandon Chang, Greg Li, Jim Meehan, Alan Geller, Siddhartha Singh, Sam Lee, Sasan Dashtinezhad, Alex Marin, Steve Cai, Thomas Fruchterman, Cory Hicks, David Smallberg, Gunavardhan Kakulapati, Danny Rabbani, Jake Cohen, Hendrik Schober, Paco Viciana, Glenn Kennedy, Jeffrey D. Oldham, Nicholas Stroustrup, Matthew Wilson, Andrei Alexandrescu, Tim Johnson, Leon Matthews, Peter Dulimov 和 Kevlin Henney。 某些个别条款的草稿由Herb Sutter和Attila F. Feher检阅。

检阅一份不够洗炼（而且可能尚未完成）的手稿是件吃力的工作，在时间压力 之下进行只会使得它更困难。我要感谢这么多人愿意为我做这件事。

如果对讨论素材缺乏背景，而又期望捕捉手稿中的每一个问题，检阅工作将更 加困难。令人惊讶的是还是有人选择成为文字编辑。Chrysta Meadowbrooke是本书 的文字编辑，她的周密工作揭露出许多逃过其他每一双眼睛的问题。

Leor Zolman在正式检阅前先以多种编译器检验所有代码，在我校订手稿之后 又做一次。如果书中仍然存在任何错误，全是我的责任。KarlWiegers和（特别是）

Effective C++中文版，第三版

Tim Johnson提供我快速而有帮助的反馈。

John Wait是我的前两版编辑，有点傻傻地又签下这一份责任约。他的助理 Denise Mickelsen熟练地处理我频繁的纠缠，带着愉快的微笑（至少我认为她是。 呃，我从未见过她）。Julie Nahil向来扮演救火队角色并因此成为我的产品经理。 她以非凡的镇定指挥产品计划内的六周通宵工作。John Fuller （她的老板）和Marty Rabinowitz （他的老板）也协助解决了产品发行量问题。Vanessa Moore的正式工作 是提供FrameMaker和PDF支持，但她也协助制作附录B的条目并格式化打印于封 底里。Solveig Haugland 协助将索引格式化。Sandra Schroeder 和 Chuti Prasertsith 负 责封面设计，Chuti总是在每次我说“如果把这张相片加上那个颜色的线条会怎 样？”时修订封面。ChandaLeary-Coutu对市场营销举重若轻。

在我忙于手稿的数月之中，电视剧集Buffy the Vampire Slayer常常帮助我在每 天工作结束后解压。带着极大的克制我才能够不让Buffyspeak的身影进入本书。 Kathy Reed于1971年教我写程序，我很高兴我们保持友谊至今。Donald French雇 用我和Moises Lejter于1989年建立起C++培训教材（这项计划诱使我真正了解 C++），1991年他又聘我在Stratus Computer体现它们。该班学生鼓励我写下最终 成为本书第一版的东西。Don也将我介绍给John Wait,他同意出版它们。

我的妻子NancyL.Urbano持续鼓励我写作，即使在我完成了七本书、一张CD 改写版、一篇论文之后。她有令人难以置信的忍耐、自制与宽容。没有她我无法完 成我所完成的任何事情。

自始至终，我们的狗儿Persephone是我们无可取代的同伴。令人悲伤的是，在 这个项目的大部分时间里，她和我们之间的交往关系已经改为办公室内的一坛骨灰 瓮。我们十分怀念她。

Effective C++中文版，第三版

#### 目录

Contents

Effective C++中文版，第三版

译序



##### [www.linuxidc.com](http://www.linuxidc.com)

xviii    目录

Declare non-member functions when type conversions should apply to all parameters. 102

Effective C++中文版，第三版

目录

Effective C++中文版，第三版

..................................................................................................................280

Effective C++中文版，第三版

### 0

#### 导读

Introduction

学习程序语言根本大法是一回事；学习如何以某种语言设计并实现高效程序则 是另一回事。这种说法对C++尤其适用，因为C++以拥有罕见的威力和丰富的表 达能力为傲。只要适当使用，C++可以成为工作上的欢愉伙伴。巨大而变化多端的 设计可以被直接表现出来，并且被有效实现出来。一组明智选择并精心设计的 classes, functions和templates可使程序编写容易、直观、高效、并且远离错误。如 果你知道怎么做，写出有效的C++程序并不太困难。然而如果没有良好培训，C++ 可能会导致你的代码难以理解、不易维护、不易扩充、效率低下又错误连连。

本书的目的是告诉你如何有效运用C++。我假设你已经知道C++是个语言并 且已经对它有某些使用经验。这里提供的是这个语言的使用导引，使你的软件易理 解、易维护、可移植、可扩充、高效、并且有着你所预期的行为。

我所提出的忠告大致分为两类：一般性的设计策略，以及带有具体细节的特定 语言特性。设计上的讨论集中于“如何在两个不同做法中择一完成某项任务”。你 该选择inheritance （继承）还是templates （模板）？该选择public继承还是private 继承？该选择private继承还是composition （复合）？该选择member函数还是 non-member函数？该选择pflss-by-vfl/ue还是pass-by-reference'i在这些选择点上做 出正确决定很重要，因为一个不良的决定有可能不至于很快带来影响，却在发展后 期才显现恶果，那时候再来矫正往往既困难又耗时间，而且代价昂贵。

即使你完全知道该做什么，完全进入正轨还是可能有点棘手■■什么是 操作符的适当返回类型^'etum type）?何时该令析构函数为virtual?当operatornew

Effective C++中文版，第三版

无法找到足够内存时该如何行事？搾出这些细节很是重要，因为如果疏忽而不那么 做，几乎总是导致未可预期的、也许神秘难解的程序行为。本书将帮助你趋吉避凶。

这并不是一本范围广泛的C++参考书。这是一份55个特定建议(我称之为条 款)的集合，谈论如何强化你的程序和设计。每个条款有相当程度的独立性，但大 多数也参考其他条款。因此阅读本书的一个方式是，从你感兴趣的条款开始，然后 看它逐步把你带往何方。

本书也不是一本C++入门书籍。例如在第2章中我热切告诉你实现构造函数 (constructors)、析构函数(destructors)和赋值操作符(assignment operators)的 一切种种，但我假设你已经知道或有能力在其他地方学得这些函数的功能以及它们

如何声明。市面上有许多C++书籍内含这类信息。

本书目的是要强调那些常常被漠视的C++编程方向与观点。其他书籍描述 C++语言的各个成分，本书告诉你如何结合那些成分以便最终获得有效程序。其他 书籍告诉你如何让程序通过编译，本书告诉你如何回避编译器难以显露的问题。

在此同时，本书将范围限制在标准C++上头。书内只会出现官方规范上所列 的特性。本书十分重视移植性，所以如果你想找一些与平台相依的秘诀和窍门，这 里没有。

另一个你不会在本书发现的是C++福音书——走向完美C++软件的唯一真 理之路。本书每个条款都提供引导，告诉我们如何发展出更好的设计，如何避免常 见的问题，或是如何达到更高的效率，但没有任何一个条款放之四海皆准、一体适 用。软件设计和实现是复杂的差使，被硬件、操作系统、应用程序的约束条件涂上 五颜六色，所以我能做的最好的就是提供指南，让你得以创造出更棒的程序。

如果任何时间你都遵循每一条准则，不太可能掉入C++最常见的陷阱中。但 是所谓准则天生就带有例外。这就是为什么每个条款都有解释与说明。这些解释与 说明是本书最重要的一部分。惟有了解条款背后的基本原理，你才能够决定是否将 它套用于你所开发的软件，并奉行其所昭示的独特约束。

Effective C++中文版，第三版

本书的最佳用途就是彻底了解C++如何行为、为什么那样行为，以及如何运 用其行为形成优势。盲目应用书中条款是非常不适合的。但如果没有好理由，你或 许也不该违反任何一个条款。

术语 （Terminology）

下面是每一位程序员都应该了解的一份小小的C++词汇。其中的术语十分重 要，我们必须确认彼此都同意它们的意义。

所谓声明式（declaration）是告诉编译器某个东西的名称和类型（type），但略 去细节。下面都是声明式，

extern int x;    //对象（object）声明式

std: : size_t numDigits （int number） ;    //函数（fbnction）声明式

class Widget;    //类（class）声明式

template<typename T>    //模板（template）声明式

class GraphNode;    / /"typename"的使用见条款 42

注意，我谈到整数x时称其为一个对象（object），即使它是个内置类型。某 些人把“对象” 一词保留给用户自定义类型（user-definedtype）的变量，但我并不 如此。也请注意，函数numDigit的返回类型是std: :size_t，这表示类型size_t 位于命名空间std内。这个命名空间是几乎所有C++标准程序库元素的栖身处。 然而C （正确说法是C89）标准程序库也适用于C++,而继承自C的符号（例如 size_t）有可能存在于global作用域或std内，甚或两者兼具，取决于哪个头文件 被含入（#included）。本书之中我假设含入的都是C++头文件，这也就是为什么 我写std::siZe_t而不只是写size_t。当我在文本中指称标准程序库内的组件时， 往往略去前导的std::，你得自己认清像size_t, vector, cout这类东西都在std 内。但范例码中我总是会含入std，因为真实程序编译时不能没有它。

顺带一提，size_t只是一个typedef，是C++计算个数（例如char*-based字 符串内的字符个数或STL容器内的元素个数等等）时用的某种不带正负号 （unsigned）类型。它也是vector, deque和string内的operator []函数接受的参

数类型。条款3阐述当我们定义自己的operator □函数时应该遵循的协议。

每个函数的声明揭示其签名式（signature）,也就是参数和返回类型。一个函数

Effective C++中文版，第三版

的签名等同于该函数的类型。numDigits函数的签名是std: :size_t (int)，也就 是说“这函数获得一个int并返回一个std::size_t”。C++对签名式的官方定 义并不包括函数的返回类型，不过本书把返回类型视为签名的一部分，这样比较有 帮助。

定义式^definition)的任务是提供编译器一些声明式所遗漏的细节。对对象而 言，定义式是编译器为此对象拨发内存的地点。对function或function template而 言，定义式提供了代码本体。对class或class template而言，定义式列出它们的成员：

int x;    //对象的定义式

std::size_t numDigits (int number) //函数的定义式 {    ~    //此函数返回其参数的数字个数，

std:: size_t digitsSoFar = 1;    //例如十位数返回2，百位数返回3.

while ({number /= 10) != 0) ++digitsSoFar; return digitsSoFar;

}

class Widget {    //class 的定义式

public:

Widget();

〜Widget ();

}；

template<typename T>    //template 的定义式

class GraphNode { public:

GraphNode();

~GraphNode();

}；

初始化(Initialization)是“给予对象初值”的过程。对用户自定义类型的对象 而言，初始化由构造函数执行，所谓洳构造函数是一个可被调用而不带任何实 参者。这样的构造函数要不没有参数，要不就是每个参数都有缺省值：

class A {

public:

A();    //ttefflw/t构造函数

}；

class B {

public:

explicit B(int x = 0f bool b = true) ;    构造函数；

};    //关于"explicit",见以下信息

Effective C++中文版，第三版

class C { public:

explicit C (int x);    //不是 de/bw/f 构造函数

}；

上述的classes B和C的构造函数都被声明为explicit,这可阻止它们被用来 执行隐式类型转换(implicit type conversions)，但它们仍可被用来进行显式类型转 换(explicit type conversions):

void doSomething (B bObject);    //函数，接受一个类型为B的对象

B bObjl;

doSomething(bObj1); B bObj2 (28);

doSomething(28);



doSomething(B(28));



//一个类型为B的对象

//没问题，传递一个B给doSomething函数 //没问题，根据int 28建立一个B // (函数的bool参数缺省为true)

//错误! DoSomething应该接受一个B，

//不是一个int，而int至B之间 //并没有隐式转换。

//没问题，使用B构造函数将int显式转换 // (也就是转型，cast)为一个B以促成此一调用. // (条款27对转型谈得更多)

被声明为explicit的构造函数通常比其non-explici兄弟更受欢迎，因为它 们禁止编译器执行非预期(往往也不被期望)的类型转换。除非我有一个好理由允 许构造函数被用于隐式类型转换，否则我会把它声明为explicit。我鼓励你遵循 相同的政策。

请注意我在上述代码中以不同的颜色特别强调转型动作。我以这样的强调方式 贯穿全书，让你特别注意值得注意的东西。

copy构造函数被用来“以同型对象初始化自我对象”，cop/flss切nwent操作符

被用来“从另一个同型对象中拷贝其值到自我对象”：

class Widget { public:

Widget ();    //def口w/t构造函数

Widget {const Widgets rhs) ;    //c叩y构造函数

Widgets operator- (const Widgets rhs) ;    //copy assignment

Widget wl; Widget w2(wl); wl - w2;



//调用defflw/r构造函数

//调用copy构造函数

//调用(:叩/仍5切wwe/n操作符

Effective C++中文版，第三版

当你看到赋值符号时请小心，因为”语法也可用来调用cop/构造函数：

Widget w3 = w2;    //调用 copy构造函数！

幸运的是“copy构造”很容易和“cop/赋值”有所区别。如果一个新对象被定 义(例如以上语句中的w3), —定会有个构造函数被调用，不可能调用赋值操作。 如果没有新对象被定义(例如前述的”wl = w2”语句)，就不会有构造函数被调 用，那么当然就是赋值操作被调用。

copy构造函数是一个尤其重要的函数，因为它定义一个对象如何passed by value (以值传递)。举个例子，考虑以下代码：

bool hasAcceptableQuality(Widget w);

Widget aWidget;

if (hasAcceptableQuality(aWidget))...

参数w是以Vfl/we方式传递给hasAcceptableQuality，所以在上述调用中 aWidget被复制到w体内。这个复制动作由Widget的cop/构造函数完成。

意味“调用构造函数”。以vfl/we传递用户自定义类型通常是 个坏主意，P仍s-iy-reference-toconst往往是比较好的选择；详见条款20。

S71是所谓标准模板库(Standard Template Library),是C++标准程序库的一 部分，致力于容器(如vector, list, set，map等等)、迭代器(如vector<int>:: iterator, set<string>:: iterator 等等)、算法(如 for_each, find, sort 等尋) 及相关机能。许多相关机能以函数对象(function objects)实现，那是“行为像函 数”的对象。这样的对象来自于重载operator (> (ft/nct/o/i o?//操作符)的classes。 如果你对STL陌生，阅读本书时手边可能需要摆一本最新参考读物，因为STL对 我太有用了，我不可能不用它。一旦你也用上它，你一定会有相同的感觉。

C++程序员如果原先来自诸如Java或C#语言阵营，可能会对所谓“不明确 行为” (undefined behavior)感到惊讶。由于各种因素，某些C++构件的行为没 有定义：你无法稳定预估运行期会发生什么事。下面两个代码片段就带有“不明确 的行为”：

int* p = 0;    //p 是个null 指针

std::cout « *p;    //对一个 null 指针取值(dereferencing)

//会导致不明确行为。

Effective C+ +中文版，第三版

char name[] = ''Oarla"; //name是个数组，大小为6 （别忘记最尾端的null!） char c = name[10] ;    //指涉一个无效的数组索引

//导致不明确行为。

我要特别强调，不明确（未定义）行为的结果是不可预期的，很可能让人不偷 快。经验丰富的C++程序员常说，带有不明确行为的程序会抹煞你的辛勤努力。 那是真的：一个带有不明确行为的程序会抹煞你的辛勤努力。但不一定如此，更可 能的是这样的程序会出现错误行为，有时执行正常，有时造成崩坏，有时更产出不 正确的结果。有战斗力的C++程序员都知道尽可能避开不明确行为。我会在书中 指出你需要密切注意的若干地方。

对其他语言转换至C++阵营的程序员而言，另一个可能造成困惑的术语是接 口 （interface）。Java和.NET语言都提供Interfaces为语言元素，但C++没有， 尽管条款31讨论了如何近似它。当我使用术语“接口 ”时，我一般谈的是函数的 签名（signature）或class的可访问元素（例如我可能会说class的“public接口”或 “protected接口”或“private接口 ”），或是针对某template类型参数需为有效的 一个表达式（见条款41）。也就是我所说的接口完全是指一般性的设计观念。

所谓客户（client）是指某人或某物，他（或它）使用你写的代码（通常是些 接口）。函数的客户是指其使用者，也就是程序中调用函数（或取其地址）的那一 部分，也可以说是编写并维护那些代码的人。Class或template的客户则是指程序 中使用class或template的那一部分，也可以说是编写并维护那些代码的人。说到 “客户”时通常我指的是程序员，因为程序员可能被迷惑、被误导、或因糟糕的接

口而恼怒，他们所写的代码却不会有这种情绪。

或许你不习惯想到客户，但我会花费大量时间试着说服你尽可能让他们的生活 轻松些。毕竟你也是其他人所开发的软件的客户。难道你不希望那些人为你把事情 弄得更轻松些吗？除此之外，在某个时间点你几乎必然会发现，你就是你自己的客 户（也就是使用你自己写的代码），那个时候你就会很髙兴你在开发接口时把客户 放在心上了。

Effective C++中文版，第三版

本书中我常常掩盖functions和function templates之间的区别，以及classes和 class templates之间的区别。那是因为对其中之一为真者往往对另一方也为真。当不 是这种情况的时候，我会区分classes, functions及它们所对应的templates。

当我在程序批注中提到构造函数和析构函数时，有时我会使用缩写字ctor和

dtoro

命名习惯 (Naming Conventions)

我尝试挑选有意义的名称用于objects, classes, functions, templates等等身上，但 某些隐藏于名称背后的意义可能不是那么显而易见，例如我最喜爱的两个参数名称 lhs和rhso它们分别代表"left-hand side"(左手端)和"right-hand side"(右手端)。 我常常以它们作为二元操作符(binary operators)函数如operate和operator* 的参数名称。举个例子，如果a和b表示两个有理数对象，而如果Rational对象 可被一个non-member operator*函数执行乘法(如条款24所言)，那么下面表达式:

a * b

等价于以下的函数调用： operator*(a, b)

在条款24中我声明此一 operator*如下： const Rational operator* (const RationalS lhs, const Rational& rhs);

如你所见，左操作数a变成函数内的lhS,右操作数b则变成rhs。

'对于成员函数，左侧实参由this指针表现出来，所以有时我单独使用参数名 称rhso你可能已经在第5页的若干Widget成员函数声明中注意到了这一点。对 了，我经常以Widget class示例，”Widget”并不代表任何东西，它只是当我需要一 个示范用的class名称时偶尔采用的名称，它和GUI toolkits的widgets完全无关。

我常将“指向一个T型对象”的指针命名为pt,意思是"pointer to Tno下面是 一些例子：

Widget* pw;    //pw = ”ptr to Widget",

class Airplane;

Airplane* pa;    //pa = nptr to Airplane".

Effective C++中文版，第三版

class GameCharacter;

GameCharacter* pgc;    //pgc = ”ptr to GameCharacter"

对于references我使用类似习惯：rw可能是个reference to Widget，ra则是个 reference to Airplane o

当我讨论成员函数时，偶尔会以mf为名。

关于线程 (Threading Consideration)

作为一个语言，C++对线程(threads)没有任何意念——事实上它对任何并发 (concurrency)事物都没有意念。C++标准程序库也一样。当C++受到全世界关

注时多线程(multithreaded)程序还不存在。

但现在它们存在了。本书的焦点放在标准可移植的C++，但我不能忽略一个事 实：线程安全性(thread safety)是许多程序员面对的主题。我对“标准C++和真 实世界之间的这个缺口”的处理方式是，如果我所检验的C++构件在多线程环境 中有可能引发问题，就把它指出来。这远远无法构成一本C++多线程编程专著，却 能让一本C++编程书籍尽管大量限制其自身处于单线程考虑之下仍承认多线程的 存在，并指出“有线程概念的程序员"在评估我所提供的忠告时需特别谨慎的地方。

如果你不熟悉多线程或无需忧虑它，可以忽略本书的线程相关讨论。然而如果 你正在编写一个与线程有关的应用程序或程序库，请记住，我的注释或许比一般“以 C++解决问题时需注意……”的起点还多一些些。

TR1 和 Boost

你会发现，本书处处提到TR1和Boost。各有一个条款详细描述它们(条款54 针对TR1,条款55针对Boost)。不幸的是这些条款位于全书末尾(它们被放在那 儿是因为那样的安排比较好。真的，我试过其他许多摆法)。如果你喜欢，可以现 在就翻过去读它们，但如果你喜欢从头读起而不颠倒次序，下面的实施摘要将助你 飞渡难关：

■ TRI ("Technical Report 1")是一份规范，描述加入C++标准程序库的诸多新机 能。这些机能以新的class templates和fimction templates形式体现，针对的题目 有 hash tables, reference-counting smart pointers, regular expressions,以及更多。 所有TRI组件都被置于命名空间tri内，后者嵌套于命名空间std内。

Effective C++中文版，第三版

■ Boost是个组织，亦是一个网站(http://boost.org)，提供可移植、同僚复审、源 码开放的C++程序库。大多数TR1机能是以Boost的工作为基础。在编译器厂 商于其C++程序库中含入TR1之前，对那些搜寻TR1实现品的开发人员而言， Boost网站可能是第一个逗留点。Boost提供比TR1更多的东西，所以无论如何 值得了解它。

Effective C++中文版，第三版

##### [www.linuxidc.com](http://www.linuxidc.com)

1条款01:视C++为一个语言联邦    11

[Linux](http://www.linuxidc.com)[公社(LinuxIDC+com)是包括Ubuntu，Fedora，SUSE技术，最新IT资讯等Linux专业类网站。](http://www.linuxidc.com)
