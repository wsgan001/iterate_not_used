### 7

#### 模板与泛型编程

Templates and Generic Programming

C-H- templates的最初发展动机很直接：让我们得以建立“类型安全”(type-safe) 的容器如vector，list和map。然而当愈多人用上templates，他们发现templates

有能力完成愈多可能的变化。容器当然很好，但泛型编程(generic programming)-

写出的代码和其所处理的对象类型彼此独立——更好。STL算法如for^each, find 和merge就是这一类编程的成果。最终人们发现，C++template机制自身是一部完 整的图灵机(Turing-complete):它可以被用来计算任何可计算的值。于是导出了 模板元编程(template metaprogramming)，创造出“在C++编译器内执行并于编 译完成时停止执行”的程序。近来这些日子，容器反倒只成为C++template馅饼上 的一小部分。然而尽管template的应用如此宽广，有一组核心观念一直支撑着所有 基于template的编程。那些观念便是本章焦点。

本章无法使你变成一个专家级的template程序员，但可以使你成为一个比较好 的template程序员。本章也会给你必要信息，使你能够扩展你的template编程，到 达你所渴望的境界。

条款41: 了解隐式接□和编译期多态

Understand implicit interfaces and compile-time polymorphism.

面向对象编程世界总是以显式接口interfaces)和运行期多态Cruntime polymorphism)解决问题。举个例子，给定这样(无甚意义)的class:

class Widget { public:

Widget();

virtual -Widget();

Effective C++中文版，第三版

virtual std::size_t size( ) const;

virtual void normalize();

void swap (Widget& other);    //见条款 25

｝；

和这样(也是无甚意义)的函数:

void doProcessing(Widgets w) {

if (w.size() > 10 && w != someNastyWidget) { Widget temp(w); temp.normalize(}; temp.swap(w);

}

}

我们可以这样说doProcessing内的w :

■由于w的类型被声明为Widget,所以w必须支持Widget接口。我们可以在源 码中找出这个接口(例如在Widget的.h文件中)，看看它是什么样子，所以我 称此为一个显式接口 (explicit interface)，也就是它在源码中明确可见。

■由于Widget的某些成员函数是virtual, w对那些函数的调用将表现出运行期多 态(runtime polymorphism)，也就是说将于运行期根据w的动态类型(见条款 37)决定究竟调用哪一个函数。

Templates及泛型编程的世界，与面向对象有根本上的不同。在此世界中显式 接口和运行期多态仍然存在，但重要性降低。反倒是隐式接口 Cimplicit interfaces) 和编译期多态C compile-time polymorphism)移到前头了。若想知道那是什么，看看 当我们将doProcessing从函数转变成函数模板(fhnction template)时发生什么事：

template<typename T> void (Coprocessing (T& w)

{

=someNastyWidget) {



if (w.size() > 10 && w T temp(w); temp.normalize(); temp.swap(w);

}

}

现在我们怎么说doProcessing内的w呢？

■ w必须支持哪一种接口，系由template中执行于《身上的操作来决定。本例看来 w的类型T好像必须支持size, normalize和swap成员函数、copy构造函数(用

Effective C++中文版，第三版

以建立 temp)、不等比较(/n叫Wfl/rty comparison，用来比较 someNasty-Widget)。 我们很快会看到这并非完全正确，但对目前而言足够真实。重要的是，这一组 表达式(对此template而言必须有效编译)便是T必须支持的一组隐式接口

(implicit interface)。

■凡涉及w的任何函数调用，例如operator〉和operator !=，有可能造成template 具现化(instantiated)，使这些调用得以成功。这样的具现行为发生在编译期。

“以不同的template参数具现化function templates”会导致调用不同的函数，这 便是所谓的编译期多态(compile-time polymorphism｝。

纵使你从未用过templates，应该不陌生“运行期多态”和“编译期多态”之间 的差异，因为它类似于“哪一个重载函数该被调用”(发生在编译期)和“哪一个 virtual函数该被绑定”(发生在运行期)之间的差异。显式接口和隐式接口的差异 就比较新颖，需要更多更贴近的说明和解释。

通常显式接口由函数的签名式(也就是函数名称、参数类型、返回类型)构成。 例如 Widget class：

class Widget ｛ public:

Widget (); virtual -Widget();

virtual std::size_t size ( ) const; virtual void normalize(); void swap(Widget& other);

｝；

其public接口由一个构造函数、一个析构函数、函数size, normalize, swap及 其参数类型、返回类型、常量性(constnesses)构成。当然也包括编译器产生的copy 构造函数和cop/砌wwenf操作符(见条款5)。另外也可以包括typedefs，以及 如果你大胆违反条款22 (令成员变量为private)而出现的public成员变量。

隐式接口就完全不同了。它并不基于函数签名式，而是由有效表达式(valid expressions)组成。再次看看 doProcessing template—开始的条件：

Effective C++中文版，第三版

template<typename T> void doProcessing( T& w)

{

if (w.size() > 10 && w != someNastyWidget) {

T (w的类型)的隐式接口看来好像有这些约束：

■它必须提供一个名为size的成员函数，该函数返回一个整数值。

■它必须支持一个operator!=函数，用来比较两个T对象。这里我们假设 someNastyWidget 的类型为 T。

真要感谢操作符重载(operator overloading)带来的可能性，这两个约束都不 需要满足。是的，T必须支持size成员函数，然而这个函数也可能从base class继 承而得。这个成员函数不需返回一个整数值，甚至不需返回一个数值类型。就此而 言，它甚至不需要返回一个定义有类型！它唯一需要做的是返回一个 类型为X的对象，而X对象加上一个int(10的类型)必须能够调用一个operator〉。 这个operator>不需要非得取得一个类型为X的参数不可，因为它也可以取得类 型Y的参数，只要存在一个隐式转换能够将类型X的对象转换为类型Y的对象！

同样道理，T并不需要支持operator !=,因为以下这样也是可以的:operator != 接受一个类型为X的对象和一个类型为Y的对象，T可被转换为X而 someNastyWidget的类型可被转换为Y，这样就可以有效调用operator !=o

(偷偷告诉你，以上分析并未考虑这样的可能性：operators被重载，从一 个连接词改变为或许完全不同的某种东西，从而改变上述表达式的意义。)

当人们第一次以此种方式思考隐式接口，大多数的他们会感到头疼。但真的不 需要阿司匹林来镇痛。隐式接口仅仅是由一组有效表达式构成，表达式自身可能看 起来很复杂，但它们要求的约束条件一般而言相当直接又明确。例如以下条件式，

if (w.size() > 10 && w != someNastyWidget)...

关于函数size, oper-ator>, operators^或operator !=身上的约束条件，我 们很难就此说得太多，但整体确认表达式约束条件却很容易。if语句的条件式必须

Effective C++中文版，第三版

是个布尔表达式，所以无论涉及什么实际类型，无论”w.sizeO > 10 && w someNastyWidgetn导致什么，它都必须与 bool 兼容。这是 template doProcessing 加诸于其类型参数(typeparameter) T的隐式接口的一部分。doProcessing要求的 其他隐式接口： copy构造函数、normalize和swap也都必须对T型对象有效。

加诸于template参数身上的隐式接口，就像加诸于class对象身上的fi式接口 一样真实，而且两者都在编译期完成检査。就像你无法以一种“与class提供之显 式接口矛盾”的方式来使用对象(代码将通不过编译)，你也无法在template中使 用“不支持template所要求之隐式接口”的对象(代码一样通不过编译)。

请记住

■ classes 和 templates 都支持接口(interfaces)和多态(polymorphism)。

■对classes而言接口是显式的(explicit),以函数签名为中心。多态则是通过virtual

函数发生于运行期。

■对template参数而言，接口是隐式的(implicit)，奠基于有效表达式。多态则 是通过template具现化和函数重载解析(function overloading resolution)发生于 编译期。

条款42: 了解 typename 的双重意义 Understand the two meanings of typename.

提一个问题：以下template声明式中，class和typename有什么不同？

template<class T> class Widget;    //使用 ”class1'

template< type name T> class Widget;    "使用'’typename”

答案：没有不同。当我们声明template类型参数，class和typename的意义 完全相同。某些程序员始终比较喜欢class,因为可以少打几个字。其他人(包括 我)比较喜欢typename，因为它暗示参数并非一定得是个class类型。少数开发人 员在接受任何类型时使用typename,而在只接受用户自定义类型时保留旧式的 class。然而从C++的角度来看，声明template参数时，不论使用关键字class或 typename,意义完全相同。

然而C++并不总是把class和typename视为等价。有时候你一'定得使用 typename。为了解其时机，我们必须先谈谈你可以在template内指涉(refer U?)的 两种名称。

Effective C++中文版，第三版

假设我们有个template function,接受一个STL兼容容器为参数，容器内持有 的对象可被赋值为intso进一步假设这个函数仅仅只是打印其第二元素值。这是一 个无聊的函数，以无聊的方式实现，而且如稍后所言，它甚至不能通过编译。但请 暂时漠视那些事，下面是实践这个愚蠢想法的一种方式：

template<typename C>

void print2nd (const C& container)    //打印容器内的第二元素

{    //注意这不是有效的C++代码

if (container.size() >= 2) {

C: : const_iterator iter (container .begin () ) ;//取得第一元素的迭代器 ++iter;    //将iter移往第二元素

int value = *iter;    //将该元素复制到某个int.

std::cout « value;    //打印那个 int.

我在代码中特别强调两个local变量iter和value。iter的类型是 C::const_iterator,实际是什么必须取决于template参数C。template内出现的名 称如果相依于某个template参数，称之为从属名称(.dependent names)。如果从属 名称在class内呈嵌套状，我们称它为嵌套从属名称(nested dependent name)。 C::const_iterator就是这样一个名称。实际上它还是个嵌套从属类型名称/ dependent type name)，也就是个嵌套从属名称并且指涉某类型。

print2nd内的另一个local变量value,其类型是into int是一个并不倚赖任 何template参数的名称。这样的名称是谓非从属名称(non-dependetU names)。我 不知道为什么不叫做独立名称(independent names)。如果你和我一样认为术语 ,,non-dependentH令人憎恶，你我之间起了共鸣。但毕竟*'non-dependentn已被定为 这一类名称的术语，所以请和我一样，眨貶眼睛然后顺从它吧。

嵌套从属名称有可能导致解析(parsing)困难。举个例子，假设我们令print2nd 更愚蠢些，这样起头：

template<typename C>

void print2nd(const C& container) {

C::const一iterator* x;

看起来好像我们声明X为一个local变量，它是个指针，指向一个 C::COnSt_iteratOr。但它之所以被那么认为，只因为我们“已经知道” C::const_iterator是个类型。如果C::const_iterator不是个类型呢？如果C 有个static成员变量而碰巧被命名为const_iterator,或如果x碰巧是个global

Effective C++中文版，第三版

变量名称呢？那样的话上述代码就不再是声明一个local变量，而是一个相乘动作： C: :const_iterator乘以X。当然啦，这听起来有点疯狂，但却是可能的，而撰写 C++解析器的人必须操心所有可能的输入，甚至是这么疯狂的输入。

在我们知道C是什么之前，没有任何办法可以知道C: : const_iterator是否为 一个类型。而当编译器开始解析template print2nd时，尚未确知C是什么东西。 C++有个规则可以解析(resolve)此一歧义状态：如果解析器在template中遭遇一 个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是。所以缺省情况下 嵌套从属名称不是类型。此规则有个例外，稍后我会提到。

把这些记在心上，现在再次看看print2nd起始处：

template<typenane C>

void print2nd(const C& container)

{

if (container.size{) >= 2) {

C::const—iterator iter (container.begin ());    //这个名称被

...    ~    //假设为非类型

现在应该很清楚为什么这不是有效的C++代码了吧。iter声明式只有在 C::const_iterator是个类型时才合理，但我们并没有告诉C++说它是，于是C++ 假设它不是。若要矫正这个形势，我们必须告诉C++说C::COnSt_iterator是个 类型。只要紧临它之前故置关键字typename即可：

template<typename C>    //这是合法的 C+4■代码

void print2nd(const C& container)

{

if (container.size() >= 2) {

typename C::const_iterator iter(container.begin());

}

}

一般性规则很简单：任何时候当你想要在template中指涉一个嵌套从属类型名 称，就必须在紧临它的前一个位置放上关键字typename。(再提醒一次，很快我 会谈到一个例外。)

typename只被用来验明嵌套从属类型名称；其他名称不该有它存在。例如下面 这个function template,接受一个容器和一个“指向该容器”的迭代器：

template<typename C>    //允许使用"typename"(或”class”)

void f (const C& container,    //不允许使用"typename"

typename C:: iterator iter);    "一定要使用"typename"

Effective C++中文版，第三版

上述的C并不是嵌套从属类型名称（它并非嵌套于任何“取决于template参数” 的东西内），所以声明container时并不需要以typename为前导，但C::iterator 是个嵌套从属类型名称，所以必须以typename为前导。

"typename必须作为嵌套从属类型名称的前缀词”这一规则的例外是， typename不可以出现在base classes list内的嵌套从属类型名称之前，也不可在 member initialization list （成员初值列）中作为base class修饰符。例如：

tempiate<typename T>

class Derived: public Base<T>::Nested {    //base class list 中

public:    //不允许 ntypenameM.

explicit Derived(int x)

:Base<T>::Nested (x)    //mem. init. list 中

{    //不允许"typename”.

typename Base<T>: :Nested temp; //嵌套从属类型名称，

...    / / 既不在 base class list 中也不在 mem. init. list 中，

}    / /作为一个base class修饰符需加上typename.

}；

这样的不一致性真令人恼恨，但一旦你有了一些经验，勉勉强强还能接受它。

让我们看看最后一个typename例子，那是你将在真实程序中看到的代表性例 子。假设我们正在撰写一个function template，它接受一个迭代器，而我们打算为该 迭代器指涉的对象做一份local复件（副本）temp。我们可以这么写：

template<typename IterT>

void workWithlterator{IterT iter）

{

typename std: : iterator一traits<IterT>: :value__type temp（*iter）;

}

别让 std::iterator_traits<IterT>::value_type 惊吓了你，那只不过是标 准traits class （见条款47〉的一种运用，相当于说“类型为IterT之对象所指之物 的类型”。这个语句声明一个local变量（temp）,使用IterT对象所指物的相同 类型，并将temp初始化为iter所指物。如果IterT是vectorcint〉：: iterator, temp 的类型就是 into 如果 IterT 是 list<string>:: iterator，temp 的类型就是 string。由于 std: :iterator_traits<IterT>: :value_type 是个嵌套从属类型名 称（value_type 被嵌套于 iterator_traits<IterT〉之内而 IterT 是个 template 参数），所以我们必须在它之前放置typename。

Effective C++中文版，第三版

如果你认为 std: :iterator_traits<IterT〉： ：value_type 读起来不畅快，想 象一下打那么长的字又是什么光景。如果你像大多数程序员一样，认为多打几次这 些字实在很恐怖，那么你应该会想建立一个typedefo对于traits成员名称如 value_type （再次请看条款47提供的traits信息），普遍的习惯是设定typedef名 称用以代表某个traits成员名称，于是常常可以看到类似这样的local typedef：

tempiate<typename IterT>

void workWithlterator（IterT iter）

{

typedef typename std::iterator_traits<IterT>::value_type value_type; value_type temp（*iter〉；

}

许多程序员最初认为把”typedef typename"并列颇不合谐，但它实在是指涉 “嵌套从属类型名称”的一个合理附带结果。你很快会习惯它，毕竟你有强烈的动

机-你希望多打几次 typename std:: iterator_traits<IterT>::value__type

吗？

作为结语，我应该提到，typename相关规则在不同的编译器上有不同的实践。 某些编译器接受的代码原本该有typename却遗漏了；原本不该有typename却出现 了；还有少数编译器（通常是较旧版本）根本就拒绝typename。这意味typename 和“嵌套从属类型名称”之间的互动，也许会在移植性方面带给你某种温和的头疼。

请记住

■声明template参数时，前缀关键字class和typename可互换。

■请使用关键字typename标识嵌套从属类型名称；但不得在base class lists （基类 列）或member initialization list （成员初值列）内以它作为base class修饰符。

条款43:学习处理模板化基类内的名称

Know how to access names in templatized base classes.

假设我们需要撰写一个程序，它能够传送信息到若干不同的公司去。信息要不 译成密码，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个 信息传至哪一家公司，就可以采用基于template的解法：

Effective C++中文版，第三版

class CompanyA { public:

void sendCleartext(const std::strings msg); void sendEncrypted(const std::strings msg);

}；

class CompanyB { public:

void sendCleartext(const std::strings msg); void sendEncrypted(const std::strings msg);

}；

...    //针对其他公司设计的classes.

class Msglnfo { ... };    //这个class用来保存信息，以备将来产生信息

template<typename Company〉 class MsgSender { public:

…    //離函数、析构函》^0

void sendClear(const Msglnfo& info)

{

std::string msg;

在这儿，根据info产生信息/

Company c;

c,sendCleartext(msg);

}

void sendSecret (const MsglnfoS info) //类似 sendClear,唯~~■不同是 { ... }    //这里调用 c. sendEncrypted

}；

这个做法行得通。但假设我们有时候想要在每次送出信息时志记(log)某些信 息。derived class可轻易加上这样的生产力，那似乎是个合情合理的解法：

template<typename Company〉

class LoggingMsgSender: public MsgSender<Company> { public:

...    //构造函数、析构函数等等.

void sendClearMsg(const Msg工nfo& info)

{

将“传送前”的信息写至log;

sendClear (info) ;    //调用base class函数；这段码无法通过编译o

将“传送后”的信息写至log;

}

｝；

Effective C++中文版，第三版

注意这个derived class的信息传送函数有一个不同的名称(sendClearMsg)， 与其base class内的名称(sendClear)不同。那是个好设计，因为它避免遮掩“继 承而得的名称”(见条款33)，也避免重新定义一个继承而得的non-virtual函数(见 条款36)。但上述代码无法通过编译，至少对严守规律的编译器而言。这样的编译 器会抱怨sendClear不存在。我们的眼睛可以看到sendClear的确在base class内， 编译器却看不到它们。为什么？

问题在于，当编译器遭遇class template LoggingMsgSender定义式时，并不知 道它继承什么样的class。当然它继承的是MsgSender<Con^pany〉，但其中的Company 是个template参数，不到后来(当LoggingMsgSender被具现化)无法确切知道它 是什么。而如果不知道Company是什么，就无法知道class MsgSender<Conipany>看 起来像什么——更明确地说是没办法知道它是否有个sendClear函数。

为了让问题更具体化，假设我们有个class CompanyZ坚持使用加密通讯：

class CompanyZ {    //这个 class 不提供

public:    //sendCleartext 函数

void sendEncrypted(const std::strings msg);

}；

一般性的MsgSender template对CompanyZ并不合适，因为那个template提供 了一个sendClear函数(其中针对其类型参数Con^any调用了 sendCleartext函 数)，而这对Co叩anyZ对象并不合理。欲矫正这个问题，我们可以针对CoinpanyZ 产生—MsgSender特化版：

templateo    / / ~*个全特化的

class MsgSender〈Company Z> {    / /MsgSender；它和—般 ten^late 相同，

public:    //差别只在于它删掉了 sendClear。

void sendSecret(const Msglnfo& info)

{ ... }

}；

注意class定义式最前头的"templateo”语法象征这既不是template也不是 标准class，而是个特化版的MsgSender template，在template实参是CompanyZ时 被使用。这是所谓的模板全特化(/o/a/如wp/aZespecfa/fz如•<?«) : template MsgSender 针对类型CompanyZ特化了，而且其特化是全面性的，也就是说一旦类型参数被定 义为CompanyZ,再没有其他template参数可供变化。

Effective C++中文版，第三版

现在，MsgSender针对CorrpanyZ进行了全特化，让我们再次考虑derived class LoggingMsgSender：

te叩late<typename Company〉

class LoggingMsgSender: public MsgSender<Company> { public:

void sendClearMsg(const Msglnfos info)

{

将“传送前”的信息写至log;

sendClear (info);    //如果Company == CompanyZ,这个函数^

将“传送后”的信息写至log;

}

｝；

正如注释所言，当base class被指定为MsgSender<Con^panyZ>时这段代码不合 法，因为那个class并未提供sendClear函数！那就是为什么C++拒绝这个调用的 原因：它知道base class templates有可能被特化，而那个特化版本可能不提供和一 般性template相同的接口。因此它往往拒绝在templatized base classes （模板化基类， 本例的MsgSender<Company>）内寻找继承而来的名称（本例的SendClear）。就 某种意义而言，当我们从Object Oriented C++跨进Template C++ （见条款1）， 继承就不像以前那般畅行无阻了。

为了重头来过，我们必须有某种办法令C++ “不进入templatized base classes 观察”的行为失效。有三个办法，第一是在base class函数调用动作之前加上

template<typename Company〉

class LoggingMsgSender: public MsgSender<Company> { public:

void sendClearMsg(const Msg工nfo& info)

{

将"传送前”的信息写至log;

this->sendClear (info);    //成立，假设 sendClear 将

将“传送后”的信息写至log;

｝；

Effective C++中文版，第三版

第二是使用using声明式。如果你已读过条款33,这个解法应该会令你感到熟 悉。条款33描述using声明式如何将“被掩盖的base class名称”带入一个derived class作用域内。我们可以这样写下sendClearMsg：

template<typename Company>

class LoggingMsgSender: public MsgSender<Company> { public:

using MsgSender<Company>: : sendClear;    //告诉编译器，请它假设

...    //sendClear 位于 base class 内。

void sendClearMsg(const Msglnfos info)

{

sendClear (info);    //OK,假设 sendClear 将被继承下来。

}

}?

(虽然using声明式在这里或在条款33都可有效运作，但两处解决的问题其 实不相同。这里的情况并不是base class名称被derived class名称遮掩，而是编译器 不进入base class作用域内查找，于是我们通过using告诉它，请它那么做。)

第三个做法是，明白指出被调用的函数位于base class内： template<typename Company〉

class LoggingMsgSender: public MsgSender<Company> { public:

void sendClearMsg(const MsglnfoS info)

{

MsgSender<Company>::sendClear (info);    //OK,假设 sendClear

...    //将被继承下来。

}

}；

但这往往是最不让人满意的一个解法，因为如果被调用的是virtual函数，上述 的明确资格修饰(explicit qualification)会关闭“virtual绑定行为”。

从名称可视点(visibilitypoint)的角度出发，上述每一个解法做的事情都相同： 对编译器承诺“base class template的任何特化版本都将支持其一般(泛化)版本所 提供的接口”。这样一个承诺是编译器在解析(parse)像LoggingMsgSencLer这样 的derived class template时需要的。但如果这个承诺最终未被实践出来，往后的编 Effective C++中文版，第三版

译最终还是会还给事实一个公道。举个例子，如果稍后的源码内含这个:

LoggingMsgSender<CompanyZ> zMsgSender;

Msglnfo msgData;

...    //在msgData内放置信息。

zMsgSender. sendClearMsg (msgData) ;    //错误！无法通过编译。

其中对sendClearMsg的调用动作将无法通过编译，因为在那个点上，编译器 知道base class是个template特化版本MsgSender<CompanyZ>,而且它们知道那个 class不提供sendClear函数，而后者却是sendClearMsg尝试调用的函数。

根本而言，本条款探讨的是，面对“指涉base class members”之无效references， 编译器的诊断时间可能发生在早期(当解析derived class template的定义式时)， 也可能发生在晚期(当那些templates被特定之template实参具现化时)。C+4■的 政策是宁愿较早诊断，这就是为什么“当base classes从templates中被具现化时” 它假设它对那些base classes的内容毫无所悉的缘故。

请记住

■可在 derived class templates 内通过"this->H 指涉 base class templates 内的成员 名称，或藉由一个明白写出的“base class资格修饰符”完成。

###### 条款44:将与参数无关的代码抽离templates

Factor parameter-independent code out of templates.

Templates是节省时间和避免代码重复的一个奇方妙法。不再需要键入20个类 似的classes而每一个带有15个成员函数，你只需键入一个class template,留给编 译器去具现化那20个你需要的相关classes和300个函数。(class templates的成员 函数只有在被使用时才被暗中具现化，所以只有在这300个函数的每一个都被使用， 你才会获得这300个函数。)Function templates有类似的诉求。替换写许多函数， 你只需要写一个function template,然后让编译器做剩余的事情。技术是不是很崇高 伟大，呵呵。

是的，唔……有时候啦。如果你不小心，使用templates可能会导致代码膨胀 icode bloat}:其二进制码带着重复(或几乎重复)的代码、数据，或两者。其结 果有可能源码看起来合身而整齐，但目标码(object code)却不是那么回事。肥胖 不结实很难被视为时尚，所以你需要知道如何避免这样的二进制浮夸。

你的主要工具有个气势恢宏的名称：共性与变性分析(commonality and variability analysis'),但其概念十分平民化。纵使你从未写过一个template,你始

Effective C++中文版，第三版

终做着这样的分析。

当你编写某个函数，而你明白其中某些部分的实现码和另一个函数的实现码实 质相同，你会很单纯地重复这些码吗？当然不。你会抽出两个函数的共同部分，把 它们放进第三个函数中，然后令原先两个函数调用这个新函数。也就是说，你分析 了两个函数，找出共同的部分和变化的部分，把共同部分搬到一个新函数去，保留 变化的部分在原函数中不动。同样道理，如果你正在编写某个class,而你明白其中 某些部分和另一个class的某些部分相同，你也不会重复这共同的部分。取而代之 的是你会把共同部分搬移到新class去，然后使用继承或复合(见条款32,38,39), 令原先的classes取用这共同特性。而原classes的互异部分(变异部分)仍然留在 原位置不动。

编写templates时，也是做相同的分析，以相同的方式避免重复，但其中有个 窍门。在non-template代码中，重复十分明确：你可以“看”到两个函数或两个classes 之间有所重复。然而在template代码中，重复是隐晦的：毕竟只存在一份template 源码，所以你必须训练自己去感受当template被具现化多次时可能发生的重复。

举个例子，假设你想为固定尺寸的正方矩阵编写一个template。该矩阵的性质 之一是支持逆矩阵运算(matrix inversion)。

/ /template 53^ n x    元素是

为T的objects;见以下

"关于size_t #1!(的信息



//求逆矩阵



template<typename T,

std::size_t n>

class SquareMatrix { public:

void invert();

}；

这个template接受一个类型参数T，除此之外还接受一个类型为3126_^的参数， 那是个非类型参数(non-typeparameter) o这种参数和类型参数比起来较不常见， 但它们完全合法，而且就像本例一样，相当自然。

现在，考虑这些代码：

SquareMatrix<double, 5> sml;

sml. invert ()；    "调用 SquareMatrix<double, 5>:: invert

SquareMatrix<doublef 10> sm2;

sm2.invert ( );    //调用 SquareMatrix<double, 10>::invert

Effective C++中文版，第三版

这会具现化两份invert。这些函数并非完完全全相同，因为其中一个操作的 是5*5矩阵而另一个操作的是10*10矩阵，但除了常量5和10,两个函数的其他部 分完全相同。这是template引出代码膨胀的一个典型例子。

如果你看到两个函数完全相同，只除了一个使用5而另一个使用10,你会怎么 做？你的本能会为它们建立一个带数值参数的函数，然后以5和10来调用这个带 参数的函数，而不重复代码。你的本能很好，下面是对SquareMatrix的第一次修 改：

template<typename T>    //与尺寸无关的 base class，

class SquareMatrixBase {    //用于正方矩阵

protected:

void invert (std: : size_t matrixSize) ;    //以给定的尺寸求逆矩阵

}；

template<typename T, std::size_t n>

class SquareMatrix： private SquareMatrixBase<T> {

private:

using SquareMatrixBase<T>:: invert;    //避掩 base 版的

//invert；见条款 33

public:

void invert ( ) { this->invert (n); }    //制造一个 inline 调用，调用

};    //base class 版的 inverto 稍后

//说明为什么这儿出现this->

就如你所看到，带参数的invert位于base class SquareMatrixBase中。和 SquareMatrix—样，SquareMatrixBase 也是个 template，不同的是它只对“矩阵 元素对象的类型”参数化，不对矩阵的尺寸参数化。因此对于某给定之元素对象类

型，所有矩阵共享同一个(也是唯--个)SquareMatrixBase class0它们也将因

此共享这唯--个class内的invert。

SquareMatrixBase::invert只是企图成为“避免derived classes代码重复”的 一种方法，所以它以protected替换public。调用它而造成的额外成本应该是0， 因为derived classes的inverts调甩base class版本时用的是inline调用(这里的 inline是隐晦的，见条款30)。这些函数使用记号，因为若不这样做， 便如条款43所说，模板化基类(templatized base classes ,例如 SquareMatrixBase<T> )内的函数名称会被derived classes掩盖。也请注意 SquareMatrix和SquareMatrixBase之间的继承关系是private。这反应一■个事实:

Effective C++中文版，第三版

这里的base class只是为了帮助derived classes实现，不是为了表现SquareMatrix 和SquareMatrixBase之间的is«a关系(关于private继承，见条款39)。

目前为止一切都好，但还有一些棘手的题目没有解决。 SquareMatrixBase::invert如何知道该操作什么数据？虽然它从参数中知道矩阵 尺寸，但它如何知道哪个特定矩阵的数据在哪儿？想必只有derived class知道。 Derived class如何联络其base class做逆运算动作？ 一个可能的做法是为 SquareMatrixBase:: invert添加另一个参数，也许是个指针，指向一块用来放置 矩阵数据的内存起始点。那行得通，但十之八九invert不是唯一一个可写为“形 式与尺寸无关并可移至SquareMatrixBase内”的SquareMatrix函数。如果有若 干这样的函数，我们唯一要做的就是找出保存矩阵元素值的那块内存。我们可以对 所有这样的函数添加一个额外参数，却得一次又一次地告诉SquareMatrixBase相 同的信息，这样似乎不好。

另一个办法是令SquareMatrixBase贮存一个指针，指向矩阵数值所在的内存。 而只要它存储了那些东西，也就可能存储矩阵尺寸。成果看起来像这样：

template<typename T>

class SquareMatrixBase {

protected:

//存储矩阵大小和一个 //指针，指向矩阵数值。 / /重新赋值给pDatao



//矩阵的大小。

//指针，指向矩阵内容。



SquareMatrixBase(std::size_t n, T* pMem)

:size (n), pData(pMem) { }

void setDataPtr(T* ptr) { pData = ptr; }

private:

std::size_t size;

T* pData;

}；

这允许derived classes决定内存分配方式。某些实现版本也许会决定将矩阵数 据存储在SquareMatrix对象内部：

template<typename T, std::size_t n>

class SquareMatrix: private SquareMatrixBase<T> {

public:

SquareMatrix ( )    //送出矩阵大小和

:SquareMatrixBase<T> (n, data) { }    "数据指针给 base class。

private:

T data [n*n];

}；

Effective C++中文版，第三版

这种类型的对象不需要动态分配内存，但对象自身可能非常大。另一种做法是 把每一个矩阵的数据放进heap (也就是通过new来分配内存)：

template<typename T, std::size_t n>

class SquareMatrix: private SquareMatrixBase<T> {

public:

SquareMatrix ( )    //将 base class 的数据指针设为 null,

:SquareMatrixBase<T〉(n, 0),    //为矩阵内容分配内存，

pData (new T [n*n] )    //将指向该内存的指针存储起来，

{ this->setDataPtr (pData. get ()); } //然后将它的一个副本交给 base class

private:

boost: : scoped_array<T> pData;    boost: :scoped_array,

};    _    //见条款13。    _

不论数据存储于何处，从膨胀的角度检讨之，关键是现在许多——说不定是所

有-SquareMatrix成员函数可以单纯地以inline方式调用base class版本，后者

由“持有同型元素”(不论矩阵大小)之所有矩阵共享。在此同时，不同大小的 SquareMatrix对象有着不同的类型，所以即使(例如SquareMatrix<double, 5>和 SquareMatrix<double, 10>)对象使用相同的 SquareMatrixBase<double> 成员函 数，我们也没机会传递一个SquareMatrix<double, 5>对象到一个期望获得 SquareMatrix<double,10> 的函数去。很棒，对吗？

是的，很棒，但必须付出代价。硬是绑着矩阵尺寸的那个invert版本，有可 能生成比共享版本(其中尺寸乃以函数参数传递或存储在对象内)更佳的代码。例 如在尺寸专属版中，尺寸是个编译期常量，因此可以藉由常量的广传达到最优化， 包括把它们折进被生成指令中成为直接操作数。这在“与尺寸无关”的版本中是无 法办到的。

从另一个角度看，不同大小的矩阵只拥有单一版本的invert,可减少执行文 件大小，也就因此降低程序的working set (译注，见下说明)大小，并强化指令髙 速缓存区内的引用集中化(locality of reference)。这些都可能使程序执行得更快速， 超越“尺寸专属版"invert的最优化效果。哪一个影响占主要地位？欲知答案，唯 一的办法是两者都尝试并观察你的平台的行为以及面对代表性数据组时的行为。

译注：所谓working set是指对一个在“虚内存环境”下执行的进程(process)而言， 其所使用的那一组内存页(pages) »

另一个效能评比所关心的主题是对象大小。如果你不介意，可将前述“与矩阵 大小无关的函数版本”搬至base class内，这会增加每一个对象的大小。例如在我 Effective C++中文版，第三版

刚才展示的例子中，每一个SquareMatrix对象都有一个指针指向 SquareMatrixBase class内的数据。虽然每个derived class已经有一种取得数据的 办法，这会对每一个SquareMatrix对象增加至少一个指针那么大。当然也可以修 改设计，拿掉这些指针，但是再一次，这其中需要若干取舍。例如令base class贮 存一个protected指针指向矩阵数据，会导致丧失封装性，如条款22所言。也可 能导致资源管理上的混乱和复杂；是的，如果base class存储一个指针指向矩阵数 据，那些数据空间也许是动态分配获得，也许存储于derived class对象内(如稍早 所见)，如何判断这个指针该不该被删除呢？这样的问题有其答案，但你愈是尝试 精密的做法，事情变得愈是复杂。从某个角度看，一点点代码重复反倒看起来有点 幸运了。

这个条款只讨论由non-type template parameters(非类型模板参数)带来的膨胀， 其实type parameters (类型参数)也会导致膨胀。例如在许多平台上int和long有 相同的二进制表述，所以像▽6£^01?<1111;>和vector<long>的成员函数有可能完全 相同——这正是膨胀的最佳定义。某些连接器(linkers)会合并完全相同的函数实 现码，但有些不会，后者意味某些templates被具现化为int和long两个版本，并 因此造成代码膨胀(在某些环境下)。类似情况，在大多数平台上，所有指针类型 都有相同的二进制表述，因此凡templates持有指针者(例如list<int*>, listcconst int*>, list<SquareMatrix<long, 3>*> 等等)往往应该对每一个成员 函数使用唯一一份底层实现。这很具代表性地意味，如果你实现某些成员函数而它 们操作强型指针^strongly typed pointers,即T*)，你应该令它们调用另一个操作 无类型指针(-untypedpointers,即void*)的函数，由后者完成实际工作。某些C++ 标准程序库实现版本的确为vector, deque和list等templates做了这件事。如果 你关心你的templates可能出现代码膨胀，也许你会想让你的templates也做相同的 事情。

请记住

■ Templates生成多个classes和多个函数，所以任何template代码都不该与某个造 成膨胀的template参数产生相依关系。

■因非类型模板参数(non-type template parameters)而造成的代码膨胀，往往可 消除，做法是以函数参数或class成员变量替换template参数。

■因类型参数(type parameters)而造成的代码膨胀，往往可降低，做法是让带有 完全相同二进制表述(binary representations)的具现类型(instantiation types) 共享实现码。

Effective C++中文版，第三版

条款45:运用成员函数模板接受所有兼容类型

Use member function templates to accept "all compatible types.n

所谓智能指针是“行为像指针”的对象，并提供指针没有的 机能。例如条款13曾经提及std： :auto_ptr和tri：:shared_ptr如何能够被用来 在正确时机自动删除heap-based资源。STL容器的迭代器几乎总是智能指针；无疑 地你不会奢望使用”什”将一个内置指针从linked list的某个节点移到另一个节点， 但这在list::iterators身上办得到。

真实指针做得很好的一件事是，支持隐式转换(implicit conversions)。Derived class指针可以隐式转换为base class指针，“指向non-const对象”的指针可以转 换为“指向const对象”……等等。下面是可能发生于三层继承体系的一些转换：

class Top { ... };

class Middle: public Top { ... };

class Bottom: public Middle { ... };

Top* ptl = new Middle;    //将Middle* 转换为 Top*

Top* pt2 = new Bottom;    //将 Bottom* 转换为 Top*

const Top* pet2 = ptl；    //将 Top* 转换为 const Top*

但如果想在用户自定的智能指针中模拟上述转换，稍稍有点麻烦。我们希望以 下代码通过编译：

ten^)late<typename T> class SmartPtr { public:

//智能指针通常

//以内置(原始)指针完成初始化



explicit SmartPtr(T* realPtr);

}；

/ /将 SmartPtr<Middle> 转换为 // SmartPtr<Top>

"将 SmartPtr<Bottom> 转换为 // SmartPtr<Top>

/ /将 SmartPtr<Top> 转换为 // SmartPtr<const Top>



SmartPtr<Top> ptl =

SmartPtr<Middle> (new Middle);

SmartPtr<Top> pt2 =

SmartPtr<Bottom> (new Bottom);

SmartPtr<const Top> pct2 = ptl;

但是，同一个template的不同具现体(instantiations)之间并不存在什么与生倶 来的固有关系(译注：这里意指如果以带有base-derived关系的B，D两类型分别具 现化某个template,产生出来的两个具现体并不带有base-derived关系)，所以编译 器视SmartPtr<Middle>和SmartPtr<Top>为完全不同的classes，它们之间的关

系并不比......唔......并不比vector<float>和Widget更密切，呵呵。为了获得我

们希望获得的SmartPtr classes之间的转换能力，我们必须将它们明确地编写出来。

Effective C++中文版，第三版

Templates 和泛型编程(Generic Programming )

在上述智能指针实例中，每一个语句创建了一个新式智能指针对象，所以现在 我们应该关注如何编写智能指针的构造函数，使其行为能够满足我们的转型需要。 一个很具关键的观察结果是：我们永远无法写出我们需要的所有构造函数。在上述 继承体系中，我们根据一个SmartPtr<Middle>或一个SmartPtr<Bottom>构造出 一个SmartPtr<Top>,但如果这个继承体系未来有所扩充，SmartPtr<Top>对象又 必须能够根据其他智能指针构造自己。假设日后添加了：

class BelowBottom: public Bottom { ... };

我们因此必须令SmartPtr<BelowBottom>对象得以生成SmartPtr<Top>对 象，但我们当然不希望一再修改SmartPtr template以满足此类需求。

就原理而言，此例中我们需要的构造函数数量没有止尽，因为一个template可 被无限量具现化，以致生成无限量函数。因此，似乎我们需要的不是为SmartPtr 写一个构造函数，而是为它写一个构造模板。这样的模板(templates)是所谓member function templates (常筒称为 member templates)，其作用是为 class 生成函数：

template<typename T> class SmartPtr { public:

template<typename U>    / /member template,

SmartPtr (const SmartPtr<U>& other) ;    //为了生成 07/?/构造函数

}；

以上代码的意思是，对任何类型T和任何类型U，这里可以根据SmartPtr<U>生

成一个SmartPtr<T>-因为SmartPtr<T>有个构造函数接受一个SmartPtr<U>

参数。这一类构造函数根据对象u创建对象t (例如根据SmartPtr<U>创建一个 SmartPtr<T>)，而u和v的类型是同一个template的不同具现体，有时我们称之 为泛化(gewera/fee</) copy构造函数。

上面的泛化apK构造函数并未被声明为explicit。那是蓄意的，因为原始指 针类型之间的转换(例如从derived class指针转为base class指针)是隐式转换，无 需明白写出转型动作(cast),所以让智能指针仿效这种行径也属合理。在模板化 构造函数(templatized constructor)中略去explicit就是为了这个目的。

完成声明之后，这个为SmartPtr而写的“泛化构造函数”提供的东西比 我们需要的更多。是的，我们希望根据一个SmartPtr<Bottom>创建一个 SmartPtr<Top>» 却不希望根据一个 SmartPtr<Top> 创建一个 SmartPtr<Bottorr、， 因为那对public继承而言(见条款32)是矛盾的。我们也不希望根据一个 Effective C++中文版，第三版

SmartPtr<double>创建一个SmartPtr<int>，因为现实中并没有“将int*转换为 double*”的对应隐式转换行为。是的，我们必须从某方面对这一 member template 所创建的成员函数群进行拣选或筛除。

假设SmartPtr遵循auto^ptr和tri:: shared_ptr所提供的榜样，也提供一 个get成员函数，返回智能指针对象（见条款15）所持有的那个原始指针的副本， 那么我们可以在“构造模板”实现代码中约束转换行为，使它符合我们的期望：

template<typename T> class SmartPtr { public:

template<typename U>

SmartPtr （const SmartPtr<U>& other） "以 other 的 heldPtr :heldPtr （other.get （） ）{.••}    // 初始化 this 的 heldPtr

T* get（） const { return heldPtr; }

private:

T* heldPtr;    //这个SmartPtr持有的内置（原始）指针

}；

我使用成员初值列（member initialization list）来初始化SmartPtr<T>之内类 型为T*的成员变量，并以类型为U*的指针（由SmartPtr<U>持有）作为初值。 这个行为只有当“存在某个隐式转换可将一个U*指针转为一个T*指针”时才能通 过编译，而那正是我们想要的。最终效益是SmartPtr<T>现在有了一个泛化copy 构造函数，这个构造函数只在其所获得的实参隶属适当（兼容）类型时才通过编译。

member function templates （成员函数模板）的效用不限于构造函数，它们常扮 演的另一个角色是支持赋值操作。例如TR1的shared_ptr （见条款13）支持所有 “来自兼容之内置指针、tri: :shared_j）trs> auto_ptrs 和 tri: :weak_ptrs （见条 款54） ”的构造行为，以及所有来自上述各物（trl::weak_ptrs除外）的赋值操 作。下面是TR1规范中关于tri: :shared_ptr的一份摘录，其中强烈倾向声明 template参数时采用关键字class而不采用typename （条款42曾说过，两者的意 义在此语境下完全相同）。

template<class T>

class shared_ptr {

public:

//构造，来自任何兼容的 //内置指针、

"或 shared_ptr、

"或 weak_j）tr>

"或 auto_ptr.



template<class Y> e^licit shared_ptr (Y* p);

template<class Y>

shared_j>tr (shared_ptr<Y> const& r); template<class Y>

explicit shared_ptr (weak_j)tr<Y> const& r); template<class Y>

G3^>licit shared_ptr (auto_ptr<Y>& r);

Effective C++中文版，第三版

template<class Y>    //赋值，来自兼容的

shared_ptr& operator= (shared__ptr<Y> const& r) ;    //shared_ptr>

template<class Y>    "或 auto_ptr.

shared_ptr& operator=(auto_ptr<Y>& r);

｝；

上述所有构造函数都是explicit,惟有“泛化构造函数”除外。那意味 从某个sharedj^tr类型隐式转换至另一个shared_ptr类型是被允许的，但从某个 内置指针或从其他智能指针类型进行隐式转换则不被认可(如果是显式转换如 强制转型动作倒是可以)。另一个趣味点是传递给trl::Shared_ptr构造函数和

操作符的auto_ptrs并未被声明为const，与之形成对比的则是 tri::shared_ptrs 和 tri: :weak__ptrs 都以 const 传递。这是因为条款 13 说过， 当你复制一个auto_ptrs，它们其实被改动了。

member function templates (成员函数模板)是个奇妙的东西，但它们并不改变 语言基本规则。条款5说过,编译器可能为我们产生四个成员函数，其中两个是copy 构造函数和c叩y flssfgnment操作符。现在，tri: :shared_ptr声明了一个泛化copy 构造函数，而显然一旦类型T和Y相同，泛化构造函数会被具现化为“正常的”

构造函数。那么究竟编译器会暗自为tri:: shared_j?tr生成一个copy构造函 数呢？或当某个tri::shared_ptr对象根据另一个同型的tri: :shared_ptr对象 展开构造行为时，编译器会将“泛化构造函数模板”具现化呢？

一如我所说，member templates并不改变语言规则，而语言规则说，如果程序 需要一个cop/构造函数，你却没有声明它，编译器会为你暗自生成一个。在class 内声明泛化构造函数(是个member template)并不会阻止编译器生成它们自 己的copy构造函数(一个non-template)，所以如果你想要控制copy构造的方方面 面，你必须同时声明泛化构造函数和“正常的” cop/构造函数。.相同规则也 适用于赋值(assignment)操作。下面是tri: :shared_ptr的一份定义摘要，例证 上述所言：

template<class T> class shared_ptr ｛ public:

shared__ptr (shared_ptr const& r) ;    //copy构造函数.

template<class Y>    "泛化构造函数.

shared__ptr (shared_ptr<Y> const& r);

shared_ptr& operator= (shared_ptr const& r) ; //copy assignment.

template<class Y>    / f&VC copy assignment

shared_ptr& operator- (shared___ptr<Y> const& r);

｝；

Effective C++中文版，第三版

[Linux](http://www.linuxidc.com)[公社(LinuxIDC.com)是包括Ubuntu,Fedora,SUSE技术，最新IT资讯等Linux专业类网站。](http://www.linuxidc.com)



请记住

■请使用member function templates (成员函数模板)生成“可接受所有兼容类型” 的函数。

■如果你声明member templates用于“泛化构造”或‘泛化flss初wwent操作”， 你还是需要声明正常的cop/构造函数和c印yflss初wne/if操作符。

条款46:需要类型转换时请为模板定义非成员函数

Define non-member functions inside templates when type conversions are desired.

条款24讨论过为什么惟有non-member函数才有能力“在所有实参身上实施隐 式类型转换”，该条款并以Rational class的operator*函数为例。我强烈建议你 继续看下去之前先让自己熟稔那个例子，因为本条款首先以一个看似无害的改动扩 充条款24的讨论；本条款将Rational和operator*模板化了：

tempiate<typename T> class Rational { public:

//条款20告诉你为什么参数以 // passed by reference 方式传递。 //条款28告诉你为什么返回值 / / 以 passed by value 方式传递。

//条款3吿诉为什么它们是const.



Rational(const T& numerator = 0r

const T& denominator - 1)?

const T numerator() const; const T denominator() const;

}；

template<typename T>

const Rational<T> operator* (const Rational<T>& lhsz const Rational<T>& rhs)

{ ... } *

就像条款24 —样，我们希望支持混合式(mixed-mode)算术运算，所以我们 希望以下代码顺利通过编译。我们也预期它会，因为它正是条款24所列的同一份 代码，唯一■不同的是Rational和operator*如今都成了 templates：

Rational<int> oneHalf (1, 2);    //这个例于来自条款 24，

//唯一不同是Rational 改为 template。

Rational<int> result - oneHalf * 2; //错误！无法通过编译。

上述失败给我们的启示是，模板化的Rational内的某些东西似乎和其 non-template版本不同。事实的确如此。在条款24内，编译器知道我们尝试调用什 么函数(就是接受两个Rationals参数的那个operator*啦)，但这里编译器不知 道我们想要调用哪个函数。取而代之的是，它们试图想出什么函数被名为operator*

Effective C++中文版，第三版

的template具现化（产生）出来。它们知道它们应该可以具现化某个“名为operator* 并接受两个妇七10阳1<!>参数”的函数，但为完成这一具现化行动，必须先算出T 是什么。问题是它们没有这个能耐、

为了推导T，它们看了看operator*调用动作中的实参类型。本例中那些类型 分别是RatiOnal<int>（OneHalf的类型）和int（2的类型）。每个参数分开考虑。

以oneHalf进行推导，过程并不困难。operator*的第一参数被声明为 Rational <T>，而传递给operator*的第一实参（oneHalf ）的类型是 Rational<int>,所以T一定是int。其他参数的推导则没有这么顺利。operator* 的第二参数被声明为Rational<T〉，但传递给operator*的第二实参（2）类型是 into编译器如何根据这个推算出T?你或许会期盼编译器使用RationaKirit〉的 non-explicit构造函数将2转换为Rational<int>，进而将T推导为int，但它们 不那么做，因为在template实参推导过程中从不将隐式类型转换函数纳入考虑。绝 不！这样的转换在函数调用过程中的确被使用，但在能够调用一个函数之前，首先 必须知道那个函数存在。而为了知道它，必须先为相关的function template推导出 参数类型（然后才可将适当的函数具现化出来）。然而template实参推导过程中并 不考虑采纳“通过构造函数而发生的”隐式类型转换。条款24不涉及templates， 所以template实参推导不成为讨论议题。现在我们却是处在template part of C++（见 条款1）领域内，template实参推导是我们的重大议题。

只要利用一个事实，我们就可以缓和编译器在template实参推导方面受到的挑 战：template class内的friend声明式可以指涉某个特定函数。那意味class Rational<T>可以声明 operator* 是它的一个 friend 函数。Class templates 并不倚 赖template实参推导（后者只施行于function templates身上），所以编译器总是能 够在class Rational<T>具现化时得知因此，令Rational<T> class声明适当的 operator*为其friend函数，可简化整个问题：

terrplate<typename T> class Rational { public:

Effective C++中文版，第三版

friend -    //声明

const Rational operator* (const Rationale lhs, //operator* 函数，

const Rationale rhs) ;    //细节详下。

｝；

template<typename T>    "定义

const Rational<T> operator* (const Rational<T>& lhs, //operator* 函数。

const Rational<T>& rhs）

现在对operator*的混合式调用可以通过编译了，因为当对象oneHalf被声 明为一■个Rational<int>，class Rational<int>于是被具现化出来，而作为过程的 一部分，friend函数operator* （接受Rational<int>参数）也就被自动声明出来。 后者身为一个函数而非函数模板（function template），因此编译器可在调用它时使 用隐式转换函数（例如Rational的rum-explicit构造函数），而这便是混合式调 用之所以成功的原因。

但是，此情境下的“成功”是个有趣的字眼，因为虽然这段代码通过编译，却 无法连接。稍后我马上回来处理这个问题，首先我要谈谈在Rational内声明 operator* 的语法。

在一个class template内，template名称可被用来作为“template和其参数”的

简略表达方式，所以在Rational<T>内我们可以只写Rational而不必写

Rational<T>o本例中这只节省我们少打几个字，但若出现许多参数，或参数名称

很长，这可以节省我们的时间，也可以让代码比较干净。我谈这个是因为，本例中

的operator*被声明为接受并返回Rationals （而非Rational<T>s）。如果它被

声明如下，一样有效：

template<typename T> class Rational { public:

friend

const Rational<T> operator*（const Rational<T>& lhs,

const Rational<T〉& rhs）;

}；

然而使用简略表达方式（速记式）比较轻松也比较普遍。

现在回头想想我们的问题。混合式代码通过了编译，因为编译器知道我们要调 用哪个函数（就是接受一个Rational<int>以及又一个Rational<int>的那个

Effective C+ +中文版,第三版

operator*),但那个函数只被声明于Rational内，并没有被定义出来。我们意图

令此class外部的operator* template提供定义式，但是行不通-如果我们自己

声明了一个函数(那正是Rational template内的作为)，就有责任定义那个函数。 既然我们没有提供定义式，连接器当然找不到它！

或许最简单的可行办法就是将operator*函数本体合并至其声明式内：

template<typename T> class Rational { public:

friend const Rational operator*(const Rational& lhs, const Rational& rhs)

{

return Rational (lhs. numerator () * rhs. numerator ( ),    //实现码与

lhs. denominator () * rhs. denominator ()) ; //条款 24 同

}

}；

这便如同我们所期望地正常运作了起来：对operator*的混合式调用现在可编译连 接并执行。万岁！

这项技术的一个趣味点是，我们虽然使用friend,却与friend的传统用途“访 问class的non-public成分”毫不相干。为了让类型转换可能发生于所有实参身上， 我们需要一个non-member函数(条款24);为了令这个函数被自动具现化，我们 需要将它声明在class内部；而在class内部声明non-member函数的唯一办法就是： 令它成为一个friend。因此我们就这样做了。不习惯？是的。有效吗？不必怀疑。

一如条款30所说，定义于class内的函数都暗自成为inline,包括像operator* 这样的friend函数。你可以将这样的inline声明所带来的冲击最小化，做法是令 operator*不做任何事情，只调用一个定义于class外部的辅助函数。在本条款的例 子中，这样做并没有太大意义，因为operator*已经是个单行函数，但对更复杂的 函数而言，那么做也许就有价值。“令friend函数调用辅助函数”的做法的确值得 细究一番。

“Rational是个template”这一事实意味上述的辅助函数通常也是个template, 所以定义了 Rational的头文件代码，很典型地长这个样子：

template<typename T> class Rational;    //声明 Rational template

Effective C++中文版，第三版

template<typename T>    "声明 helper template

const Rational<T> doMultiply(const Rational<T>& lhs,

const Rational<T>& rhs);

template<typename T>

class Rational {

public:

friend

const Rational<T> operator*(const Rational<T>& lhs, const Rational<T>& rhs)

{ return doMultiply (lhs, rhs); }    //令 friend 调用 helper

}；

许多编译器实质上会强迫你把所有template定义式放进头文件内，所以你或许 需要在头文件内定义doMultiply (—如条款30所言，这样的templates不需非得是 inline不可)，看起来像这样：

template<typename T>    .    "若有必要，

const Rational<T> doMultiply (const Rational<T>& lhs,    //在头文件内定义

const Rational<T>& rhs) //helpertemplate

{

return Rational<T>(lhs.numerator() * rhs.numerator(),

lhs.denominator() * rhs.denominator());

}

作为一个template，doMultiply当然不支持混合式乘法，但它其实也不需要。 它只被operator*调用，而operator*支持了混合式操作！本质上operator*支 持了类型转换所需的任何东西，确保两个Rational对象能够相乘，然后它将这两 个对象传给一个适当的doMultiply template具现体，完成实际的乘法操作。协作 为成功之本，不是吗？

请记住

■当我们编写一个class template,而它所提供之“与此template相关的”函数支 持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部 的friend函数”。

条款47:请使用traits classes表现类型信息

Use traits classes for information about types.

STL主要由“用以表现容器、迭代器和算法"的templates构成，但也覆盖若 干工具性templates,其中一个名为advance,用来将某个迭代器移动某个给定距离: Effective C++中文版，第三版

template<typename IterT, typename DistT> //将迭代器向前移动 d 单位。 void advance (IterTS iter, DistT d);    //如果 d < 0 则向后移动。

观念上advance只是做iter+=d动作，但其实不可以全然那么实践，因为只 有randowflccess (随机访问)迭代器才支持+=操作。面对其他威力不那么强大的 迭代器种类，advance必须反复施行++或--，共d次。

嗯，你不记得你的STL迭代器分类(categories) 了吗？没关系，让我们来一 次迷你回顾。STL共有5种迭代器分类，对应于它们支持的操作。"/npirt迭代器只 能向前移动，一次一步，客户只可读取(不能涂写)它们所指的东西，而且只能读 取一次。它们模仿指向输入文件的阅读指针(read pointer) ; C++程序库中的 istream_iterators是这一分类的代表。Output迭代器情况类似，但一切只为输出： 它们只向前移动，一次一步，客户只可涂写它们所指的东西，而且只能涂写一次。 它们模仿指向输出文件的涂写指针(write pointer) ; ostream_iterators是这一分 类的代表。这是威力最小的两个迭代器分类。由于这两类都只能向前移动，而且只 能读或写其所指物最多一次，所以它们只适合“一次性操作算法” (one-pass algorithms)。

另一个威力比较强大的分类是/bnvfld迭代器。这种迭代器可以做前述两种分 类所能做的每一件事，而且可以读或写其所指物一次以上。这使得它们可施行于多 次性操作算法(multi-pass algorithms)。STL并未提供单向lipked list，但某些程序 库有(通常名为slist),而指入这种容器的迭代器就是属于forward迭代器。指 入TRI hashed容器(见条款54)的也可能是这一分类。(译注：这里说“可能” 是因为hashed容器的迭代器可为单向也可为双向，取决于实现版本。)

fi以/rertZozw/迭代器比上一个分类威力更大：它除了可以向前移动，述可以向后 移动。STL的list迭代器就属于这一分类，set, multiset, map和multimap的迭 代器也都是这一分类，

最有威力的迭代器当属random access迭代器。这种迭代器比上一个分类威力 更大的地方在于它可以执行“迭代器算术”，也就是它可以在常量时间内向前或向 后跳跃任意距离。这样的算术很类似指针算术，那并不令人惊讶，因为random access 迭代器正是以内置(原始)指针为榜样，而内置指针也可被当做random access迭 代器使用。vector, deque和string提供的迭代器都是这一分类。

对于这5种分类，C++标准程序库分别提供专属的卷标结构(tag struct)加以 确认：

Effective C++中文版，第三版

struct input_iterator_tag {}； struct output_iterator_tag {};

struct forward一iterator_tag: public input_iterator_tag { };

struct bidirectional_iterator_tag: public forward_iterator_tag { };

struct random_access_iterator_tag： public bidirectional_iterator_tag {};

这些structs之间的继承关系是有效的/'s-fl关系(见条款32)：是的，所有forward 迭代器都是加ptrt迭代器，依此类推。很快我们会看到这个继承关系的效力。

现在回到advance函数。我们已经知道STL迭代器有着不同的能力，实现 advance的策略之一是采用“最低但最普及”的迭代器能力，以循环反复递增或递 减迭代器。然而这种做法耗费线性时间。我们知道random access迭代器支持迭代 器算术运算，只耗费常量时间，因此如果面对这种迭代器，我们希望运用其优势。

我们真正希望的是以这种方式实现advance：

tempiate<typename IterT, typename DistT> void advance(IterT& iter, DistT d)

{

if (iter is a random access iterator) {

iter += d;    "针对ra/wtom access迭代器使用迭代器算术运算

}

else {

if (d >= 0) { while (d--) ++iter; }    //针对其他迭代器分类

else { while (d++) - -iter; }    //反复调用 ++ 或--

}

}

这种做法首先必须判断iter是否为random access迭代器，也就是说需要知道 类型IterT是否为random access迭代器分类。换句话说我们需要取得类型的某些 信息。那就是Zrato让你得以进行的事：它们允许你在编译期间取得某些类型信息。

Traits并不是C++关键字或一个预先定义好的构件；它们是一种技术，也是一 个C++程序员共同遵守的协议。这个技术的要求之一是，它对内置(built-in)类 型和用户自定义(user-defined)类型的表现必须一样好。举个例子，如果上述advance 收到的实参是一个指针(例如const char*)和—"bint，上述advance仍然必须 有效运作，那意味traits技术必须也能够施行于内置类型如指针身上。

“traits必须能够施行于内置类型”意味“类型内的嵌套信息(nesting information) ”这种东西出局了，因为我们无法将信息嵌套于原始指针内。因此类 型的traits信息必须位于类型自身之外。标准技术是把它放进一个template及其一 或多个特化版本中。这样的templates在标准程序库中有若干个，其中针对迭代器 者被命名为 iterator_traits:

Effective C++中文版，第三版

tempi ate <typename IterT>    "ten^late，用来处理

struct iterater_traits;    / /迭我器分类的相关信息

如你所见，iterator traits是个struct。是的，习惯上traits总是被实现为 structs，但它们却又往往被称为traits classes 0

iterator_traits的运作方式是，针对每一个类型IterT，在struct iterator_ traits<IterT> 内一定声明某个 typedef 名为 iterator_category。这个 typedef 用来确认IterT的迭代器分类。

iterator_traits以两个部分实现上述所言。首先它要求每一个“用户自定义 的迭代器类型”必须嵌套一个typedef,名为iterator category，用来确认适当的 卷标结构(tag struct)。例如deque的迭代器可随机访问，所以一个针对deque迭 代器而设计的class看起来会是这样子：

template < ...〉    //略而未写 template 参数

class deque { public:

class iterator {

-public:

typedef random_access_iterator_tag iter atorgeateg ory;

}；

}；

list的迭代器可双向行进，所以它们应该是这样： template < ... > class list { public:

class iterator { public:

typedef bidirectional_iterator_tag iterator_category;

}；

}；

至于iterator_traits,只是鸦鹅学舌般地响应iterator class的嵌套式typedef：

//类型IterT的iterator_category其实就是用来表现“IterT说它自己是什么”。 "关于"typedef typename"的运用，见条款42。

template<typename IterT> struct iterator_traits {

typedef typename IterT::iterator_category iterator—category;

}；

Effective C++中文版，第三版

这对用户自定义类型行得通，但对指针(也是一种迭代器)行不通，因为指针 不可能嵌套typedef。iterator_traits的第二部分如下，专门用来对付指针。

为了支持指针迭代器，iteratOr_traitS特别针对指针类型提供一个偏特化 版本{partial template specialization} □由于指针的行径与raw而/r? flccess迭代器类 似，所以iterator traits*指针指定的迭代器类型是：

tempi ate <typename 工 terT>    //template 偏特化

struct iterator_traits<IterT*>    //针对内置指针

{ ~

typedef random_access__iterator_tag iterator_category;

}；

现在，你应该知道如何设计并实现一个traits class 了：

■确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将 来可取得其分类(category)。

■为该信息选择一个名称(例如iterator_category)。

■提供一■个template和一组特化版本(例如稍早说的iterator_traits)，内含 你希望支持的类型相关信息。

好，现在有了 iterator_traits (实际上是 std: :iterator_traits，因为它 是C++标准程序库的一部分)，我们可以对advance实践先前的伪码(pseudocode):

template<typename IterT, typename DistT〉 void advance(IterT& iter, DistT d)

{

if (typeid( typename std: : iterator_traits<IterT>:: iterator_category) ==typeid (std:: random_access_iterator_tag))

虽然这看起来前景光明，其实并非我们想要。首先它会导致编译问题，但我将 在条款48才探讨这一点，此刻有更根本的问题要考虑。IterT类型在编译期间获知， 所以 iterator_traits<IterT>: :iterator_category 也可在编译期间确定。但 if 语句却是在运行期才会核定。为什么将可在编译期完成的事延到运行期才做呢？这 不仅浪费时间，也造成可执行文件膨胀。

我们真正想要的是一个条件式(也就是一个if...else语句)判断“编译期核 定成功”之类型。恰巧C++有一个取得这种行为的办法，那就是重载(overloading)。

£j^cft‘peC++中文版，第三版

当你重载某个函数f,你必须详细叙述各个重载件的参数类型。当你调用f, 编译器便根据传来的实参选择最适当的重载件，编译器的态度是“如果这个重载件 最匹配传递过来的实参，就调用这个f;如果那个重载件最匹配，就调用那个f; 如果第三个f最匹配，就调用第三个f! ”依此类推。看到了吗，这正是一个针对 类型而发生的“编译期条件句”。为了让advance的行为如我们所期望，我们需要 做的是产生两版重载函数，内含advance的本质内容，但各自接受不同类型的 iterator_category对象。我将这两个函数取名为doAdvance：

template<typename IterT, typename DistT>    "这份实现用于

void doAdvance (XterT& iterf DistT d,    / / random access

std:: random_access_iterator_tag) / /迭代器 { - - —

iter += d;

template<typename IterT, typename DistT〉    //这份实现用于

void doAdvance (IterT& iter, DistT d,    //bidirectional

std::bidirectional_iterator_tag) //迭代器 { _ -

if (d >= 0) { while (d--) ++iter; } else { while (d++) --iter; }

teinplate<typename IterT, typename DistT>    "这份实现用于

void doAdvance (IterT& iter, DistT d,    迭代器

std:: input__iterator_tag)

{ ~ -

if (d < 0 ) {

throw std::out_of_range ("Negative distance"); "详下

}

while (d--) ++iter;

}

由于 forward_iterator__tag 继承自 input__iterator_tag，所以上述 doAdvance的input_iterator版本也能够处理forward迭代器。这是 iterator_tag structs继承关系带来的一项红利。实际上这也是public继承带来的 部分好处：针对base class编写的代码用于derived class身上也行得通。

advance函数规范说，如果面对的是rww/wn access和汝ww/迭代器，则 接受正距离和负距离；但如果面对的是forward或fnpwt迭代器，则移动负距离会导 致不明确(未定义)行为。我所检验过的实现码都假设d不为负，于是直接进入一 个冗长的循环迭代，等待计数器降为0。上述代码中我以抛出异常取而代之。两种 做法都有根据，但“无法预言发生何事”是“不明确行为”之祸源所在。

Effective C++中文版，第三版

有了这些doAdvance重载版本，advance需要做的只是调用它们并额外传递一 个对象，后者必须带有适当的迭代器分类。于是编译器运用重载解析机制

（overloading resolution）调用适当的实现代码：

template<typename IterT, typename DistT> void advance（IterT& iter, DistT d）

{

doAdvance （    / /调用的 doAdvance 版本

iter, d,    //对iter之迭代器分类而言

typename    //必须是适当的。

std::iterator_traits<IterT〉：:iterator_category{）

）； _ —

}

现在我们可以总结如何使用一个traits class T:

■建立一组重载函数（身份像劳工）或函数模板（例如doAdvance）,彼此间的 差异只在于各自的traits参数。令每个函数实现码与其接受之traits信息相应和。

■建立一个控制函数（身份像工头）或函数模板（例如advance）,它调用上述 那些“劳工函数”并传递traits class所提供的信息。

Traits广泛用于标准程序库。其中当然有上述讨论的iterator_traits，除了 供应iterator__category还供应另四份迭代器相关信息（其中最有用的是 value_type，见条款42）。此外还有char_traits用来保存字符类型的相关信息， 以及numeric_limitS用来保存数值类型的相关信息，例如某数值类型可表现之最 小值和最大值等等；命名为rmmeric limits有点让人惊讶，因为traits classes的名 称常以"traits”结束，但numeric_limits却没有遵守这种风格。

TR1 （条款54）导入许多新的traits classes用以提供类型信息，包括 is_fundamental <T> （判断T是否为内置类型），is_array<T> （判断T是否为 数组类型），以及 is_base_of<Tl, T2>（T1 和 T2 相同，抑或 T1 是 T2 的 base class）。 总计TR1 —共为标准C++添加了 50个以上的traits classes。

请记住

■ Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates 特化”完成实现。

■整合重载技术（overloading）后，traits classes有可能在编译期对类型执行 if...else 测拭。

Effective C++中文版，第三版

条款48:认识template元编程

Be aware of template metaprogramming.

Template metaprogramming (TMP，模板元编程)是编写 template-based C++ 程 序并执行于编译期的过程。花一分钟想想这个：所谓template metaprogram (模板元 程序)是以C++写成、执行于C++编译器内的程序。一旦TMP程序结束执行， 其输出，也就是从templates具现出来的若干C++源码，便会一如往常地被编译。

如果这没有带给你异乎寻常的印象，你一定是没有足够认真地思考它。

C++并非是为template metaprogramming而设计，但自从TMP于1990s初期 被发现以后，由于日渐被证明十分有用，其延伸部分很可能加入语言和标准程序库 内，使TMP更容易进行。是的，TMP是被发现而不是被发明出来的。.当templates 加入C++时TMP底层特性也就被引进了。对某些人而言唯一需要注意的是如何以 熟练巧妙而意想不到的方式使用TMP。

TMP有两个伟大的效力。第一，它让某些事情更容易。如果没有它，那些事情 将是困难的，甚至不可能的=第二，由于template metaprograms执行于C++编译 期，因此可将工作从运行期转移到编译期。这导致的一个结果是，某些错误原本通 常在运行期才能侦测到，现在可在编译期找出来。另一个结果是，使用TMP的C++ 程序可能在每一方面都更高效：较小的可执行文件、较短的运行期、较少的内存需 求。然而将工作从运行期移转至编译期的另一个结果是，编译时间变长了。是的， 程序如果使用TMP，其编译时间可能远长于不使用TMP的对应版本。

考虑p.228导入的STL advance伪码(位于条款47。或许你会想现在就阅读它， 因为本条款中我假设你已经熟悉条款47的内容)。就像p.228所示，我特别强调那 段代码的伪码部分(pseudo part):

teirplate< typename IterT, typename DistT> void advance(lterT& iter, DistT d)

{

if (iter is a random access iterator) {

iter += d； "针对random access迭代器使用迭代器算术运算

}

else {

if (d >= 0) { while (d--) ++iter; } //针对其他迭代器类型 else { while (d++) - -iter； }    //反复调用 ++ 或--

}

}

Effective C++中文版，第三版

我们可以使用typeid让其中的伪码成真，取得对此问题的一个“正常”

解决方案——所有工作都在运行期进行：

template<typename IterT, typename DistT〉 void advance(IterT& iterf DistT d)

{

if (typeid (typename std:: iterator_traits<IterT〉： ： iterator—category) typeid(std::random_access_iterator_tag)) {

iter += d;    //针对raAw/om access迭代器，使用迭代器算术运算。

}

else {

if (d >= 0) { while (d--) ++iter; } //针对其他迭代器分类 else { while (d++) - -iter; }    //反复调用 ++ 或--

}

}

条款47指出，这个typeid-based解法的效率比traits解法低，因为在此方案中，

(1)类型测试发生于运行期而非编译期，(2) “运行期类型测试”代码会出现在(或 说被连接于)可执行文件中。实际上这个例子正可彰显TMP如何能够比“正常的”

C-H-程序更髙效，因为traits解法就是TMP。别忘了，traits引发“编译期发生于 类型身上的if...else计算”。

稍早我曾谈到，某些东西在TMP比在“正常的” C++容易，对此advance也 提供了 一个好例子。条款47曾经提过advance的typeid-based实现方式可能导致 编译期问题，下面就是个例子：

std::list<int>::iterator iter;

advance (iter, 10);    //移动 iter 向前走 10 个元素；

"上述实现无法通过编译。

下面这一版advance便是针对上述调用而产生的。将template参数IterT和 DistT分别替换为iter和10的类型之后，我们得到这些：

void advance(std::list<int>::iterators iter, int d)

{

if (typeid(std::iterator_traits<std::list<int>::iterator〉：：iterator—category) ==typeid(std::random_access_iterator_tag)) {

iter += d;    //错误！

}

else {

if (d >= 0) { while (d--) ++iter; } else    { while (d++) --iter; }

}

}

Effective C++中文版，第三版

问题出在我所强调的那一行代码使用了+=操作符，那便是尝试在一个 list<int>::iterator 身上使用 +=，但 list<int>:: iterator 是 bidirectional迭代 器(见条款47),并不支持+=。只有ran咖w access迭代器才支持+=。此刻我们 知道绝不会执行起+=那一行，因为测试typeid的那一行总是会因为 list<int>::iterators而失败，但编译器必须确保所有源码都有效，纵使是不会 执行起来的代码！而当iter不是random twxess迭代器时”iter十=d”无效。与 此对比的是traits-based TMP解法，其针对不同类型而进行的代码，被拆分为不同 的函数，每个函数所使用的操作(操作符)都可施行于该函数所对付的类型。

TMP已被证明是个“图灵完全”(Turing-complete)机器，意思是它的威力大 到足以计算任何事物。使用TMP你可以声明变量、执行循环、编写及调用函数…… 但这般构件相对于“正常的”C++对应物看起来很是不同，例如条款47展示的TMP if...else条件句是藉由templates和其特化体表现出来。不过那毕竟是汇编语言层 级的TMP。针对TMP而设计的程序库(例如Boost's MPL,见条款55)提供更高 层级的语法——尽管目前还不足以让你误以为那是“正常的” C++。

为了再次浮光掠影地认识一下“事物在TMP中如何运作”，让我们看看循环。 TMP并没有真正的循环构件，所以循环效果系藉由递归(recursion)完成。如果你 对递归不太适应，恐怕必须在大胆投入TMP之前先解决它。TMP主要是个“函数 式语言”(functional language)，而递归之于这类语言就像电视之于美国通俗文化 一样地无法分割。TMP的递归甚至不是正常种类，因为TMP循环并不涉及递归函 数调用，而是涉及“递归模板具现化”(recursive template instantiation)。

TMP的起手程序是在编译期计算阶乘(factorial)。这不是个令人特别兴奋的 程序，但”hello world”程序也不是，而两者对于语言的导入都很有帮助。TMP的 阶乘运算示范如何通过“递归模板具现化”(recursive template instantiation)实现 循环，以及如何在TMP中创建和使用变量：

tempiate<unsigned n>    //—般情况：Factorial<n> 的值是

struct Factorial {    // ri 乘以 Factorial<n-1> 的值。

enum { value = n * Factorial<n-1>::value };

}；

template <>    / / 特殊情况：

struct Factorial<0> {    //Factorial<0> 的值是 1

enum { value = 1 };

}；

Effective O+中文版，第三版

有了这个 template metaprogram （其实只是个单一的 template metafunction

Factorial）,只要你指涉Factorial<n>::value就可以得到n阶乘值。

循环发生在template具现体Factorial<n〉内部指涉另一个template具现体 FactoriaKn-l〉之时。和所有良好递归一样，我们需要一个特殊情况造成递归结 束。这里的特殊情况是template特化体Factorial<0〉。

每个Factorial template具现体都是一个struct,每个struct都使用enum hack (见条款2)声明一个名为value的TMP变量，value用来保存当前计算所得的阶 乘值。如果TMP拥有真正的循环构件，value应该在每次循环内获得更新。但由 于TMP系以“递归模板具现化”(recursive template instantiation)取代循环，每个

具现体有自己的一份value,而每个value有其循环内的适当值。

你可以这样使用Factorial:

int main ()

{

std: :cout « Factorial<5>: :value;    "印出 120

std::cout « Factorial<10>::value;    //印出 3628800

}

如果你认为这比冬天吃冰淇淋还酷，你就是取得了成为一个template metaprogrammer的必要条件。如果templates和其特化版本，以及递归具现化和enum

hacks,以及键入Factorial<n-1>: :value这样的东西会使你汗毛直竖，唔......你

是个十分“正常化”的C++程序员。

当然，Factorial示范TMP的用途就只是像”hello world”示范任何传统语言 的用途一样。为求领悟TMP之所以值得学习，很重要的一点是先对它能够达成什 么目标有一个比较好的理解。下面举出三个例子：

■确保量度单位正确。在科学和工程应用程序中，确保量度单位(例如质量、距 离、时间……等等)正确结合是绝对必要的。举个例子，将一个质量变量赋值 给一个速度变量是错误的，但是将一个距离变量除以一个时间变量并将结果赋 值给一个速度变量则成立。如果使用TMP，就可以确保(在编译期)程序中所 有量度单位的组合都正确，不论其计算多么复杂。这也就是为什么TMP可被用 来进行早期错误侦测。这种TMP用途的一个有趣情况是，就连因次为分数的指 数(fractional dimensional exponents)也可支持，但分数必须先在编译期被约简，

Effective O+中文版，第三版

例如time"2的单位和time478的单位相同。

■优化矩阵运算。条款21曾经提过某些函数包括operator*必须返回新对象，而

条款44又导入了一个SquareMatrix classo考虑以下代码：

typedef SquareMatrix<double, 10000> BigMatrix;

BigMatrix ml, m2, m3, m4, m5;    //创建矩阵并

...    //赋予它们数值。

BigMatrix result = ml * m2 * m3 * m4 * m5; //计算它们的乘积。

以“正常的”函数调用动作来计算result,会创建4个暂时性矩阵，每一 个用来存储对operator*的调用结果。犹有进者，各自独立的乘法产生了 4个 作用于矩阵元素身上的循环。如果使用高级、与TMP相关的template技术，即 所谓expression templates,就有可能消除那些临时对象并合并循环，这一切都无 需改变客户端的用法（像上面那样）。于是TMP软件使用较少的内存，执行速 度又有戏剧性的提升。

■可以生成客户定制之设计模式（custom design pattern）实现品。设计模式如 Strategy （见条款35） ,Observer, Wsftor等等都可以多种方式实现出来。运用 所谓policy-based design之TMP-based技术，有可能产生一些templates用来表 述独立的设计选项（所谓"policies"）,然后可以任意结合它们，导致模式实现 品带着客户定制的行为。这项技术已被用来让若干templates实现出智能指针的 行为政策（behavioralpolicies）,用以在编译期间生成数以百计不同的智能指针 类型。这项技术已经超越编程工艺领域如设计模式和智能指针，更广义地成为 generative programming （殖生式编程）的一个基础。

不是每个人都喜欢TMP。其语法不直观，其支持工具目前还不充分（template metaprograms的调拭器？哈，还早咧！）由于TMP是一个在相对短时间之前才意 外发现的语言，其编程方式还多少需要倚赖经验。尽管如此，将工作从运行期移往 编译期所带来的效率改善还是令人印象深刻，而TMP对“难以或甚至不可能于运 行期实现出来的行为”的表现能力也很吸引人。

TMP仿佛旭日东升。有可能下一版C++会对它提供明确的支持，甚至TR1已 经这样做了（见条款54）。TMP书籍已逐渐出现，网络上的TMP信息愈来愈丰富。

Effective C++中文版，第三版

TMP或许永远不会成为主流，但对某些程序员一一特别是程序库开发人员—— 几乎确定会成为他们的主要粮食。

请记住

■    Template metaprogramming (TMP,模板元编程)可将工作由运行期移往编译期， 因而得以实现早期错误侦测和更高的执行效率。

■    TMP可被用来生成“基于政策选择组合”(based on combinations of policy choices)的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。

Effective C++中文版，第三版
