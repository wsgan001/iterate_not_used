### 第I部分 C++基础

内容

任何常用的编程语言都具备•组公共的语法特征，不同语言仅在特征的细节上有所区 别。要想学习并掌握一种编程语言，理解其语法特征的实现细节是第一步。最基本的特征 包括：

•整型、字符型等内置类型

•变量，用來为对象命名

•表达式和语句，用于操纵上述数据类型的具体值

• if或while等控制结构，这些结构允许我们有选择地执行一些语句或者重复地执 行一些语句

•函数，用于定义可供随时调用的计算单元

大多数编程语言通过两种方式来进一步补充其基本特征：一是赋予程序员自定义数裾 类型的权利，从而实现对语言的扩展：二是将一些有用的功能封装成库函数提供给程序员。

与大多数编程语言一样，C++的对象类型决定了能对该对象进行的操作，一条表达式 是否合法依赖于其中参与运算的对象的类型。一些语言，如Smalltalk和Python等，在程 序运行时检査数据类型；与之相反，C++是一种静态数据类型语言，它的类型检查发生在 编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。

C++提供了一组内置数据类型、相应的运算符以及为数不多的几种程序流控制语句， 这些元素共向构成了 CM•语言的基本形态。以这些元素为基础，我们可以编写出规模庞火、 结构复杂、用T•解决实际M题的软件系统。仅就C++的基本形态來说，它是一种简单的编 程语言，其强大的能力显示于它对程序员自定义数据结构的支持。这种支持作用巨大，显 而易见的一个事实是，C++语言的缔造者无须洞悉所有程序员的要求，而稈序员恰好可以 通过自主定义新的数据结构來使语言满足他们各自的需求。

C++中最重要的语法特征应该就是类了，通过它，程序员可以定义自己的数据类型。 为了与C++的内置类型区别开来，它们通常被称为“类类型(class type)\在一呰编程语 言中，程序员自定义的新类型仅能包含数据成员；另外一些语言，比如C++,则允许新类 型中既包含数据成员，也包含函数成员。C++语言主要的一个设计目标就是让程序员自定 义的数据类型像内置类型一样好用。基于此，标准C++库实现了丰富的类和函数。

本书第I部分的主题是学习C++语言的基础知识，这也是掌握C++语言的第一步。第 2章详述内置类型，并初步介绍了自定义数据类型的方法。第3章介绍了两种最基本的数 据类型：字符串和向量。C++和许多编程语言所共有的•一种底层数据结构——数组也在本 章有所提及，接下來，第4~6章依次介绍了表达式、语句和函数。作为第I部分的最后 ---章，第7章描述了如何构建我们自己的类，完成这一任务需要综合运用之前各章所介绍 的知识。

#### 第2章



### 变量和基本类型

内容

....................................................................................................................69

数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。

C++语言支持广泛的数据类型，它定义了几种基本内置类型（如字符、整型、浮点数 等），同时也为程序员提供了自定义数据类型的机制。基于此，C++标准库定义了一残更加 复杂的数据类型，比如可变长字符串和向量等。本章将主要讲述内置类型，并带领大家初 步了解C++语言是如何支持更复杂数据类型的。

□C>    数据类型决定了程序中数据和操作的意义。如下所示的语句是一个简单示例：

i = i + j;

其含义依赖于i和j的数据类型。如果i和j都是整型数，那么这条语句执行的就是最 普通的加法运算。然而，如果i和j是Sales_item类型的数据（参见1.5.1节，第17 页），则上述语句把这两个对象的成分相加。

##### 2.1基本内置类敬

C++定义了一套包枯算术类型（arithmetic type）和空类型（void）在内的基本数据类 型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用 于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返冋类型。

###### $6 2.1.1算术类型

算术类型分为两类：整型（integral type,包括字符和布尔类型在内）和浮点型。

算术类型的尺寸（也就是该类型数据所占的比特数）在不同机器上有所差别。表2.1 列出了 C++标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。某一类 型所占的比特数不同，它所能表示的数据范围也不一样。

| 表2.1: C++：算术类型 |                |              |
| -------------------- | -------------- | ------------ |
| 类型                 | 含义           | 最小尺寸     |
| bool                 | 布尔类型       | 未定义       |
| char                 | 字符           | 8位          |
| wchar t              | 宽字符         | 16位         |
| char16 t             | Unicode 字符   | 16位         |
| char32 t             | Unicode 字符   | 32位         |
| short                | 短整型         | 16位         |
| int                  | 整型           | 16位         |
| long                 | 长整型         | 32位         |
| long long            | 长整型         | 64位         |
| float                | 单精度浮点数   | 6位有效数字  |
| double               | 双精度浮点数   | 10位有效数字 |
| long double          | 扩展精度浮点数 | 10位有效数字 |

布尔类型（bool）的取值是真（true）或者假（false）。

C++提供了几种字符类型，其中多数支持国际化。基本的字符类型是char, 一个char 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char 的大小和一个机器字节一样。

I 33〉    其他字符类型用于扩展字符集，如wchar_t、charl6_t、char32_t。wchar_t

类型用于确保可以存放机器最大扩展字符集+的任意一个¥符，类型charl6_tln char32_t则为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）。

除字符和布尔类型之外，其他整型用于表示（可能）不同尺寸的整数。C杆语言规定 一个int至少和一个short —样大，一个long至少和一个int —样大，一个long long

至少和一个long—样大。其中，数据类型long long是在C++11中新定义的。    1 CiT 1

内a类增的机器实现

计算机以比特序列存储数据，每个比特非0即1，例如：

00011011011100010110010000111011 ...

大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字 节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。在C++语言 中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成， 字则由32或64比特构成，也就是4或8字节。

大多数计算机将内存中的每个字节与一个数字（被称为“地址（address ）”）关联起 来，在一个字节为8比特、字为32比特的机器上，我们可能看到一个字的内存区域如 下所示：

| 736424 | 0    | 0    | 1    | 1 1  | 0    | 1    | 1    |      |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 736425 | 0    | 0    | 0    | 1    | 1    | 0    | 1    | 1    |
| 736426 | 0    | 1    | 1    | 1    | 0    | 0    | 0    | 1    |
| 736427 | 0    | 1    | 1    | 0    | 0    | 1    | 0    | 0    |

其中，左侧是字节的地址，右侧是字节中8比特的具体内容„

我们能够使用某个地址来表示从这个地址开始的大小不同的比特串，例如，我们可 能会说地址736424的那个字或者地址736427的那个字节。为了赋予内存中某个地址明 确的含义，必须首先知道存储在该地址的数据的类型,，类型决定了数据所占的比特数以 及该如何解释这些比特的内容。

如果位置736424处的对象类型是float,并且该机器中float以32比特存储， 那么我们就能知道这个对象的内容占满了整个字。这个float数的实际值依赖于该机 器是如何存储浮点数的。或者如果位置736424处的对象类型是unsigned char,并且 该机器使用ISO-Latin-1字符集，则该位置处的字节表示一个分号。

浮点型可表示单精度、双精度和扩展精度值，C++标准指定了一个浮点数有效位数的 最小值，然而大多数编译器都实现了更高的精度。通常，float以1个字（32比特）来 表示，double以2个字（64比特）来表示，long double以3或4个字（96或128 比特）来表示。一般来说，类型float和double分别有7和16个有效位；类型long double则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。 CK3 带符号类型和无符号类型

除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号 的（unsigned）两种。带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于 等于0的值。

类型int、short、long和long long都是带符号的，通过在这些类型名前添加 unsigned就可以得到无符号类型，例如unsigned long.类型unsigned int可以 缩写为unsigned。

与其他整型不H，字符型被分为了二种：char、signed char和unsigned char。

特别需要注意的是：类型char和类型signed char并不一样。尽管字符型有三种，但 是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两 种形式中的一种，具体是哪种由编译器决定。

无符号类型中所有比特都用来存储值，例如，8比特的unsigned char可以表示0 至255区间内的值。

C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的 量应该平衡。因此，8比特的signed char理论上应该可以表示-127至127区间内的 值，大多数现代计算机将实际的表示范围定为-128至127。

建议：如何选择类观

和C语言一样，C++的设计准则之一也是尽可能地接近硬件。C++的算术类型必须 满足各种硬件特质，所以它们常常显得繁杂而令人不知所措。事实上，：大多数程序员能 够（也应该）对数据类型的使用做出限定从而简化选择的过程=以下是选择类型的一些 经验准则：

•当明确知晓数值不可能为负时，选用无符号类型。

•使用int执行整数运算。在实际应用中，short常常显得太小而long—般和int 有一样的尺寸。如果你的数值超过了 int的表示范围，选用long long。

•在算术表达式中不要使用char或bool,只有在存放字符或布尔值时才使用它 们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的， 所以如果使用c h a r进行运算特别容易出问题。如果你需要使用一个不大的整数， 那么明确指定它的类型是signed char或者unsigned char。

•执行浮点数运算选用double,这是因为float通常精度不够而且双精度浮点 数和单精度浮点数的计算代价相差无几。事实上，对于某些机器來说，双精度运 算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的， 况且它带来的运行时消耗也不容忽视&

###### 2.1.1节练习

练习2.1:类型int、long、long long和short的区别是什么？无符号类型和带符 号类型的区别是什么？ float和double的区别是什么？

练习2.2:计算按揭贷款时，对于利率、本金和付款分别应选择何种数据类型？说明你 的理由。

###### 檢2.1.2类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支 持，就是将对象从一种给定的类型转换（convert）为另一种相关类型。

当在程序的某处我们使用了 一种类型而其实对象应该取另一种类型时，程序会自动进 行类型转换，在4.11节（第141页）中我们将对类型转换做更详细的介绍。此处，有必要 说明当给某种类型的对象强行赋了另一种类型的值时，到底会发生什么。

当我们像下面这样把一种算术类型的值赋给另外一种类型时：

// b为真



bool b = 42;

int i = b; // i = 3.14; // double pi = i; // unsigned char c = -1; // signed char c2 = 256; //



i的值为1

i的值为3

pi的值为3.0

假设char占8比特，c的值为255 假设char占8比特，c2的值是未定义的



类型所能表示的值的范围决定了转换的过程:

•当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false, 否则结果为true。

•当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为 true则结果为1。

•当我们把一个浮点数赋给整数类型时，进行了近似处理，结果值将仅保留浮点数中 小数点之前的部分。

•当我们把一个整数值赋给浮点类型时，小数部分记为0»如果该整数所占的空间超 过了浮点类型的容量，精度可能有损失。

•当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表 示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至 255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256 取模后所得的余数=因此，把-1赋给8比特大小的unsigned char所得的结果 是 255。

•当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的(undefined)o 此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。

建议：避免无法预知和依賴于实现环境的行为

无法预知的行为源于编译器无须(有时是不能)检测的错误。即使代码编译通过了， 如果程序执行了一条未定义的表达式，仍有可能产生错误。

不幸的是，在某些情况和/或某些编译器下,含有无法预知行为的程序也能正确执行。 但是我们却无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通过的代 码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对另一组输 入就一定有效_。

程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个 确定不变的已知值，那么这样的程序就称作不可移植的(nonportable)。当程序移植到别 的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误 可不是一件轻松愉快的工作。

当在程序的某处使用了一种算术类型的值而其实所需的是另一种类型的值时，编译器 同样会执行上述的类型转换。例如，如果我们使用了一个非布尔值作为条件(参见1.4.1 节，第10页)，那么它会被自动地转换成布尔值，这一做法和把非布尔值赋给布尔变量时 的操作完全一样：

int i = 42;

if (i)    //if条件的值将为true

i = 0;

如果i的值为0,则条件的值为false; i的所有其他取值(非0)都将使条件为true-

以此类推，如果我们把一个布尔值用在算术表达式里，则它的取值非0即1，所以一 般不宜在算术表达式里使用布尔值。

eg含有无符号类型的表达式

尽管我们不会故意给无符号对象赋一个负值，却可能（特别容易）写出这么做的代码。 例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号 数。把int转换成无符号数的过程和把int直接赋给无符号变量一样：

unsigned u = 10; int i = -42;

std: :cout << i + i << std: :endl; // 输出-84

std: :cout « u + i « std: :endl; // 如果 int 占 32 位，输出 4294967264

在第一个输出表达式里，两个（负）整数相加并得到了期望的结果。在第二个输出表达式 里，相加前首先把整数-42转换成无符号数。把负数转换成无符号数类似于直接给无符号 数赋一个负值，结果等于这个负数加上无符号数的模。

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不 能是一个负值：

| 37 〉 unsigned ul = 42, u2 = 10;

std: : cout « ul - u2 « std: :endl; // 正确：输出 32

std: :cout << u2 - ul << std::endl; //正确：不过，结果是取模后的值

无符号数不会小于0这一事实同样关系到循环的写法。例如，在1.4.1节的练习（第11页） 中需要写一个循环，通过控制变量递减的方式把从10到0的数字降序输出。这个循环可 能类似于下面的形式：

for （int i = 10; i >= 0; --i）

std::cout « i « std::endl;

可能你会觉得反正也不打算输出负数，可以用无符号数来重写这个循环。然而，这个不经 意的改变却意味着死循环：

//错误：变量u永远也不会小于0,循环条件一直成立 for （unsigned u = 10; u >= 0;——u）

std::cout « u « std::endl;

来看看当u等于0时发生了什么，这次迭代输出0,然后继续执行for语句里的表达式。 表达式一11从11当中减去1,得到的结果-1并不满足无符号数的要求，此时像所有表示范 围之外的其他数字一样，-1被自动地转换成一个合法的无符号数。假设int类型占32 位，则当u等于0时，--U的结果将会是4294967295。

一种解决的办法是，用while语句来代替for语句，因为前者让我们能够在输出变 量之前（而非之后）先减去1:

unsigned u = 11; //确定要输出的最大数，从比它大1的数开始 while （u > 0）{

—u;    / /先减1，这样最后一■次迭代时就会输出0

std::cout << u « std::endl;

}

改写后的循环先执行对循环控制变量减1的操作，这样最后一次迭代时，进入循环的U值 为1。此时将其减1,则这次迭代输出的数就是0:下一次再检验循环条件吋，u的值等

于0而无法再进入循环。因为我们要先做减1的操作，所以初始化u的值应该比要输出 的最大值大1。这里，u初始化为11，输出的最大数是10。

提示：切勿混用带符号类概和无符唼类彻

如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异 常结杲，这是因为带符号数会自动地转换成无符号数。例如，在一个形如a*b的式子 中，如果a = -1, b = 1,而且a和b都是int,则表达式的值显然为-1。然而，如 果a是int,而b是unsigned,则结果须视在当前机器上int所占位数而定在我 们的环境里，结果是4294967295。

###### 2.1.2节练习

<38~|



练习2.3:读程序写结果。

| unsigned u | =           | 10,  | u2 = 42; |              |         |
| ---------- | ----------- | ---- | -------- | ------------ | ------- |
| std:       | :cout       | «    | u2       | -u « std     | ::endl; |
| std:       | :cout       | «    | u _      | u2 « std     | ::endl; |
| intstd:    | i = 10:cout | t«   | i2 =i2   | 42;-i« std:: | endl;   |
| std:       | :cout       | «    | i -      | i2<< std:    | :endl;  |
| std:       | ::cout      | «    | i -      | u« std::     | endl;   |
| std:       | ::cout      | «    | u -      | i« std::     | endl;   |

练习2.4:编写程序检查你的估计是否正确，如果不正确，请仔细研读本节直到弄明白 问题所在。

###### 2.1.3字面值常量

一个形如42的值被称作字面值常量（literal）,这样的值一望而知。每个字面值常量 都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

整型和浮点型字面值

我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整 数代表八进制数，以Ox或0X开头的代表十六进制数。例如，我们能用下面的任意一种 形式来表示数值20:

20 /*十进制*/    024 /*八进制*/    0x14 /*十六进制*/

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数， 八进制和十六进制字面值既可能是带符号的也可能是无符号的。十进制字面值的类型是 int、long和long long中尺寸最小的那个（例如，三者当中最小是int）,当然前提 是这种类型要能容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的 int、unsigned int、long、unsigned long、long long 和 unsigned long long 中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。 类型short没有对应的字面值。在表2.2 （第37页）中，我们将以后缀代表相应的字面 值类型。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负

数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的 作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识：

3.14159    3.14159E0    0.    OeO    .001

L39＞默认的，浮点型字面值是一个double,我们可以使用表2.2 （第37页）中的后缀来表示 其他浮点型。

字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则 构成字符串型字面值。

'a'    II字符字面值

"Hello World! "    //字符串字面值

字符串字面值的类型实际上是由常量字符构成的数组（array）,该类型将在3.5.4节（第 109页）介绍。编译器在每个字符串的结尾处添加一个空字符（AO1）,因此，字符串字 面值的实际长度要比它的内容多1=例如，字面值'A'表示的就是单独的字符A,而字符 串”A”则代表了一个字符的数组，该数组包含两个字符：一个是字母A、另一个是空字符。

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一 个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的 方式：

II分多行书写的字符串字面值

std::cout « "a really, really long string literal "that spans two lines" « std::endl;

转义序列

有两类字符程序员不能直接使用：一类是不可打印（nonprintable）的字符，如退格或 其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单 引号、双引号、问号、反斜线）=在这些情况下需要用到转义序列（escape sequence）,转 义序列均以反斜线作为开始，C++语言规定的转义序列包括：

| 换行符     | \n   | 横向制表符 | \t   | 报警（响铃）符 | \a   |
| ---------- | ---- | ---------- | ---- | -------------- | ---- |
| 纵向制表符 | \v   | 退格符     | \b   | 双引号         | V    |
| 反斜线     | \\   | 问号       | \?   | 单引号         |      |
| 回车符     | \r   | 进纸符     | \f   |                |      |

在程序中，上述转义序列被当作一个字符使用：

std: :cout « r \nr;    // 转到新一行

std::cout «    //输出一个制表符，输出"Hi!",转到新一行

我们也可以使用泛化的转义序列，其形式是\*后紧跟1个或多个十六进制数字，或者\后 紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。假设使用的 是Latin-1字符集，以下是一些示例：

\7 （响铃） \12 （换行符）    \40（空格）

\0 （空字符）\115 （字符M）    \x4d （字符M）

S＞我们可以像使用普通字符那样使用C++语言定义的转义序列：

std: : cout « "Hi \x4dO\115!\n";    //输出 Hi MOM!,转到新一行

std::cout «    << '\n';    //输出 M，转到新一行

注意，如果反斜线\后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列。 例如，”\1234”表示2个字符，即八进制数123对应的字符以及字符4。相反，\x要用 到后面跟着的所有数字，例如，•’\xl234”表示一个16位的字符，该字符由这4个十六 进制数所对应的比特唯一确定。因为大多数机器的char型数据占8位，所以上面这个例 子可能会报错=一般来说，超过8位的十六进制字符都是与表2.2中某个前缀作为开头的 扩展字符集一起使用的。

指定字面值的类型

通过添加如表2.2中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默 认类型。

L,a,

u8，'hi!n

42ULL

1E-3F

3.14159L



//宽字符型字面值，类型是wchar_t

// utf-8字符串字面值（utf-8用8位编码一个Unicode字符） //无符号整型字面值，类型是unsigned long long //单精度浮点型字面值，类型是float

//扩展精度浮点型字面值，类型是long double

Best    当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母1和数

字1太容易混淆了。夂

表2.2:指定字面值的类型

字符和字符串字面值

| 前缀     | 含义                           | 类型         |             |
| -------- | ------------------------------ | ------------ | ----------- |
| u        | Unicode 16 字符                |              | charl6_t    |
| U        | Unicode 32 字符                |              | char32 t    |
| L        | 宽字符                         |              | wchar t     |
| u8       | UTF-8 （仅用于字符串字面常量） | char         |             |
|          | 整型字面值                     | 浮点型字面值 |             |
| 后缀     | 最小匹配类型                   | 后缀         | 类型        |
| u or U   | unsigned                       | f或F         | float       |
| 1 orL    | long                           | 1或L         | long double |
| 11 or LL | long long                      |              |             |

对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。如果后 缀中有U,则该字面值属于无符号类型，也就是说，以U为后缀的十进制数、八进制数或 十六进制数都将从 unsigned int、unsigned long 和 unsigned long long 中选择 能匹配的空间最小的一个作为其数据类型。如果后缀中有L,则字面值的类型至少是long; 如果后缀中有LL，则字面值的类型将是long long和unsigned long long中的一种。 显然我们可以将U与L或LL合在一起使用。例如，以UL为后缀的字面值的数据类型将 根据具体数值情况或者取unsigned long，或者取unsigned long long。

on



布尔字面值和指针字面值

true和false是布尔类型的字面值：

bool test =



false;



nullptr是指针字面值，2.3.2节(第47页)将有更多关丁•指针和指针字面值的介绍。

###### 2.1.3节练习

练习2.5:指出下述字面值的数据类型并说明每一组内几种字面值的区别：

\1/

abed



'a', L'a', "a", L"a"

10, lOu, 10L, lOuL, 012, OxC

3.14, 3.14f, 3.14L

10, lOu, 10., 10e-2

练习2.6:下面两组定义是否有区别，如果有，请叙述之：

int month = 9, day = 7; int month = 09, day = 07;

练习2.7:下述字面值表示何种含义？它们各自的数据类型是什么？

(a)    "Who goes with F\145rgus?\012n

(b)    3.14elL    (c) 1024f    (d) 3.14L

练习2.8:请利用转义序列编写一段程序，要求先输出2M,然后转到新一行。修改程序 使其先输出2,然后输出制表符，再输出M,最后转到新一行。
