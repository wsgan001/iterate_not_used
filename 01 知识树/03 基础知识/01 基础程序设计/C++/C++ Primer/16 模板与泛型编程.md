第16章

### 模板与泛型编程

<65T|



内容

面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之 处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译吋就能 获知类型了。

本书第II部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛 型程序吋，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型 或值，程序实例可在其上运行。

例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这 个泛型定义来定义很多类型的vector,它们的差异就在于包含的元素类型不同。

模板是泛型编程的基础。我们不必了解模板是如何定义的就能使用它们，实际上我们 已经这样用了。在本章中，我们将学习如何定义自己的模板。

[652>    模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。

当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信 息，将蓝图转换为特定的类或函数。这种转换发生在编译时。在本书第3章和第II部分中 我们已经学习了如何使用模板。在本章中，我们将学习如何定义模板。

##### 16.1定义模板

假定我们希望编写一个函数来比较两个值，并指出第一个值是小于、等于还是大于第 二个值。在实际中，我们可能想要定义多个函数，每个函数比较一种给定类型的值。我们 的初次尝试可能定义多个重载函数：

//如果两个值相等，返回0，如果vl小返回-1，如果v2小返回1 int compare(const string &vl, const string &v2)

{

if (vl < v2) return -1; if (v2 < vl) return 1; return 0;

}

int compare(const double &vl, const double &v2)

{

if (vl < v2) return -1; if (v2 < vl) return 1; return 0;

}

这两个函数几乎是相同的，唯一的差异是参数的类型，函数体则完全一样。

如果对每种希望比较的类型都不得不重复定义完全一样的函数体，是非常烦琐且容易 出错的。更麻烦的是，在编写程序的时候，我们就要确定可能要compare的所有类型。 如果希望能在用户提供的类型上使用此函数，这种策略就失效了。

###### 50 16.1.1函数模板

我们可以定义一个通用的函数模板(function template),而不是为每个类型都定义一 个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare 的模板版本可能像下面这样：

template <typename T>

int compare(const T &vl, const T &v2)

{

if (vl < v2) return -1; if (v2 < vl) return 1; return 0;

}

L-6533>模板定义以关键字template开始，后跟一个模板参数列表(template parameter list)，这 是一个逗号分隔的一个或多个模板参数(template parameter)的列表，用小于号(<)和大 于号(>)包围起来。

在模板定义中，模板参数列表不能为空。

模板参数列表的作用很像函数参数列表。函数参数列表定义了若干特定类型的局部变 量，但并末指出如何初始化它们。在运行时，调用者提供实参来初始化形参。

类似的，模板参数表示在类或函数定义中用到的类型或值。当使用模板吋，我们(隐 式地或显式地)拒定模板实参(template argument),将其绑定到模板参数上。

我们的compare函数声明了一个名为T的类型参数。在compare中，我们用名字T 表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况來确定。

实例化函数模板

当我们调用一个函数模板时，编译器(通常)用函数实参来为我们推断模板实参，即， 当我们调用compare时，编译器使用实参的类型來确定绑定到模板参数T的类型。例如， 在下面的调用中：

cout « compare(1, 0) « endl; // T 为 int

实参类型是int。编译器会推断出模板实参为int,并将它绑定到模板参数T。

编译器用推断出的模板参数来为我们实例化(instantiate) 个特定版本的函数。当编 译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的个 新"实例”。例如，给定下面的调用：

//实例化出int compare(const int&, const int&) cout « compare(1, 0) << endl; // T 为 int

// 实例化出 int compare (const vector<int>&, const vector<int>&)

vector<int> vecl{1, 2, 3}, vec2{4, 5, 6};

cout << compare (vecl, vec2) << endl; // T 为 vector<int>

编译器会实例化出两个不同版本的compareo对于第一个调用，编译器会编写并编译一 个compare版本，其中T被锌换为int:

int compare(const int &vl, const int &v2)

{

if (vl < v2) return -1; if (v2 < vl) return 1; return 0;

}

对于第二个调用，编译器会生成另一个compare版本，其中T被转换为vector<int>。 这些编译器生成的版本通常被称为模板的实例(instantiation)o 模板类型参数

<654~|



我们的compare函数有一个模板类型参数(type parameter)。一般来说，我们可以将 类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可 以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：

//正确：返回类型和参数类型相同 template <typename T> T foo(T* p)

{

T tmp = *p; // tmp的类型将是指针p指向的类型 //...

return tmp;

类型参数前必须使用关键字class或typename：

//错误：U之前必须加上class或typename

template〈typename T, U> T calc (const T&, const U&);

在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以 同时使用这两个关键字：

//正确：在模板参数列表中，typename和class没有什么不同 template <typename T, class U> calc (const T&, const U&);

看起来用关键字typename来指定模板类型参数比用class更为直观。毕竟，我们 可以用内置(非类)类型作为模板类型实参。而且，typename更清楚地指出随后的名字 是一个类型名。但是，typename是在模板已经广泛使用之后才引入C++语言的，某些程 序员仍然只用class。

非类型模板参数

除了定义类型参数，还可以在模板中定义非类型参数(nontype parameter)。一个非类 型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或 typename来指定非类型参数。

当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。 这些值必须是常量表达式(参见2.4+4节，第58页)，从而允许编译器在编译时实例化 模板。

例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const char的数组。由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用(参见 6.2.4节，第195页)。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义 了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数 组的长度：

I 655〉    template<unsigned N, unsigned M>

int compare(const char (&pl)[N], const char (&p2)[M])

return strcrap(pi, p2);

1

当我们调用这个版本的compare时： compare("hi", "mom")

编译器会使用字面常量的大小来代替N和M,从而实例化模板。记住，编译器会在一个字 符串字面常量的末尾插入一个空字符作为终结符(参见2.1.3节，第36页)，因此编译器 会实例化出如下版本：

int compare(const char (&pl) [3], const char (&p2) [4])

一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或(左值) 引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参 数的实参必须具有静态的生存期(参见第12章，第400页)。我们不能用一个普通(非 static)局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以 用nullptr或一个值为0的常量表达式来实例化。

在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用

非类型参数，例如，指定数组大小。

非类型模板参数的模板实参必须是常量表达式。

inline和constexpr的函数模板

函数模板可以声明为inline或constexpr的，如同非模板函数一样。inline或 constexpr说明符放在模板参数列表之后，返冋类型之前：

//正确：inline说明符跟在模板参数列表之后

template <typename T> inline T min(const T&, const T&);

//错误：inline说明符的位置不正确

inline template <typename T> T min(const T&, const T&);

编写类型无关的代码

我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则：

•模板中的函数参数是const的引用。

•函数体中的条件判断仅使用 < 比较运算。

通过将函数参数设定为const的引用，我们保证了函数可以用于不能拷贝的类型。大多<656： 数类型，包括内置类型和我们己经用过的标准库类型(除unique_ptr和IO类型之外)，

都是允许拷贝的。但是，不允许拷贝的类类型也是存在的。通过&参数设定为const的 引用，保证了这些类型可以用我们的compare函数来处理。而且，如果compare用于 处理大对象，这种设计策略还能使函数运行得更快。

你可能认为既使用<运算符又使用>运算符来进行比较操作会更为自然：

//期望的比较操作 if (vl < v2) return -1; if (vl > v2) return 1; return 0;

但是，如果编写代码时只使用<运算符，我们就降低了 compare函数对要处理的类型的 要求。这些类型必须支持<,但不必同时支持>»

实际上，如果我们真的关心类型无关和可移植性，可能需要用less (参见14.8.2节，

第510页)来定义我们的函数：

//即使用于指针也正确的compare版本；参见14.8.2节(第510页) template <typename T> int compare(const T &vl, const T &v2)

{

if (less<T> () (vl, v2)) return -1; if (less<T> () (v2, vl)) return 1; return 0;

}

原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，

则代码的行为是未定义的(据查阅资料，less<T>的默认实现用的就是<,所以这其实并 未起到让这种比较有一个良好定义的作用——译者注)。

Prcustices 模板程序虚该尽量减少对实参类型的要求。

3编译器遇到-个模板定义吋，它并不生成代码。只有当我们实例化出模板的一个特 定版本时，编译器才会生成代码。当我们使用(而不是定义)模板时，编译器才生成代码， 这一特性影响了我们如何组织代码以及错误何时被检测到。

通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用 -个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我

们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。

模板则不同：为了生成•个实例化版本，编译器需要掌握函数模板或类模板成员函数 的定义，因此，与非模板代码不模板的头文件通常既包括声明也包括定义。

K键概念：投板和头文件

模板包含两种名字：

•那些不依赖于模板参数的名字

•那些依赖于模板参数的名字

当使用模板时，所有不依赖干模板参数的名字都必须是可见的，这是由模板的提供者来 保证的。而且，模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板 的成员的定义，也必须是可见的。

用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见 的，这是由模板的用户来保证的。

通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计 者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声 明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件、

大多数编译错误在实例化期间报告

模板直到实例化吋才会生成代码，这一特性影响了我们何时才会获知模板内代码的编 译错误，通常，编译器会在三个阶段报告错误，

第•个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器 可以检查语法错误，例如忘记分0或者变量名拼错等，但也就这么多了。

第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对 r函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。 对于类模板，编译器可以检查用户是否提供了正确数因的模板实参，但也仅限于此了。

第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖f编译器 如何管理实例化，这类错误可能在链接时才报告。

当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类型 有-些假设。例如，我们最初的compare函数中的代码就假定实参类型定义了<运算符。

if (vl < v2) return -1;    //要求类型T的对象支持〈操作

if (v2 < vl) return 1;    //要求类型T的对象支持〈操作

return 0;    //返回int;不依軸于T

当编译器处理此模板时，它不能验证if语句中的条件是否合法。如果传递给compare <658j 的实参定义了<运算符，则代码就是正确的，否则就是错误的。例如，

Sales_data datal, data2;

cout << compare （datal, data2） << endl; // 错误：Sales_data 未定义<

此调用实例化了 compare的一个版本，将T替换为Sales_data- if条件试图对 Sales_data对象使用<运算符，但Sales_data并未定义此运算符。此实例化生成了 一个无&编译通过的函数版本。但是，这样错误直至编译器在类型Sales_data上实 例化compare时才会被发现。

WARNING



保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确 工作，是调用者的责任。

###### 16.1.1节练习

练习16.1:给出实例化的定义。

练习16.2:编写并测试你自己版本的compare函数。

练习16.3:对两个Sales_data对象调用你的compare函数，观察编译器在实例化 过程中如何处理错误。

练习16.4:编写行为类似标准库find算法的模板。函数需要两个模板类型参数，-个 表示函数的迭代器参数，另一个表示值的类型。使用你的函数在一个 一个list<string>中查找给定值。

练习16.5:为6.2.4节（第195页）中的print函数编写模板版本，它接受一个数组的 引用，能处理任意大小、任意元素类型的数组。

练习16.6：你认为接受一个数组实参的标准庠函数begin和end是如何工作的？定义 你自己版本的begin和end。

练习16.7:編写一个constexpr模板，返回给定数组的大小。

练习16.8:在第97页的“关键概念”中，我们注意到，C++程序员喜欢使用！=而不喜 欢<。解释这个习惯的原因。

###### 16.1.2类模板    $0

类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器 不能为类模板推断模板参数类型。如我们已经多次看到的，为了使用类模板，我们必须在 模板名后的尖括号中提供额外信息（参见3.3节，第87页）——用来代替模板参数的模板<§59] 实参列表。

定义类模板

作为一个例子，我们将实现StrBlob （参见12.1.1节，第405页）的模板版本。我 们将此模板命名为Blob,意指它不再针对string。类似StrBlob,我们的模板会提供 对元素的共享（且核查过的）访问能力。与类不同，我们的模板可以用于更多类型的元素。

与标准库容器相同，当使用Blob时，用户需要指出元素类型。

类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板(及 其成员)的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值:

template <typename T> class Blob { public:

typedef T value_type;

typedef typename std::vector<T>::size_type size_type;

//构造函数 Blob();

Blob(std::initializer_list<T> il);

// Blob中的元素数目

size_type size() const { return data->size(); } bool empty() const { return data->empty(); }

//添加和删除元素

void push_back(const T &t) {data-〉push_back(t);}

//移动版本，参见13.6.3节(第484页)

void push—back(T &&t)    { data->push_back(std::move(t));    }

void pop_back();

//元•访问 T& back();

T& operator [ ] (size_type i) ; // 在 14.5 节(第 501 瓦)中定义 private:

std::shared_ptr<std::vector<T>> data;

//若data [i]无效，则抛出msg

void check(size_type i, const std::string &msg) const;

}；

我们的Blob模板有一个名为T的模板类型参数，用来表示Blob保存的元素的类型。例 如，我们将元素访问操作的返回类型定义为T&。当用户实例化Blob时，T就会被替换为 特定的模板实参类型。

除了模板参数列表和使用T代替string之外，此类模板的定义与12.1.1节(第405 页)中定义的类版本及12.1.6节(第422页)和第13章、第14章中更新的版本是一样的。

X>实例化类模板

我们已经多次见到，当使用一个类模板时，我们必须提供额外信息。我们现在知道这 些额外信息是显式模板实参(explicit template argument)列表，它们被绑定到模板参数。 编译器使用这些模板实参来实例化出特定的类。

例如，为了用我们的Blob模板定义一个类型，必须提供元素类型：

Blob<int> ia;    // 空 Blob<int>

Blob<int> ia2 = {0,1,2,3,4}; // 有 5 个元素的 Blobcint〉

ia和ia2使用相同的特定类型版本的Blob (即Blob<int>)。从这两个定义，编译器 会实例化出一个与下面定义等价的类：

template <> class Blob<int> {

typedef typename std::vector<int>::size_type size_type; Blob ();

Blob(std::initializer_list<int> il);

//...

int& operator[](size_type i);

private:

std::shared_ptr<std::vector<int>> data;

void check（size_type i, const std::string &msg） const;

｝；

当编译器从我们的Blob模板实例化出一个类时，它会重写Blob模板，将模板参数T的 每个实例替换为给定的模板实参，在本例中是int。

对我们指定的每一种元素类型，编译器都生成一个不同的类，

//下面的定义实例化出两个不同的Blob类型 Blob<string> names; // 保存 string 的 Blob Blob<double> prices; //不同的元素类型

这两个定义会实例化出两个不同的类。names的定义创建了一个Blob类，每个T都被替 换为string。prices的定义生成了另一个Blob类，T被替换为double。

![img](C++  Primer 5-152.jpg)



一个类模板的每个实例都形成一个独立的类。类哩Blob<string〉与任何其 他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限」

在模板作用域中引用模板类型

为了阅读模板类代码，应该记住类模板的名字不是一个类型名（参见3.3节，第87 页）。类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。

可能令人迷惑的是，一个类模板中的代码如果使用了另外一个模板，通常不将一个实 际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用 模板的实参。例如，我们的data成员使用了两个模板，vector和shared_ptr。我们<661 | 知道，无论何时使用模板都必须提供模板实参，在本例中，我们提供的模板实i就是Blob 的模板参数。因此，data的定义如下：

std::shared_ptr<std::vector<T» data;

它使用了 Blob的类型参数来声明data是一个shared_ptr的实例，此shared_ptr 指向一个保存类型为T的对象的vector实例。当我们实7例化一个特定类型的Blof,例 如 Blob<string>R^，data 会成为：

shared_ptr<vector<string»

如果我们实例化Blob<int>，则data会成为shared_ptr<vector<int»,依此类推。

类模板的成员函数

与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函 数，且定义在类模板内的成员函数被隐式声明为内联函数。

类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的 成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之 外的成员函数就必须以关键字template开始，后接类模板参数列表。

与往常一样，当我们在类外定义一个成员时，必须说明成员属于哪个类。而且，从一 个模板生成的类的名字中必须包含其模板实参。当我们定义一个成员函数时，模板实参与 模板形参相同。即，对于StrBlob的一个给定的成员函数

ret-type StrBlob: :member-name(parm-list)

对应的Blob的成员应该是这样的：

template ctypename T>

ret-type Blob<T>: :member-name(parm-list)

check和元素访问成员

我们首先定义check成员，它检查一个给定的索引:

template <typename T>

void Blob<T>::check(size_type i, const std::string &msg) const {

if (i >= data->size())

throw std::out_of_range(msg);

}

除了类名中的不同之处以及使用了模板参数列表外，此函数与原StrBlob类的check成 员完全一样。

下标运算符和back函数用模板参数指出返回类型，其他未变：

| 662〉    template <typename T>

T& Blob<T>::back()

check(0, "back on empty Blob"); return data->back();

}

template <typename T>

T& Blob<T>::operator[](size_type i)

{

//如果i大大，check会抛出异常，阻止访问一个不存在的元素 check(i, "subscript out of range"); return (*data)[i];

}

在原StrBlob类中，这些运算符返回strings。而模板版本则返回一个引用，指向用来 实例化Blob的类型。

pop_back函数与原StrBlob的成员几乎相同：

template <typename T> void Blob<T>::pop_back()

{

check(0, "pop_back on empty Blob"); data->pop_back();

}

在原StrBlob类中，下标运算符和back成员都对const对象进行了重载。我们将这些 成员及front成员的定义留作练习。

Blob构造函数

与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始：

template <typename T>

Blob<T>: :Blob () : data (std: :make_shared<std: : vector<T»() )    { }

这段代码在作用域Blob<T>中定义了名为Blob的成员函数。类似StrBlob的默认构造

函数(参见12.1.1节，第405页)，此构造函数分配一个空vector,并将指向vector 的指针保存在data中。如前所述，我们将类模板自己的类型参数作为vector的模板实 参来分配vector。

类似的，接受一个initializer_list参数的构造函数将其类型参数T作为 initializer_list参数的元素类型：

template <typename T>

Blob<T>::Blob(std::initializer_list<T> il):

data(std::make_shared<std::vector<T»(il))    { }

类似默认构造函数，此构造函数分配一个新的vector。在本例中，我们用参数il来初 始化此vector。

为了使用这个构造函数，我们必须传递给它一个initialiZer_liSt,其中的元素 必须与Blob的元素类型兼容：

Blob<string> articles = {"a",    "an", "the"};

这条语句中，构造函数的参数类型为initializer_list<string>。列表中的每个字 符串字面常量隐式地转换为一个string。

< 663 1



类模板成员函数的实例化

默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。例如，下面代码

//实例化Blob<int>和接受initializer_list<int>的构造函数

Blob<int> squares = {0,1,2,3,4,5,6,7,8,9};

// 实例化 Blob<int>: :size() const

for (size_t i = 0; i != squares.size(); ++i)

squares [i ] = i*i; // 实例化 Blob<int> :: operator [](size_t)

实例化了 Blob<int>类和它的三个成员函数：operator [] > size和接受 initializer_list<int> 的构造函数。

如果一个成员函数没有被使用，则它不会被实例化。成员函数只有在被用到时才进行 实例化，这一特性使得即使某种类型不能完全符合模板操作的要求(参见9.2节，第294 页)，我们仍然能用该类型实例化类。

![img](C++  Primer 5-153.jpg)



默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。

在类代码内简化模板类名的使用

当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板 自己的作用域中，我们可以直接使用模板名而不提供实参：

//若试图访问一个不存在的元素，BlobPtr抛出一个异常 template <typename T> class BlobPtr { public:

BlobPtr(): curr(0)    { }

BlobPtr(Blob<T> &a, size_t sz = 0):

wptr(a.data), curr(sz) { }

T& operator*() const

{ auto p = check (curr, "dereference past end，，)； return (*p) [curr] ; // (*p)为本对象指向的 vector

}

//递增和递减

BlobPtr& operator++() ； // 前置运算符 BlobPtr& operator——()；

private:

//若检查成功，check返回一个指向vector的shared_ptr std::shared_ptr<std::vector<T>>

check(std::size_t, const std::strings) const;

//保存一个weak_ptr，表示底层vector可能被销毁 std::weak_ptr<std::vector<T>> wptr; std: : size_t curr; //数组中的当前位置

}；

细心的读者可能已经注意到，BlobPtr的前置递增和递减成员返回BlobPtr&,而不是 BlobPtr<T>&o当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好

E6M>像我们已经提供了与模板参数匹配的实参一样。即，就好像我们这样编写代码一样：

BlobPtr<T>& operator++();

BlobPtr<T>& operator——();

在类模板外使用类模板名

当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类 名才表示进入类的作用域(参见7.4节，第253页)：

//后置：递增/递减对象但返回原值 template <typename T>

BlobPtr<T> BlobPtr<T>::operator++(int)

{

//此处无须检查；调用前置递增时会进行检查 BlobPtr ret = *this; // 保存当前值 ++*this; //推进一个元素；前置++检查递增是否合法 return ret; //返回保存的状态

}

由于返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的BlobPtr, 它所用类型与类实例化所用类型一致。在函数体内，我们己经进入类的作用域，因此在定 义ret时无须重复模板实参。如果不提供模板实参，则编译器将假定我们使用的类型与 成员实例化所用类型一致，因此，ret的定义与如下代码等价：

BlobPtr<T> ret = *this;

在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。

类模板和友元

当一个类包含一个友元声明(参见7.2.1节，第241页)时，类与友元各自是否是模 板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板 实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

一对一友好关系

类模板与另一个(类或函数)模板间友好关系的最常见的形式是建立对应实例及其友 元间的友好关系。例如，我们的Blob类应该将BlobPtr类和一个模板版本的Blob相

等运算符（最初是在14.3.1节（第498页）练习中为StrBlob定义的）定义为友元。

为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板 声明包括模板参数列表：

//前置声明，在Blob中声明友元所需要的

< 665 1



template

template

template

bool



<typename> class BlobPtr;

<typename> class Blob; //运算符==中的参数所需要的 <typename T>

operator==(const Blob<T>&, const Blob<T>&);

template <typename T> class Blob {

//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符 friend class BlobPtr<T>;

friend bool operator==<T>

(const Blob<T>&, const Blob<T>&);

//其他成员定义，与12.1.1 (第405页)相同

我们首先将Blob、BlobPtr和operator==声明为模板。这些声明是operator==0 数的参数声明以及Blob中的友元声明所需要的。

友元的声明用Blob的模板形参作为它们自己的模板实参。因此，友好关系被限定在 用相同类型实例化的Blob与BlobPtr相等运算符之间：

Blob<char> ca; // BlobPtr<char〉和 operator==<char>都是本对象的友元 Blob<int> ia; // BlobPtr<int>和 operator==<int〉都是本对象的友元

BlobPtr<char〉的成员可以访问ca （或任何其他Blob<char>对象）的非public部 分，但ca对ia （或任何其他Blobdrit〉对象）或Blob的任何其他实例都没有特殊访 问权限。

通用和特定的模板友好关系

一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为 友元：

//前置声明，在将模板的一个特定实例声明为友元时要用到 template <typename T> class Pal; class C { // C是一个普通的非模板类

friend class Pal<C>; //用类C实例化的Pal是C的一个友元 // Pal2的所有实例都是C的友元；这种情况无须前置声明 template <typename T> friend class Pal2;

}；

template ctypename T> class C2 { // C2 本身是一个类模板 // C2的每个实例将相同实例化的Pal声明为友元 friend class Pal<T>; // Pal的模板声明必须在作用域之内 // Pal2的所有实例都是C2的每个实例的友元，不需要前置声明 template <typename X〉 friend class Pal2;

// Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; //不需要Pal3的前置声明

}；

为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。

[»令模板自己的类型参数成为友元

py]    在新标准中，我们可以将模板类型参数声明为友元：

template ctypename Type〉 class Bar { friend Type; //将访问权限授予用来实例化Bar的类型

}；

此处我们将用来实例化Bar的类型声明为友元。因此，对于某个类型名Foo, Foo将成 为 Bar<Foo>W友元，Sales一data 将成为 Bar<Sales_data>W友元，依此类推》

值得注意的是，虽然友元通常来说应该是一个类或是一个函数，但我们完全可以用一 个内置类型来实例化Bar。这种与内置类型的友好关系是允许的，以便我们能用内置类型 来实例化Bar这样的类。

模板类型别名

类模板的-个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个 typedef （参见2.5.1节，第60页）来引用实例化的类：

typedef Blob<string> StrBlob;

这条typedef语句允许我们运行在12.1.1节（第405页）中编写的代码，而使用的却是 用string实例化的模板版本的Blob。由于模板不是一个类型，我们不能定义一个 typedef引用一个模板。即，无法定义一个typedef引用Blob<T>。

岡 但是，新标准允许我们为类模板定义一个类型别名：

tempiate<typename T> using twin = pair<T, T>; twin<string> authors; II authors是一个pair<string, string>

在这段代码中，我们将twin定义为成员类型相同的pair的别名。这样，twin的用户 只需指定一次类型。

一个模板类型别名是一族类的别名：

twin<int> win_loss; // win_loss是一个pair<int, int> twin<double> area; // area是一个pair<double, double>

就像使用类模板一样，当我们使用twin时，需要指出希望使用哪种特定类型的twin。 当我们定义一个模板类型别名时，可以固定一个或多个模板参数：

template <typename T> using partNo = pair<T, unsigned〉； partNo<string> books; // books 是一个 pair<string, unsigned〉 partNo<Vehicle> cars; // cars 是一个 pair<Vehicle, unsigned〉 partNo<Student> kids; // kids 是一个pair<Student, unsigned>

这段代码中我们将partNo定义为一族类型的别名，这族类型是second成员为 unsigned的pair。partNo的用户需要指出pair的first成员的类型，但不能指定 second成员的类型。

E667>类模板的static成员

与任何其他类相同，类模板可以声明static成员（参见7.6节，第269页）:

template <typename T> class Foo { public:

static std::size_t count ()    { return ctr; }

//其他接口成员

private:

static std::size_t ctr;

//其他实现成员

}；

在这段代码中，Foo是一个类模板，它有一个名为count的public static成员函数 和一个名为ctr的private static数据成员。每个Foo的实例都有其自己的static 成员实例。即，对任意给定类型X，都有一个Foo<X> : : ctr和一个Foo<X> : : count 成员。所有Foo<X〉类型的对象共享相同的ctr对象和count函数。例如，

// 实例化 static 成员 Foo<string〉： ： ctr 和 Foo<string>:: count

Foo<string> fs;

//所有三个对象共享相同的Foo<int>: : ctr和Foo<int>: :count成员

Foo<int> fi, fi2, fi3;

与任何其他static数据成员相同，模板类的每个static数据成员必须有且仅有一 个定义。但是，类模板的每个实例都有一个独有的static对象。因此，与定义模板的成 员函数类似，我们将static数据成员也定义为模板：

template <typename T>

size_t Foo<T>: :ctr = 0; // 定义并初始化 ctr

与类模板的其他任何成员类似，定义的开始部分是模板参数列表，随后是我们定义的成员 的类型和名字。与往常一样，成员名包括成员的类名，对于从模板生成的类来说，类名包 括模板实参。因此，当使用一个特定的模板实参类型实例化Foo吋，将会为该类类型实 例化一个独立的ctr,并将其初始化为0。

与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的static 成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问static成 员，我们必须引用一个特定的实例：

Foo<int> f i;    // 实例化 Foo<int>类和 static 数据成员 ctr

auto ct = Foo<int>: : count () ; // 实例化 Foo<int〉：： count ct = f i . count () ;    // 使用 Foo<int〉：： count

ct = Foo: : count () ;    //错误：使用哪个模板实例的count?

类似任何其他成员函数，一个static成员函数只有在使用时才会实例化。

###### 16.1.2节练习

< 668 |



练习16.9:什么是函数模板？什么是类模板？

练习16.10:当一个类模板被实例化时，会发生什么？

练习16.11:下面List的定义是错误的。应如何修正它？

template <typename eleraType> class Listltem; template <typename elemType> class List { public:

List<elemType>();

List<elemType>(const List<elemType> &); List<elemType>& operator=(const List<elemType> &); 〜List ();

void insert(Listltem *ptr, elemType value); private:

Listltem *front, *end;

}；

练习16.12：编写你自己版本的Blob和BlobPtr模板，包含书中未定义的多个const 成员。

练习16.13:解释你为BlobPtr的相等和关系运算符选择哪种类型的友好关系？

练习16.14：编写Screen类模板，用非类型参数定义Screen的高和宽。

练习16.15：为你的Screen模板实现输入和输出运算符。Screen类需要哪些友元(如 果需要的话)来令输入和输出运算符正确工作？解释每个友元声明(如果有的话)为什 么是必要的。

练习16.16:将StrVec类(参见13.5节，第465页)重写为模板，命名为Vec。

###### 16.1.3模板参数

类似函数参数的名字，一个模板参数的名字也没有什么内在含义。我们通常将类型参 数命名为T,但实际上我们可以使用任何名字：

template <typename Foo> Foo calc(const Foo& a, const Foo& b)

{

Foo tmp = a; // tmp的类型与参数和返回类型一样

return tmp; //返回类型和参数类型一样

}

模板参数与作用域

模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模 □6L>板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同

名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名： typedef double A;

template <typename A, typename B> void f(A a, B b)

{

A tmp = a; // tmp的类型为模板参数A的类型，而非double double B; //错误：重声明模板参数B

}

正常的名字隐藏规则决定了 A的typedef被类型参数A隐藏。因此，tmp不是一个 double,其类型是使用f时绑定到类型参数A的类型。由于我们不能重用模板参数名， 声明名字为B的变量是错误的。

由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：

//错误：非法重用模板参数名V

template <typename V, typename V> //...

模板声明

模板声明必须包含模板参数:

//声明但不定义compare和Blob

template <typename T> int compare(const T&, const T&); template <typename T> class Blob;

与函数参数相同，声明中的模板参数的名字不必与定义中相同：

// 3个calc都指向相同的函数模板

template ctypename T> T calc (const T&, const T&) ; // 声明 template <typename U> U calc (const U&, const U&) ; // 声明 //模板的定义

template ctypename Type>

Type calc (const Types a, const Type& b) {/*...*/}

当然，一个给定模板的每个声明和定义必须有相同数量和种类(即，类型或非类型)的参数。

Best    一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于

任何使用这些模板的代码之前，原因我们将在16.3节(第617页)中解释;，

使用类的类型成员

回忆一下，我们用作用域运算符(：：)来访问static成员和类型成员(参见7.4节， 第253页和7.6节，第269页)。在普通(非模板)代码中，编译器掌握类的定义。因此， 它知道通过作用域运算符访问的名字是类型还是static成员。例如，如果我们写下 string: : size_type,编译器有string的定义，从而知道size_type是一个类型。

<670~1



但对于模板代码就存在困难。例如，假定T是一个模板类型参数，当编译器遇到类似 T: :mem这样的代码时，它不会知道mem是一个类型成员还是一个static数据成员，直 至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。例 如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时：

T::size_type * p;

它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数 据成员与名为P的变量相乘。

默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们 希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们 通过使用关键字type name来实现这一点：

template <typename T>

typename T::value_type top(const T& c)

{

if (!c.empty())

return c.back();

else

return typename T::value_type();

}

我们的top函数期待一个容器类型的实参，它使用typename指明其返回类型并在c中 没有元素时生成一个值初始化的元素(参见7.5.3节，第262页)返回给调用者。

当我们希望通知编译器一个名字表示类型时，必须使用关键字typename,而 L    不能使用 class。.、：

默认模板实参

就像我们能为函数参数提供默认实参一样(参见6.5.1节，第211页)，我们也可以提 供默认模板实参(default template argument)。在新杯准中，我们可以为函数和类模板提供 默认实参。而更早的C杆标准只允许为类模板提供默认实参。

例如，我们重写compare,默认使用标准库的less函数对象模板(参见14+8.2节， 第509页):

II compare有一个默认模板实参less<T>和一个.默认函数实参F()

template <typename T, typename F = less<T»

int compare(const T &vl, const T &v2, F f = F())

{

if (f(vl, v2)) return -1; if (f(v2, vl)) return 1; return 0;

}

在这段代码中，我们为模板添加了第二个类型参数，名为F,表示可调用对象(参见10.3.2 节，第346页)的类型；并定义了一个新的函数参数f，绑定到一个可调用对象上。

我们为此模板参数提供了默认实参，并为其对应的函数参数也提供了默汄实参。默汄 模板实参指出compare将使用标准库的less函数对象类，它是使用与compare f'C 的类型参数实例化的。默认函数实参指出f将是类型F的一个默认初始化的对象。

当用户调用这个版本的compare时，可以提供自己的比较操作，但这并不是必耑的：

bool i = compare (0, 42) ; // 使用 less; i 为-1

II结果依赖于iteml和item2中的isbn

Sales_data iteml(cin), item2(cin);

bool j = compare(iteml, item2, compareIsbn);

第一个调用使用默认函数实参，即，类型less<T>的一个默认初始化对象。在此调用中， T为int,因此可调用对象的类型为less<int>„ compare的这个实例化版本将使用 1633<；1111；>进行比较操作。

在第二个调用中，我们传递给compare三个实参：comparelsbn (参见11.2.2节， 第379页)和两个SaleS_data类型的对象。当传递给compare三个实参时，第三个实 参的类型必须是一个可调i对象，该可调用对象的返回类型必须能转换为bOOi值，且接 受的实参类型必须与compare的前两个实参的类型兼容，与往常一样，模板参数的类型 从它们对应的函数实参推断而来。在此调用中，T的类型被推断为Sales_data, F被推 断为comparelsbn的类型。

与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时, 它才可以有默认实参。

模板默认实参与类模板

无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须 从一个模板实例化而来。特别是，如果一个类模板为其所有模板参数都提供了默认实参， 上L我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：

template Cclass T = int> class Numbers { // T 默认为 int public:

Numbers(T v = 0): val(v) { }

//对数值的各种操作 private:

T val;

}；

Numbers<long double> lots_of_precision;

Numberso average_precision; //空<>表示我们希望使用默认类型

此例中我们实例化了两个Numbers版本：average_precision是用int代替T实例 化得到的：lots_of_precision是用long double代替T实例化而得到的。

###### 16.1.3节练习

<672]



练习16.17:声明为typename的类型参数和声明为class的类型参数有什么不同(如 果有的话)？什么时候必须使用typename?

练习16.18：解释下面每个函数模板声明并指出它们是否非法。更正你发现的每个错误。

(a)    template <typename T, U, typename V〉void f1 (T, U, V);

(b)    template〈typename T> T f2 (int &T);

(c)    inline template <typename T> T foo (T, unsigned int*);

(d)    template <typename T> f4 (T, T);

(e)    typedef char Ctype;

template <typename Ctype> Ctype f5(Ctype a);

练习16.19:编写函数，接受一个容器的引用，打印容器中的元素。使用容器的size_type 和size成员来控制打印元素的循环。

练习16.20:重写上一题的函数，使用begin和end返回的迭代器來控制循环。

###### 16.1.4成员模板

一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。这种成员被称 为成员模板(membertemplate)。成员模板不能是虚函数。

普通(非模板)类的成员模板

作为普通类包含成员模板的例子，我们定义一个类，类似unique_ptr所使用的默 认删除器类型(参见12丄5节，第418页)。类似默认删除器，我们的異将包含一个重载 的函数调用运算符(参见14.8节，第506页)，它接受一个指针并对此指针执行delete， 与默认删除器不同，我们的类还将在删除器被执行时打印一条信息。由于希望刪除器适用 丁-任何类型，所以我们将调用运算符定义为一个模板：

//函数对象类，对给定指针执行delete class DebugDelete { public:

DebugDelete(std::ostream &s = std::cerr) : os (s)    { }

//与任何函数模板相同，T的类型由编译器推断

template <typename T> void operator()(T *p) const

{ os << "deleting unique_ptr" « std::endl; delete p; } private:

std::ostream &os;

}；

\^>与任何其他模板相同，成员模板也是以模板参数列表开始的。每个DebugDelete对象都 有一个ostream成员，用于写入数据：还包含一个自身是模板的成员函数。我们可以用 这个类代替delete：

double* p = new double;

DebugDelete d; //可像delete表达式一样使用的对象 d (p) ; // 调用 DebugDelete: : operator () (double*)，释放 p int* ip = new int;

// 在一个临时 DebugDelete 对象上调用 operator () (int*)

DebugDelete()(ip);

由于调用一个DebugDelete对象会delete其给定的指针，我们也可以将 DebugDelete用作unique_ptr的删除器。为了重载unique_ptr的删除器，我们在 尖括号内给出删除器类型，并_提供一个这种类型的对象给unique_ptr的构造函数(参 见12.1.5节，第418页)：

/ /销毁p指向的对象

// 实例化 DebugDelete : : operator (} <int〉(int *) unique_ptr<int, DebugDelete> p (new int, DebugDelete());

//销毁~sp指向的对象

// 实例化 DebugDelete: : operator () <string> (string*) unique_ptr<string, DebugDelete> sp(new string, DebugDelete());

在本例中，我们声明p的删除器的类型为DebugDelete,并在p的构造函数中提供了该 类型的一个未命名对象。

unique_ptr的析构函数会调用DebugDelete的调用运算符。因此，无论何吋 unique_ptr的析构函数实例化时，DebugDelete的调用运算符都会实例化：因此，上 述定义会这样实例化.

// DebugDelete的成S模板实例化样例

void DebugDelete::operator() (int *p) const { delete p; } void DebugDelete::operator() (string *p) const { delete p; }

类模板的成员模板

对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各自有自己的、 独立的模板参数。

例如，我们将为Blob类定义一个构造函数，它接受两个迭代器，表示要拷贝的元素 范围。由于我们希望支持不同类型序列的迭代器，因此将构造函数定义为模板：

template <typename T> class Blob {

template <typename It〉 Blob(It b, It e);

}；

此构造函数有自己的模板类型参数It,作为它的两个函数参数的类型。

与类模板的普通函数成员不同，成员模板是函数模板。当我们在类模板外定义一个成 C6Z4>员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后

跟成员自己的模板参数列表：

template <typename T> // 类的类型参数 template < type name It> //构造函数的类型参数

Blob<T〉：：Blob(Itb, It e):

data(std::make_shared<std::vector<T>>(b, e))    { }

在此例中，我们定义了一个类模板的成员，类模板有一个模板类型参数，命名为T。而成 员自身是一个函数模板，它有一个名为工t的类型参数。

实例化与成员模板

为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。与往常 一样，我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的 实参。与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板 实参(参见16.1.1节，第579页)：

int ia[] = {0,1,2,3,4,5,6,7,8,9}; vector<long> vi = {0,1,2,3,4,5,6,7,8,9}; list<const char*> w = {"nown, nis", "the", "time"};

//实例化Blob<int>类及其接受两个int*参数的构造函数 Blob<int> al(begin(ia), end(ia));

//实例化Blob<int>类的接受两个vector<long>: : iterator的构造画数

Blob<int> a2(vi.begin (), vi.end());

//实例化Blob<string〉及其接受两个list<const char*〉：： iterator参数的构造函数

Blob<string> a3(w.begin(), w.end());

当我们定义al时，显式地指出编译器应该实例化一个int版本的Blobo构造函数自己 的类型参数则通过begin (ia)和end (ia)的类型来推断，结果为int*。因此，al的定 义实例化了如下版本：

Blob<int>::Blob(int*, int*);

a2的定义使用了已经实例化了的Blob<int〉类，并用vector<short>: : iterator 替换It来实例化构造函数。a3的定义(显式地)实例化了一个string版本的Blob, 并(隐式地)实例化了该类的成员模板构造函数，其模板参数被绑定到list<COnSt char*>。

###### 16.1.4节练习

![img](C++  Primer 5-154.jpg)



练习16.21:编写你自己的DebugDelete版本。

练习16.22：修改12.3节(第430贾)中你的TextQuery程序，令shared_ptr成 员使用DebugDelete作为它们的删除器(参见12.1.4节，第415页)。

练习16.23：预测在你的查询主程序中何时会执行调用运算符。如果你的预测和实际不 符，确认你理解了原因。

练习16.24:为你的Blob模板添加一个构造函数，它接受两个迭代器。

###### 16.1.5控制实例化

当模板被使用时才会进行实例化(参见16.1.1节，第582页)这一特性意味着，相同 的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，Lli-并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。

在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，

我们可以通过显式实例化(explicitinstantiation)来避免这种开销。一个显式实例化有如下

形式:

extern template declaration;    // 实例化声明

template declaration;    // 实例化定义

如n是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，

//实例化声明与定义

extern template class Blob<string>;    // 声明

template int compare (const int&, const int&) ; // 定义

当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声 明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明(定义)。对 于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。

由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使 用此实例化版本的代码之前：

// Application.cc

//这些模板类型必须在程序其他位置进行实例化 extern template class Blob<string>;

extern template int compare(const int&, const int&);

Blob<string> sal, sa2; //实例化会出现在其他位置 // Blob<int>及其接受initializer_list的构造函数在本文件中实例化 Blob<int> al = {0,1,2,3,4,5,6,7,8,9};

Blob<int> a2(al); //拷贝构造函数在本文件中实例化

int i = compare (al [0] , a2 [0] ) ; //实例化出现在其他位置

| 676〉文件Application. o将钮含Blob<int〉的实例及其接受initializer_list参数的 构造函数和拷贝构造函数的实例。而compare<int〉函数和Blob<string>类将不在本 文件屮进行实例化。这些模板的定义必须出现在程序的其他文件中：

// templateBuild.cc

//实例化文件必须为每个在其他文件中声明为extern的类型和函数提供一个(非extern ) //的定义

template int compare(const int&, const int&);

template class Blob<string>; //实例化类模板的所有成员

当编译器遇到一个实例化定义(与声明相对)时，它为其生成代码。因此，文件 templateBuild.o将会包含compare的int实例化版本的定义和Blob<string>类 的定义。当我们编译此应用程序时，必须将templateBuild.o和Application.。链 接到一起。

WARNING



对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。.

实例化定义会实例化所有成员

-个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译 器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通 实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例 化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。

![img](C++  Primer 5-156.jpg)



在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。

###### 16.1.5节练习    -

练习16.25：解释下面这些声明的含义：

extern template class vector<string>; template class vector<Sales_data>;

练习16.26：假设NoDefault是一个没有默认构造函数的类，我们可以显式实例化 vector<NoDefault>吗？如果不可以，解释为什么。

练习16.27:对下面每条带标签的语句，解释发生了什么样的实例化（如果有的话X如 果：个模板被实例化，解释为什么；如果未实例化，解释为什么没有。

template <typename T> class Stack { };

| void             | .f1(Stack<char>);                   | // (a) |
| ---------------- | ----------------------------------- | ------ |
| class Exercise { |                                     |        |
|                  | Stack<double> &rsd;                 | //(b)  |
|                  | Stack<int> si;                      | "⑷     |
| ｝；             |                                     |        |
| int              | main ()    {                        |        |
|                  | Stack<char> ★sc;                    | // (d) |
|                  | fl (*sc);                           | // (e) |
| }                | int iObj = sizeof(Stack< string >); | // (0  |

16.1.6效率与灵活性

对模板设计者所面对的设计选择，标准库智能指针类型（参见12.1节，第400页）给 出了一个很好的展示。

shared_ptr和unique_ptr之间的明显不同是它们管理所保存的指针的策略-

前者给予我们共享指针所有权能力；后者则独占指针。这一差异对两个类的功能来说是 至关重要的。

这两个类的另-•个差异是它们允许用户重载默认删除器的方式。我们可以很容易地重 载一个shared_ptr的删除器，只要在创建或reset指针时传递给它一个可调用对象即 可。与之相反，删除器的类型是一个unique_ptr对象的类型的一部分。用户必须在定 义uniquejtr时以显式模板实参的形式提&删除器的类型。因此，对于

unique_ptr

的用户来说，提供自己的删除器就更为复杂。

如何处理删除器的差异实际上就是这两个类功能的差异。但是，如我们将要看到的，<67L] 这一实现策略上的差异可能对性能有重要影响。

在运行时绑定删除器

虽然我们不知道标准库类型是如何实现的，但可以推断出，shared ptr必须能直接 访问其删除器。即，删除器必须保存为一个指针或一个封装了指针的类_（如function,

参见14.8.3节，第512页）。

我们可以确定shared_ptr不是将删除器直接保存为一个成员，因为删除器的类型

直到运行时才会知道。实际上，在一个shared_ptr的生存期中，我们可以随时改变其 删除器的类型。我们可以使用一种类型的删除器构造一"shared_ptr,随后使用reset 赋予此shared_ptr另一种类型的删除器。通常，类成员的类型去运行时是不能改变的。 因此，不能直接^存删除器。

为了考察删除器是如何正确工作的，让我们假定shared_ptr将它管理的指针保存 在一个成员p中，且删除器是通过一个名为del的成员来访问的。则shared_ptr的析 构函数必须包含类似下面这样的语句：

// del的值只有在运行时才知道；通过一个指针来调用它

del ? del(p) : delete p; // del (p)需要运行时跳转到del的地址

rCT＞由于删除器是间接保存的，调用del (P＞需要一次运行时的跳转操作，转到del中保存的 地址来执行对应的代码。

在编译时绑定删除器

现在，让我们来考察unique_ptr可能的工作方式。在这个类中，删除器的类型是 类类型的一部分，即，unique_ptr有两个模板参数，一个表示它所管理的指针，另一个 表示删除器的类型。由于删除器的类型是unique_Ptr类型的一部分，因此删除器成员 的类型在编译时是知道的，从而删除器可以直接保&在unique_ptr对象中。

unique_ptr的析构函数与shared_ptr的析构函数类似，也是对其保存的指针调 用用户提供&删除器或执行delete:

// del在编译时紼定；直接调用实例化的删除器 del (p) ; //无运行时额外开销

del的类型或者是默认删除器类型，或者是用户提供的类型。到底是哪种情况没有关系， 应该执行的代码在编译时肯定会知道。实际上，如果删除器是类似DebugDelete (参见 16.1.4节，第595页)之类的东西，这个调用甚至可能被编译为内联形式。

通过在编译时绑定删除器，uniqUe_Ptr避免了间接调用删除器的运行时开销。通过 在运行时绑定删除器，shared_ptr使运户重载删除器更为方便。

###### 16.1.6节练习

练习16.28：编写你自己版本的shared_ptr和unique_ptr。

练习16.29:修改你的Blob类，用你自己的shared_ptr代替标准库中的版本。

练习16.30:重新运行你的一些程序，验证你的shared_Ptr类和修改后的Blob类。 (注意：实现weak_ptr类型超出了本书范围，因此你不能将BlobPtr类与你修改后 的Blob 一起使用《 )

练习16.31:如果我们将DebugDelete与unique_ptr 一起使用，解释编译器将删 除器处理为内联形式的可能方式。

##### 16.2模板实参推断

我们已经看到，对于函数模板，编译器利用调用中的函数实参来确定其模板参数。从 函数实参来确定模板实参的过程被称为模板实参推断(template argument deduction)。在模

板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参 生成的函数版本与给定的函数调用最为匹配。

###### 16.2.1类型转换与模板类型参数

<6791



与非模板函数一样，我们在一次调用中传递给函数模板的实参被用来初始化函数的形 参。如果一个函数形参的类型使用了模板类型参数，那么它采用特殊的初始化规则。只有 很有限的几种类型转换会自动地应用于这些实参。编译器通常不是对实参进行类型转换， 而是生成一个新的模板实例。

与往常一样，顶层const (参见2.4.3节，第57页)无论是在形参中还是在实参中， 都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。

• const转换：可以将一个非const对象的引用(或指针)传递给一个const的 引用(或指针)形参(参见4.11.2节，第144页)。

•数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实 参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似 的，一个函数实参可以转换为一个该函数类型的指针(参见4.11.2节，第143页)。

其他类型转换，如算术转换(参见4.11.1节，第142页)、派生类向基类的转换(参见15.2.2 节，第530页)以及用户定义的转换(参见7.5.4节，第263页和14.9节，第514页)，都 不能应用于函数模板。

作为一个例子，考虑对函数fobj和fref的调用。fobj函数拷贝它的参数，而fref 的参数是引用类型：

template <typename T> T fobj (T, T) ; // 实参被拷贝 template <typename T> T fref (const T&, const T &) ; // 引用 string si ("a value");

const string s2 (’’another value”)；

fobj (si, s2) ;    // 调用 fobj (string, string) ; const 被忽略

fref (si, s2) ;    // 调用 fref (const strings, const strings)

//将si转换为const是允许的

int a[10], b[42];

fobj (a, b) ;    // 调用 f (int*, int*)

fref (a, b) ;    //错误：数组类型不匹配

在第一对调用中，我们传递了一个string和一个const string。虽然这些类型不严格 匹配，但两个调用都是合法的。在fobj调用中，实参被拷贝，因此原对象是否是const 没有关系。在fref调用中，参数类型是const的引用。对于一个引用参数来说，转换 为const是允许的，因此这个调用也是合法的。

在下一对调用中，我们传递了数组实参，两个数组大小不同，因此是不同类型。在 fobj调用中，数组大小不同无关紧要。两个数组都被转换为指针。fobj中的模板类型 为int*。但是，fref调用是不合法的。如果形参是一个引用，则数组不会转换为指针 (参见6.2.4节，第195页)。a和b的类型是不匹配的，因此调用是错误的。

![img](C++  Primer 5-157.jpg)



将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const 转换及数组或函数到指针的转换。

<680 |



使用相同模板参数类型的函数形参

一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换， 因此传递给这些形参的实参必须具有扣M的类型。如果推断出的类型不匹配，则调用就是 错误的。例如，我们的compare趙数(参见16.1.1节，第578页)接受两个const T& 参数，其实参必须是相同类型：

long lng;

compare (lng, 1024) ; // 错误：不能实例化 compare (long, int)

此凋用是错误的，因为传递给compare的实参类型不同。从第一个函数实参推断出的模 板实参为long,从第二个函数实参推断出的模板实参为int。这些类型不匹配，因此模 板实参推断失败。

如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型 参数：

//实参类型可以不同，但必须兼容

template <typename A, typename B>

int flexibleCompare(const A& vl, const B& v2)

{

if (vl < v2) return -1; if (v2 < vl) return 1; return 0;

}

现在用户可以提供不同类型的实参了： long lng;

f lexibleCompare (lng, 1024) ; // 正确：调用 flexibleCompare (long, int)

当然，必须定义了能比较这些类型的值的<运算符。

正常类型转换应用于普通函数实参

函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数 实参不进行特殊处理；它们正常转换为对应形参的类型(参见6.］节，第183页)。例如， 考虑下面的模板：

template <typename T> ostream Sprint(ostream &os, const T &obj)

{

return os « obj;

}

第一个函数参数是一个已知类型ostreamS。第二个参数obj则是模板参数类型。由于 os的类型是固定的，因此当调用print时，传递给它的实参会进行正常的类型转换：

I 681〉    print (cout, 42); // 实例化 print (ostream&, int)

ofstream f ("output");

print (f, 10);    // 使用 print <ostream&, int);将 f 转换为 ostream&

在第一个调用中，第一个实参的类型严格匹配第一个参数的类型。此凋用会实例化接受一 个ostream&和一个int的print版本。在第二个凋用中，第一个实参是一个of stream, 它可以转换为ostream& (参见8.2.1节，第284页)。由于此参数的类型不依赖于模板参 数，因此编译器会将f隐式转换为ostream&。

![img](C++  Primer 5-158.jpg)



如果函数参数类型不是模板参数，则对实参进行正常的类型转换._

###### 16.2.1节练习

练习16.32：在模板实参推断过程中发生了什么？

练习16.33：指出在模板实参推断过程中允许对函数实参进行的两种类型转换。

练习16.34：对下面的代码解释每个调用是否合法。如果合法，T的类型是什么？如果 不合法，为什么？

template <class T> int compare(const T&, const T&);

(a) compare("hi", "world"); (b) compare("bye", "dad");

练习16.35：下面调用中哪些是错误的(如果有的话)？如果调用合法，T的类型是什 么？如果调用不合法，问题何在？

template <typename T> T calc(T, int); template <typename T> T fcn(T, T); double d; float f; char c;

(a) calc (c, ’ c' ) ;    (b) calc (d, f);

(c)    fen (c, 'c');    (d) fcn(d, f);

练习16.36：进行下面的调用会发生什么：

template <typename T> f1(T, T);

template <typename Tl, typename T2) f2 (T1, T2); int i = 0, j = 42, *pl = &i, *p2 = &j; const int *cpl = &i, *cp2 = &j;

⑻ fl (pi, p2) ;    (b) f2 (pi, p2) ;    (c) fl(cpl, cp2);

(d)    f2(cpl, cp2) ;    (e) fl(pl' cpl) ; (e) f2 (pi, cpl);

16.2.2函数模板显式实参    6

在某些情况下，编译器无法推断出模板实参的类型。其他-些情况下，我们希望允许 用户控制模板实例化。当函数返回类型与参数列表中任何类型都不相同时，这两种情况最<682~| 常出现。

指定显式模板实参

作为一个允许用户指定使用类型的例子，我们将定义一个名为sum的函数模板，它 接受两个不同类型的参数。我们希望允许用户指定结果的类型。这样，用户就可以选择合 适的精度。

我们可以定义表示返回类型的第三个模板参数，从Iflj允许用户控制返回类型：

II编译器无法推断T1，它未出现在函数参數列表中 template <typename Tl, typename T2, typename T3>

T1 sum(T2, T3);

在本例中，没有任何函数实参的类型可用米推断Tl的类型。毎次调用sum吋调用者都必 须为T1提供一■个显式模板实参(explicit template argument )。

我们提供显式模板实参的方式与定义类模板实例的方式相同。敁式模板实参在尖括号 中给出，位于函数名之后，实参列表之前：

// T1是显式指定的，T2和T3是从函数实参类型推断而来的

auto val3 = sum<long long>（i, lng）; // long long sum（int, long）

此调用显式指定T1的类型。而T2和T3的类型则由编译器从i和lng的类型推断出来。

显式模板实参按由左至右的顺序与对应的模板参数匹配；第一个模板实参与第一个模 板参数匹配，第二个实参与第二个参数匹配，依此类推。只有尾部（最右）参数的显式模 板实参才可以忽略，而且前提是它们可以从函数参数推断出來。如果我们的sum函数按 照如下形式编写：

//糟糕的设计：用户必须指定所有三个模板参数

template <typename Tl, typename T2, typename T3>

T3 alternative_sum（T2, Tl）;

则我们总是必须为所有三个形参指定实参，

//错误：不能推断前几个模板参数

auto val3 = alternative_sum<long long〉（i, lng）;

//正确：显式指定了所有三个奏数

auto val2 = alternative_sum<long long, int, long〉（i, lng）;

正常类型转换应用于显式指定的实参

对于用普通类型定义的函数参数，允许进行正常的类型转换（参见16.2.1节，第602 页），出于同样的原因，对于模板类型参数已经显式指定了的函数实参，也进行正常的类型 转换:

I 683〉    long lng;

compare(lng, 1024〉； compare<long>(lng, 1024); compare<int>(lng, 1024);



//错误：模板参数不匹配

// 正确：实例化 compare （long, long） // 正确：实例化 compare （int, int）

如我们所见，第一个调用是错误的，因为传递给compare的实参必须具有相同的类 型。如果我们显式指定模板类型参数，就可以进行正常类型转换了。因此，调用 compare<long〉等价于调用一个接受两个const long&参数的函数。int类型的参数 被自动转化为long。在第三个调用中，T被显式指定为int,因此lng被转换为int。

###### 16.2.2节练习

练习16.37:标准库max函数有两个参数，它返回实参中的较大者。此函数有一个模板 类型参数。你能在调用max时传递给它一个int和一个double吗？如果可以，如何 做？如果不可以，为什么？

练习16.38：当我们调用make^hare （参见12.1.1节，第401页）时，必须提供一个 显式模板实参，解释为什么需i显式模板实参以及它是如何使用的。

练习16.39:对16.1.1节（第578页）中的原始版本的compare函数，使用一个显式 模板实参，使得可以向函数传递两个字符串字面常量。

###### 16.2.3尾置返回类型与类型转换

当我们希望用户确定返回类型时，用显式模板实参表示模板函数的返回类型是很有效 的。但在其他情况下，要求显式指定模板实参会给用户增添额外负担，而且不会带来什么 好处。例如，我们可能希望编写一个函数，接受表示序列的一对迭代器和返回序列中一个

元素的引用:

template <typename It〉

??? &fcn(It beg, It end)

{

//处理序列

return *beg; //返回序列中一个元素的引用

}

我们并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型:

vector<int> vi = {1,2,3,4 Blob<string> ca = { "hi", auto &i = fen(vi.begin(), auto &s = fen(ca.begin(),



5};

"bye" };

vi . end () ) ; // fen 应该返回 int& ca.end () ) ; // fen 应该返回 strings

此例中，我们知道函数应该返而且知道我们可以用decltype （*beg）来获取此< 684 | 表达式的类型。但是，在编译器遇到函数的参数列表之前，beg都是不存在的。为了定义 此函数，我们必须使用尾置返回类型（参见6.3.3节，第206页）。由于尾置返回出现在参UlJ 数列表之后，它可以使用函数的参数，

//尾置返回允许我们在参数列表之后声明返回类型 template <typename It〉

auto fen （It beg, It end） -> decltype（*beg）

{

//处理序列

return *beg; //返回序列中一个元素的引用

此例中我们通知编译器fen的返回类型与解引用beg参数的结果类型相同。解引用运算 符返回一个左值（参见4.1.1节，第121页），因此通过decltype推断的类型为beg表 示的元素的类型的引用。因此，如果对一个string序列调用fen,返回类型将是 strings。如果是int序列，则返回类型是int&。

进行类型转换的标准库模板类

有时我们无法直接获得所需要的类型。例如，我们可能希望编写一个类似fen的函 数，但返回一个元素的值（参见6.3.2节，第201页）而非引用。

在编写这个函数的过程中，我们面临一个问题：对于传递的参数的类型，我们几乎一 无所知。在此函数中，我们知道唯一可以使用的操作是迭代器操作，而所有迭代器操作都 不会生成元素，只能生成元素的引用。

为了获得元素类型，我们可以使用标准库的类型转换（type transformation）模板。这 些模板定义在头文件type_traitS中。这个头文件中的类通常用于所谓的模板元程序设 计，这一主题已超出本书6^范围。但是，类型转换模板在普通编程中也很有用。表16.1 列出了这些模板，我们将在16.5节（第624页）中看到它们是如何实现的。

在本例中，我们可以使用remove_reference来获得元素类型 Oremove_reference 模板有一个模板类型参数和一个名为type的（public）类型成员。如果ii们用一个引 用类型实例化remove_reference，则type将表示被引用的类型。例如，如果我们实 例化remove_reference<int&>，则type成员将是into类似的，如果我们实例化 remove_reference<string&>,则 type 成员将是 string，依此类推。更一般的， 给定一个迭代器beg：

remove_reference<decltype （*beg） >: : type

将获得beg引用的元素的类型：decltypeCbeg）返回元素类型的引用类型。 remove_ref erence: : type脱去引用，剩下兀素类型本身。

组合使用remove_reference>尾置返冋及decltype，我们就可以在函数中返回 元素值的拷贝：

I卿〉    //为了使用模板参数的成员，必须用typename,参见16.1.3节（第593 I ）

template <typename It〉 auto fcn2（It beg, It end）->

typename remove_reference<decltype（*beg）>::type

{

//处理序列

return *beg; //返回序列中一个元素的拷贝

}

注意，type是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型 的声明中使用typename来告知编译器，type表示一个类型（参见16.1.3节，第593页）

| 表16.1:标准类型转换模板 |                   |                    |
| ----------------------- | ----------------- | ------------------ |
| 对Mod<T>,其中Mod为      | 若T为             | 则 Mod<T>::type 为 |
| remove reference        | X&或 X&&          | X                  |
|                         | 否则              | T                  |
| add const               | X&、const X或函数 | T                  |
|                         | 否则              | const T            |
| add lvalue reference    | X&                | T                  |
|                         | X&&               | X&                 |
|                         | 否则              | T&                 |
| add_rvalue_reference    | X&或 X&&          | T                  |
|                         | 否则              | T&&                |
| remove_pointer          | X*                | X                  |
|                         | 否则              | T                  |
| add_pointer             | X&或 X&&          | X*                 |
|                         | 否则              | T*                 |
| make_signed             | unsigned X        | X                  |
|                         | 否则              | T                  |
| make_unsigned           | 带符号类型        | unsigned X         |
|                         | 否则              | T                  |
| remove extent           | X[n]              | X                  |
|                         | 否则              | T                  |
| remove all extents      | X[nl] [n2].“      | X                  |
|                         | 否则              | T                  |

表16.1中描述的每个类型转换模板的工作方式都与remove_reference类似。每 个模板都有一个名为type的public成员，表示一个类型。此型与模板自身的模板类 型参数相关，其关系如模板名所示。如果不可能（或者不必要）转换模板参数，则type 成员就是模板参数类型本身。例如，如果T是一个指针类型，则 remove pointer<T>: : type是T指向的类型。如果T不是一个指针，则无须进行任何

转换，从而type具有与T相同的类型。

###### 16.2.3节练习

练习16.40：下面的函数是否合法？如果不合法，为什么？如果合法，对可以传递的实 参类型有什么限制(如果有的话)？返回类型是什么？ template <typename It〉

auto fcn3(It beg, It end) -> decltype(*beg + 0)

{

//处理序列

return *beg; //返回序列中一个元素的拷贝

}

练习16.41:编写一个新的sum版本，它的返回类型保证足够大，足以容纳加法结果。

###### 16.2.4函数指针和实参推断

当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值(参见6.7节，第 221页)时，编译器使用指针的类型来推断模板实参。

例如，假定我们有一个函数指针，它指向的函数返回int，接受两个参数，每个参数 都是指向const int的引用。我们可以使用该指针指向compare的一个实例：

template <typename T> int compare(const T&, const T&);

// pfl 指向实例 int compare (const int&, const int&) int (*pf1)(const int&, const int&) = compare;

pfl中参数的类型决定了 T的模板实参的类型。在本例中，T的模板实参类型为int。指 针pfl指向compare的int版本实例。如果不能从函数指针类型确定模板实参，则产 生错误：

// func的重载版本；每个版本接受一个不同的函数指针类型 void func(int(*)(const strings, const strings)); void func (int (*) (const int&, const int&)); func (compare) ; //错误：使用compare的哪个实例？

这段代码的问题在于，通过func的参数类型无法确定模板实参的唯一类型。对func的 调用既可以实例化接受int的compare版本，也可以实例化接受string的版本。由于 不能确定func的实参的唯一实例化版本，此调用将编译失败。

我们可以通过使用显式模板实参来消除func调用的歧义：

//正确：显式指出实例化哪个compare版本

func (compare<int>) ; // 传递 compare (const int&, const int&)

此表达式调用的func版本接受一个函数指针，该指针指向的函数接受两个const int& 参数。

![img](C++  Primer 5-159.jpg)



当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数, 能唯一确定其类型或值。

<687~|



###### 16.2.5模板实参推断和引用

为了理解如何从函数调用进行类型推断，考虑下面的例子:

template <typename T> void f(T &p);

其中函数参数p是一个模板类型参数T的引用，非常重要的是记住两点：编译器会应用正 常的引用绑定规则；const是底层的，不是顶层的，

从左值引用函数参数推断类型

当一个函数参数是模板类型参数的一个普通(左值)引用时(即，形如T&),绑定规 则告诉我们，只能传递给它一个左值(如，一个变量或一个返回引用类型的表达式)。实 参可以是const类型，也可以不是。如果实参是const的，则T将被推断为const类型：

template <typename T> void f 1 (T&) ; // 实参必须是一个左值

//对fl的调用使用实参所引用的类型作为模板参数类型 fl (i) ;    // i是一tint;模板参数类型T是int

f 1 (ci) ;    // ci 是一个 const int;模板参数 T 是 const int

fl(5) ;    //错误：传递给一个&参数的实参必须是一个左值

如果一个函数参数的类型是const T&，正常的绑定规则告诉我们可以传递给它任何 类型的实参——一个对象(const或非const)、一个临时对象或是一个字面常量值。当 函数参数本身是const时，T的类型推断的结果不会是一个const类型。const已经是 函数参数类型的一部分；因此，它不会也是模板参数类型的一部分：

template <typename T> void. f2 (const T&) ; // 可以接受一个右值

// f2中的参教是const &;实参中的const是无关的

//在每个调用中，f2的函数参数都被推断为const int& f2 (i) ;    // i是一个int;模板参数T是int

f2 (ci) ;    // ci 是一个 const int,但模板参数 T 是 int

f2 (5) ;    // 一个const &参数可以绑定到一个右值；T是int

从右值引用函数参数推断类型

当一个函数参数是一个右值引用(参见13.6.1节，第471页)(即，形如T&&)时， 正常绑定规则告诉我们可以传递给它一个右值。当我们这样做时，类型推断过程类似普通 左值引用函数参数的推断过程。推断出的T的类型是该右值实参的类型：

template <typename T> void f3 (T&&);

f3(42); //实参是一个int类型的右值；模板参数T是int

s§>引用折叠和右值引用参数

假定i是一个int对象，我们可能认为像f3(i)这样的调用是不合法的。毕竟，i 是一个左值，而通常我们不能将一个右值引用绑定到一个左值上。但是，C++语言在正常 绑定规则之外定义了两个例外规则，允许这种绑定。这两个例外规则是move这种标准库 设施正确工作的基础。

第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值(如i)传递 给函数的右值引用参数，且此右值引用指向模板类型参数(如T&&)时，编译器推断模板 类型参数为实参的左值引用类型。因此，当我们调用f3(i)时，编译器推断T的类型为 int&，而非 int。

T被推断为看起来好像意味着f 3的函数参数应该是一个类型int&的右值引用

通常，我们不能（直接）定义一个引用的引用（参见2.3.1节，第46页）。但是，通过类 型别名（参见2.5.1节，第60页）或通过模板类型参数间接定义是可以的，

在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个引用的引 用，则这些引用形成了 “折fi”。在所有情况下（除了一个例外），引用会折叠成一个普通fcTTl 的左值引用类型。在新标准中，折叠规则扩展到右值引用。只在一种特殊情况下引用会折11 叠成右值引用：右值引用的右值引用。即，对于一个给定类型X:

• X& &、X& &&和X&& &都折叠成类型X&

•类型X & & &&折叠成X& &

引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数

如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起，则意味着我们可以 对一个左值调用f3»当我们将一个左值传递给f3的（右值引用）函数参数时，编译器推 断T为一个左值引用类型：

f3（i） ;    //实参是一个左值；模板参数T是int&

f3 （ci） ;    //实参是一个左值；模板参数T是一个const int&

当一个模板参数T被推断为引用类型时，折叠规则告诉我们函数参数T&&折叠为一个左值 引用类型。例如，f3（i）的实例化结果可能像下面这样：

//无效代码，只是用于演示目的

void f3<int&> （int& &&） ; // 当 T 是 int&时，函数参数为 int& &&

f3的函数参数是T&&且T是int&,因此T&&是int&会折叠成int&。因此，即使 f3的函数参数形式是一个右值引用（即，T&&）,此调用也会用一个左值引用类型（即， int& ）实例化f3:

void f3<int&> （int&） ; // 当 T 是 int&时，函数参数折叠为 int&

这两个规则导致了两个重要结果：

•如果一个函数参数是一个指向模板类型参数的右值引用（如，T&&）,则它可以被 绑定到一个左值；且

•如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将 被实例化为一个（普通）左值引用参数（T&）

另外值得注意的是，这两个规则暗示，我们可以将任意类型的实参传递给T&&类型的函数 参数。对于这种类型的参数，（显然〉可以传递给它右值，而如我们刚刚看到的，也可以 传递给它左值。

如果一个函数参数是指向模板参数类型的右值引用（如，T&& ）,则可以传递 给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例 化为一个普通的左值引用（T& ）。

编写接受右值引用参数的模板函数

模板参数可以推断为一个引用类型，这一特性对模板内的代码可能有令人惊讶的影响: template <typename T> void f3（T&& val）

T t = val; //拷贝还是绑定一个引用？

t = fcn(t); //赋值只改变t还是既改变t又改变val?

if (val == t) {/*...*/}// 若 T 是引用类型，则一直为 true

}

当我们对一个右值调用f 3时，例如字面常量42, T为int。在此情况下，局部变量t的 类型为int,且通过拷贝参数val的值被初始化。当我们对t赋值时，参数val保持 不变。

另一方面，当我们对一个左值i调用f3时、则T为int&。当我们定义并初始化局 部变量t时，赋予它类型int&。因此，对t的初始化将其绑定到val。当我们对t赋值 时，也同时改变了 val的值。在f3的这个实例化版本中，if判断永远得到true。

当代码中涉及的类型可能是普通(非引用)类型，也可能是引用类型时，编写正确的 代码就变得异常困难(虽然remove_reference这样的类型转换类可能会有帮助(参见

16.2.3 节，第 605 页))。

在实际中，右值引用通常用于两种情况：模板转发其实参或模板被重载。我们将在 16.2.7节(第612页)中介绍实参转发，在16.3节(第614页)中介绍模板重载。

目前应该注意的是，使用右值引用的函数模板通常使用我们在13.6.3节(第481页) 中看到的方式来进行重载：

template <typename T> void f (T&s) ;    // 瑯定到非 const 右值

template <typename T> void f (const T&) ;    // 左值和 const 右值

与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或 const右值。

I 690 >



###### 16.2.5节练习

练习16.42:对下面每个调用，确定T和val的类型：

template <typename T> void g (T&& val); int i = 0; const int ci = i;

(a) g(i);    (b) g(ci); (c) g (i * ci);

练习16.43：使用上一题定义的函数，如果我们调用g(i = ci), g的模板参数将是什 么？

练习16.44:使用与第一题中相同的三个调用，如果g的函数参数声明为T(而不是T&& ), 确定T的类型。如果g的函数参数是const T&呢？

练习16.45:给定下面的模板，如果我们对一个像42这样的字面常量调用g,解释会发 生什么？如果我们对一个int类型的变量调用g呢？

template <typename T> void g(T&& val) { vector<T> v; }

###### 16.2.6 理解 std::move

标准库move函数(参见13.6.1节，第472页)是使用右值引用的模板的一个很好的 例子。幸运的是，我们不必理解move所使用的模板机制也可以直接使用它。但是，研究 move是如何工作的可以帮助我们巩固对模板的理解和使用。

在13.6.2节(第473页)中我们注意到，虽然不能直接将一个右值引用绑定到一个左 值上，但可以用move获得一个绑定到左值上的右值引用。由于move本质上可以接受任

何类型的实参，因此我们不会惊讶于它是一个函数模板。

std::move是如何定义的

标准库是这样定义move的：

//在返回类型和类型转换中也要用到typename,参见16.1.3节(第593页)

// remove_reference 是在 16.2.3 节(第 605 页)中介紹的 template <typename T>

typename remove_reference<T>::type&& move(T&& t)

{

// static_cast是在4.11.3节(第145页)中介绍的

return static_cast<typename remove_reference<T>::types&> (t);

}

这段代码很短，但其中有些微妙之处。首先，move的函数参数T&&是一个指向模板类型 参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可 以传递给move—个左值，也可以传递给它一个右值：

string si ("hi!"), s2;

s2 = std: :move (string ("bye ! ") ) ; // 正确：从一个右值移动数据 s2 = std: :move (si) ; //正确：但在赋值之后，si的值是不确定的

std::move是如何工作的

在第一个赋值中，传递给move的实参是string的构造函数的右值结果-

<69i~l



string ("bye !")。如我们已经见到过的，当向一个右值引用函数参数传递一个右值时， 由实参推断出的类型为被引用的类型(参见16.2.5节，第608页)。因此，在 std: :move (string (’’bye ! ’*))中：

•推断出的T的类型为string。

•因此，remove_reference 用 string 进行实例化。

•    remove_reference<string>的 type 成员是 string。

•    move的返回类型是string&&。

•    move的函数参数t的类型为string&&。

因此，这个调用实例化move<string>,即函数

string&& move(string &&t)

函数体返回static_cast<string&&> (t) o t的类型已经是string&&,于是类型转 换什么都不做。因此？此调用的结果就是它所接受的右值引用。

现在考虑第二个赋值，它调用了 std: :move ()。在此调用中，传递给move的实参 是一个左值。这样：

•推断出的T的类型为strings (string的引用，而非普通string)。

•因此，remove—reference 用 strings进行实例化。

•    remove_reference<string&〉的 type 成员是 string。

•    move的返回类型仍是string&&。

•    move的函数参数t实例化为strings    会折叠为strings。

因此，这个调用实例化move<string&〉，即

string&& move(string &t)

这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值=这个实例的函数体返 回static cast<string&&> (t)。在此情况下，t的类型为strings，cast将其转 换为 string&&o

从一个左值static_cast到一个右值引用是允许的

通常情况下，static_cast只能用于其他合法的类型转换(参见4.11.3节，第145 页)。但是，这里又有一条it■对右值引用的特许规则：虽然不能隐式地将一个左值转换为 右值引用，但我们可以用static_caSt显式地将一个左值转换为一个右值引用。

对于操作右值引用的代码来说，将一个右值引用绑定到一个左值的特性允许它们截断 I 692>左值。有时候，例如在我们的StrVec类的reallocate函数(参见13.6.1节，第469 页)中，我们知道截断一个左值是安全的。一方面，通过允许进行这样的转换，C++语言 认可了这种用法。但另一方面，通过强制使用static_cast, C++语言试图阻止我们意

外地进行这种转换。

最后，虽然我们可以直接编写这种类型转换代码，但使用标准库move函数是容易得 多的方式。而且，统一使用std: :mOve使得我们在程序中查找潜在的截断左值的代码变 得很容易。

###### 16.2.6节练习

练习16.46:解释下面的循环，它来自n.5节(第469页)中的StrVec: : reallocate:

for (size_t i = 0; i != size (); ++i)

alloc.construct(dest++, std::move(*elem++));

驗16.2.7转发

某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们 需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值。

作为一个例子，我们将编写一个函数，它接受一个可调用表达式和两个额外实参。我 们的函数将调用给定的可调用对象，将两个额外参数逆序传递给它。下面是我们的翻转函 数的初步模样：

//接受一个可调用对象和另外两个参数的模板

//对“翻转”的参数调用给定的可调用对象

// flipl是一个不完整的实现：顶层const和引用去失了 template <typename F, typename Tl, typename T2> void flipl(F f, Tl tl, T2 t2)

f(t2, tl);

}

这个函数一般情况下工作得很好，但当我们希望用它调用一个接受引用参数的函数时就会 出现问题：

void f (int vl, int &v2) // 注意 v2 是一个引用

cout « vl «



« ++v2 « endl;



在这段代码中，f改变了绑定到v2的实参的值。但是，如果我们通过flipl调用f，f 所做的改变就不会影响实参：

f(42, i);    // f 改变了实参 i

flipl (f, j, 42) ; //通过flipl调用f不会改变j

问题在于j被传递给flipl的参数tl。此参数是一个普通的、非引用的类型int,而非 int&o因此，这个flipl调用会实例化为

void flipl(void(*fcn)(int, int&), int tl, int t2); j的值被拷贝到tl中，f中的引用参数被绑定到tl,而非j,从而其改变不会影响j。

< 693 I



定义能保持类型信息的函数参数

为了通过翻转函数传递一个引用，我们需要重写函数，使其参数能保持给定实参的“左 值性”，更进一步，可以想到我们也希望保持参数的const属性。

通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应 实参的所有类型信息。而使用引用参数(无论是左值还是右值)使得我们可以保持const 属性，因为在引用类型中的const是底层的。如果我们将函数参数定义为T1&&和T2&&, 通过引用折叠(参见16.2.5节，第608页)就可以保持翻转实参的左值/右值属性(参见

16.2.5 节，第 608 页)：

template <typename F, typename Tl, typename T2> void flip2(F f, T1 &&tl, T2 &&t2)

{

f(t2, tl);

}

与较早的版本一样，如果我们调用flip2(f, j, 42),将传递给参数tl 一个左值j。 但是，在fliP2中，推断出的T1的类型为int&,这意味着tl的类型会折叠为int&。 由于是引用类型，tl被绑定到j上。当fliP2调用f时，f中的引用参数v2被绑定到 tl,也就是被绑定到j。当f递增v2时，它也同时改变了 j的值。

![img](C++  Primer 5-160.jpg)



如果一个函数参数是指向模板类型参数的右值引用(如T&& ),它对应的实参 的const属性和左值/右值属性将得到保持。

这个版本的fliP2解决了一半问题。它对于接受一个左值引用的函数工作得很好, 但不能用于接受右值引用参数的函数。例如：

void g(int &&i, int& j)

{

cout « i « " ’’ « j << endl;

}

如果我们试图通过fliP2调用g,则参数t2将被传递给g的右值引用参数。即使我们传 递一个右值给flip2：

flip2(g, i, 42); //错误：不能从一个左值实例化int&S,

传递给g的将是flip2中名为t2的参数。函数参数与其他任何变量一样，都是左值表 达式(参见13.6.1节，第471页)》因此，flip2中对g的调用将传递给g的右值引用参 数一个左值。

在调用中使用std:forward保持类型信息

I 694〉    我们可以使用一个名为forward的新标准库设施来传递flip2的参数，它能保持原

始实参的类型。类似move, forward定义在头文件utility中。与move不同，forward

岡必须通过显式模板实参来调用（参见16.2.2节，等603页）。forward返回该显式实参类 型的右值引用。即，fOrward<T>的返回类型是T&&。

通常情况下，我们使用forward传递那些定义为模板类型参数的右值引用的函数参 数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值/右值属性：

template <typename Type> intermediary（Type &&arg）

{

finalFcn（std::forward<Type>（arg））;

}

本例中我们使用Type作为forward的显式模板实参类型，它是从arg推断出来的。由 于arg是一个模板类型参数的右值引用，Type将表示传递给arg的实参的所有类型信息。 如果实参是一个右值，则Type是一个普通（非引用）类型，forward<Type>将返回 Types,&o如果实参是一个左值，则通过引用折疊，Type本身是一个左值引用类型。在此 情况下，返回类型是一个指向左值引用类型的右值引用。再次对forwarcKType〉的返回 类型进行引用折叠，将返回一个左值引用类型。

当用于一个指向模板参数类型的右值引用函数参数（T&&）时，forward会保 持实参类型的所有细节。

使用forward,我们可以再次重写翻转函数:

template <typename F, typename Tl, typename T2> void flip(F f, Tl &&tl, T2 &&t2)

{

f(std::forward<T2>(t2), std::forward<Tl>(tl));

}

如果我们调用flip (g, i, 42) , i将以int&类型传递给g, 42将以int&&类型传递 给g。

![img](C++  Primer 5-161.jpg)



与std: :move相同，对std: :forward不使用using声明是一个好主意， 我们将在18.2.3节（第706页）中解释原因。

###### 16.2.7节练习

练习16+47:编写你自己版本的翻转函数，通过调用接受左值和右值引用参数的函数来 测试它，

##### 驗16.3重载与模板

函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函 数必须具有不同数量或类型的参数。

I 695〉



如果涉及函数模板，则函数匹配规则（参见6.4节，第209页）会在以下几方面受到

影响：

•对于一个调用，其候选函数包括所有模板实参推断(参见16.2节，第600页)成 功的函数模板实例。

•候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。

•与往常一样，可行函数(模板与非模板)按类型转换(如果对此调用需要的话)米

排序。当然，可以用于函数模板调用的类型转换是非常有限的(参见16.2.1节，第 601 页)。

•与往常一样，如果恰有•个函数提供比任何其他函数都更好的匹配，则选择此函数。 但是|如果有多个函数提供同样好的匹配.贝IJ:

—如果同样好的函数中只有一个是非模板函数，则选择此函数。

-如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比 其他模板更特例化，则选择此模板。

—否则，此调用有歧义。

\ 正确定义一组重载的函数模板需要对类型间的关系及模板函数允许的有限的 实参类型转换有深刻的理解

编写重载模板

作为一个例子，我们将构造一组函数，它们在调试中可能很有用。我们将这些调试函 数命名为debug_rep,每个函数都返回一个给定对象的string表示。我们首先编写此 函数的最通用版i,将它定义为一个模板，接受一个const对象的引用：

//打印任何我们不能处理的类型

template <typename T> string debug_rep(const T &t)

{

ostringstream ret; // 参见 8.3 节(第 287 页)

ret « t; //使用T的输出运算符打印t的一个表示形式

return ret. str () ; // 返回 ret 绑定的 string 的一个副本

}

此函数可以用来生成一个对象对应的string表示，该对象可以是任意具备输出运算符的<6961 类型。

接下来，我们将定义打印指针的debug_rep版木：

//打印指针的值，后跟指针指向的对象

II注意：此函数不能用于char*;参见16.3节(第617页)

template <typename T> string debug_rep(T *p)

{

ostringstream ret;

ret « "pointer: "<< p;    //打印指针本身的值

if (p)

ret « ’• " « debug_rep (*p) ; // 打印 p 指向的值

else

ret « " null pointer"; // 或指出 p 为空 return ret. str () ; // 返回 ret 绑定的 string 的一个副本

}

此版本生成一个string,包含指针本身的值和调用debug_rep获得的指针指向的值。 注意此函数不能用于打印字符指针，因为IO库为char*值定义了一个<<版本。此<<版木 假定指针表示一个空字符结尾的字符数组，并打印数组的内容而非地址值。我们将在16.3

节(第617页)介绍如何处理字符指针。

我们可以这样使用这些函数：

string s (’’hi");

cout << debug_rep(s) << endl;

对于这个调用，只有第一个版本的debug_rep是可行的。第二个debug_rep版本要求 一个指针参数，但在此调用中我们传递的i一个非指针对象。因此编译器€法从一个非指 针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。由于只有一个可行 函数，所以此函数被调用。

如果我们用一个指针调用debug_rep： cout << debug_rep(&s) « endl;

两个函数都生成可行的实例：

•    debug_rep (const string*&),由第一个版本的 debug_rep 实例化而来，T 被绑定到string*。

•    debug_rep (string*),由第二个版本的debug_rep实例化而来，T被绑定到 string。

第二个版本的debug_rep的实例是此调用的精确匹配。第一个版本的实例需要进行普通 指针到const指针6转换。正常函数匹配规则告诉我们应该选择第二个模板，实际上编 译器确实选择了这个版本。

s>多个可行模板

作为另外一个例子，考虑下面的调用：

const string *sp = &s;

cout « debug_rep(sp) « endl;

此例中的两个模板都是可行的，而且两个都是精确匹配：

•    debug_rep (const string*&).由第~■个版本的 debug_rep 实例化而来，T 被绑定到string*。

•    debug_rep (const string*),由第二个版本的 debug_rep 实例化而来，T 被绑定至1J const string。

在此情况下，正常函数匹配规则无法区分这两个函数。我们可能觉得这个调用将是有歧义 的。但是，根据重载函数模板的特殊规则，此调用被解析为debUg_rep(T*)，即，更特 例化的版本。

设计这条规则的原因是，没有它，将无法对一个const的指针调用指针版本的 debug_rep。问题在于模板debug_rep (const T&)本质上可以用于任何类型，包括指 针类型了此模板比debug_rep(T*r更通用，后者只能用于指针类型。没有这条规则，传 递const的指针的调用永远是有歧义的。

当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本、

非模板和模板重载

作为下一个例子，我们将定义一个普通非模板版本的debug rep来打印双引号包围

的 string：

//打印双引号包围的string string debug_rep(const string &s) {

return z + s + r ;

现在，当我们对一个string调用debug_rep时：

string s ("hi**);

cout « debug_rep(s) << endl;

有两个同样好的可行函数：

•    debug_rep<string> (const strings),第一个模板，T 被绑定到 string*»

•    debug_rep (const strings) , 非模板函数。

在本例中，两个函数具有相同的参数列表，因此显然两者提供同样好的匹配。但是，编译OS 器会选择非模板版本。当存在多个同样好的函数模板时，编译器选择最特例化的版本，出 于相同的原因，一个非模板函数比一个函数模板更好。

对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选 择非模板版本。

重载模板和类型转换

还有一种情况我们到目前为止尚未讨论：C风格字符串指针和字符串字面常量。现在 有了一个接受string的debug_rep版本，我们可能期望一个传递字符串的调用会匹配 这个版本。但是，考虑这个调用：

cout << debug_rep ("hi world!’，)<< endl; // 调用 debug_rep (T*)

本例中所有三个debug_rep版本都是可行的：

•    debug_rep (const T&) , T 被绑定至ij char [ 10]。

•    debug_rep (T*) , T 被绑定至Ij const char。

•    debug_rep (const strings),要求从 const char*至Ij string 的类型转换。

对给定实参来说，两个模板都提供精确匹配——第二个模板需要进行一次(许可的)数组 到指针的转换，而对于函数匹配来说，这种转换被认为是精确匹配(参见6.6.1节，第219 页)。非模板版本是可行的，但需要进行一次用户定义的类型转换，因此它没有精确匹配 那么好，所以两个模板成为可能调用的函数。与之前一样，T*版本更加特例化，编译器会 选择它。

如果我们希望将字符指针按string处理，可以定义另外两个非模板重载版本：

//将字符指针转换为string,并调用string版本的debug_reg string debug_rep(char *p)

{

return debug_rep(string(p));

}

string debug_rep(const char *p)

return debug一rep(string(p));

缺少声明可能导致程序行为异常

值得注意的是，为了使char*版本的debug_rep正确工作，在定义此版本时， debug_rep (const strings)的声明必须在作用域中。否则，就可能调用错误的 debug_rep 版本：

| 699>    template <typename T> string debug_rep(const T &t);

template <typename T> string debug_rep(T *p);

II为了使debug_rep (char* )的定义正确工作，下面的声明必彡贞在作用域中 string debug_rep(const string &);

string debug_rep(char *p)

{

//如果接受一个const string&的版本的声明不在作用域中，

//返回语句将调用debug_rep (const T&)的T实例化为string的版本 return debug_rep(string(p));

}

通常，如果使用了一个忘记声明的函数，代码将编译失败。但对于重载函数模板的函数而 言，则不是这样。如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不 重要了。在本例中，如果忘记了声明接受string参数的debug_rep版本，编译器会默 默地实例化接受const T&的模板版本。

![img](C++  Primer 5-162.jpg)



在定义任何函数之前，记得声明所有重载的函数版本，这样就不必担心编译器 由于未遇到你希望调用的函数而实例化一个并非你所需的版本。乂：

###### 16.3节练习

练习16.48：编'弓你自己版本的debug_rep函数。 练习16.49：解释下面每个调用会发生什么：

template <typename T> void f(T); template <typename T> void f(const T*); template <typename T> void g(T); template <typename T> void g(T*); int i = 42, *p = &i;

const int ci = 0, *p2 = &ci; g(42) ; g(p); g(ci) ; g(p2); f(42) ; f(p); f(ci); f(p2);

练习16.50：定义上一个练习中的函数，令它们打印一条身份信息。运行该练习中的代 码。如果函数调用的行为与你预期不符，确定你理解了原因。

##### 驗16.4吋变参数模板

[C++ j    个可变参数模板(variadic template)就是一个接受可变数冃参数的模板函数或模板

类。可变数目的参数被称为参数包(parameter packet)。存在两种参数包：模板参数包

LZOO> (template parameter packet),表示零个或多个模板参数；函数参数包(function parameter packet),表示零个或多个函数参数。

我们用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表

中，class...或typename...指出接下来的参数表示零个或多个类型的列表；一个类型 名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中， 如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。例如：

// Args是一个模板参数包；rest是一个函数参数包 // Args表示零个或多个模板类型参数 // rest表示掌个或多个函数参数 template <typename T, typename... Args> void foo (const T &t, const Args& ... rest);

声明了 foo是一个可变参数函数模板，它有一个名为T的类型参数，和一个名为Args 的模板参数包。这个包表示零个或多个额外的类型参数。foo的函数参数列表包含一个 const &类型的参数，指向T的类型，还包含一个名为rest的函数参数包，此包表示零 个或多个函数参数。

与往常一样，编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译 器还会推断包中参数的数目。例如，给定下面的调用：

| int i = 0; double d = 3.14; string s = | "how now brown cow |      |
| -------------------------------------- | ------------------ | ---- |
| foo (i, s, 42r d);                     | //包中有三个参数   |      |
| foo(s, 42, "hi");                      | //包中有两个参数   |      |
| foo(d, s);                             | //包中有一个参数   |      |
| foo("hi");                             | //空包             |      |

编译器会为foo实例化出四个不同的版本:

void foo(const int&, const strings, const int&, const doubles); void foo(const strings, const int&, const char[3]&); void foo (const doubles, const strings);

void foo(const char[3]&);

在每个实例中，T的类型都是从第一个实参的类型推断出来的。剩下的实参(如果有的话) 提供函数额外实参的数目和类型。

sizeof...运算符

当我们需要知道包中有多少元素时，可以使用sizeof...运算符。类似sizeof (参 见4.9节，第139页)，sizeof...也返回一个常量表达式(参见2.4.4节，第58页)，而且 不会对其实参求值：

template<typename ... Args> void g(Args ... args) { cout « sizeof . . . (Args) << endl; // 类型参数的数目 cout « sizeof... (args) « endl; // 函数参数的数目

###### 16.4节练习

练习16.51:调用本节中的每个foo,确定sizeof... (Args)和sizeof... (rest)分别 返回什么。

练习16.52:编写一个程序验证上一题的答案。

###### 16.4.1编写可变参数函数模板

如6.2.6节(第198页)所述，我们可以使用一个initializer_list来定义一个 可接受可变数目实参的函数。但是，所有实参必须具有相同的类型(或它们的类型可以转 换为同一个公共类型)。当我们既不知道想要处理的实参的数目也不知道它们的类型时， 可变参数函数是很有用的。作为一个例子，我们将定义一个函数，它类似较早的 error_msg函数，差别仅在于新函数实参的类型也是可变的。我们首先定义一个名为 print的函数，它在一个给定流上打印给定实参列表的内容。

可变参数函数通常是递归的(参见6.3.2节，第204页)。第一步调用处理包中的第一 个实参，然后用剩余实参调用自身。我们的print函数也是这样的模式，每次递归调用 将第二个实参打印到第一个实参表示的流中。为了终止递归，我们还需要定义一个非可变 参数的print函数，它接受一个流和~个对象：

//用来终止递归并打印最后一个元素的函数

//此函教必须在可变参数版本的print定义之前声明

template<typename T>

ostream Sprint(ostream &os, const T &t)

{

return os « t; //包中最后一个元素之后不打印分隔符

}

//包中除了最后一个元素之外的其他元素都会调用这个版本的print template <typename T, typename... Args>

ostream Sprint(ostream &os, const T &t, const Args&... rest)

{

os « t « ", "；    //打印第一个实参

return print (os, rest...);    // 递!)3 调用，打印其他实参

)

第一个版本的print负责终止递归并打印初始调用中的最后一个实参。第二个版本的 print是可变参数版本，它打印绑定到t的实参，并调用自身来打印函数参数包中的剩 余值。

这段程序的关键部分是可变参数函数中对print的调用： return print (os, rest...); //递担调用，打印其他实参

我们的可变参数版本的print函数接受三个参数：一个ostreams，一个const T&和一 个参数包。而此调用只传递了两个实参。其结果是rest中的第一个实参被绑定到t,剩

[202>余实参形成下一个print调用的参数包。因此，在每个调用中，包中的第一个实参被移 除，成为绑定到t的实参。即，给定：

print (cout, i, s, 42); //包中有两个参数 递归会执行如下：

调用    t    rest...

print(cout,    i,    s, 42)    i    s, 42

print(cout,    s,    42)    s    42

print (cout, 42)调用非可变参数版本的print

前两个调用只能与可变参数版本的print匹配，非可变参数版本是不可行的，因为这两 个调用分别传递四个和三个实参，而非可变参数print只接受两个实参。

对于最后一次递归调用print （cout, 42）,两个print版本都是可行的。这个调 用传递两个实参，第一个实参的类型为ostream&»因此，可变参数版本的print可以 实例化为只接受两个参数：一个是ostream&参数，另一个是const T&参数。

对于最后一个调用，两个函数提供同样好的匹配。但是，非可变参数模板比可变参数 模板更特例化，因此编译器选择非可变参数版本（参见16.3节，第615页）。

WARNING



当定义可变参数版本的print时，非可变参数版本的声明必须在作用域中。 否则，可变参数版本会无限递归。

###### 16.4.1节练习

练习16.53:编写你自己版本的print函数，并打印一个、两个及五个实参来测试它， 要打印的每个实参都应有不同的类型。

练习16.54:如果我们对一个没有<<运算符的类型调用print,会发生什么？

练习16.55：如果我们的可变参数版本print的定义之后声明非可变参数版本，解释可 变参数的版本会如何执行。

###### 16.4.2包扩展

对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展（expand）

它。当扩展一个包时，我们还要提供用于每个扩展元素的模式（pattern）。扩展一个包就是<70^ 将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在模式右边 放一个省略号（...）来触发扩展操作，

例如，我们的print函数包含两个扩展：

template <typename T, typename... Args> ostream &

print（ostream &os, const T &t, const Args&... rest） // 才广展Args

{

os « t <<    ;

return print（os, rest...）;    // ,展rest

}

第一个扩展操作扩展模板参数包，为print生成函数参数列表。第二个扩展操作出现在 对print的调用中。此模式为print调用生成实参列表。

对Args的扩展中，编译器将模式const Arg&应用到模板参数包Args中的每个元 素。因此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如 const type&o 例如：

print （cout, i, s, 42）; //包中有两个参数 最后两个实参的类型和模式一起确定了尾置参数的类型。此调用被实例化为：

ostream&

print（ostreams, const int&, const strings, const int&）;

第二个扩展发生在对print的（递归）调用中。在此情况下，模式是函数参数包的 名字（即rest）。此模式扩展出一个由包中元素组成的、逗号分隔的列表。因此，这个调

用等价于：

print(os, s, 42);

理解包扩展

print中的函数参数包扩展仅仅将包扩展为其构成元素，C++语言还允许更复杂的扩 展模式。例如，我们可以编写第二个可变参数函数，对其每个实参调用debug_rep (参 见16.3节，第615页)，然后调用print打印结果string:

II在print调用中对每个实参讲用debug_rep template <typename... Args>

ostream SerrorMsg(ostream &os, const Args&... rest)

{

// print(os, debug_rep(al), debug_rep(a2),    debug_rep(an)

return print(os, debug_rep(rest)...);

}

I 704〉 这个print调用使用了模式debug_reg (rest)。此模式表示我们希望对函数参数 包rest中的每个元素调用debug_repo扩展结果将是一个逗号分隔的debug_rep调 用列表。即，下面调用：

errorMsg(cerr, fcnName, code.num(), otherData, "other”， item);

就好像我们这样编写代码一样

print (cerr, debug_rep(fcnName), debug_rep(code.num()),

debug_rep(otherData), debug_rep("otherData"), debug_rep(item));

与之相对，下面的模式会编译失败

// 将包传递给 debug_rep; print (os, debug_rep (al, a2,    an))

print (os, defc)ug_rep (rest...)); // 错误：此调用无匹配函数

这段代码的问题是我们在debug_rep调用中扩展了 rest,它等价于

print(cerr, debug_rep(fcnName, code.num(),

otherData, "otherData", item));

在这个扩展中，我们试图用一个五个实参的列表来调用debug_rep，但并不存在与此调 用匹配的debug_rep版本。debug_rep函数不是可变参数的，而且没有哪个debug_rep 版本接受五个参i。

扩展中的模式会独立地应用于包中的每个元素。

###### 16.4.2节练习

练习16.56：编写并测试可变参数版本的errorMsg。

练习16.57:比较你的可变参数版本的errorMsg和6.2.6节(第198页冲的error_msg 函数。两种方法的优点和缺点各是什么？

#### @ 16.4.3转发参数包

■c^    在新标准下，我们可以组合使用可变参数模板与forward机制来编写函数，实现将

其实参不变地传递给其他函数。作为例子，我们将为StrVec类(参见13.5节，第465 页)添加一个emplace_back成员。标准库容器的emplace_back成员是一个IJT变参 数成员模板(参见16.1.4_节，第596页)，它用其实参在容器管理的内存空间中直接构造 一个元素。

我们为StrVec设计的emplace_back版本也应该是可变参数的，因为string有 多个构造函数，参数各不相同。由于我1门希望能使用string的移动构造函数，因此还需<ZQ5： 要保持传递给emplace_back的实参的所有类型信息。

如我们所见，保持类型信息是一个两阶段的过程。首先，为了保持实参中的类型信息，

必须将emplace_back的函数参数定义为模板类型参数的右值引用(参见16.2.7节，第 613 页)：

class StrVec { public:

template 〈class... Args> void emplace_back(Args&&...);

//其他成员的定义，同13.5节(第465页)

}；

模板参数包扩展中的模式是&&，意味着每个函数参数将是一个指向其对应实参的右值引 用。

其次，当emplace_back将这些实参传递给construct时，我们必须使用forward 来保持实参的原始类型(参见16.2.7节，第614页)：

template <class... Args> inline

void StrVec::emplace_back(Args&&... args)

{

chk_n_alloc () ; //如果需要的话重新分配StrVec内存空间

alloc.construct(first_free++, std::forward<Args>(args)...)；

}

emplace_back的函数体调用了 chk_n_alloc (参见13.5节：第465 50来确保有足 够的空间容纳一个新兀素，然后调用了 construct在first_free指向的位置中创建 了一个元素。construct调用中的扩展为

std::forward<Args>(args)...

它既扩展了模板参数包Args,也扩展了函数参数包args。此模式牛成如下形式的元素 std: : forward<Ti> (ti)

其中A表示模板参数包中第i个元素的类型，ti表示函数参数包中第i个元素。例如， 假定svec是一个StrVec,如果我们调用

svec. emplace_back (10, r c’)； // 将 cccccccccc 添力口为新的尾元素 construct调用中的模式会扩展出

std::forward<int>(10), std::forward<char>(c)

通过在此调用中使用forward，我们保证如果用一个右值调用emplaCe_back,则 construct也会得到一个右值。例如，在下面的调用巾：

svec.emplace_back (si + s2) ; // 使用移动构造函数 传递给emplace back的实参是一个右值，它将以如下形式传递给construct

std::forward<string>(string("the end"))

forward<string>的结果类型是string&&,因此construct将得到一个右值引用实 参。construct会继续将此实参传递给string的移动构造函数来创建新元素。

进议：转发和"T变参数模板

可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的 emplace_back函数一样的形式：

// fun有零个或多个参数，每个参数都是一个模板参数类型的右值引用 template<typename... Args>

void fun (Args&& . . . args) //将Args扩展为一个右值引用的列表

{

// work的实参既扩展Args又扩展args work(std::forward<Args>(args)...);

}

这里我们希望将fun的所有实参转发给另一个名为work的函数，假定由它完成函数的 实际工作6类似emplace_back中对construct的调用，work调用中的扩展既扩展 了模板参数包也扩展了函i参数包。

由于fun的参数是右值引用，因此我们可以传递给它任意类型的实参；由于我们 使用std: : forward传递这些实参，因此它们的所有类型信息在调用work时都会得 到保持。

###### 16.4.3节练习

练习16.58：为你的StrVec类及你为16.1.2节(第591页)练习中编写的Vec类添加 emplace_back 函数。

练习16.59:假定s是一个string,解释调用svec . emplace_back (s)会发生什么。 练习16.60：解释make_shared (参见12.1.1节，第401页)是如何工作的。

练习16.61:定义你自己版本的make shared。

绿16.5模板特例化

编写单一模板，使之对任何可能的模板实参都是最适合的，都能实例化，这并不总是 能办到。在某些情况下，通用模板的定义对特定类型是不适合的：通用定义可能编译失败 或做得不正确。其他时候，我们也可以利用某些特定知识来编写更高效的代码，而不是从 通用模板实例化。当我们不能(或不希望)使用模板版本时，可以定义类或函数模板的-• 个特例化版本。

我们的compare函数是一个很好的例子，它展示了函数模板的通用定义不适合一个 特定类型(即字符指针)的情况。我们希望compare通过调用strcmp比较两个字符指 针而非比较指针值。实际上，我们已经重载了 compare函数来处理字符串字面常量(参 见16.1.1节，第579页)：

//第一个版本；可以比较任意两个类型

template <typename T> int compare(const T&, const T&);

//第二个版本处理字符串字面常量 template<size_t N, size_t M>

int compare(const char (&)[N], const char (&)[M]);

但是，只有当我们传递给compare 一个字符串字面常量或者一个数组时，编译器才会调 用接受两个非类型模板参数的版本。如果我们传递给它字符指针，就会调用第一个版本：

const char *pl = "hi", *p2 = "mom";

compare (pi, p2) ;    //调用第一个模板

compare ("hi" f "mom");    //调用有两个非类型参数的版本

我们无法将一个指针转换为一个数组的引用，因此当参数是pi和p2时，第二个版本的 compare是不可行的。

为了处理字符指针(而不是数组)，可以为第一个版本的compare定义一个模板特例 化(template specialization)版本。一个特例化版本就是模板的一个独立的定义，在其中一 个或多个模板参数被指定为特定的类型。

定义函数模板特例化

当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指 出我们正在实例化一个模板，应使用关键字template后跟一个空尖括号对(<〉)。空尖 括号指出我们将为原模板的所有模板参数提供实参：

// compare的特殊版本，处理字符数组的指针 template <>

int compare(const char* const &pl, const char* const &p2)

{

return strcmp(pi, p2);

}

理解此特例化版本的困难之处是函数参数类型。当我们定义一个特例化版本时，函数参数 类型必须与一个先前声明的模板中对应的类型匹配。本例中我们特例化：

template <typename T> int compare(const T&, const T&);

其中函数参数为一个const类型的引用。类似类型别名，模板参数类型、指针及const 之间的相互作用会令人惊讶(参见2.5.1节，第60页)。

我们希望定义此函数的一个特例化版本，其中T为const char*。我们的函数要求 一个指向此类型const版本的引用。一个指针类型的const版本是一个常量指针而不是 指向const类型的指针(参见2.4.2节，第56页)。我们需要在特例化版本中使用的类型 是const char * const &，即一个指向const char的const指针的引用。

函数重载与模板特例化

<~707~|



<70^1



当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模 板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而 非函数名的一个重载版本。

![img](C++  Primer 5-164.jpg)



特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配17

我们将--个特殊的函数定义为一个特例化版本还是一个独立的非模板函数，会影响到 函数匹配。例如，我们己经定义了两个版本的compare函数模板，一个接受数组引用参 数，另一个接受const T&。我们还定义了一个特例化版本来处理字符指针，这对函数匹 配没有影响-当我们对字符串字面常量调用compare时

compare（"hi", "mom"）

对此调用，两个函数模板都是可行的，且提供同样好的（即精确的）匹配。但是，接受字 符数组参数的版本更特例化（参见16.3节，第615页），因此编译器会选择它，

如果我们将接受字符指针的compare版本定义为一个普通的非模板函数（而不是模 板的一个特例化版本），此调用的解析就会不同。在此情况下，将会有三个可行的函数： 两个模板和非模板的字符指针版本。所有三个函数都提供同样好的匹配。如前所述，当一 个非模板函数提供与函数模板同样好的匹配时，编译器会选择非模板版本（参见16.3节， 第615页）。

关键概念：绔通作川域现则应川于特例化

为了特例化一个模板，原模板的声明必须在作用域中D而且，在任何使用模板实例 的代码之前，特例化版本的声明也必须在作用域中，

对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处 理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生 成代码:.由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特 例化版本声明顺序导致的错误，而这种错误又很难查找。

如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参 集合，就会产生错误。但是，这种错误编译器又无法发现。

卩^«模板及其特例化版本应该声明在同一个头文件中所有同名模板的声明应该放 在前面，然后是这些模板的特例化版本、

类模板特例化

除了特例化函数模板，我们还可以特例化类模板。作为一个例子，我们将为标准库 hash模板定义一个特例化版本，可以用它来将Sales_data对象保存在无序容器中。默 i人情况下，无序容器使用hash<key_type> （参见11.4节，第394页）来组织其元素。 为了让我们自己的数据类型也能使用三种默汄组织方式，必须定义hash模板的一个特例 化版本。一个特例化hash类必须定义：

• 一个重载的调用运算符（参见14.8节，第506页），它接受一个容器关键字类型的 对象，返回一■个size_t»

•两个类®成员，result_type和argument_type，分别调用运算符的返回类型 和参数类型，

•默认构造函数和拷贝赋值运算符（可以隐式定义，参见13.1.2节，第443页）。

在定义此特例化版本的hash时，唯一复杂的地方是：必须在原模板定义所在的命名空 间中特例化它。我们将在18.2节（第695页）中介绍更多命名空间的相关内容。现在，我 们只需知道一我们可以向命名空间添加成员。为了达到这一目的，首先必须打开命名空间：

II打开std命名空间，以便特例化std: :hash namespace std {

} //关闭std命名空间；注意：右花括号之后没有分号 花括号对之间的任何定义都将成为命名空间Std的一部分。

下面的代码定义了一个能处理Sales_data的特例化hash版本：

II打开std命名空间，以便特例化std: :hash namespace std {

template <> //我们正在定义一个特例化版本，模板参数为Sales_data struct hash<Sales_data>

{

//用来散列一个无序容器的类型必须要定义下列类型 typedef size_t result一type;

typedef Sales_data argument_type; // 默认情况下，此类型需要== size_t operator()(const Sales_data& s) const;

//我7们的类使用合成的拷贝控制成员和i认构造函数

}；

size_t

hash<Sales_data>::operator()(const Sales_data& s) const

{

return hash<string>()(s.bookNo) A

hash<unsigned>()(s.units_sold) A hash<double>()(s.revenue);

}

} //关闭std命名空间；注意：右花括号之后没有分号

我们的hash<Sales_data>定义以templateo开始，指出我们正在定义一"^全特例化03 的模板=我们正在特例化的模板名为hash,而特例化版本为hash<Sales_data>。接 下来的类成员是按照特例化hash的要求而定义的。

类似其他任何类，我们可以在类内或类外定义特例化版本的成员，本例中就是在类外 定义的。重载的调用运算符必须为给定类型的值定义一个哈希函数。对于一个给定值，任 何时候调用此函数都应该返回相同的结果。一个好的哈希函数对不相等的对象(儿乎总是)

应该产生不同的结果。

在本例中，我们将定义一个好的哈希函数的复杂任务交给了标准库。标准库为内置类 型和很多标准库类型定义了 hash类的特例化版本。我们使用一个(未命名的) hash<string>对象来生成bookNo的哈希值，用一个hashfunsigned:^5!]^来生成 units_sold的哈希值，用一个hash<double>对象來生成revenue的哈希值。我们 将这些结果进行异或运算(参见4.8节，第137页)，形成给定Sales_data对象的完整 的哈希值。

值得注意的是，我们的hash函数计算所有三个数据成员的哈希值，从而与我们为 Sales_data定义的operator==(参见14.3.1节，第497页)是兼容的。默认情况下，

为了处&特定关键字类型，无序容器会组合使用key_type对应的特例化hash版本和 key_type上的相等运算符。

假定我们的特例化版本在作用域中，当将Sales_data作为容器的关键字类型吋，

编译器就会自动使用此特例化版本：

II 使用 hash<Sales_data>* 14.3」节(第 497 瓦)中 Sales_data 的 operator= unordered_multiset<Sales_data> SDset;

由于hash<Sales data〉使用Sales data的私有成员，我们必须将它声明为

Sales_data 的友兀：

template〈class T> class std: :hash; // 友元声明所需要的 class Sales_data {

friend class std::hash<Sales_data>;

//其他成贾定义，如前

}；

这段代码指出特殊实例hash<Sales_data〉是Sales_data的友元。由于此实例定义 在std命名空间中，我们必须记得在friend声明中应使用std: :hash。

![img](C++  Primer 5-165.jpg)



为了让Sales_data的用户能使用hash的特例化版本，我们应该在 Sales_data的头文件中定义该特例化版本。

类模板部分特例化

与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一 r7iE>部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化 (partial specialization)本身是一个模板，使用它时用户还必须为那些在特例化版本中未指

定的模板参数提供实参。

![img](C++  Primer 5-166.jpg)



我们只能部分特例化类模板，而不能部分特例化函数模板。

在16.2.3节(第605页)中我们介绍了标准库remove_reference类型。该模板是 通过一系列的特例化版本来完成其功能的：

//原始的、最通用的版本

template <class T> struct remove_reference { typedef T type;

}；

//部分特例化版本，将用于左值引用和右值引用

template〈class T> struct remove_reference<T&> // 左值弓 1 用 { typedef T type; };

template〈class T> struct remove_reference<T&&> // 右值引用 { typedef T type; };

第一个模板定义了最通用的模板。它可以用任意类型实例化；它将模板实参作为type成 员的类型=接下来的两个类是原始模板的部分特例化版本。

由于一个部分特例化版本本质是一个模板，与往常一样，我们首先定义模板参数。类 似任何其他特例化版本，部分特例化版本的名字与原模板的名字相同。对每个未完全确定 类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，我们 为要特例化的模板参数指定实参，这些实参列于模板名之后的尖括号中。这些实参与原始 模板中的参数按位置对应。

部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例 化版本。在本例中，特例化版本的模板参数的数目与原始模板相同，但是类型不同。两个 特例化版本分别用于左值引用和右值引用类型：

int i;

// decltype (42)为int，使用原始模板 remove reference<decltype(42)>::type a;

// decltype (i)为int&，使用第一个(T& )部分特例化版本 remove_reference<decltype(i)>::type b;

// decltype (std: :move (i))为int&&,使用第二个(即T&& )部分特例化版本 remove reference<decltype(std::move(i))>::type c;

三个变量a、b和c均为int类型。

特例化成员而不是类

我们可以只特例化特定成员函数而不是特例化整个模板。例如，如果FOO是一个模 板类，包含一个成员Bar,我们可以只特例化该成员：

template <typename T> struct Foo {

Foo (const T &t = T()): mem(t) { } void Bar() { /* ... */ }

T mem;

// Foo的其他成员

}；

tempiate<>    //我们正在特例化一个模板

void Foo<int> : :Bar () // 我们正在特例化 Foo<int>的成员 Bar {

//进行应用于int的特例化处理

}

本例中我们只特例化？00<;1111:>类的一个成员，其他成员将由Foo模板提供：

Foo<string> fs;    // 实例化 Foo<string>: :Foo ()

f s .Bar () ;    // 实例化 Foo<string> ::Bar ()

Foo<int> f i;    // 实例化 Foo<int>:: Foo ()

fi .Bar () ;    //使用我们特例化版本的Foo<int>: :Bar ()

当我们用int之外的任何类型使用Foo时，其成员像往常一样进行实例化。当我们用int 使用Foo时，Bar之外的成员像往常一样进行实例化。如果我们使用FOO<int>的成员 Bar,则会使用我们定义的特例化版本。

###### 16.5节练习_

练习16.62：定义你自己版本的hash<Sales_data〉，并定义一个Sales_data对象 的unordered_multiset。将多条交易记录保存到容器中，并打印其内容。

练习16.63:定义一个函数模板，统计一个给定值在一个vector中出现的次数。测试 你的函数，分别传递给它一■个double的vector,—个int的vector以及一个 string 的 vector。

练习16.64：为上一题中的模板编写特例化版本来处理vector<const char*〉。编 写程序使用这个特例化版本。

练习16.65:在16.3节(第617页)中我们定义了两个重载的debug_rep版本，一个 接受const char*参数，另一个接受char*参数。将这两个函数重写为特例化版本。 练习16.66:重载debtig_rep函数与特例化它相比，有何优点和缺点？

练习16.67:定义特例化版本会影响debLig rep的函数匹配吗？如果不影响，为什么？

Era＞小结_

模板U C++语i众不M的特性，也是标准叩的基础.-个機板就是-个编译器用來 1-:成特定炎类51或函数的蓝困.'I:-成特纪类或函数的过样称为实例化.我们只编'与一次模 板，就町以将其用n种类型和值，编译器僉为毎种类型相值进汀模板实例化•

我们既可以定义涵数模板，也W以定义类模板。标准祚律法都记函数模板，标准库容 器都是类校板

W乂投板实参允i'卩我们阆定-个或多个模板参数的类■值。对f指定了显式模板实 参的模板参数.可以应用止常的类彻转換.

•个投板特例化就足 '个用户提供的模板实例，它将•个或多个模板参数绑定到特定 类增成值上. '与我们不能(或不沿望)将模板定义用r某鵷特定类型时，特例化依常夯用.

诚新C++鉍准的个1:耍部分足川'变参数摸板.个4变参数模板叫'以接受数H和类 可变的参歎。叫变養数模板允许我们编1像容器卿emplace成霧和标准峰

make_shareci 数这样的函数，实现将实参传递给对象的构造函数-

类模板(class template)投板定义，吋

从它实例化出牯定的类.炎投板的定义以 关键'? template开始,后跟尖括号对＜ 和＞，M:内为个用逗分隔的•个或多个 模板参故的列表，随后足类的定义。

默认模板实参(default template argument)

•个类咽或-•个值.'与肋提供対应校 &实参时，模板会使川它，

显式实例化 ＜ explicit instantiation) ■个

声明，y、j所夼模板参数提供了显式实参. 川求-指列化过程。如宋卢叫A1; extern 的，模板将不会被实例化:否则，模板将 利蜊指定的实参道行寃駒化。对毎个 extern投板声明，/EfiUY:中某处必须 个IP extern的!ul式丈例化.

显式模板实参(.explicit template argument)

花•个函数调用中成定义模板类类型时, 由用P提供的模板实参.赇式模板实参在 紧跟作模板名的尖括G对中给岀。

函数参数包(function parameter pack)表

不；个或多个函数参数的参数包„

函数模板(function template)模板定义，

|叮从它沈例化岀特定函数，函数模板的定

义以又键7 template斤始，JTI+跟尖ttU 对＜和＞.K内为-••个用屬分分隔的-个或 多个模板参敷的列犮，随后是函数的定义,

实例化(instantiate)編汴器处评过柷，

W实际的模板实参來乍成模板的_个特殊 实例.其屮参数波锌換为对应的实参.， 函数投板被凋谢对，会T彳动根裾传述给它 的实参來实例化。时使/B类桢板时，则： 要我们提供姑式模板实参。

实例(instantiation)编汗器从模板成

的类或函放。

成员模板(member template) 4^ ft IeIK 板的成S函数。成0模板不能是虚函数。

非类型参数(nontype parameter) 喪水

值的模板参数。11:类喂模板参数的实参必 须玷常W炎达式.

包扩展(packexpansion)处理过程，将

••个参数包押换为其中元素的列表.

参数包(parameter pack)衣丫'^个成多 个参数的税板或函数参数。

部分特例化(partial specialization)类投

板的-个版木，其中指记厂策，+坫所

有模板参数，或是一个或多个参数的属性 未被完全指定。

模式(pattern)定义了扩展后参数包中每 个元素的形式。

模板实参(template argument)用来实

例化模板参数的类型或值。

模板实参推断(template argument deduction)编译器确定实例化哪个函数 模板的过程。编译器检查那些使用模板参 数的实参的类型，将这些类型或值绑定到 模板参数，來自动实例化一个函数版本。

模板参数(template parameter)在模板

参数列表中指定的名字，可在模板定义内 部使用。模板参数可以是类型参数，也可 以是非类型参数。为了使用•个类模板， 我们必须为毎个模板参数提供显式实参， 编译器使用这些类型或值实例化出一个类 版本，其中所有用到模板参数的地方都被 替换为实际的实参。当使用一个函数模板 时，编译器使用调用中的函数实参推断模 板实参，并使用推断出的模板实参实例化 出一个特定的函数。

模板参数列表(template parameter list)

用逗号分隔的参数列表，用丁•模板的定义 或声明中。每个参数可以是一个类型参数， 也可以是一个非类型参数。

模板参数包(template parameter pack)

表示零个或多个模板参数的参数包。

模板特例化(templatespecialization)类

模板、类模板的成员或函数模板的重定义， 其中指定了某些(或全部)模板参数。模 板特例化版本必须出现在原模板的声明之 后，必须出现在任何利用特殊实参来使用 模板的代码之前。一个函数模板中的每个 模板参数都必须完全特例化。

类型参数(type parameter)模板参数列

表中的名字，用來表示类型。类型参数在 关键字typename或class之后指定。

类型转换(type transformation)由标准

库定义的类模板，可将给定的模板类型参 数转换为一个相关类型。

可变参数模板(variadic template)接受

可变数目模板实参的模板。模板参数包用 省略号指定(如class...、typename...或 type-name...)
