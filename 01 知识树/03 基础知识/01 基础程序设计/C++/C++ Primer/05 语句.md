#### 第5章

<J7T]



### 语句

内容

........................ 178

..................................................................................................................178

和大多数语言一样，C++提供了条件执行语句、重复执行相同代码的循环语句和用于 中断当前控制流的跳转语句。本章将详细介绍C++语言所支持的这些语句。

Ht2>    通常情况下，语句是顺序执行的。但除非是最简单的程序，否则仅有顺序执行远远不

够。因此，C++语言提供了一组控制流(flow-of-control)语句以支持更复杂的执行路径。

###### 50 5.1简单语句

C++语言中的大多数语句都以分号结束，一个表达式，比如ival + 5,末尾加上分 号就变成了表达式语句(expression statement)。表达式语句的作用是执行表达式并丢弃掉 求值结果：

ival + 5；    // 一条没什么实际用处的表达式语句

cout << ival；    // 一条有用的表达式语句

第一条语句没什么用处，因为虽然执行了加法，但是相加的结果没被使用。比较普遍的情 况是，表达式语句中的表达式在求值时附带有其他效果，比如给变量赋了新值或者输出了 结果。

空语句

最简单的语句是空语句(null statement),空语句中只含有一个单独的分号：

;//空语句

如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语 句。一种常见的情况是，当循环的全部工作在条件部分就可以完成时，我们通常会用到空 语句。例如，我们想读取输入流的内容直到遇到一个特定的值为止，除此之外什么事情也 不做：

//重复读入教据直至到达文件末尾或某次愉入的值等于sought while (cin » s && s != sought)

，-II空语句

while循环的条件部分首先从标准输入读取一个值并且隐式地检查cin,判断读取是否 成功。假定读取成功，条件的后半部分检查读进来的值是否等于sought的值。如果发现 了想要的值，循环终止；否则，从cin中继续读取另一个值，再一次判断循环的条件。

Bert    使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略

偏嫩的

别漏写分号，也别多写分号

因为空语句是一条语句，所以可用在任何允许使用语句的地方。由于这个原因，某些 看起来非法的分号往往只不过是一条空语句而已，从语法上说得过去。下面的片段包含两 条语句：表达式语句和空语句。

I 173〉    ival = vl + v2;; //正确：第二个分号表示一条多余的空语句

多余的空语句一般来说是无害的，但是如果在if或者while的条件后面跟了一个额外的 分号就可能完全改变程序员的初衷。例如，下面的代码将无休止地循环下去：

//出现了糟糕的情况：额外的分号，循环体是那条空语句

while (iter ! = svec . end () )    ；    // while 循环体是那条空语句

++iter；    //递增运算不属于循环的一部分

虽然从形式上来看执行递增运算的语句前面有缩进，但它并不是循环的一部分。循环条件 后面跟着的分号构成了一条空语句，它才是真正的循环体。

,!\ 多余的空语句并非总是无害的•

WARNING

复合语句（块）

复合语句（compound statement）是指用花括号括起来的（可能为空的）语句和声明 的序列，复合语句也被称作块（block）。一个块就是一个作用域（参见2.2.4节，第43页）， 在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。通常，名字在有限的区域 内可见，该区域从名字定义处开始，到名字所在的（最内层）块的结尾为止。

如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使 用复合语句。例如，while或者for的循环体必须是一条语句，但是我们常常需要在 循环体内做很多事情，此时就需要将多条语句用花括号括起来，从而把语句序列转变 成块。

举个例子，回忆1.4+1节（第10页）的while循环： while （val <= 10）    {

sum += val;    // 4巴 sum + val 的值赋给 sunu

++val;    // 给val加 1

}

程序从逻辑上来说要执行两条语句，但是while循环只能容纳一条。此时，把要执行的 语句用花括号括起来，就将其转换成了一条（复合）语句。

块不以分号作为结束。

所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句：

while （cin » s && s != sought）

{ } //空块

###### 5.1节练习

<3741



练习5.1:什么是空语句？什么时候会用到空语句？

练习5.2:什么是块？什么时候会用到块？

练习5.3:使用逗号运算符（参见4.10节，第140页）重写1.4.1节（第10页）的while 循环，使它不再需要块，观察改写之后的代码的可读性提高了还是降低了。

##### 5.2语句作用域

可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构 当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：

while （int i = get_num（）） //每次迭代时创建并初始化i cout « i << endl;

i = 0; //错误：在循环外部无法访问i

如果其他代码也需要访问控制变量，则变量必须定义在语句的外部：

//寻找第一个负值元素

auto beg = v.begin()；

while (beg != v.end() && *beg >= 0)

++beg；

if (beg == v.end())

//此时我们知道v中的所有元素都大于等于0

因为控制结构定义的对象的值马上要由结构本身使用，所以这些变量必须初始化。

5.2节练习

练习5.4:说明下列例子的含义，如果存在问题，试着修改它。

(a)    while (string::iterator iter != s.end())    { /*...*/ }

(b)    while (bool status = find (word) )    { /*..•*/ }

if (!status) { /* ...*/ }

##### 5.3条件语句

C++语言提供了两种按条件执行的语句。一种是if语句，它根据条件决定控制流； 另外一种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径 中选择一条。

龍5.3.1 if语句

□ZD> if语句(if statement)的作用是：判断一个指定的条件是否为真，根据判断结果决定 是否执行另外一条语句。if语句包括两种形式：一种含有else分支，另外一种没有。简单 if语句的语法形式是

if {condition) statement

if else语句的形式是

if (condition) statement

else

statement!

在这两个版本的if语句中，condition都必须用圆括号包围起来。condition可以是一个表 达式，也可以是一个初始化了的变量声明(参见5.2节，第155页)。不管是表达式还是变 量，其类型都必须能转换成(参见4.11节，第141页)布尔类型。通常情况下，statement 和statement!是块语句。

如果condition为真，执行statement。当仙如狀咐执行完成后，程序继续:执行if语 句后面的其他语句。

如果condition为假，跳过伽妃/wez^。对于简单if语句来说，程序继续执行if语句 后面的其他语句；对于if else语句来说，执行伽Zewezzd。

使用if else语句

我们举个例子来说明if语句的功能，程序的目的是把数字形式表示的成绩转换成字 母形式。假设数字成绩的范围是从0到100 (包括100在内)，其中100分对应的字母形式 是“A++”，低于60分的成绩对应的字母形式是“F”。其他成绩每10个划分成一组：60 到69 (包括69在内)对应字母“D”、70到79对应字母“C”，以此类推。使用vector 对象存放字母成绩所有可能的取值：

const vector<string> scores = {"F", "D", "C", "B", "A", "A++"};

我们使用if else语句解决该问题，根据成绩是否合格执行不同的操作：

//如果grade小于60，对应的字母是F;否则计算其下标 string lettergrade; if (grade < 60)

lettergrade = scores[0];

else

lettergrade = scores[(grade - 50)/10];

判断grade的值是否小于60,根据结果选择执行if分支还是else分支。在else分支 中，由成绩计算得到一个下标，具体过程是：首先从grade中减去50,然后执行整数除 法(参见4.2节，在125页)，去掉余数后所得的商就是数组scores对应的下标。

嵌套if语句

<1761



接下来让我们的程序更有趣点儿，试着给那些合格的成绩后面添加一个加号或减号。 如果成绩的末位是8或者9,添加一个加号；如果末位是0、1或2,添加一个减号：

if (grade % 10 > 7)

lettergrade += '+';//末尾是8或者9的成绩添加一个加号 else if (grade % 10 < 3)

lettergrade += ' - • ； //末尾是0、1或者2的成绩添加一个减号 我们使用取模运算符(参见4.2节，第125页)计算余数，根据余数决定添加哪种符号。

接着把这段添加符号的代码整合到转换成绩形式的代码中去：

//如果成绩不合格，不需要考虑添加加号减号的问题 if (grade < 60)

lettergrade = scores[0]; else {

lettergrade = scores [ (grade - 50)/10]; // 获得字母形式的成绩 if (grade != 100) //只要不是A++,就考虑添加加号或减号

if (grade % 10 > 7)

lettergrade += '+';//末尾是8或者9的成绩添加一个加号 else if (grade % 10 < 3)

lettergrade += ’-•;//末尾是0、1或者2的成绩添加一个减号

}

注意，我们使用花括号把第一个else后面的两条语句组合成了一个块。如果grade不 小于60要做两件事：从数组scores中获取对应的字母成绩，然后根据条件设置加号或 减号，

注意使用花括号

有一种常见的错误，本来程序中有几条语句应该作为一个块来执行，但是我们忘了用 花括号把这些语句包围。在下面的例子中，添加加号减号的代码将被无条件地执行，这显 然违背了我们的初衷：

if (grade < 60)

lettergrade = scores[0];

else //错误：缺少花括号

lettergrade = scores[(grade - 50)/10];

//虽然下面的语句从形式上看有缩进，但是因为没有花括号，

//所以无论什么情况都会执行接下来的代码

//不及格的成绩也会添加上加号或减号，这显然是错误的

if (grade != 100)

if (grade % 10 > 7)

lettergrade += '+';//末尾是8或者9的成绩添加一个加号 else if (grade % 10 < 3)

lettergrade +=    末尾是0、1或者2的成绩添加一个减号

要想发现这个错误可能非常困难，毕竟这段代码“看起来”是正确的。

为了避免此类问题,有些编码风格要求在if或else之后必须写上花括号(对while □IZ>和for语句的循环体两端也有同样的要求)。这么做的好处是可以避免代码混乱不清，以

后修改代码时如果想添加别的语句，也可以很容易地找到正确位置。

许多编辑器和开发环境都提供一种辅助工具，它可以自动地缩进代码以匹配其 语法结构。善用此类工具益处多多。

悬垂else

当一个if语句嵌套在另一个if语句内部时，很可能if分支会多于else分支，事 实上，之前那个成绩转换的程序就有4个if分支，而只有2个else分支。这时候问题 出现了：我们怎么知道某个给定的else是和哪个if匹配呢？

这个问题通常称作悬垂else Cdangling else),在那些既有if语句又有if else语 句的编程语言中是个普遍存在的问题。不同语言解决该问题的思路也不同，就CM而言， 它规定else与离它最近的尚末匹配的if匹配，从而消除了程序的二义性。

当代码中if分支多于else分支时，程序员有时会感觉比较麻烦。举个例子来说明， 对于添加加号减号的那个最内层的if else语句，我们用另外一组条件改写它：

II错误：实际的执行过程并非像缩进格式显示的那样；else分支匹配的是内层if语句 if (grade % 10 >= 3)

if (grade % 10 > 7)

lettergrade +=    //末尾是8或者9的成绩添加一个加号

else

lettergrade +=    //末尾是3、4、5、6或者7的成绩添加一个减号！

从代码的缩进格式来看，程序的初衷应该是希望else和外层的if匹配，也就是说，我 们希望当grade的末位小于3时执行else分支。然而，不管我们是什么意图，也不管 程序如何缩进，这里的else分支其实是内层if语句的一部分。最终，上面的代码将在 末位大于3小于等于7的成绩后面添加减号！它的执行过程实际上等价于如下形式：

//缩进格式与执行过程相符，但不是程序M的意图 if (grade % 10 >= 3)

if (grade % 10 > 7)

lettergrade += * + ';//末尾是8或者9的成绩添加一个加号

else

lettergrade +=    末尾是3、4、5、6或者7的成绩添加一个减号！

使用花括号控制执行路径

要想使else分支和外层的if语句匹配起来，可以在内层if语句的两端加上花括 号，使其成为一个块：

//末尾是8或者9的成绩添加一个加号，末尾是0、1或者2的成绩添加一个减号 if (grade % 10 >= 3) {

if (grade % 10 > 7)

lettergrade += '+#; //末尾是8或者9的成绩添加一个加号 } else //花括号强迫else与外层if匹配

lettergrade    //末尾是0、1或者2的成绩添加一个减号

语句属于块，意味着语句一定在块的边界之内，因此内层if语句在关键字else前面的<3781 那个花括号处已经结束了。else不会再作为内层if的一部分。此时，最近的尚未匹配 的if是外层if,也就是我们希望else匹配的那个。

###### 5.3.1节练习

练习5.5:写一段自己的程序，使用if else语句实现把数字成绩转换成字母成绩的要求。

练习5.6:改写上一题的程序，使用条件运算符(参见4.7节，第134页)代替if else 语句。

练习5.7:改正下列代码段中的错误。

(a) if (ivall ! = ival2) ivall = ival2 else ivall = ival2 = 0;

| (b) if   | (ival < minval) minval = ival; |                     |       |            |
| -------- | ------------------------------ | ------------------- | ----- | ---------- |
| occurs = | 1;                             |                     |       |            |
| (c)      | if                             | (int ival           | =get  | _value ()) |
|          |                                | cout « *'           | •ival | =’’ « ival |
|          | if                             | (!ival)             |       |            |
|          |                                | cout « *'           | 'ival | =0\n";     |
| (d)      | if                             | (ival = 0)          |       |            |
|          |                                | ival = get value(); |       |            |

练习5.8:什么是“悬垂else” ？ C++语言是如何处理else子句的？

###### 5.3.2 switch 语句

switch语句(switch statement)提供了一条便利的途径使得我们能够在若干固定选项 中做出选择。举个例子，假如我们想统计五个元音字母在文本中出现的次数，程序逻辑应 该如下所示：

•从输入的内容中读取所有字符。

•令每一个字符都与元音字母的集合比较。

•如果字符与某个元音字母匹配，将该字母的数量加U •显示结果=

例如，以（原书中）本章的文本作为输入内容，程序的输出结果将是:

| Number | of   | vowel | a:   | 3195 |
| ------ | ---- | ----- | ---- | ---- |
| Number | of   | vowel | e :  | 6230 |
| Number | of   | vowel | i:   | 3102 |
| Number | of   | vowel | o:   | 3289 |
| Number | of   | vowel | u:   | 1033 |

□/§>要想实现这项功能，直接使用switch语句即可：

//为每个元音字母初始化其计数值

unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0； char ch；

while (cin >> ch) {

//如果ch是元音字母，将其对应的计数值加1 switch (ch) {

case r az:

++aCnt;

break;

case z ez:

++eCnt;

break;

case * i*:

++iCnt; break;

case ' or :

++oCnt;

break;

case r ur :

++uCnt;

break;

//输出结果

| cout « | "Number  | of   | vowel | a :  | \t"  | « aCnt « * \nz |      |         |
| ------ | -------- | ---- | ----- | ---- | ---- | -------------- | ---- | ------- |
| <<     | "Number  | of   | vowel | e :  | \t"  | «              | eCnt | « ,\n.  |
| «      | ’’Number | of   | vowel | i :  | \t”  | «              | iCnt | « z \nf |
| «      | "Number  | of   | vowel | o:   | \t"  | «              | oCnt | « ’ \nr |
| «      | "Number  | of   | vowel | u:   | \t"  | «              | uCnt | « endl  |

switch语句首先对括号里的表达式求值，该表达式紧跟在关键字switch的后面，可以 是一个初始化的变量声明（参见5.2节，第155页）。表达式的值转换成整数类型，然后与 每个case标签的值比较。

如果表达式和某个case标签的值匹配成功，程序从该标签之后的第一条语句开始执 行，直到到达了 switch的结尾或者是遇到一条break语句为止。

我们将在5.5.1节（第170页）详细介绍break语句，简言之，break语句的作用是

中断当前的控制流。此例中，break语句将控制权转移到switch语句外面。因为switch 是while循环体内唯一的语句，所以从switch语句中断出来以后，程序的控制权将移 到while语句的右花括号处。此吋while语句内部没有其他语句要执行，所以while 会返回去再一次判断条件是否满足。

如果switch语句的表达式和所有case都没有匹配上，将直接跳转到switch结构 之后的第一条语句。刚刚说过，在上面的例子中，退出switch后控制权回到while语 句的条件部分。

case关键字和它对应的值一起被称为case标签(case label)。case标签必须是整 型常量表达式(参见2.4.4节，第58页)：

<J80~|



char ch = getVal()； int ival = 42； switch(ch) {

case 3.14: //错误：case标签不是一个整数 case ival: //错误：case标签不是一个常量 "...

任何两个case标签的值不能相冋，否则就会引发错误。另外，default也是一种特殊 的case标签，关于它的知识将在第162页介绍。

switch内部的控制流

理解程序在case标签之间的执行流程非常重要。如果某个case标签匹配成功，将 从该标签开始往后顺序执行所有case分支，除非程序显式地中断了这一过程，否则直到 switch的结尾处才会停下来。要想避免执行后续case分支的代码，我们必须显式地告 诉编译器终止执行过程。大多数情况下，在下一个case标签之前应该有一条break语 句。

然而，也有一些时候默认的switch行为才是程序真正需要的。每个case标签只能 对应一个值，但是有时候我们希望两个或更多个值共享同一组操作。此时，我们就故意省 略掉break语句，使得程序能够连续执行若干个case标签。

例如，也许我们想统计的是所有元音字母出现的总次数：

unsigned vowelCnt = 0；

// ...

switch (ch)

{

//出现了 a、e、i、o或u中的任意一个都会将vowelCnt的值加1

case z ar :

case * ez：

case # i# ：

case 'o#:

case * u#:

++vowelCnt； break；

在上面的代码中，几个case标签连写在一起，中间没有break语句。因此只要ch是元 音字母，不管到底是五个中的哪一个都执行相同的代码。

C++程序的形式比较自由，所以case标签之后不一定非得换行，把几个case标签

写在一行里，强调这些case代表的是某个范围内的值：

switch (ch)

{

//另一种合法的书写形式

case * a.' : case 1 e' case * iz : case z o# ： case r u# : ++vowelCnt; break;

I 181 >



Best



一般不要省略case分支最后的break语句。:如果没写break语句，最好加 一段注释说清楚程序的逻辑

漏写break容易引发缺陷

有一种常见的错觉是程序只执行匹配成功的那个case分支的语句。例如，下面程序 的统计结果是错误的：

//警告：不正确的程序逻辑！ switch (ch) {

| case * ar：++aCnt；         | //   | 此处应该有一条break语句 |
| --------------------------- | ---- | ----------------------- |
| case x er：++eCnt；         | //   | 此处应该有一条break语句 |
| case # iz ：++iCnt；        | //   | 此处应该有一条break语句 |
| case f o1:++oCnt；case    : | //   | 此处应该有一条break语句 |
| ++uCnt；                    |      |                         |

}

要想理解这段程序的执行过程，不妨假设ch的值是此时，程序直接执行case -e-标签后面的代码，该代码把eCnt的值加1。接下来，程序将跨越case标签的边界，接 着递增 iCnt、oCnt 和 uCnt。

Bert 尽管switch语句不是非得在最后一个标签后面写上break,但是为了安全 起见，最好这么做。因为这样的话，即使以后再增加新的case分支，也不用 再在前面补充break语句了，，

default 标签

如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在 default标签(default label)后面的语句。例如，可以增加一个计数值来统计非元音字 母的数量，只要在default分支内不断递增名为otherCnt的变量就可以了：

II如果ch是一个元音字母，将相应的计数值加1 switch (ch) {

case * az: case 'e' z case r i#： case * o' : case ru#:

++vowelCnt； break;

default:

++otherCnt； break；

}

}

在这个版本的程序中，如果ch不是元音字母，就从default标签开始执行并把＜182] otherCnt 加 lo

即使不准备在default标签下做任何工作，定义一个default标签也是有 卩™^ 用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前

什么也没做。

标签不应该孤零零地出现，它后面必须跟上一条语句或者另外一个case标签。如果 switch结构以—空的default标签作为结束，则该default标签后面必须跟上一条 空语句或一个空块。

switch内部的变量定义

如前所述，switch的执行流程有可能会跨过某些case标签。如果程序跳转到了某 个特定的case，则switch结构中该case标签之前的部分会被忽略掉。这种忽略掉一 部分代码的行为引出了一个有趣的问题：如果被略过的代码中含有变量的定义该怎么办？

答案是：如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用 域之内，则从前一处跳转到后一处的行为是非法行为。

case true:

//因为程序的执行流程可能绕开下面的初始化语句，所以该switch语句不合法

string file_name； // 错误 int ival = 0 ； // 错误 int jval; / / 正确

控制流绕过一个隐式初始化的变量 控制流绕过一个显式初始化的变量 因为jval没有初始化



break; case false:

//正确：jval虽然在作用域内，但是它没有被初始化

jval = next_num() ；    // 正确：给jval 赋一个值

if (file_name .empty () )    // file_name在作用域内，但是没有被初始化

// ...

假设上述代码合法,则一旦控制流直接跳到false分支,也就同时略过了变量filename 和ival的初始化过程。此时这两个变量位于作用域之内，跟在false之后的代码试图 在尚未初始化的情况下使用它们，这显然是行不通的。因此C++语言规定，不允许跨过变 量的初始化语句直接跳转到该变量作用域内的另一个位置。

如果需要为某个case分支定义并初始化一个变量，我们应该把变量定义在块内，从 而确保后面的所有case标签都在变量的作用域之外。

case true:

{

//正确：声明语句位于语句块内部 string file_name = get_file_name()； // ...

}

break; case false:

if (file_name.empty()) // 错误：file_name 不在作用域之内

###### |j83> | 5.3.2 节练习

练习5.9:编写一段程序，使用一系列if语句统计从cin读入的文本中有多少元音字 母。

练习5.10：我们之前实现的统计元音字母的程序存在一个问题，如果元音字母以大写形 式出现，不会被统计在内。编写一段程序，既统计元音字母的小写形式，也统计大写形 式，也就是说，新程序遇到，Y和，都应该递增aCnt的值，以此类推。

练习5.11:修改统计元音字母的程序，使其也能统计空格、制表符和换行符的数量。

练习5.12：修改统计元音字母的程序，使其能统计以下含有两个字符的字符序列的数量: ff、f 1 和 fi-

练习5.13：下面显示的每个程序都含有一个常见的编程错误，指出错误在哪里，然后修 改它们。

(a)    unsigned aCnt = 0, eCnt = 0, iouCnt = 0; char ch = next_text();

switch (ch) {

case 'ar : aCnt++; case z er: eCnt++; default: iouCnt++;

I

(b)    unsigned index = some_value(); switch (index) {

case 1:

int ix = get_value(); ivec[ ix ] = index; break;

default:

ix = ivec.size()-1; ivec[ ix ] = index;

}

(c)    unsigned evenCnt = 0, oddCnt = 0; int digit = get_num() % 10; switch (digit) {

case 1, 3, 5, 7, 9: oddcnt++; break;

case 2, 4, 6, 8, 10: evencnt++; break;

}

(d)    unsigned ival=512, jval=1024, kval=4096; unsigned bufsize;

unsigned swt = get__bufCnt (); switch(swt) {

| case ival: |                           |       |                |
| ---------- | ------------------------- | ----- | -------------- |
|            | bufsize =break;case jval: | ival  | * sizeof(int); |
|            | bufsize =break;case kval: | jval  | * sizeof(int); |
|            | bufsizebreak;             | =kval | * sizeof(int); |

##### 5.4迭代语句

迭代语句通常称为循环，它重复执行操作直到满足某个条件才停下来。while和for 语句在执行循环体之前检杳条件，do while语句先执行循环体，然后再检查条件。

###### 5.4.1 while 语句

只要条件为真，while语句(while statement)就重复地执行循环体，它的语法形式 是

while (condition) statement

在while结构中，只要condition的求值结果为真就一直执行statement (常常是一个块)。 condition不能为空，如果condition第一次求值就得false, statement 一次都不执行。

while的条件部分可以是一个表达式或者是一个带初始化的变量声明(参见5.2节， 第155页)。通常来说，应该由条件本身或者是循环体设法改变表达式的值，否则循环可 能无法终止。

![img](C++  Primer 5-49.jpg)



定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到 销毁的过程，

使用while循环

当不确定到底要迭代多少次时，使用while循环比较合适，比如读取输入的内容就 是如此。还有一种情况也应该使用while循环，这就是我们想在循环结朿后访问循环控 制变量。例如：

vector<int> v；    <J85~1

int i；

//重复读入数据，直至到达文件末尾或者遇到其他输入问题 while (cin >> i)

v.push_back(i)；

//寻找第一不负值元素

auto beg = v.beginO ;

while (beg != v.end() && *beg >= 0)

++beg；

if (beg == v.end())

//此时我们知道V中的所有元素都大于等于0

第一个循环从标准输入中读取数据，我们一开始不清楚循环要执行多少次，当cin读取 到无效数据、遇到其他一些输入错误或是到达文件末尾时循环条件失效。第二个循环重复 执行直到遇到一个负值为止，循环终止后，beg或者等于v.end(),或者指向v中一个 小于0的元素。可以在while循环外继续使用beg的状态以进行其他处理。

###### 5.4.1节练习

练习5.14：编写一段程序，从标准输入中读取若干string对象并查找连续重复出现的 单词。所谓连续重复出现的意思是，一个单词后面紧跟着这个单词本身。耍求记录连续 重复出现的最大次数以及对应的单词，如果这样的单词存在，输出重复出现的最大次数: 如果不存在，输出一条信息说明任何单词都没有连续出现过。例如，如果输入是 how now now now brown cow cow

那么输出应该表明单词now连续出现了 3次。

® 5.4.2传统的for语句

for语句的语法形式是

for (init-statemen; condition; expression) statement

关键字for及括号里的部分称作for语句头。

必须是以下三种形式中的一种：声明语句、表达式语句或者空语句，因 为这些语句都以分号作为结束，所以for语句的语法形式也可以看做

f or (initializer; condition; expression) statement

一般情况下，init-statement负责初始化一个值，这个值将随着循环的进行而改变。 conrfZZZon作为循环控制的条件，只要condition为真，就执行一次sZfltonenZ。如果cow/(+/Zon

I 186＞第一次的求值结果就是false,则statement 一次也不会执行。expression负责修改 init-statement初始化的变量，这个变量正好就是condition检查的对象，修改发生在每次循 环迭代之后。可以是一条单独的语句也可以是一条复合语句。

传统for循环的执行流程

我们以3.2.3节(第85页)的for循环为例：

//重复处理s中的字符直至我们处理完全部字符或者遇到了一个表示空白的字符 for (decltype(s.size()) index = 0；

index != s.sizef) && !isspace(s[index])； ++index)

s [index] = toupper (s [index] ) : //将当前字符改成大写形式

求值的顺序如下所示：

1-循环开始时，首先执行一次init-statement。此例中，定义index并初始化为0»

2.接下來判断cont/tow。如果index不等于s . size ()而且在s [index]位置的 字符不是空白，则执行for循环体的内容。否则，循环终止。如果第一次迭代时 条件就为假，for循环体一次也不会执行。

3.如果条件为真，执行循环体。此例中，for循环体将s[ index]位置的字符改写

成大写形式。

4.最后执行expression。此例中，将index的值加1。

这4步说明了 for循环第一次迭代的过程。其中第1步只在循环开始时执行一次，第2、 3、4步重复执行直到条件为假时终止，也就是在s中遇到一个空白字符或者index大于 s . size ()时终止。

![img](C++  Primer 5-50.jpg)



牢记for语句头中定义的对象只在for循环体内可见。因此在上面的例子中， for循环结束后index就不可用了。

for语句头中的多重定义

和其他的声明一■样，biit-statement也可以定义多个对象。但是init-statement只能有一• 条声明语句，因此，所有变量的基础类型必须相同(参见2.3节，第45页)。举个例子， 我们用下面的循环把vector的元素拷贝一份添加到原来的元素后面：

//记录下v的大小，当到达原来的最后一个元素后结束循环

for (decltype(v.size()) i = 0, sz = v.size()； i != sz; ++i)

v.push_back(v[i]);

在这个循环中，我们在init-statement里同时定义了索引i和循环控制变量sz。

省略for语句头的某些部分

<167~|



for语句头能省略掉init-statement、condition和expression中的任何一个(或者全部)。

如果无须初始化，则我们可以使用一条空语句作为init-statement.例如，对于在 vector对象中寻找第一个负数的程序，完全能用for循环改写：

auto beg = v.begin()；

for ( /* 空语句 */; beg ! = v.end() && *beg >= 0; ++beg)

;//什么也不做

注意，分号必须保留以表明我们省略掉了 init-statement。说得更准确一点，分号表示的是 一个空的时。在这个循环中，因为所有要做的工作都在for语句头的条件和表 达式部分完成了，所以for循环体也是空的。其中，条件部分决定何时停止查找，表达 式部分递増迭代器。

省略condition的效果等价于在条件部分写了一个true。因为条件的值永远是true, 所以在循环体内必须有语句负责退出循环，否则循环就会无休止地执行下去：

for (int i = 0； /* 条件为空 */ ; ++i) {

//对i进行处理，循环内部的代码必须负责终止迭代过程！

}

我们也能省略掉for语句头中的expression,但是在这样的循环中就要求条件部分或 者循环体必须改变迭代变量的值。举个例子，之前有一个将整数读入vector的while 循环，我们使用for语句改写它：

vector<int> v；

for (int i; cin >> i； /* 表达式为空 */ ) v.push_back(i)；

因为条件部分能改变i的值，所以这个循环无须表达式部分。其中，条件部分不断检查输

入流的内容，只要读取完所有的输入或者遇到一个输入错误就终iM盾环。

1~188>



###### 5.4.2节练习

练习5.15：说明下列循环的含义并改正其中的错误。

| (a) for    | (int ix = 0; ix != sz; | ++ix)    {        |                   |
| ---------- | ---------------------- | ----------------- | ----------------- |
| if         | (ix !                  | =sz)              |                   |
| (b) intfor | // • ix;(ix            | != sz; ++ix) { /* |                   |
| (c) for    | (int                   | ix = 0; ix != sz; | ++ix, ++ sz) { /* |

练习5.16： while循环特别适用于那种条件保持不变、反复执行操作的情况，例如， 当未达到文件末尾时不断读取下一个值。for循环则更像是在按步骤迭代，它的索引值 在某个范围内依次变化。根据每种循环的习惯用法各自编写一段程序，然后分别用另一 种循环改写。如果只能使用一种循环，你倾向于使用哪种呢？为什么？

练习5.17：假设有两个包含整数的vector对象，编写一段程序，检验其中一个vector 对象是否是另一个的前缀。为了实现这一目标，对于两个不等长的vector对象，只需 挑出长度较短的那个，把它的所有元素和另一个vector对象比较即可。例如，如果两 个vector对象的元素分别是0、1、1、2和0、1、1、2、3、5、8,则程序的返回 结果应该为真。

^6 5.4.3范围for语句

C++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的 所有元素。范围for语句（range for statement）的语法形式是：

for （declaration : expression） statement

表示的必须是一个序列，比如用花括号括起来的初始值列表（参见3.3.1节，第 88贞）、数组（参见3.5节，第101页）或者vector或string等类型的对象，这些类 型的共同特点是拥有能返回迭代器的begin和end成员（参见3.4节，第95页）。

t/ecZararion定义一个变量，序列中的每个元素都得能转换成该变量的类型（参见4.11 节，第141页）。确保类型相容最简单的办法是使用auto类型说明符（参见2.5.2节，第 61页），这个关键字可以令编译器帮助我们指定合适的类型。如果需要对序列中的元素执 行写操作，循环变量必须声明成引用类型。

每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会 执行像往常一样，•statonenZ可以是一条单独的语句也可以是一个块。所有元素 都处理完毕后循环终止。

之前我们已经接触过几个这样的循环。接下来的例子将把vector对象中的每个元素 都翻倍，它涵盖了范围for语句的几乎所有语法特征：

vector<int> v = {0,1,2,3,4,5,6,7,8,9};

//范围变量必须是引用类型，这样才能对元素执行写操作 for （auto &r ： v） //对于v中的每一个元素

r *= 2；    //将v中每个元素的值翻倍

for语句头声明了循环控制变量r,并把它和v关联在一起，我们使用关键字auto令编 译器为r指定正确的类型。由于准备修改v的元素的值，因此将r声明成引用类型。此 时，在循环体内给r赋值，即改变了 r所绑定的元素的值。

范围for语句的定义来源于与之等价的传统for语句：

for (auto beg = v.beginO , end = v.end() ； beg ! = end； ++beg) { auto &r = *beg； // r必须是引用类型，这样才能对元素执行写操作 r *= 2；    //将v中每个元素的值翻倍

}

学习了范围for语句的原理之后，我们也就不难理解为什么在3.3.2节(第90页)强调 不能通过范围for语句增加vector对象(或者其他容器)的元素了。在范围for语句<S 中，预存了 end(>的值。-旦在序列中添加(删除)元素，end函数的值就可能变得无效 了(参见3.4.1节，第98页)。关于这一点，将在9.3.6节(第315页)做更详细的介绍。



###### 5.4.4 do while 语句

do while语句(do while statement)和while语句非常相似，唯一的区别是，do while 语句先执行循环体后检查条件。不管条件的值如何，我们都至少执行一次循环。do while 语句的语法形式如下所示：

statement

while (condition);

do while语句应该在括号包围起来的条件后面用一个分号表示语句结束.:：

在do语句中，求condition的值之前首先执行一次statement, condition不能为空。如果 的值为假，循环终止：否则，重复循环过程。使用的变量必须定义在循

环体之外。

我们可以使用do while循环(不断地)执行加法运算：

//不断提示用户输入一对数，然后求其和

string rsp； //作为循环的条件，不能完义在do的内部

do {

cout << "please enter two values:"； int vail = 0, val2 = 0； cin >> vail >> val2；

cout << "The sum of " << vail << " and " << val2 << "="<< vail + val2 << "\n\n"

<< "More? Enter yes or no:"；

cin >> rsp；

} while (!rsp•empty() && rsp [0]    !=，n');

循环首先提示用户输入两个数字，然后输出它们的和并询问用户是否继续。条件部分检查 用户做出的回答，如果用户没有回答，或者用户的回答以字母n开始，循环都将终止。否 则循环继续执行。

因为对于do while来说先执行语句或者块，后判断条件，所以不允许在条件部分

定义变量：

do {

// ...

mumble(foo)；

} while (int foo = get_foo () ) ; //错误：将变量声明放在了 do的条件部分

如果允许在条件部分定义变量，则变量的使用出现在定义之前，这显然是不合常理的!

[J9Q>



###### 5.4.4节练习

练习5.18：说明下列循环的含义并改正其中的错误。

(a)    do

int vl, v2;

cout « "Please enter two numbers to sum:"; if (cin » vl >> v2)

cout « "Sum is: " « vl + v2 « endl; while (cin);

(b)    do {

// ...

} while (int ival = get_response());

⑹do {

int ival = get_response();

} while (ival);

练习5.19：编写一段程序，使用do while循环重复地执行下述任务：首先提示用户 输入两个string对象，然后挑出较短的那个并输出它。

##### 5.5跳转语句

跳转语句中断当前的执行过程。C杆语言提供了 4种跳转语句：break、continue, goto和return。本章介绍前三种跳转语句，return语句将在6.3节(第199页)进行 介绍。

###### 5.5.1 break 语句

break 语句(break statement)负责终止离它最近的 while、do while、for 或 switch 语

句，并从这些语句之后的第一条语句开始继续执行。

break语句只能出现在迭代语句或者switch语句内部(包括嵌套在此类循环里的 语句或块的内部)。break语句的作用范围仅限于最近的循环或者switch:

string buf；

while (cin >> buf && !buf.empty()) { switch(buf[0]) { case 1z

//处理到第一个空白为止

for (auto it = buf.begin()+1； it != buf.end()； ++it) { if (*it == r *)

break; // #1，离开 for 猸环

}

// break #1将控制权转移到这里 //剩余的处理： break; // #2,离开 switch 语句 case f:

//...

} // 结束 switch

//结束switch: break #2将控制权转移到这里 } // 结束 while

标记为#1的break语句负责终止连字符case标签后面的for循环。它不但不会终止 switch语句，甚至连当前的case分支也终止不了。接下来，程序继续执行for循环之 后的第一条语句，这条语句可能接着处理连字符的情况，也可能是另一条用于终止当前分 支的break语句。

标记为#2的break语句负责终止switch语句，但是不能终止while循环。执行 完这个break后，程序继续执行while的条件部分。

###### 5.5.1节练习

练习5.20：编写一段程序，从标准输入中读取string对象的序列直到连续出现两个相 同的单词或者所有单词都读完为止。使用while循环一次读取一个单词，当一个单词 连续出现两次时使用break语句终止循环。输出连续重复出现的单词，或者输出一个 消息说明没有任何单词是连续重复出现的。

###### 5.5.2 continue 语句

continue语句(continue statement)终止最近的循环中的当前迭代并立即开始下•次 迭代。continue语句只能出现在for、while和do while循环的内部，或者嵌套在此类循环 里的语句或块的内部。和break语句类似的是，出现在嵌套循环中的continue语句也仅作 用于离它最近的循环。和break语句不同的是，只有当switch语句嵌套在迭代语句内部时， 才能在switch里使用continueo

continue语句中断当前的迭代，但是仍然继续执行循环。对于while或者do while 语句来说，继续判断条件的值；对于传统的for循环来说，继续执行for语句头的 expression'而对于范围./br语句来说，则是用序列中的下一个元素初始化循环控制变量。

例如，下面的程序每次从标准输入中读取一个单词。循环只对那些以下画线开头的单 词感兴趣，其他情况下，我们直接终止当前的迭代并获取下一个单词：

string buf;

while (cin » buf && !buf.empty()) { if (buf[0]    !=    )

continue; //接着读取下一个输入

//程序执行过程到了这里？说明当前的输入是以下画线开始的；接着处理buf……

}

###### 5.5.2节练习

练习5.21：修改5.5.1节(第171页)练习题的程序，使其找到的重复单词必须以大写 字母开头。

@ 5.5.3 goto 语句

goto语句(goto statement)的作用是从goto语句无条件跳转到同一函数内的另一条语句。

卩不要在租序中使用goto语句，因为它使得程序既难理解又难修改。

goto语句的语法形式是 goto label;

其中，是用于标识一条语句的标示符。带标签语句(labeled statement)是一种特殊的 语句，在它之前有一个标示符以及一个冒号：

end: return; //带标签语句，可以作为goto的目标

标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的 标示符使用同一个名字而不会相互干扰。goto语句和控制权转向的那条带标签的语句必 须位于同一个函数之内。

和switch语句类似，goto语句也不能将程序的控制权从变量的作用域之外转移到 作用域之内：

goto end；

int ix = 10； II错误：goto语句绕过了一个带初始化的变量定义

end：

//错误：此处的代码需要使用ix，但是goto语句绕过了它的声明 ix = 42;

向后跳过一个已经执行的定义是合法的。跳回到变量定义之前意味着系统将销毁该变 量，然后重新创建它，

//向后跳过一个带初始化的变量定义是合法的 begin:

int sz = get_size()； if (sz <= 0) {

goto begin;

}

在上面的代码中，goto语句执行后将销毁sz。因为跳回到begin的动作跨过了 sz的 定义语句，所以sz将重新定义并初始化。

###### □M> 5.5.3节练习

练习5.22：本节的最后一个例子跳回到begin,其实使用循环能更好地完成该任务。 重写这段代码，注意不再使用goto语句。

##### 穆5.6 try语句块和异常处理

异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异 常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一 部分。

当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，检测出 问题的部分应该发出某种信号以表明程序遇到了故障，无法继续下去了，而且信号的发出 方无须知道故障将在何处得到解决，一旦发出异常信号，检测出问题的部分也就完成了任 务。

如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。例如，

如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据：如果 丢失了数据库连接，会发出报警信息。

异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言 中，异常处理包括：

•    throw表达式(throw expression)，异常检测部分使用throw表达式来表示它遇到 了无法处理的问题。我们说throw引发(raise) 了异常。

•    try语句块(try block)，异常处理部分使用try语句块处理异常。try语句块以 关键字try开始，并以一■个或多个catch子句(catch clause)结束。try语句块 中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理"异常，

所以它们也被称作异常处理代码(exception handler)。

•    一套异常类(exception class),用于在throw表达式和相关的catch子句之间传 递异常的具体信息。

在本节的剩余部分，我们将分别介绍异常处理的这三个组成部分。在18+1节(第684页)

还将介绍更多关于异常的知识。

###### 5.6.1 throw 表达式

程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字 throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达 式后面通常紧跟一个分号，从而构成一条表达式语句。

举个简单的例子，回忆1.5.2节(第20页)把两个Sales_item对象相加的程序。<J94l 这个程序检查它读入的记录是否是关于同一种书籍的，如果示是，输出一条信息然后 退出。

Sales_item iteml, item2； cin >> iteml >> item2；

//首先检查iteml和item2是否表示同一种书籍 if (iteml.isbn() == item2.isbn()) {

cout << iteml + item2 << endl； return 0； //表示成功

} else {

cerr << "Data must refer to same ISBN" << endl; return -1； //表示失败

}

在真实的程序中，应该把対象相加的代码和用户交互的代码分离开来。此例中，我们 改写程序使得检查完成后不再直接输出一条信息，而是抛出一个异常：

//首先检查两条数据是否是关于同一种书籍的 if (iteml.isbn()    != item2.isbn())

throw runtime_error("Data must refer to same ISBN");

//如果程序执行到了 里，表示两个ISBN是相同的 cout << iteml + item2 << endl；

在这段代码中，如果ISBN不一样就抛出一个异常，该异常是类型runtime_error的对 象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。

类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。关 于标准库异常类型多的知识将在5.6.3节(第176页)介绍。我们必须初始化 runtime_error的对象，方式是给它提供一个string对象或者一个C风格的字符串 (参见3.5.7节，第109页)，这个字符串中有一些关于异常的辅助信息。

###### 5.6.2 try语句块

try语句块的通用语法形式是 try {

program-statements

} catch (exception-declaration)    {

handler-statements

} catch (exception-declaration)    {

handler-statements

}//...

try语句块的一开始是关键字try，随后紧跟着一个块，这个块就像大多数时候那样是花 括号括起来的语句序列。

|J95> 跟在try块之后的是一个或多个catch子句。catch子句包括三部分：关键字 catch、括号内一个(可能未命名的)对象的声明(称作异常声明，exception declaration) 以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch—旦 完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。

try语句块中的program-statements组成程序的正常逻辑，像其他任何块一样， program-statements可以有包括声明在内的任意C++语句。一如往常，try语句块内声明 的变量在块外部无法访问，特别是在catch子句内也无法访问。

编写处理代码

在之前的例子里，我们使用了一个throw表达式以避免把两个代表不同书籍的 Sales_item相加。我们假设执行Sales_item对象加法的代码是与用户交互的代码分 离开来b。其中与用户交互的代码负责处理发生的异常，它的形式可能如下所示：

while (cin >> iteml >> item2) { try {

//执行添加两个Sales_item对象的代码 //如果添加失败，代码抛出一个runtime_error异常

} catch (runtime_error err) {

//提醒用户两个ISBN必须一致，询问是否重新输入 cout << err.what()

<< "\nTry Again? Enter y or n" << endl； char c； cin >> c；

if (!cin || c == 'n')

break; // 跳出 while 循环

}

程序本来要执行的任务出现在try语句块中，这是因为这段代码可能会抛出一个 runtime_error #3^的异常-

try语句块对应—t- catch子句，该子句负责处理类型为runtime_error的异常。

如果try语句块的代码抛出了 runtime_error异常，接下来执行catch块内的语句。

在我们书写的catch子句中，输出一段示信息要求用户指定程序是否继续，如果用户 输入，n，，执行break语句并退出while循环；否则，直接执行while循环的右侧花 括号，意味着程序控制权跳回到while条件部分准备下一次迭代。

给用户的提示信息中输出了 err.whatO的返回值，我们知道err的类型是 runtime_error,因此能推断what是runtime_error类的一个成员函数（参见1.5.2 节，第20_页）。每个标准库异常类都定义了名为wlTat的成员函数，这些函数没有参数，

返回值是C风格字符串（即const char*）。其中，runtime_error的what成员返＜196 I 回的是初始化一个具体对象时所用的string对象的副本。如果I一节编写的代码抛出异 常，则本节的catch子句输出

Data must refer to same ISBN

Try Again? Enter y or n

函数在寻找处理代码的过程中退出

在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try 语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语 句块可能调用了包含又一个try语句块的新函数，以此类推。

寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常 的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻 找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的 函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。

如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的柚准 库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。

对于那些没有任何try语句块定义的异常，也按照类似的方式处理：毕竟，没有try 语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常， 系统会调用terminate函数并终止当前程序的执行。

提示：编¥异常安全的代码非常M难

要好好理解这句话：异常中断了程序的正常流程:.异常发生时，调用者请求的一部 分计算可能已经完成了，另一部分则尚未完成。通常情况下，略过部分程序意味着某些 对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正 常释放，等等。那些在异常发生期间正确执行了 “清理"工作的程序被称作异常安全 （exception safe）的代码」然而经验表明，编写异常安全的代码非常困难，这部分知识也 （远远）超出了本书的范围。

对于一些程序来说，当异常发生时只是简单地终止程序。此时，我们不怎么需要担

心异常安全的问题，

但是对于那些确实要处理异常并继续执行的程序，就要加倍注意了。我们必须时刻 清楚异常何时发生，异常发生后程序应如何确保对象有效、资源无泄漏、程序处于合理 状态，等等。

我们会在本书中介绍一些比较常规的提升异常安全性的技术。但是读者需要注意， 如果你的程序要求非常鲁棒的异常处理，那么仅有我们介绍的这些技术恐怕还是不 够的。

EZ97> 5.6.3标准异常

C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用 户编写的程序中使用，它们分别定义在4个头文件中：

•    exception头文件定义了最通用的异常类exception。它只报告异常的发生， 不提供任何额外信息。

•    stdexcept头文件定义了几种常用的异常类，详细信息在表5.1中列出。

•    new头文件定义了 bad_allOc异常类型，这种类型将在12.1.2节（第407页）详 细介绍。

•    type_info头文件定义了 bad_cast异常类型，这种类型将在19.2节（第731 页）详细介绍。

| 表 5.1:          | <std except〉定义的异常类                      |
| ---------------- | ---------------------------------------------- |
| exception        | 最常见的问题                                   |
| runtime_error    | 只有在运行时j能检测出的问题                    |
| range error      | 运行吋错误：生成的结果超出了有意义的值域范围   |
| overflow_error   | 运行时错误：计算上溢                           |
| underflow error  | 运行吋错误：计算下溢                           |
| logic_error      | 程序逻辑错误                                   |
| domain error     | 逻辑错误：参数对应的结果值不存在               |
| invalid_argument | 逻辑错误：无效参数                             |
| length—error     | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
| out of range     | 逻辑错误：使用个超出有效范围的值               |

标准库异常类只定义了几种运算，包括创建或拷贝异常类型的对象，以及为异常类型 的对象赋值。

我们只能以默认初始化（参见2.2.1节，第40页）的方式初始化exception, bad_alloc和bad_cast对象，不允许为这些对象提供初始值。

其他异常类型的行为则恰好相反：应该使用string对象或者C风格字符串初始化这 些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值， 该初始值含有错误相关的信息。

异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个 指向C风格字符串（参见3.5.4节，第109页）的const char*。该字符串的目的是提 供关于异常的一些文本信息。

what函数返回的C风格字符串的内容与异常对象的类型有关。如果异常类型有一个＜S 字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回 的内容由编译器决定。

###### 5.6.3节练习

练习5.23：编写一段程序，从标准输入读取两个整数，输出第一个数除以第二个数的结 果。

练习5.24:修改你的程序，使得当第二个数是0时抛出异常。先不要设定catch子句, 运行程序并真的为除数输入0,看看会发生什么？

练习5.25:修改上一题的程序，使用try语句块去捕获异常。catch子句应该为用户 输出一条提示信息，询问其是否输入新数并重新执行try语句块的内容。

Pi99> 小结    _

C++语言仅提供了有限的语句类型，它们中的大多数会影响程序的控制流程：

•    while、for和do while语句，执行迭代操作。

•    if和switch语句，提供条件分支结构。

•    continue语句，终it循环的当前一次迭代。

•    break语句，退出循环或者switch语句。

•    goto语句，将控制权转移到一条带标签的语句。

•    try和catch,将-•段可能抛出异常的语句序列括在花括号里构成try语句块。 catch子句负责处理代码抛出的异常。

•    throw表达式语句，存在于代码块中，将控制权转移到相关的catch子句，

•    return语句，终止函数的执行。我们将在第6章介绍return语句。

除此之外还有表达式语句和声明语句。表达式语句用〒求解表达式，关于变量的声明 和定义在第2章己经介绍过了。

术语表

块(block)包围在花括号内的由0条或多 条语句组成的序列:，块也是-条语句，所 以只要是能使用语句的地方，就可以使用 块。

break 语句(break statement)终止离它

最近的循环或switch语句。控制权转移 到循环或switch之后的第一条语句。

case 标签(case label)在 switch 语句 中紧跟在case关键字之后的常量表达式 (参见2.4.4节，第58页)。在同一个swi tch 语句中任意两个case标签的值不能相同。

catch子句(catch clause)由三部分组成：

catch关键字、括号里的异常声明以及一 个语句块。catch子句的代码负责处理在 异常声明中定义的异常。

复合语句(compound statement)和块是

同义词。

continue 语句(continue statement)终止

离它最近的循环的当前迭代。控制权转移 到while或do while语句的条件部分、 或者范ffl for循环的下一次迭代、或者传 统for循环头部的表达式。

悬垂 else (dangling else)是一个俗语，

指的是如何处理嵌套if语句中if分支多 于else分支的情况。OH■语言规定，else 应该与前一个未匹配的if匹配在一起。使 用花括号可以把位于内层的if语句隐藏 起來，这样程序员就能更好地控制else 该与哪个if匹配。

default 标签(default label)是--种特殊的

case标签，当switch表达式的值与所有 case标签都无法匹配吋，程序执行 default标签下的内容。

I 200>do while 语句(do while statement)与

while语句类似，区别是do while语句 先执行循环体，再判断条件。循环体代码 至少会执行一次。.



异常类/exception class)是标准库定义

的一组类，用于表示程序发生的错误。表

5.1 (第176页)列出了不同用途的异常类。

异常声明(exception declaration)位于

catch子句中的声明，指定了该catch 子句能处理的异常类型。

异常处理代码(exception handler)程序

某处引发异常后，用于处现该异常的另一 处代码。和catch子句是同义同。

异常安全(exception safe)是一个术语，

表示的含义是当抛出异常后，程序能执行 正确的行为。

表达式语句(expression statement)即一

条表达式后面跟上一个分号，令表达式执 行求值过程。

控制流(flow of control)程序的执行路径.。

for语句(for statement)提供迭代执行的

迭代语句。常常用子遍历一个容器或者重 复计算若干次。

goto语句(goto statement)令控制权无

条件转移到同一函数中一个指定的带标签 语句„ goto语句容易造成程序的控制流混 乱，应禁止使用•》

if else 语句(if else statement)判断条件，

根据其结果分别执行if分支或else分支 的语句。

if语句.(if statement)判断条件，根据其 结果有选择地执行语句。如果条件为真， 执行if分支的代码；如果条件为假，控制 权转移到if结构之后的第 '条语句。

带标签语句(labeled statement)前面带

有标签的语句。所谓标签是指一个标识符 以及紧跟着的■-个冒号。对于同一个标识 符来说，用作标签的同吋还能用于其他目 的，互不干扰。

空语句(null statement)只含有一个分号

的语句。

引发(raise)含义类似于throw。在C++ 语言中既可以说抛出异常，也可以说引发 异常。

范围 for 语句(range for statement)在--

个序列中进行迭代的语句。

switch 语句(switch statement). —种条件

语句，首先求switch关键字后面表达式 的值，如果某个case标签的值与表达式 的值相等，程序直接跨过之前的代码从这 个case标签开始执行。3所有case标 签都无法匹配时，如果有default标签， 从default标签继续执行；如果没有，结 束switch语句。.

terminate是一个标准库函数，当异常没有 被捕捉到吋调用。terminate终止当前程 序的执行。

throw 表达式(throw expression)--种中

断当前执行路径的表达式。throw表达式 抛出一个异常并把控制权转移到能处理该 异常的最近的catch子句。

try语句块(try block)跟在try关键字后

面的块，以及一个或多个catch子句。如 果try语句块的代码引发异常并且其中一 个catch子句匹配该异常类型，则异常被 该catch子句处理。否则，异常将由外围 try语句块处理，或者程序终it。

while语句(while statement)只要指定的

条件为真，就，直迭代执行H标语句。随 着条件真值的不同，循坏可能执行多次， 也可能一次也不执行。
