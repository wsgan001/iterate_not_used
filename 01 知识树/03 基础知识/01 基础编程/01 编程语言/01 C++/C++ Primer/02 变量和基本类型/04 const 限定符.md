
###### 2.4 const限定符

有时我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲 区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。 另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关 键字const对变量的类型加以限定：

const int bufSize = 512;    // 输入缓冲区大小

这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误：

bufSize = 512;    //错误：试图向const对象写值

因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。一如既往， 初始值可以是任意复杂的表达式：

const int i = get_size () ;    //正确：运行时初始化

const int j = 42;    //正确：编译时初始化

const int k;    //错误：k是一个未经初始化的常量

初始化和const

正如之前反复提到的，对象的类型决定了其上的操作。与非const类型所能参与的 操作相比，const类型的对象能完成其中大部分，但也不是所有的操作都适合。主要的限 制就是只能在const类型的对象上执行不改变其内容的操作。例如，const int和普通 的int—样都能参与算术运算，也都能转换成一个布尔值，等等。

在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外 一个对象，则它们是不是const都无关紧要：

int i = 42/

const int ci = i;    //正确：i的值被拷贝给了 ci

int j = ci;    //正确：ci的值被拷贝给了 j

尽管ci是整型常量，但无论如何ci中的值还是一个整型数。ci的常量特征仅仅在执行 改变ci的操作时才会发挥作用。当用ci去初始化j时，根本无须在意ci是不是一个常 量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关 系了。

Ejo>默认状态下，const对象仅在文件内有效

当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样： const int bufSize = 512; // 输入缓冲区大小

编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到 代码中所有用到bufSize的地方，然后用512替换。

为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个 用了 const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每 一个用到变量的文件中都有对它的定义(参见2.2.2节，第41页)。为了支持这一用法， 同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当 多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必 要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反， 我们想让这类const对象像其他(非常量)对象一样工作，也就是说，只在一个文件中 定义const，而在其他多个文件中声明并使用它。

解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样 只需定义一次就可以了：

// file_l.cc定义并初始化了一个常量，该常量能被其他文件访问 extern const int bufSize = fcn ();

// file_l.h 头文件

extern const int bufSize; // 与 file_l. cc 中定义的 bufSize 是同一个

如上述程序所示，file_l.cc定义并初始化了 bufSize。因为这条语句包含了初始值， 所以它(显然)是一次£义=然而，因为bufSize是一个常量，必须用extern加以限 定使其被其他文件使用。

file_l .h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本 文件所独i，它的定义将在别处出现。

i

![img](C++  Primer 5-24.jpg)



如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern 关键字。

###### 2.4节练习

练习2.26：下面哪些句子是合法的？如果有不合法的句子，请说明为什么？

(a) const int buf;    (b) int cnt = 0;

(c) const int sz = cnt;    (d)++cnt; ++sz;

啦2.4.1 const的引用

CK>    可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量

的引用(reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它所绑 定的对象：

const int ci = 1024;

const int &r 1 = ci; //正确：引用及其对应的对象都是常量

rl = 42;    //错误：rl是对常量的引用

int &r2 = ci;    II错谡：试图让一个非常量引用指向一个常量对象

因为不允许直接为ci赋值，当然也就不能通过引用去改变ci，因此，对r2的初始化是 错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确的。

术语：常fl引川足对const的引用

C#程序员们经常把词组"对const的引用”筒称为“常量引用”，这一简称还是挺 靠谱的，不过前提是你得时刻记得这就是个简称而已。

严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身 恒定不变。事实上，由于C#语言并不允许随意改变引用所绑定的对象，所以从这层意 义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与 的操作，却无论如何都不会影响到引用和对象的绑定关系本身。

初始化和对const的引用

2.3.1节（第46页）提到，引用的类型必须与其所引用对象的类型一致，但是有两个 例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表 达式的结果能转换成（参见2.1.2节，第32页）引用的类型即可。尤其，允许为一个常量 引用绑定非常量的对象、字面值，甚至是个一般表达式：

int i = 42;-

| const     | int  | &rl  | =i；     | //   |
| --------- | ---- | ---- | -------- | ---- |
| const     | int  | &r2  | =42;     | //   |
| const     | int  | &r3  | =rl * 2; | //   |
| int &r4 = | rl   | 2;   | //       |      |



允许将const int&绑定到一个普通int对象上

正确：rl是一个常量引用

正确：r3是一个常量引用

错误：是一个普通的非常量引用

要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外•种 类型上时到底发生了什么：

double dval = 3.14; const int &ri = dval;

此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精 度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下 形式：

const int temp = dval; //由双精度浮点数生成一个临时的整型常量 const int &ri = temp; //让ri绑定这个临时量

<62~|



在这种情况下，ri绑定了一个临时量（temporary）对象。所谓临时量对象就是当编译器 需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常 常把临时量对象简称为临时量。

接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的 后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意， 此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval,就肯定想通过 ri改变dval的值，否则干什么要给ri赋值呢？如此看来，既然大家基本上不会想着把 引用綁定到临时量上，C++语言也就把这种行为归为非法。

对const的引用可能引用一个并非const的对象

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不 是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

int i = 42;

int &rl = i;    //引用ri辨定对象i

const int &r2 = i;    // r2也绑定对象i，但是不允许通过r2修改i的值

rl = 0;    // rl并非常量，i的值修改为0

r2 = 0;    //错误：r2是一个常量引用

is2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此, i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像rl 一样绑定到 i的其他引用来修改。

###### 沿2.4.2指针和const

与引用一样，也可以令指针指向常量或非常量。类似于常量引用（参见2.4.1节，第 54页），指向常量的指针（pointer to const）不能用于改变其所指对象的值。要想存放常量 对象的地址，只能使用指向常量的指针：

const double pi = 3.14; double *ptr = &pi; const double *cptr = &pi; *cptr = 42;



// pi是个常量，它的值不能改变 //错误：ptr是一个普通指针 //正确：cptr可以指向一个双精度常量 //错误：不能给*cptr赋值

2.3.2节（第47页）提到，指针的类型必须与其所指对象的类型一致，但是有两个例 夕卜。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：

double dval = 3.14;    // dval是一个双精度浮点数，它的值可以改变

cptr = &dval;    //正确：但是不能通过cptr改变dval的值

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指 向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过 其他途径改变。

![img](C++  Primer 5-25.jpg)



试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是” 罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。

const指针

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常 量指针（constpointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针 中的那个地址）就不能再改变了。把*放在const关键字之前用以说明指针是一个常量， 这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：

int errNumb = 0;

int *const curErr = SerrNumb; // curErr 将一直指向 errNumb const double pi = 3.14159;

const double *const pip = &pi; // pip是一个指向常量对象的常量指针

如同2.3.3节（第52页）所讲的，要想弄清楚这些声明的含义最行之有效的办法是从右向 左阅读。此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对 象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*,意思是curErr

是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个 int对象。与之相似，我们也能推断出，pip是一个常量指针，它指向的对象是一个双精 度浮点型常量。

指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全 依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的 对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一4'一般的 非常量整数，那么就完全可以用curErr去修改errNumb的值：

*pip = 2.72;    //错误：pip是一个指向常量的指针

//如果curErr所指的对象(也就是errNumb )的值不为0

if (*curErr) {

errorHandler();

\* curErr = 0;    //正确：把curErr所指的对象的值重置

###### 2.4.2节练习

练习2.27:下面的哪些初始化是合法的？请说明原因。

(a) int i = -1, &r = 0;    (b)    int *const p2 = &i2;

(c) const int i = -1, &r = 0;    (d)    const int * const p3 = &i2;

(e) const int *pl = &i2;    (f)    const int &const r2;

(g) const int i2 = i, &r = i;

练习2.28:说明下面的这些定义是什么意思，挑出其中不合法的。

(a) int i, *const cp;    (b) int *pl, *const p2;

(c) const int ic, &r = ic; (d) const int * const p3;

(e) const int *p;

练习2.29:假设己有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说 明原因。

(a) i = ic;

Il I- -I 1 3 C p p .1 b)(d)(o



![img](C++  Primer 5-26.jpg)



(c) pi = &ic;

& r



(e)p2 = Pl；

###### 2.4.3 顶层 const    粗

如前所述，指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不 是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const (top-level const)表示指针本身是个常量，而用名词底层const (low-level const)表示指 针所指的对象是一个常量。

更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，

如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。

比较特殊的是，指针类型既可以是顶层const也可以是底层const,这一点和其他类型 相比区别明显：

int i = 0;

int *const pi = &i; const int ci = 42; const int *p2 = &ci;



//不能改变pi的值， //不能改变ci的值， //允许改变p2的值，



这是一个项层const 这是一个顶层const 这是一个底层const



const int *const p3 = p2; // 靠右的 const 是顶层 const，靠左的是底层 const const int &r = ci;    //用于声明弓1用的const都是底层const

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶 层const不受什么影响：

i = ci;    //正确：拷贝ci的值，ci是一个顶层const，对此操作无影响

p2 = p3;    //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响

执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么 影响。

另一方面，底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出 的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般

来说，非常量可以转换成常量，反之则不行:

| l~65?> | int *p =  | P3;       | //错误 |
| ------ | --------- | --------- | ------ |
|        | p2 = p3;  |           | //正确 |
|        | p2 = &i;  |           | //正确 |
|        | int &r =  | ci;       | //错误 |
|        | const int | :&r2 = i; | //正确 |



p3包含底层const的定义，而p没有 p2和p3都是底层const int*能转换成 const int*

普通的int&不能绑定到int常量上 const int&可以绑定到一个普通int上



p3既是顶层const也是底层const,拷贝p3时可以不在乎它是一个顶层const,但是 必须清楚它指向的对象得是一个常量。因此，不能用P3去初始化p,因为p指向的是一 个普通的（非常量）整数。另一方面，p3的值可以赋给p2,是因为这两个指针都是底层 const,尽管p3同时也是一个常量指针（顶层const）,仅就这次赋值而言不会有什么 影响。

###### 2.4.3节练习

练习2.30:对于下面的这些语句，请说明对象被声明成了顶层const还是底层const?

const int v2 = 0;    int vl = v2;

int *pl = &vl, &rl = vl;

const int *p2 = &v2, *const p3 = &i, &r2 = v2;

练习2.31:假设已有上一个练习中所做的那些声明，则下面的哪些语句是合法的？请说 明顶层const和底层const在每个例子中有何体现。 rl = v2;

pi = p2; p2 = pi； pi = p3; p2 = p3;

###### 緣2.4.4 constexpr和常量表达式

常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的 表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表 达式。后面将会提到，C++语言中有几种情况下是要用到常量表达式的。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：

const int max_files = 20;    // max_files 是常量表达式

const int limit = max_files + 1;    // limit 是常量表达式

int staff size = 27;    // staff size 不是常量表达式

const int sz = get_size（）;    // sz 不是常量表达式

尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而 非const fnt,所以它不属于常量表达式。另一方面，尽管sz本身是一个常量，但它 的具体值直到运行时才能获取到，所以也不是常量表达式。

constexpr 变量

在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。 当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实 际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种 情况下，对象的定义和使用根本就是两回事儿。

C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的 值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量' 表达式初始化：

| constexpr int mf = 20;    // |      |                 |      |
| ---------------------------- | ---- | --------------- | ---- |
| constexpr                    | int  | limit = mf + 1; | //   |
| constexpr                    | int  | sz = size ();   | //// |



20是常量表达式

mf + 1是常量表达式

只有当size是一个constexpr函数时 才是一条正确的声明语句



尽管不能使用普通函数作为constexpr变量的初始值，但是正如6.5.2节（第214页） 将要介绍的，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使 得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。

Best



一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr 类型

字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必 须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字 面值类型”（literal type）。

到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义 类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成 constexpr。其他一些字面值类型将在7.5.6节（第267页）和19.3节（第736页）介绍。

尽管指针和引用都能定义成constexpr,但它们的初始值却受到严格限制。一个 constexpr指针的初始值必须是nullptr或者0,或者是存储于某个固定地址中的对象。

6.1 + 1节（第184页）将要提到，函数体内定义的变量一般来说并非存放在固定地址中， 因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地 址固定不变，能用来初始化constexpr指针。同样是在6.1 + 1节（第185页）中还将提 到，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变 量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指 针也能指向这样的变量。

指针和 constexpr

必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅

对指针有效，与指针所指的对象无关，

const int *p = nullptr;    // p是一个指向整型常量的指针

constexpr int *q = nullptr; // q是一个指向整数的常量指针

p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在 于constexpr把它所定义的对象置为了顶层const (参见2.4.3节，第57页)。

与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量

constexpr int *np = nullptr; int j = 0;

constexpr int i = 42;

// i和j都必须定义在函数体之外 constexpr const int *p = &i; constexpr int *pl = &j;



// np是一个指向整数的常量指针，其值为空



// i的类型是整型常量



// p是常量指针，指向整型常量i // pi是常量指针，指向整数j



###### 2.4.4节练习

练习2.32:下面的代码是否合法？如果非法，请设法将其修改正确。 int null =0, *p = null;
