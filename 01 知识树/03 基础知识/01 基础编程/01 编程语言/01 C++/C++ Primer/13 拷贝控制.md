### 第13章 拷贝控制

内容

如我们在第7章所见，每个类都定义了一个新类型和在此类型对象上可执行的操作。 在本章中，我们还将学到，类可以定义构造函数，用来控制在创建此类型对象时做什么。

在木V中，我们还将学刃类如何控制该类型对象拷贝、赋值、移动或销毁时做什么。 类通过一些特殊的成员函数控制这些操作，包括：拷贝构造函数、移动构造函数、拷贝赋 值运算符、移动赋值运算符以及析构函数。

n§6>    当定义一个类时，我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁

时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数 (copy constructor)、拷贝赋值运算符(copy-assignment 叩erator)、移动构造函数(move constructor)、移动赋值运算符(move-assignment 叩erator)和析构函数(destructor)。拷贝 和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值 运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对 象销毁时做什么。我们称这些操作为拷贝控制操作(copycontrol)。

如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。因 此，很多类会忽略这些拷贝控制操作(参见7.1.5节，第239页)。但是，对一些类来说， 依赖这些操作的默认定义会导致灾难。通常，实现拷贝控制操作最困难的地方是首先认识 到什么时候需要定义这些操作。

WARNING



在定义任何C++类时，拷贝控制操作都是必要部分...对初学C++的程序员来说， 必须定义对象拷贝、移动、赋值或销毁时做什么，这常常令他们感到困惑:.这 种困扰很复杂，因为如果我们不显式定义这些操作，编译器也会为我们定义， 但编译器定义的版本的行为可能并非我们所想。

##### 13.1拷贝、赋值与销毁

我们将以最基本的操作一拷贝构造函数、拷贝赋值运算符和析构函数作为开始。我 们在13.6节(第470页)中将介绍移动操作(新标准所引入的操作)。

13.1.1拷贝构造函数

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值， 则此构造函数是拷贝构造函数。

class Foo { public:

Foo () ;    //默认构造函数

Foo (const Foo&) ;    //拷贝构造函数

// ...

}；

拷贝构造函数的第一个参数必须是一个引用类型，原因我们稍后解释。虽然我们可以定义 一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。拷贝构 造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是explicit 的(参见7.5.4节，第265页)。

合成拷贝构造函数

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构 造函数(参见7.1.4节，第235页)不同，即使我们定义了其他构造函数，编译器也会为 我们合成一个拷贝构造函数。

如我们将在13.1.6节(第450页冲所见，对某些类来说，合成拷贝构造函数(synthesized copy constructor)用来阻止我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数 会将其参数的成员逐个拷贝到正在创建的对象中(参见7.1.5节，第239页)。编译器从给

定对象中依次将每个非static成员拷贝到正在创建的对象中。

每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝： 内置类型的成员则直接拷贝。虽然我们不能直接拷贝一个数组（参见3.5.1节，第102页）， 何合成拷贝构造函数会逐元素地拷贝一个数组类型的成员，如果数组元素是类类型，则使 用元素的拷贝构造函数來进行拷贝。

作为一个例子，我们的Sales_data类的合成拷贝构造函数等价于：

class Sales_data {

public:

//其他成员和构造函数的定义，如前

//与合成的拷贝构造函数等价的拷贝构造函数的声明

Sales_data(const Sales_data&); private:

std::string bookNo; int units_sold = 0; double revenue = 0.0;

}；

//与Sales_data的合成的拷贝构造函数等价

Sales data: : Sales data (const Sales data &ong):



bookNo(orig.bookNo), units_sold(orig.units_sold), revenue(orig.revenue)

{ }



//使用string的拷贝构造函数 // 拷贝 orig. units_sold // 拷贝 orig. revenue //空函数体



拷贝初始化

现在，我们可以完全理解直接初始化和拷贝初始化之间的差异了（参见3.2.1节，第76页）:

string

string

string

string

string

| dots (10, ’ .r);             | //   | 直接初始化 |
| ---------------------------- | ---- | ---------- |
| s(dots);                     | //   | 直接初始化 |
| s2 = dots;                   | II   | 拷贝初始化 |
| null_book = "9-999-99999-9"; | //   | 拷贝初始化 |
| nines = string(100, '9');    | //   | 拷贝初始化 |

当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配（参见6.4节，第209 页）来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化（copy initialization）时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的 话还耍进行类型转换（参见7.5.4节，第263页）。

拷贝初始化通常使用拷贝构造函数来完成。但是，如我们将在13.6.2节（第473页） 所见，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝 构造函数来完成。但现在，我们只需了解拷贝初始化何时发生，以及拷贝初始化是依靠拷 贝构造函数或移动构造函数来完成的就可以了。

<498~|



拷贝初始化不仅在我们用=定义变量吋会发生，在下列情况下也会发生

•将一个对象作为实参传递给一个非引用类型的形参

•从一个返回类型为非引用类型的函数返回一个对象

•用花括号列表初始化一个数组中的元素或一个聚合类中的成员（参见7.5.5节，第 266 页）

某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或 是调用其insert或push成员（参见9.3.1节，第306页）时，容器会对其兀素进彳丁摔 贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化（参见9.3.1节，第 308 页）。

参数和返回值

在函数调用过程中，具有非引用类型的参数要进行拷贝初始化（参见6.2.1节，第188 页）。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结 果（参见6.3.2节，第201页）。

拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数 自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了 调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造 函数，如此无限循环。

拷贝初始化的限制

如前所述，如果我们使用的初始化值要求通过一个explicit的构造函数来进行类 型转换（参见7.5.4节，第265页），那么使用拷贝初始化还是直接初始化就不是无关紧要 的了：

vector<int> vl （10） ;    //正确：直接初始化

vector<int> v2 = 10; //错误：接受大小参教的构造函数是explicit的 void f （vector<int>） ; // f的参数进行拷贝初始化 f （10） ; II错误：不能用一个explicit的构造函数拷贝一个实参 f （vector<int> （10） ） ;    //正确：从一十int直接构造一个临时vector

直接初始化vl是合法的，但看起来与之等价的拷贝初始化v2则是错误的，因为vector 的接受单一大小参数的构造函数是explicit的。出于同样的原因，当传递一个实参或 从函数返回一个值时，我们不能隐式使用一个explicit构造函数。如果我们希望使用 一个explicit构造函数，就必须显式地使用，像此代码中最后一行那样。

099>编译器可以绕过拷贝构造函数

在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建 对象。即，编译器被允许将下面的代码

string null_book = "9-999-99999-9"; // 拷贝初始化

改写为

string null_book （"9-999-99999-9"） ; // 编译器略过了拷贝构造函数

但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必 须是存在且可访问的（例如，不能是private的）。

###### 13.1.1节练习

练习13.1:拷贝构造函数是什么？什么时候使用它？ 练习13.2:解释为什么下面的声明是非法的：

Sales_data::Sales_data(Sales_data rhs);

练习13.3:当我们拷贝一个StrBlob时，会发生什么？拷贝一个StrBlobPtr呢？

练习13.4:假定Point是一个类类型，它有一个public的拷贝构造函数，指出下面 程序片段中哪些地方使用了拷贝构造函数：

Point global;

Point foo_bar(Point arg)

{ ，

Point local = arg, *heap = new Point(global);

*heap = local;

Point pa[ 4 ] = { local, *heap }; return *heap;

}

练习13.5:给定下面的类框架，编写一个拷贝构造函数，拷贝所有成员。你的构造函数 应该动态分配一个新的string (参见12.1.2节，第407页)，并将对象拷贝到ps指向 的位置，而不是ps本身的位置。

class HasPtr { public:

HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0)    { }

private:

std::string *ps; int i;

###### 13.1.2拷贝赋值运算符

6 <500 1



与类控制其对象如何初始化一样，类也可以控制其对象如何赋值：

Sales_data trans, accum;

trans = accum; //使用Sales_data的拷贝赋值运算符 与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

重载赋值运算符

在介绍合成赋值运算符之前，我们需要了解一点儿有关重载运算符(overloaded operator)的知识，详细内容将在第14章中进行介绍。

重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的 符号组成。因此，赋值运算符就是一个名为函数。类似于任何其他函数， 运算符函数也有一个返回类型和一个参数列表。

重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义 为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参 数(参见7.1.2节，第231页)。对于一个二元运算符，例如赋值运算符，其右侧运算对象 作为显式参数传递。

拷贝赋值运算符接受一个与其所在类相同类型的参数：

class Foo { public:

Foo& operator= (const Foo&) ; // 赋值运算符

}；

为了与内置类型的赋值(参见4.4节，第129页)保持一致，赋值运算符通常返回一个指 向其左侧运算对象的引用。另外值得注意的是，标准库通常要求保存在容器中的类型要具 有赋值运算符，且其返回值是左侧运算对象的引用。

赋值运算符通常应该返回一个指向其左侧运算对象的引用..

合成拷贝赋值运算符

与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它 生成一个合成拷贝赋值运算符(synthesized copy-assignment operator)。类似拷贝构造函数， 对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值(参见13.1.6节，第450页)。 如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的每个非static成员赋予左 侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组 类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

EM> 作为一个例子，下面的代码等价于SaleS_data的合成拷贝赋值运算符：

//等价于合成拷贝赋值运算符

Sales_data&

Sales_data::operator=(const Sales_data &rhs)

{

bookNo = rhs .bookNo;    // 调用 string:: operator:

units_sold = rhs.units_sold; // 使用内置的 int 賦值 revenue = rhs . revenue;    // 使用内置的 double 赋值

return *this;    //返回一个此对象的引用

###### 13.1.2节练习

练习13.6:拷贝赋值运算符是什么？什么时候使用它？合成拷贝赋值运算符完成什么工 作？什么时候会生成合成拷贝赋值运算符？

练习13.7:当我们将一个StrBlob赋值给另一个StrBlob时，会发生什么？赋值 StrBlobPtr 呢？

练习13.8:为13.1.1节(第443页)练习13.5中的HasPtr类编写赋值运算符。类似 拷贝构造函数，你的赋值运算符应该将对象拷贝到ps指向的位置。

###### 沿13.1.3析构函数

析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员， 还可能做一些其他工作:析构函数释放对象使用的资源,并销毁对象的非static数据成员。

析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受 参数：

class Foo {

public:

〜Foo() ; //析构函数

II...

1;

由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。

析构函数完成什么工作

如同构造函数有一个初始化部分和一个函数体（参见7.5.1节，第257页），析构函数 也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前 完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，<502] 然后销毁成员。成员按初始化顺序的逆序销毁。

在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何收尾工 作。通常，析构函数释放对象在生存期分配的所有资源。

在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，

析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要 执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要 做。

隐式销毁一个内置指针类型的成员不会delete它所指向的对象。

与普通指针不同，智能指针（参见12.1.1节，第402页）是类类型，所以具有析构函数。

因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁。

什么时候会调用析构函数

无论何时一个对象被销毁，就会自动调用其析构函数：

•变量在离开其作用域时被销毁。

•当一个对象被销毁时，其成员被销毁。

•容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。

•对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁（参见12.1.2 节，第409页）》

•对于临时对象，当创建它的完整表达式结束时被销毁。

由于析构函数自动运行，我们的程序可以按需要分配资源，而（通常）无须担心何时释放 这些资源。

例如，下面代码片段定义了四个Sales_data对象：

{ //新作用域

// p和p2指向动态分配的对象

Sales_data *p = new Sales_data;    // p 是一个内置指针

auto p2 = make_shared<Sales_data> （） ;    // p2 是一个 shared_ptr

Sales_data item （*p） ;    //拷贝构造函数将*?拷贝到item中

vector<Sales_data> vec; // 局部对象

vec.push_back （*p2） ;    // 拷贝 p2 指向的对象

delete p;    //对p指向的对象执行析构函数

} //退出局部作用域；对item、p2和vec调用析构函数 //销毀p2会递减其引用计数；如果引用计数变为0，对象被释放 //销毁vec会销毁它的元素

I 503＞每个Sales_data对象都包含一个string成员，它分配动态内存米保存bookNo成w 中的字符。是，我们的代码唯一需要直接管理的内存就是我们直接分配的Sales_data 对象。我们的代码只需直接释放绑定到P的动态分配对象。

其他Sales_data对象会在离开作用域时被自动销毁。当程序块结束时，vec、p2 和item都离开了作用域，意味着在这些对象上分別会执行vector、shared_ptr和 Sales_data的析构函数。vector的析构函数会销毁我们添加到vec &元素。 Share^_ptr的析构函数会递减P2指向的对象的引用计数。在本例中，引用计数会变为 0,因此shared_ptr的析构函数会delete p2分配的Sales_data对象。

在所有情况下，Sales_data的析构函数都会隐式地销毁bookNo成员。销毁bookNo 会调用string的析构函数，它会释放用来保存ISBN的内存。

![img](C++  Primer 5-112.jpg)



当指向一个对象的引用或指针离开作用域时，析构函数不会执行

合成析构函数

当-•个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数(synthesized destructor类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻 止该类型的对象被销毁(参见13.1.6节，第450页)。如果不是这种情况，合成析构函数 的函数体就为空。

例如，下面的代码片段等价于Sales_data的合成析构函数：

class Sales_data { public:

//成员会被自动销毀，除此之外不需要做其他事情 ~Sales_data()    { }

//其他成员的定义，如前

}；

在(空)析构函数体执行完毕后，成员会被自动销毁。特别的，string的析构函数会被 调用，它将释放bookNo成员所用的内存。

汄识到析构函数体自身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐 含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外 的另一部分而进行的。

###### 13.1.3节练习

练习13.9:析构函数是什么？合成析构函数完成什么工作？什么时候会生成合成析构函 数？

练习13.10:当一个StrBlob对象销毁时会发生什么？ 一个StrBlobPtr对象销毁时 呢？

练习13.11:为前面练习中的HasPtr类添加一个析构函数。

练习13.12:在下面的代码片段中会发生几次析构函数调用？

bool fen(const Sales_data *trans, Sales_data accum)

{

Sales data iteml(*trans), item2(accum);

return iteml.isbn()    != item2.isbn();

}

练习13.13:理解拷贝控制成员和构造函数的一个好方法是定义一个简单的类，为该类 定义这些成员，每个成员都打印出自己的名字： struct X {

X ()    {std::cout « "X()" « std::endl;}

X (const X&)    {std::cout « "X(const X&)" « std::endl;}

}；

给X添加拷贝赋值运算符和析构函数，并编写一个程序以不同方式使用X的对象：将它 们作为非引用和引用参数传递：动态分配它们；将它们存放于容器中；诸如此类。观察 程序的输出，直到你确认理解了什么时候会使用拷贝控制成员，以及为什么会使用它们。 当你观察程序输出时，记住编译器可以略过对拷贝构造函数的调用。

###### 13.1.4三/五法则

如前所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符 和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运 算符，我们将在13.6节(第470页)中介绍这些内容。

C++语言并不要求我们定义所有这些操作：可以只定义其中一个或两个，而不必定义＜504^ 所有。但是，这些操作通常应该被看作一个整体。通常，只需要其中一个操作，而不需要 定义所有操作的情况是很少见的。

需要析构函数的类也需要拷贝和赋值操作

当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确 定这个类是否需要一个析构函数。通常，对析构函数的需求要比对拷贝构造函数或赋值运 算符的需求更为明显。如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷 贝构造函数和一个拷贝赋值运算符。

我们在练习中用过的HasPtr类是一个好例子(参见13.1.1节，第443页)。这个类 在构造函数中分配动态内存。合成析构函数不会delete—个指针数据成员。因此，此类 需要定义一个析构函数来释放构造函数分配的内存。

应该怎么做可能还有点儿不清晰，但基本原则告诉我们，HasPtr也需要一个拷贝构 造函数和一个拷贝赋值运算符。

如果我们为HasPtr定义一个析构函数，但使用合成版本的拷贝构造函数和拷贝赋值＜5051 运算符，考虑会发生什么：

class HasPtr { public:

HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0)    { }

〜HasPtr()    { delete ps; }

//错误：HasPtr需要一个拷贝构造函数和一个拷贝赋值运算符 //其他成员的定义，如前

}；

在这个版本的类定义中，构造函数中分配的内存将在HasPtr对象销毁时被释放。供 不幸的是，我们引入了一个严重的错误！这个版本的类使用了合成的拷贝构造函数和拷贝

赋值运算符。这些函数简单拷贝指针成员,这意味着多个HasPtr对象可能指向相同的内存： HasPtr f (HasPtr hp)    // HasPtr是传值参数，所以将被拷贝

{

HasPtr ret = hp;    // 拷贝给定的 HasPtr

//处理ret

return ret;    // ret 和 hp 被销毁

}

当f返回时，hp和ret都被销毁，在两个对象上都会调用HasPtr的析构函数。此析构 函数会delete ret和hp中的指针成员。但这两个对象包含相同的指针值。此代码会导 致此指针被delete两次，这显然是一个错误(参见12.1.2节，第411页)。将要发生什 么是未定义的。

此外，f的调用者还会使用传递给f的对象：

HasPtr p("some values");

f (p) ;    //当f结束时，p.ps指向的内存被释放

HasPtr q (p) ;    II现在p和q都指向无效内存！

P (以及q)指向的内存不再有效，在hp (或ret!)销毁时它就被归还给系统了。

![img](C++  Primer 5-113.jpg)



如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝賦值运算 符和拷贝构造函数。

需要拷贝操作的类也需要赋值操作，反之亦然

虽然很多类需要定义所有(或是不需要定义任何)拷贝控制成员，但某些类所要完成 的工作，只需要拷贝或赋值操作，不需耍析构函数。

作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的序号。这个类需要一 个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷 贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要自定义拷贝赋值运算符來避 '免将序号赋予目的对象。但是，这个类不需要自定义析构函数。

这个例子引出了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定 它也需耍一个拷贝赋值运算符。反之亦然——如果一个类需要一个拷贝赋值运算符，几乎 可以肯定它也需要一个拷贝构造函数。然而，无论是需要拷贝构造函数还是需要拷贝赋值 运算符都不必然意味着也需要析构函数。

###### 13.1.4节练习

练习13.14:假定numbered是一个类，它有一个默认构造函数，能为每个对象生成一 个唯一的序号，保存在名为mysn的数据成员中。假定numbered使用合成的拷贝控制 成员，并给定如下函数：

void f (numbered s) { cout « s.mysn « endl; }

则下面代码输出什么内容？

numbered a, b = a, c = b; f (a) ； f (b) ; f (c);

练习13.15:假定numbered定义了一■个拷贝构造函数，能生成一个新的序号。这会改 变上一题中调用的输出结果吗？如果会改变，为什么？新的输出结果是什么？

练习13.16:如果f中的参数是const numbered&,将会怎样？这会改变输出结果吗？ 如果会改变，为什么？新的输出结果是什么？

练习13.17:分别编写前三题中所描述的numbered和f,验证你是否正确预测了输出 结果。

13.1.5 使用=default

我们可以通过将拷贝控制成员定义*=default来显式地要求编译器生成合成的版本 (参见7.1.4节，第237页)：

class Sales_data { public:

//拷贝控制成员；使用default Sales_data() = default;

Salesdata(const Sales_data&) = default;

Sales_data& operator= (const Sales_data &);

~Sales_data() = default;

//其他k员的定义，如前

}；

Sales_data& Sales_data::operator=(const Sales_data&) = default;

当我们在类内修饰成员的声明时，合成的函数将隐式地声明为内联的 (就像任何其他类内声明的成员函数一样)。如果我们不希望合成的成员是内联函数，应该＜507] 只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样。

B我们只能对具有合成版本的成员函数使用^default (即，默认构造函数或拷 贝控制成员)

13.1.6阻止拷贝

Best



大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐 式地还是显式地。

虽然大多数类应该定义(而且通常也的确定义了)拷贝构造函数和拷贝赋值运算符，

但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻 止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO 缓冲。为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的：

如果我们的类未定义这些操作，编译器为它生成合成的版本。

定义删除的函数

在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数(deleted 1^71 function)来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何 方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的：

struct NoCopy {

NoCopy () = default;    //使用合成的默认构造函数

NoCopy (const NoCopy&) = delete;    // 阻止拷贝

NoCopy &operator= (const NoCopy&) = delete; // 阻止绒值

~NoCopy（） = default;    Z/使用合成的析构函数

//其他成员

｝；

=delete通知编译器（以及我们代码的读者），我们不希望定义这些成员。

不同，=delete必须出现在函数第一次声明的时候，这个差异与这些声 明的含义在逻辑上是吻合的。一个默认的成员只影响为这个成员而生成的代码，因此 =default直到编译器生成代码时才需要。而另一方面，编译器需要知道一个函数是删除 的，以便禁止试图使用它的操作。

与=<^£313让的另一个不同之处是，我们可以对任何函数指定=delete （我们只能对 L5Q8>编译器可以合成的默认构造函数或拷贝控制成员使用=default）»虽然删除函数的主要 用途是禁Ik拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。

析构函数不能是删除的成员

值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的 对象了，对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类 的临时对象。而且，如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类 的变量或临时对象。因为如果一个成员的析构函数是删除的，则该成员无法被销毁。而如 果一个成员无法被销毁，则对象整体也就无法被销毁了。

对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态 分配这种类型的对象。但是，不能释放这些对象：

struct NoDtor ｛

NoDtor 0 = default; //使用合成默认构造函数 -NoDtor （） = delete; //我们不能销毁NoDtor类型的对象

｝；

NoDtor nd; //错误：NoDtor的析构函数是删除的

NoDtor *p = new NoDtor （）;// 正确：但我们不能 delete p delete p; //错误：NoDtor的析构函数是删除的

WARNING



对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分 配对象的指针。

合成的拷贝控制成员可能是删除的

如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本，类似的， 如果一个类未定义构造函数，编译器会为其合成一个默认构造函数（参见7.1.4节，第235 页）。对某些类来说，编译器将这些合成的成员定义为删除的函数：

•如果类的某个成员的析构函数是刪除的或不可访问的（例如，是private的）， 则类的合成析构函数被定义为删除的。

•如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函 数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合 成的拷贝构造函数也被定义为删除的。

•如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。

•如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它 没有类内初始化器（参见2.6.1节，第65页），或是类有一个const成员，它没有

类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为 删除的。

本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，＜509] 则对应的成员函数将被定义为删除的。

一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义 为删除的，这看起来可能有些奇怪。其原因是，如果没有这条规则，我们可能会创建出无 法销毁的对象。

对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构 造函数，这应该不奇怪。同样不出人意料的规则是：如果一个类有const成员，则它不 能使用合成的拷贝赋值运算符。毕竟，此运算符试图赋值所有成员，而将一个新值赋予一 个const对象是不可能的。

虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的 值，而不是引用本身。如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍 然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起 来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

我们将在13.6.2节（第476页）、15.7.2节（第553页）及19.6节（第751页）中介 绍导致类的拷贝控制成员被定义为删除函数的其他原因。

本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被 定义为删除的-

private拷贝控制

在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private 的来阻止拷贝：

class PrivateCopy {

//无访问说明符；接下来的成员默认为private的；参见7.2节（第240页）

//拷贝控制成员是private的，因此普通用户代码无法访问 PrivateCopy（const PrivateCopyS）;

PrivateCopy &operator=（const PrivateCopy&）;

//其他成员

public:

PrivateCopy （） = default; //使用合成的默认构造函数 -PrivateCopy （） ; //用户可以定义此类型的对象，但无法拷贝它们

}；

由于析构函数是public的，用户可以定义PrivateCopy类型的对象。但是，由于拷贝 构造函数和拷贝赋值运算符是private的，用户代码将不能拷贝这个类型的对象。但是，

友元和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝，我们将这些拷贝 控制成员声明为private的，但并不定义它们。

声明但不定义一个成员函数是合法的（参见6.1.2节，第186页），对此只有一个例外，

我们将在15.2.1节（第528页）中介绍。试图访问一个未定义的成员将导致一个链接时错 误。通过声明（但不定义）private的拷贝构造函数，我们可以预先阻止任何拷贝该类＜5W： 型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函 数中的拷贝操作将会导致链接时错误。

希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝 赋值运算符，而不应该将它们声明为private的.

###### 13.1.6节练习

练习13.18:定义一个Employee类，它包含雇员的姓名和唯一的雇员证号。为这个类 定义默认构造函数，以及接受一个表示雇员姓名的string的构造函数。每个构造函数 应该通过递增一个static数据成员来生成一个唯一的证号。

练习13.19:你的Employee类需要定义它自己的拷贝控制成员吗？如果需要，为什么？ 如果不需要，为什么？实现你认为Employee需要的拷贝控制成员。

练习13.20：解释当我们拷贝、赋值或销毁TextQuery和QueryResult类（参见12.3 节，第430页）对象时会发生什么。

练习13.21:你认为TextQuery和QueryResult类需要定义它们自己版本的拷贝控 制成员吗？如果需要，为什么？如果不需要，为什么？实现你认为这两个类需要的拷贝 控制操作。

##### S 13.2拷贝控制和资源管理

通常，管理类外资源的类必须定义拷贝控制成员。如我们在13.1.4节（第447页）中 所见，这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那 么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。

为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选 择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。

类的行为像一个值.意味着它应该也有自己的状态。当我们拷贝一个像值的对象时， 副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然》

行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相 同的底层数据。改变副本也会改变原对象，反之亦然。

在我们使用'过的标准库类中，标准库容器和string类的行为像一个值。而不出意外 的，shared_ptr类提供类似指针的行为，就像我们的StrBlob类（参见12.1.1节，第 405页）一样，IO类型和Unique_ptr不允许拷贝或赋值，因此它们的行为既不像值也 不像指针。

为了说明这两种方式，我们会为练习中的HasPtr类定义拷贝控制成员。首先，我们 将令类的行为像一个值；然后重新实现类，使它的行为像一个指针。

我们的HasPtr类有两个成员，一个int和一个string指针。通常，类直接拷贝 内置类型（不包括指针）成员；这些成员本身就是值，因此通常应该让它们的行为像值一 样。我们如何拷贝指针成员决定了像HasPtr这样的类是具有类值行为还是类指针行为。

###### 13.2节练习    _

练习13.22:假定我们希望HasPtr的行为像一个值。即，对于对象所指向的string

成员，每个对象都有一份自己的拷贝。我们将在下一节介绍拷贝控制成员的定义。但是， 你已经学习了定义这些成员所需的所有知识。在继续学习下一节之前，为HasPtr编写 拷贝构造函数和拷贝赋值运算符，

13.2.1行为像值的类    50

为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。这 意味着对于ps指向的string,每个HasPtr对象都必须有自己的拷贝。为了实现类值 行为，HasPtr需要

•定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针

•定义一个析构函数米释放string

•定义一个拷贝赋值运算符来释放对象当前的string,并从右侧运算对象拷贝 string

类值版本的HasPtr如下所示

class HasPtr { public:

}；

我们的类足够简单，在类内就已定义了除赋值运算符之外的所有成员函数。第一个构造函＜5R] 数接受一个(可选的)string参数。这个构造函数动态分配它自己的string副本，并 将指向string的指针保存在ps中。拷贝构造函数也分配它自己的string副本。析构 函数对指针成员ps执行delete,释放构造函数中分配的内存。

类值拷贝赋值运算符

赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁 左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。但是，

非常重要的一点是，这些操作是以正确的顺序执行的，即使将一个对象赋予它自身，也保 证正确。而且，如果可能，我们编写的赋值运算符还应该是异常安全的——当异常发生时 能将左侧运算对象置于一个有意义的状态(参见5.6.2节，第175页)。

在本例中，通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证在异常发 生时代码也是安全的。在完成拷贝后，我们释放左侧运算对象的资源，并更新指针指向新 分配的string：

HasPtr& HasPtr::operator=(const HasPtr &rhs)

{

auto newp = new string (*rhs.ps) ; // 拷贝底层 string delete ps;    //释放旧内存

ps = newp;    //从右侧运算对象拷贝数据到本对象

i = rhs.i;

return *this;    //返回本对象

)

在这个赋值运算符中，非常清楚，我们首先进行了构造函数的工作：newp的初始化器等 价于HasPtr的拷贝构造函数中ps的初始化器。接下来与析构函数一样，我们delete 当前ps指向的string。然后就只剩下拷贝指向新分配的string的指针，以及从rhs 拷贝int值到本对象了。

发键概念：赋值运算符

当你编写赋值运算符时，有两点需要记住：

•如果将一个对象赋予它自身，赋值运算符必须能正确工作。

•大多数賦值运算符组合了析构函数和拷贝构造函数的工作。

当你编写一个赋值运算符时，y个好的模式是先将右侧运算对象拷见到一个局部临时对 象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象 的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。

C513>    为了说明防范自赋值操作的重要性，考虑如果赋值运算符如下编写将会发生什么

//这样编写賦值运算符是错误的！

HasPtr&

HasPtr::operator=(const HasPtr &rhs)

{

delete ps; //鋒放对象指向的string

//如果rhs和*this是同一个对象，我们就将从已释放的内存中拷贝数据！ ps = new string (* (rhs.ps)); i = rhs.i;

return *this;

}

如果rhs和本对象是同一个对象，delete ps会释放*this和rhs指向的string。接 下来，当我们在new表达式中试图拷贝* (rhs.ps)时，就会访问一个指向无效内存的指 针，其行为和结果是未定义的。

对于一个赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它 /!\ 自身，也要能正确工作一个好的方法是在销毁左侧运算对象资源之前拷贝右 WARNING侧运算对象。

###### 13.2.1节练习

练习13.23：比较上一节练习中你编写的拷贝控制成员和这一节中的代码。确定你理解 了你的代码和我们的代码之间的差异(如果有的话)。

练习13.24:如果本节中的HasPtr版本未定义析构函数，将会发生什么？如果未定义 拷贝构造函数，将会发生什么？

练习13.25:假定希望定义StrBlob的类值版本,而且希望继续使用shared ptr.

这样我们的StrBlobPtr类就仍能使用指向vector的weak_ptr 了。你修改后的类 将需要一个拷贝构造函数和一个拷贝赋值运算符，但不需要析&函数。解释拷贝构造函 数和拷贝赋值运算符必须要做什么。解释为什么不需要析构函数。

练习13.26:对上一题中描述的StrBlob类，编写你自己的版本。

13.2.2定义行为像指针的类    ?6

对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝 指针成员本身而不是它指向的string,我们的类仍然需要自己的析构函数来释放接受 string参数的构造函数分配的内存（参见13.1.4节，第447页）。但是，在本例中，析 构函数不能单方面地释放关联的string。只有当最后一个指向string的HasPtr销毁 时，它才可以释放string。

令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。

拷贝（或赋值）一个shared_ptr会拷贝（赋值）shared_ptr所指向的指针。＜514 I shared_ptr类自己记录有多&用户共享它所指向的对象。当有用户使用对象时， shared_ptr类负责释放资源。

但是，有时我们希望直接管理资源，在这种情况下，使用引用计数（reference count）

（参见12.1.1节，第402页）就很有用了。为了说明引用计数如何工作，我们将重新定义 HasPtr,令其行为像指针一样，但我们不使用shared_Ptr,而是设计自己的引用计数。

引用计数

引用计数的工作方式如下：

•除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数， 用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一 个对象共享状态，因此将计数器初始化为1。

•拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷 贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。

•析构函数递减计数器，指出共享状态的用户少了一个，如果计数器变为0,则析构 函数释放状态。

•拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左 侧运算对象的计数器变为0,意味着它的共享状态没有用户了，拷贝赋值运算符就 必须销毁状态。

唯一的难题是确定在哪里存放引用计数。计数器不能直接作为HasPtr对象的成员。 下面的例子说明了原因：

HasPtr pl（"Hiya!"）;

HasPtr p2（pl）;    // pi 和 p2 指向相同的 string

HasPtr p3 （pi） ;    // pi、p2 和 p3 都指向相同的 string

如果引用计数保存在每个对象中，当创建P3时我们应该如何正确更新它呢？可以递增pi 中的计数器并将其拷贝到p3中，但如何更新p2中的计数器呢？

解决此问题的一种方法是将计数器保存在动态内存中。当创建一个对象时，我们也分 配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法， 副本和原对象都会指向相同的计数器，

定义一个使用引用计数的类

通过使用引用计数，我们就可以编写类指针的HasPtr版本了：

I 515〉    class HasPtr {

public:

//构造函数分配新的string和新的计数器，将计数器置为1 HasPtr(const std::string &s = std::string()):

ps(new std::string(s))z i(0), use(new std::size_t(1))    {}

//拷贝构造函数拷贝所有三个数据成员，并递增计数器 HasPtr(const HasPtr &p):

ps(p.ps), i(p.i), use(p.use) { ++*use; }

HasPtr& operator=(const HasPtrS);

〜HasPtr(};

private:

std::string *ps; int i;

std: : size_t *use; //用来记录有多少个对象共享*ps的成员

}；

在此，我们添加了一个名为use的数据成员，它记录有多少对象共享相同的string。接 受string参数的构造函数分配新的计数器，井将其初始化为1,指出当前有一个用户使 用本对象的string成员。

类指针的拷贝成员“篡改”引用计数

当拷贝或赋值一个HasPtr对象时，我们希望副本和原对象都指向相同的string。 即，当拷贝一个HasPtr时，我们将拷贝ps本身，而不是ps指向的string。当我们 进行拷贝时，还会递增该string关联的计数器。

(我们在类内定义的)拷贝构造函数拷贝给定HasPtr的所有三个数据成员。这个构 造函数还递增use成员，指出ps和p.ps指向的string又有了一个新的用户。

析构函数不能无条件地delete ps —■可能还有其他对象指向这块内存。析构函数应 该递减引用计数，指出共享string的对象少了一个。如果计数器变为0,则析构函数释 放ps和use指向的内存：

HasPtr::〜HasPtr()

{

if (--*use == 0)    {    //如果引用计数变为0

delete ps;    // 释放 string 内存

delete use;    //释放计数器内存

}

}

拷贝赋值运算符与往常一样执行类似拷贝构造函数和析构函数的工作。即，它必须递 增右侧运算对象的引用计数(即，拷贝构造函数的工作)，并递减左侧运算对象的引用计 数，在必要时释放使用的内存(即，析构函数的工作)。

而且与往常一样，赋值运算符必须处理自赋值。我们通过先递增rhs中的计数然后 im＞再递减左侧运算对象中的计数来实现这一点。通过这种方法，当两个对象相同时，在我们

检查ps (及use)是否应该释放之前，计数器就已经被递增过了：

HasPtr& HasPtr::operator=(const HasPtr &rhs)

++*rhs.use; //递增右侧运算对象的引用计数

//然后递减本对象的引用计数 //如果没有其他用户 //释放本对象分配的成员

//将数据从rhs拷贝到本对象



//返回本对象



if (--*use == 0)    {

delete ps; delete use;

}

ps = rhs.ps; i = rhs.i; use = rhs.use; return *this;

###### 13.2.2节练习

练习13.27：定义你自己的使用引用计数版本的HasPtr。

练习13.28：给定下面的类，为其实现一个默认构造函数和必要的拷贝控制成员。

(a) class TreeNode { private:

(b) class BinStrTree { private:

TreeNode *root;



｝；



std::string value; int    count;

TreeNode    *left;

TreeNode    *right;

}；

##### 13.3交换操作

除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数（参见9.2.5 节，第303页）。对于那些与重排元素顺序的算法（参见10.2.3节，第342页）一起使用 的类，定义swap是非常重要的。这类算法在需要交换两个元素吋会调用swap。

如果一个类定义了自己的swap,那么算法将使用类自定义版本。否则，算法将使用 标准库定义的swap。虽然与往常一样我们不知道swap是如何实现的，但理论上很容易 理解，为了交换两个对象我们需要进行一次拷贝和两次赋值。例如，交换两个类值HasPtr 对象（参见13.2+1节，第453页）的代码可能像下面这样：

HasPtr temp = vl;    //创建vl的值的一^个临时副本

vl = v2;    //将v2的值赋予vl

v2 = temp;    //将保存的vl的值賦予v2

这段代码将原来vl中的string拷贝了两次——第一次是HasPtr的拷贝构造函数将vl <^71 拷贝给temp,第二次是赋值运算符将temp赋予v2。将v2赋予vl的语句还拷贝了原 来v2中的string。如我们所见，拷贝一个类值的HasPtr会分配一个新string并将 其拷贝到HasPtr指向的位置。

理论上，这些内存分配都是不必要的。我们更希望swap交换指针，而不是分配 string的新副本。即，我们希望这样交换两个HasPtr:

string *temp = vl .ps; //为vl .ps中的指针创建一个副本

vl.ps = v2.ps;    // 将 v2.ps 中的指针賦予 vl .ps

v2.ps = temp;    //将保存的vl .ps中原来的指针赋予v2 .ps

编写我们自己的swap函数

可以在我们的类上定义一个自己版本的swap来重载swap的默认行为。swap的典 型实现如下：

class HasPtr {

friend void swap(HasPtr&, HasPtr&);

//其他成员定义，与13.2.1节(第453页)中一样

}；

inline

void swap(HasPtr &lhs, HasPtr &rhs)

{

using std::swap;

swap (lhs .ps, rhs.ps); // 交换指针，而不是 string 数据 swap (lhs . i, rhs.i);    // 交换 int 成员

我们昔先将swap定义为friend,以便能访问HasPtr的(private的)数据成员。 由于swap的存在就是为了优化代码，我们将其声明为inline函数(参见6.5.2节，第 213页)。swap的函数体对给定对象的每个数据成员调用swap。我们首先swap绑定到 rhs和lhs的对象的指针成员，然后是int成员。

![img](C++  Primer 5-115.jpg)



与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定 义swap可能是一种很重要的优化手段。

swap函数应该调用swap,而不是std::swap

此代码中有一个很重要的微妙之处：虽然这一点在这个特殊的例子中并不重要，但在 一般情况下它非常重要——swap函数中调用的swap不是std: : swap。在本例中，数据 成员是内置类型的，而内置类型是没有特定版本的swap的，所以在本例中，对swap的 调用会调用标准库std::swap„

但是，如果一个类的成员有自己类型特定的swap函数，调用std: :swap就是错误 的了 =例如，假定我们有另一个命名为Foo的类，它有一个类型为HasPtr的成员h。如

CIS〉果我们未定义Foo版本的swap,那么就会使用标准库版本的swap。如我们所见，标准 库swap对HasPtr管理的string进行了不必要的拷贝。

我们可以为Foo编写一个swap函数，来避免这些拷贝，但是，如果这样编写Foo 版本的swap：

void swap(Foo &lhs, Foo &rhs)

{

//错误：这个函数使用了标准库版木的swap，而不是HasPtr版本 std::swap(lhs.h, rhs.h);

//交换类型Foo的其他成员

}

此编码会编译通过，且正常运行。但是，使用此版本与简单使用默认版本的swap并没有 任何性能差异。问题在于我们显式地调用了标准库版本的swap。但是，我们不希望使用 std中的版本，我们希望调用为HasPtr对象定义的版本。

正确的swap函数如下所示： void swap(Foo &lhs, Foo &rhs)

{

using std::swap;

swap （lhs . h, rhs.h）; // 使用 HasPtr 版本的 swap //交换类型Foo的其他成员

}

每个swap调用应该都是未加限定的。即，每个调用都应该是swap.而不是std: : swap。 如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本，原因我们将在 16.3节（第616页）中进行解释。因此，如果存在类型特定的swap版本，swap调用会 与之匹配。如果不存在类型特定的版本，则会使用std中的版本（假定作用域中有using 声明）。

非常仔细的读者可能会奇怪为什么swap函数中的using声明没有隐、藏HasPtr版 本swap的声明（参见6.4.1节，第210页）。我们将在18.2.3节（第706页）中解释为什 么这段代码能正常工作。

在赋值运算符中使用swap

定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为 拷贝并交换（copy and swap）的技术。这种技术将左侧运算对象与右侧运算对象的一个副 本进行交换：

//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数

//将右侧运算对象中的string拷贝到rhs

HasPtr& HasPtr::operator=（HasPtr rhs）

{

//交换左侧运算对象和局部变量rhs的内容

swap （*this, rhs） ;    // rhs现在指向本对象曾经使用的内存

return *this;    // rhs 被销毁，从而 delete 了 rhs 中的指针

}

在这个版本的赋值运算符中，参数并不是一个引用，我们将右侧运算对象以传值方式传递 给了赋值运算符。因此，rhs是右侧运算对象的一个副本。参数传递时拷贝HasPtr的操 作会分配该对象的string的一个新副本。

在赋值运算符的函数体中，我们调用swap来交换rhs和*this中的数据成员。这 个调用将左侧运算对象中原来保存的指针存入rhs中，并将rhs中原來的指针存入*this 中。因此，在swap调用之后，*this中的指针成员将指向新分配的string——右侧运 算对象中string的一个副本。

当赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行。此析构函数delete rhs现在指向的内存，BP,释放掉左侧运算对象中原来的内存。

这个技术的有趣之处是它自动处理了自赋值情况且天然就是异常安全的。它通过在改 变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确，这与我们在原来的赋值运算 符中使用的方法是一致的（参见13.2.1节，第453页）。它保证异常安全的方法也与原来 的赋值运算符实现一样。代码中唯一可能抛出异常的是拷贝构造函数中的new表达式。 如果真发生了异常，它也会在我们改变左侧运算对象之前发生。

![img](C++  Primer 5-116.jpg)



使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。



###### 13.3节练习

练习13.29:解释swap （HasPtrS, HasPtr&＞中对swap的调用不会导致递归循环。

练习13.30:为你的类值版本的HasPtr编写swap函数，并测试它。为你的swap函 数添加一个打印语句，指出函数什么吋候执行。

练习13.31:为你的HasPtr类定义一个＜运算符，并定义一个HasPtr的vector。 为这个vector添加一些元素，并对它执行sort。注意何时会调用swap-

练习13.32:类指针的HasPtr版本会从swap函数受益吗？如果会，得到了什么益处？ 如果不是，为什么？

##### 13.4拷贝控制示例

虽然通常来说分配资源的类更需要拷贝控制，但资源管理并不是一个类需要定义自己 的拷贝控制成员的唯一原因。一些类也需要拷贝控制成员的帮助来进行簿记工作或其他操作。

作为类需要拷贝控制来进行簿记操作的例子，我们将概述两个类的设计，这两个类可 能用于邮件处理应用中。两个类命名为Message和Folder,分别表示电子邮件（或者

□2Q＞其他类型的）消息和消息目录。每个Message对象可以出现在多个Folder中。但是， 任意给定的Message的内容只有一个副本。这样，如果一条Message的内容被改变， 则我们从它所在的任何Folder来浏览此Message时，都会看到改变后的内容。

为了记录Message位于哪些Folder中，每个Message都会保存一个它所在 Folder的指针的set.同样的，每个Folder都保存一个它包含的Message的指针的 set。图13.1说明了这种设计思路。

Message

| 消息文本 |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- |
|          |      |      |      |      |

Folder

Message

| t    |      | 消辱文木 |      |      |      |      |
| ---- | ---- | -------- | ---- | ---- | ---- | ---- |
| 1    |      |          |      |      |      |      |
|      |      |          |      |      |      |      |

图 13.1: Message 和 Folder 类设计

我们的Message类会提供save和 remove操作，来向一个给定Folder添加一条 Message或是从中删除一条Message。为了创建一个新的Message,我们会指明消息 内容，但不会指出Folder。为了将一条Message放到一个特定Folder中，我们必须 调用save。

当我们拷贝一个Message时，副本和原对象将是不同的Message对象，但两个 Message都出现在相同的Folder中。因此，拷贝Message的操作包括消息内容和 Folder指针set的拷贝。而且，我们必须在每个包含此消息的Folder中都添加一个指 向新创建的Message的指针。

当我们销毁一个Message时，它将不复存在。因此，我们必须从包含此消息的所有

Folder中刪除指向此Message的指针。

当我们将一个Message对象赋予另一个Message对象时，左侧Message的内容会 被右侧Message的内容所替代。我们还必须更新Folder集合，从原来包含左侧Message 的Folder中将它删除，并将它添加到包含右侧Message的Folder中。

观察这些操作，我们可以看到，析构函数和拷贝赋值运算符都必须从包含一条 Message的所有Folder中刪除它。类似的，拷贝构造函数和拷贝赋值运算符都要将一 个Message添加到给定的一组Folder中。我们将定义两个private的工具函数来完 成这些工作。

拷贝賦值运算符通常执行拷贝构造函数和析构函数中也要做的工作,、这种情况

ra£t£e&s

下，公共的工作应该放在private的工具函数中完成5

Folder类也需要类似的拷贝控制成员，来添加或删除它保存的Message。

我们将Folder类的设计和实现留作练习。但是，我们将假定Folder类包含名为 addMsg和remMsg的成员，分别完成在给定Folder对象的消息集合中添加和删除 Message的工作。

Message 类

根据上述设计，我们可以编写Message类，如下所示：

class Message {

friend class Folder;

public:

// folders被隐式初始化为空集合

explicit Message(const std::string &str =: contents(str) { }

//拷贝控制成员，用来管理指向本Message的指针 Message (const Messages) ;    // 拷贝构造函数

Messages operator= (const Messages) ;    // 拷贝賊值运算符

-Message () ;    // 析构函数

//从给定Folder集合中添加/删除本Message

void save(Folders); void remove(Folders);

private:

std: :string contents;    // 实际消息文本

std: : set<Folder*> folders; // 包含本 Message 的 Folder

//拷贝构造函数、拷贝赋值运算符和析构函数所使用的工具函数

//将本Message添加到指向参数的Folder中

void add_to_Folders(const Messages);

//从folders中的每个Folder中删除本Message void remove_f rom_Folders ();

}；

这个类定义了两个数据成员：contents,保存消息文本；folders.保存指向本Message 所在Folder的指针。接受一个string参数的构造函数将给定string拷贝给 contents,并将folders (隐式)初始化为空集。由于此构造函数有一个默认参数，因 此它也被当作Message的默认构造函数(参见7.5.1节，第260页)。

save 和 remove 成员

除拷贝控制成员外，Message类只有两个公共成员：save,将本Message存放在 给定 Folder 中；remove,删除本 Message:

void Message::save(Folder &f)

folders . insert (&f) ;    //将给定Folder添加到我们的Folder列表中

f . addMsg (this) ;    // 将本 Message 添加到 f 的 Message 集合中

}

L5^>



void Message::remove(Folder &f)

{

folders .erase (&f) ;    //将给定Folder从我们的Folder列表中删除

f.remMsg (this) ;    // 将本 Message 从 f 的 Message 集合中删除

}

为了保存(或删除)一个Message，需要更新本Message的folders成员。当save 一个Message时，我们应保存一个指向给定Folder的指针；当remove —个Message 时，我们要删除此指针。

这些操作还必须更新给定的Folder。更新一个Folder的任务是由Folder类的 addMsg和remMsg成员来完成的，分别添加和删除给定Message的指针。

Message类的拷贝控制成员

当我们拷贝一个Message时，得到的副本应该与原Message出现在相同的Folder 中。因此，我们必须遍历Folder指针的set，对每个指向原Message的Folder添加 一个指向新Message的指针。拷贝构造函数和拷贝赋值运算符都需要做这个工作，因此 我们定义一个函数来完成这个公共操作：

//将本Message添加到指向m的Folder中

void Message::add_to_Folders(const Message &m)

{

for (auto f : m. folders) // 对每个包含 m 的 Folder

f->addMsg (this) ;    //向该Folder添力口一个指向本Message的指针

}

此例中我们对m. folders中每个Folder调用addMsg。函数addMsg会将本Message 的指针添加到每个Folder中。

Message的拷贝构造函数拷贝给定对象的数据成员：

Message::Message(const Message &m):

contents(m.contents), folders(m.folders)

{

add_to_Folders (m) ; //将本消息添加到指向m的Folder中

} -

并调用add_to_Folders将新创建的Message的指针添加到每个包含原Message的 Folder 中。

Message的析构函数

当一个Message被销毁时，我们必须从指向此Message的Folder中删除它。拷 贝赋值运算符也要执行此操作，因此我们会定义一个公共函数来完成此工作：

//从对应的Folder中删除本Message void Message::remove_from_Folders()

{

for (auto f : folders) // 对 folders 中每个指针

f->remMsg (this) ;    // 从该 Folder 中删除本 Message

}

函数remove_from_Folders的实现类似add_to_Folders »不同之处是它调用< 523 I remMsg来删除当前Message而不是调用addMsg来添加Message。

有了 remove_from_Folders函数，编写析构函数就很简单了：

Message::〜Message()

{

remove_from_Folders();

}

调用remove_f rom_Folders确保没有任何Folder保存正在销毁的Message的指针。

编译器自动调string的析构函数来释放contents,并自动调用set的析构函数来 清理集合成员使用的内存。

Message的拷贝赋值运算符

与大多数赋值运算符相同.我们的Message类的拷贝赋值运算符必须执行拷贝构造 函数和析构函数的工作。与往常一样，最重要的是我们要组织好代码结构，使得即使左侧 和右侧运算对象是同一个Message,拷贝赋值运算符也能正确执行。

在本例中，我们先从左侧运算对象的folders中删除此Message的指针，然后再 将指针添加到右侧运算对象的folders中，从而实现了自赋值的正确处理：

Messages Message::operator=(const Message &rhs)

//通过先删除指针再插入它们来处理自赋值情况

remove_f rom_Folders () ;    // 更新已有 Folder

contents = rhs . contents; // 从 rhs 拷贝消息内容

folders = rhs . folders;    // 从 rhs 拷贝 Folder 指针

add_to_Folders (rhs) ;    // 将本 Message 添加到那些 Folder 中

return *this;

}

如果左侧和右侧运算对象是相同的Message，则它们具有相同的地址。如果我们在 add_to_Folders 之后调用 remove_f rom_Folders,就会将此 Message 从它所在的 所有Folder中删除。

Message 的 swap 函数

标准库中定义了 string和set的swap版本(参见9.2.5节，第303页)。因此， 如果为我们的Message类定义它自己的swap版本，它将从中受益。通过定义一个 Message特定版本的swap，我们可以避免对contents和folders成员进行不必要的拷贝。

但是，我们的swap函数必须管理指向被交换Message的Folder指针。在调用 swap (ml,m2)之后，原来指向ml的Folder现在必须指向m2，反之亦然。

我们通过两遍扫描folders中每个成员来正确处理Folder指针。第一遍扫描将 Message从它们所在的Folder中删除。接下来我们调用swap来交換数据成员。最后

对folders进行第二遍扫描来添加交换过的Message：

| 524〉    void swap (Message &lhs, Message &rhs)

{

using std: : swap; //在本例中严格来说并不需要，但这是一个好习惯 //将每个消息的指针从它(原来)所在Folder中删除 for (auto f: lhs.folders)

f->remMsg(&lhs); for (auto f: rhs.folders)

f->remMsg(&rhs);

// 交换 contents 和 Folder 指针 set

swap (lhs . folders, rhs . folders) ;    // 使用 swap(set&, sets)

swap(lhs.contents, rhs.contents);    // swap(strings, strings)

//将每个Message的指针添加到它的(新)Folder中

for (auto f: lhs.folders) f->addMsg(&lhs);

for (auto f: rhs-folders) f->addMsg(&rhs);

###### 13.4节练习

练习13.33:为什么Message的成员save和remove的参数是一个Folders?为什 么我们不将参数定义为Folder或是const Folders?

练习13.34：编写本节所描述的Message。

练习13.35:如果Message使用合成的拷贝控制成员，将会发生什么？

练习13.36：设计并实现对应的Folder类。此类应该保存一个指向Folder中包含的 Message 的 set。

练习13.37:为Message类添加成员，实现向folders添加或删除一个给定的 Folder* o这两个成员类似Folder类的addMsg和remMsg操作。

练习13.38：我们并未使用拷贝和交换方式来设计Message的赋值运算符。你认为其 原因是什么？

##### 驗13.5动态内存管理类

某些类需要在运行时分配可变大小的内存空间。这种类通常可以（并且如果它们确实 可以的话，一般应该）使用标准库容器来保存它们的数据。例如，我们的StrBlob类使 用一个vector来管理其元素的底层内存。

但是，这一策略并不是对每个类都适用；某些类需要自己进行内存分配。这些类一般 来说必须定义自己的拷贝控制成员来管理所分配的内存。

□?5> 例如，我们将实现标准库vector类的一个简化版本。我们所做的一个简化是不使用 模板，我们的类只用于string。因此，它被命名为StrVec。

StrVec类的设计

回忆一下，vector类将其元素保存在连续内存中。为了获得可接受的性能，vector

预先分配足够的内存来保存可能需要的更多元素(参见9.4节，第317页)。vector的每 个添加元素的成员函数会检查是否有空间容纳更多的元素。如果有，成员函数会在下一个 可用位置构造一个对象。如果没有可用空间，vector就会重新分配空间：它获得新的空 间，将已有元素移动到新空间中，释放旧空间，并添加新元素。

我们在StrVec类中使用类似的策略。我们将使用一个allocator来获得原始内存 (参见12.2.2节，第427页)。由于allocator分配的内存是未构造的，我们将在需要添 加新元素时用allocator的construct成员在原始内存中创建对象。类似的，当我们 需要删除一个元素时，我们将使用destroy成员来销毁元素。

每个StrVec有三个指针成员指向其元素所使用的内存：

•    elements,指向分配的内存中的首元素

•    first_free，指向最后一个实际元素之后的位置

•    cap, g向分配的内存末尾之后的位置 图13.2说明了这些指针的含义。

| 0    | 1    | 2    | 3    | 4    | 未构造的元素 |
| ---- | ---- | ---- | ---- | ---- | ------------ |
|      |      |      |      |      |              |

1    !    I

elements    first一free    cap

图13.2： StrVec内存分配策略

除了这些指针之外，StrVec还有一个名为alloc的静态成员，其类型为 allocator<string>o alloc成员会分配StrVec使用的内存。我们的类还有4个工 具函数：

•    alloc_n_copy会分配内存，并拷贝一个给定范围中的元素。

•    free会&毁构造的元素并释放内存。

•    chk_n_alloc保证StrVec至少有容纳一个新元素的空间。如果没有空间添加新 元素，chk_n_alloc会调用reallocate来分配更多内存。

•    reallocate在内存用完时为StrVec分配新内存。

虽然我们关注的是类的实现，但我们也将定义vector接口中的一些成员。

<5263



StrVec类定义

有了上述实现概要，我们现在可以定义StrVec类，如下所示：

//类vector类内存分配策略的简化实现 class StrVec { public:

StrVec () : // allocator成员进行默认初始化

elements(nullptr), first_free(nullptr), cap(nullptr) { }

StrVec (const StrVecS) ;    // 拷贝构造函数

StrVec &operator= (const StrVecS) ;    // 拷贝賦值运算符

-StrVec () ;    //析构函数

void push_back (const std: : strings) ;    // 拷贝元素

size_t size () const { return first_free - elements; } size_t capacity() const { return cap - elements; } std::string *begin() const { return elements; } std::string *end() const { return first free; }

private:

Static std: :allocator<std: :string> alloc; // 分西己元素 //被添加元素的函数所使用 void chk_n_alloc()

{ if (size () == capacity()) reallocate(); }

//工具函数，被拷贝构造函数、赋值运算符和析构函数所使用



std::pair<std::string*, (const std::string*

void free(); void reallocate (); std::string *elements; std::string *first_free; std::string *cap;

}；

类体定义了多个成员：



std::string*〉 alloc_n_copy const std::string*）;

//销毁元素并释放内存 //获得更多内存并拷贝已有元素 //指向数组首元素的指针 //指向教组第一个空闲元素的指针 //指向数组尾后位置的指针



•默认构造函数（隐式地）默认初始化alloc并（显式地）将指针初始化为nullptr, 表明没有元素。

•    size成员返回当前真正在使用的元素的数目，等于first_free-elements。

•    capacity成员返回StrVec可以保存的元素的数量，等价于cap-elements。

•当没有空间容纳新兀素，即cap==f irst_f ree时，chk_n_alloc会为StrVec 重新分配内存。

•    begin和end成员分别返回指向首元素（即elements）和最后一个构造的元素 之后位置（即first_free）的指针。

使用 construct

函数push_back调用chk_n_alloc确保有空间容纳新元素。如果需要，

I 527〉chk_n_alloc 会调用 reallocate。当 chk_n_alloc 返回时，push_back 知道必有

空间容纳新元素。它要求其allocator成员来construct新的尾元素：

void StrVec::push_back（const strings s）

{

chk_n_alloc （） ; //确保有空间容纳新元素 //在first_free指向的元素中构造s的副本 alloc.construct（first_free++, s）;

}

当我们用allocator分配内存时，必须记住内存是未构造的（参见12.2.2节，第428页）。 为了使用此原始内存，我们必须调用construct,在此内存中构造一个对象。传递给 construct的第一个参数必须是一个指针，指向调用allocate所分配的未构造的内存 空间。剩余参数确定用哪个构造函数来构造对象。在本例中，只有一个额外参数，类型为 string,因此会使用string的拷贝构造函数。

值得注意的是，对construct的调用也会递增first_free，表示已经构造了一个 新元素。它使用前置递增（参见4.5节，第131页），因此£个调用会在first_free当 前值指定的地址构造一个对象，并递增first free指向下一个未构造的元素。

alloc_n_copy 成员

我们在拷贝或赋值StrVec时，可能会调用alloc_n_copy成员。类似vector,

我们的StrVec类有类值的行为(参见13.2.1节，第453页)。当我们拷贝或赋值StrVec 时，必须分配独立的内存，并从原StrVec对象拷贝元素至新对象。

alloc_n_copy成员会分配足够的内存来保存给定范围的元素，并将这些元素拷贝 到新分配的;;中。此函数返回一个指针的pair (参见11.2.3节，第379页)，两个指针 分别指向新空间的开始位置和拷贝的尾后的位置：

pair<string*, string*〉

StrVec::alloc_n_copy(const string *b, const string *e)

{

//分配空间保存给定范围中的元素

auto data = alloc.allocate(e - b);

//初始化并返回一个pair，该pair由data和uninitialized_copy的返回值构成 return {data, uninitialized_copy(b, e, data)};

}

alloc_n_copy用尾后指针减去首元素指针：来计算需要多少空间。在分配内存之后，

它必须三而空间中构造给定元素的副本。

它是在返回语句中完成拷贝工作的，返回语句中对返回值进行了列表初始化(参见 6.3.2节，第203页)。返回的pair的first成员指向分配的内存的开始位置；second 成员则是uninitialized_copy (参见12.2.2节，第429页)的返回值，此值是一个指< 528 | 针，指向最后一个构造元素后的位置。

free成员

free成员有两个责任：首先destroy元素，然后释放StrVec自己分配的内存空 伺。for循环调用allocator的destroy成员，从构造的尾元素开始，到首元素为止，

逆序销毁所有元素：

void StrVec::free()    '

{

//不能传递给deallocate—个空指针，如果elements为0,函数什么也不做 if (elements) {

//逆序销毁旧元素

for (auto p = first_free; p != elements; /* 空 */) alloc.destroy(——p);

alloc.deallocate(elements, cap - elements);

}

}

destroy函数会运行string的析构函数。string的析构函数会释放string自己分 配的内存空间。

一旦元素被销毁，我们就调用deallocate来释放本StrVec对象分配的内存空间。

我们传递给deallocate的指针必须是之前某次allocate调用所返回的指针。因此，

在调用deallocate之前我们首先检查elements是否为空。

拷贝控制成员

实现了 allOC_n_COpy和free成员后，为我们的类实现拷贝控制成员就很简单了。

拷贝构造函数调用alloc_n_copy：

StrVec::StrVec(const StrVec &s)

{

//调用alloc_n_copy分配空间以容纳与s中一^羊多的元素 auto newdata = alloc_n_copy(s.begin(), s.end()); elements = newdata.first;

first_free = cap = newdata.second;

}

并将返回结果赋予数据成员。alloc_n_copy的返回值是一个指针的pair。其first 成员指向第一个构造的元素，second 员指向最后一个构造的元素之后的位置。由于 alloc_n_copy分配的空间恰好容纳给定的元素，cap也指向最后一个构造的元素之后 的位置。

析构函数调用free：

StrVec::〜StrVec()    { free();    }

拷贝赋值运算符在释放己有元素之前调用alloc_n_copy,这样就可以正确处理自赋值 了：

I 529〉    StrVec SStrVec::operator=(const StrVec &rhs)

{

//调用alloc_n_copy分配内存，大小与rhs中元素占用空间一样多 auto data = alloc_n_copy(rhs.begin() , rhs.end()); free ();

elements = data.first; first_free = cap = data.second; return *this;

}

类似拷贝构造函数，拷贝赋值运算符使用allOc_n_copy的返回值来初始化它的指针。

卷在重新分配内存的过程中移动而不是拷贝元素

在编写reallocate成员函数之前，我们稍微思考一下此函数应该做什么。它应该

•为一个新的、更大的string数组分配内存

•在内存空间的前一部分构造对象，保存现有元素

•销毁原内存空间中的元素，并释放这块内存

观察这个操作步骤，我们可以看出，为一个StrVec重新分配内存空间会引起从旧内 存空间到新内存空间逐个拷贝string。虽然我们不知道string的实现细节，但我们知 道string具有类值行为。当拷贝一个string时，新string和原string是相互独 立的。改变原string不会影响到副本，反之亦然。

由于string的行为类似值，我们可以得出结论，每个string对构成它的所有字符 都会保存自己的一份副本。拷贝一个string必须为这些字符分配内存空间，而销毁一个 string必须释放所占用的内存。

拷贝一个string就必须真的拷贝数据，因为通常情况下，在我们拷贝了一个string 之后，它就会有两个用户。但是，如果是reallocate拷贝StrVec中的string,则 在拷贝之后，每个string只有唯一的用户。一旦将元素从旧空间拷贝到了新空间，我们 就会立即销毁原string.

因此，拷贝这些string中的数据是多余的。在重新分配内存空间吋，如果我们能避 免分配和释放string的额外开销，StrVec的性能会好得多。

移动构造函数和std::move

通过使用新标准库引入的两种机制，我们就可以避免string的拷贝。首先，有一些岡 标准库类，包括string,都定义了所谓的“移动构造函数”。关于string的移动构造 函数如何工作的细节，以及有关实现的任何其他细节，目前都尚未公开。但是，我们知道，＜530] 移动构造函数通常是将资源从给定对象"移动"而不是拷贝到正在创建的对象。而且我们 知道标准库保证“移后源”(moved-from) string仍然保持一个有效的、可析构的状态。

对于string,我们可以想象每个string都有一个指向char数组的指针。可以假定 string的移动构造函数进行了指针的拷贝，而不是为字符分配内存空间然后拷贝字符。

我们使用的第二个机制是一个名为move的标准库函数，它定义在utility头文件 中。目前，关于move我们需要了解两个关键点。首先，当reallocate在新内存中构 造string时，它必须调用move来表示希望使用string的移动构造函数，原因我们将 在13.6.1节(第470页)中解释。如果它漏掉了 move调用，将会使用string的拷贝构 造函数。其次，我们通常不为move提供一个using声明(参见3.1节，第74页)，原因 将在18.2.3节(第706页)中解释。当我们使用move时，直接调用std: :move而不是 move0

reallocate 成员

了解了这些知识，现在就可以编写reallocate成员了。首先调用allocate分配 新内存空间。我们每次重新分配内存时都会将StrVec的容量加倍。如果StrVec为空，

我们将分配容纳一个元素的空间：

void StrVec::reallocate()

{

//我们将分配当前大小两倍的内存空间

auto newcapacity = size () ? 2 * size ()    : 1;

//分配新内存

auto newdata = alloc.allocate(newcapacity);    •

//将数据从旧内存移动到新内存

auto dest = newdata;    //指向新数组中下一个空闲位置

auto elem = elements; //指向旧数组中下一个元素 for (size_t i = 0; i != size(); ++i)

alloc.construct(dest++, std::move(*elem++)); free () ; // 一旦我们移动完元素就释放旧内存空间 //更新我们的数据结构，执行新元素

elements = newdata;

first一free = dest;

cap = elements + newcapacity;

}

for循环遍历每个己有元素，并在新内存空间中construct 一个对应元素。我们使用 dest指向构造新string的内存，使用elem指向原数组中的元素。我们每次用后置递 增运算将dest (和elem)推进到各自数组中的下一个元素。

construct的第二个参数(即，确定使用哪个构造函数的参数(参见12.2.2节，第 428页))是move返回的值。调用move返回的结果会令construct使用string的移

动构造函数。由于我们使用了移动构造函数，这些string管理的内存将不会被拷贝。相 反，我们构造的每个string都会从elem指向的string那里接管内存的所有权。

r^T>    在元素移动完毕后，我们调用free销毁旧元素并释放StrVec原来使用的内存。

string成员不再管理它们曾经指向的内存；其数据的管理职责已经转移给新StrVec内 存中的元素了。我们不知道旧StrVec内存中的string包含什么值，但我们保证对它们 执行string的析构函数是安全的。

剩下的就是更新指针，指向新分配并已初始化过的数组了。first_free和cap指 针分别被设置为指向最后一个构造的元素之后的位置及指向新分配空间&尾后位置。

###### 13.5节练习

练习13.39:编写你自己版本的StrVec，包括自己版本的reserve、capacity （参 见9.4节，第318页）和resize （参见9.3.5节，第314页）。

练习13.40:为你的StrVec类添加一个构造函数，它接受一个initializer_list <string> 参数。

练习13.41:在push_back中，我们为什么在construct调用中使用前置递增运算？ 如果使用后置递増运i的话，会发生什么？

练习13.42:在你的TextQuery和QueryResult类（参见12.3节，第431页）中用 你的StrVec类代替vector<string>,以此來测试你的StrVec类。

练习13.43：重写free成员，用for_each和lambda （参见10.3.2节，第346页）来 代替for循环destroy元素。你更｛i向于哪种实现，为什么？

练习13.44:编写标准库string类的简化版本，命名为String。你的类应该至少有 一个默认构造函数和一个接受C风格字符串指针参数的构造函数。使用allocator为 你的String类分配所需内存。

##### 驗13.6对象移动

新标准的一个最主要的特性是可以移动而非拷贝对象的能力。如我们在13.1.1节（第 440页）中所见，很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即 被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。

如我们已经看到的，我们的StrVec类是这种不必要的拷贝的一个很好的例子。在重 新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。 使用移动而不是拷贝的另一个原因源于IO类或Unique_ptr这样的类。这些类都包含不 能被共享的资源（如指针或IO缓冲）。因此，这些类型€对象不能拷贝但可以移动。

□?2>    在旧C杆标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我

们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间（如string）,进 行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可 拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。

1    标准库容器、string和shared_ptr类既支持移动也支持拷贝（，IO类和

i unj_qUe_ptr类可以移动但不能拷贝'。'/'■

![img](C++  Primer 5-117.jpg)



###### 13.6.1右值引用

为了支持移动操作I新标准引入了一种新的引用类型-右值引用（rvaluereference）。

所谓右值引用就是必须绑定到右值的引用。我们通过&&而不是&来获得右值引用。如我们rc^q 将要看到的，右值引用有一个重要的性质一只能绑定到一个将要销毁的对象。因此，我 们可以自由地将一个右值引用的资源“移动”到另一个对象中。

回忆一下，左值和右值是表达式的属性（参见4.1.1节，第121页）。一些表达式生成 或要求左值，而另外一些则生成或要求右值。一般而言，一个左值表达式表示的是一个对 象的身份，而一个右值表达式表示的是对象的值。

类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。如我们所知，对 于常规引用（为了与右值引用区分开来，我们可以称之为左值引用（lvalue reference））,

我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式（参见2.3.1节，

第46页）。右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达 式上，但不能将一个右值引用直接绑定到一个左值上：

| int           | i = 42;   |       |      |      |
| ------------- | --------- | ----- | ---- | ---- |
| int           | &r = i;   |       | //   | 正确 |
| int           | &&rr = i; |       | //   | 错误 |
| int           | &r2 = i * | 42;   | //   | 错误 |
| const int &r3 | =i * 42;  | //    | 正确 |      |
| int           | &&rr2 = i | ★ 42; | //   | 正确 |



r引用i

不能将一个右值引用绑定到一个左值上 i*42是一个右值

我们可以将一个const的引用绑定到一个右值上 将rr2绑定到乘法结果上



返回左值引用的函数，连同赋值、下标、解引用和前置递増/递减运算符，都是返回左 值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。

返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。 我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个const的左值引用或 者一个右值引用绑定到这类表达式上。

左值持久；右值短暂    <M1

考察左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，

而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

由于右值引用只能绑定到临时对象，我们得知

•所引用的对象将要被销毁 •该对象没有其他用户

这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。

![img](C++  Primer 5-118.jpg)



右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象“窃 取”状态

变量是左值

变量可以看作只有一个运算对象而没有运算符的表达式，虽然我们很少这样看待变

量。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。带来的 结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上，这有些令人惊讶：

int iSrrl = 42;    //正确：字面常量是右值

int &&rr2 = rrl; //错误：表达式rrl是左值！

其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，变 量是持久的，直至离开作用域时才被销毁。

![img](C++  Primer 5-119.jpg)



变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个 变量是右值幻用类型也不行。：

标准库move函数

虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换 fcTH 为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定 到左值上的右值引用，此函数定义在头文件utility中。move函数使用了我们将在16.2.6

节(第610页)中描述的机制来返回给定对象的右值引用。 int S&rr3 = std::move(rrl); // ok

move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须 认识到，调用move就意味着承诺：除了对rrl赋值或销毁它外，我们将不再使用它。在 调用move之后，我们不能对移后源对象的值做任何假设。

我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对 象的值' …

如前所述，与大多数标准库名字的使用不同，对move (参见13.5节，第469页)我们不 提供using声明(参见3.1节，第74页)。我们直接调用std: move而不是move,其 原因将在18.2.3节(第707页)中解释。

WARNING



使用move的代码应该使用std: :move而不是move。这样做可以避免潜在 的名字冲突。

###### 13.6.1节练习

练习13.45：解释右值引用和左值引用的区别。

练习13.46：什么类型的引用可以绑定到下面的初始化器上？ int f ();

vector<int> vi(100);

int? rl = f();

int? r2 = vi[0];

int? r3 = rl;

int? r4 = vi[0] * f();

练习13.47：对你在练习13.44 (13.5节，第470页)中定义的String类，为它的拷 贝构造函数和拷贝赋值运算符添加一条语句，在每次函数执行时打印一条信息。

练习13.48:定义一■个vector＜String＞并在其上多次调用push_back。运行你的程 序，并观察String被拷贝了多少次。

###### 13.6.2移动构造函数和移动赋值运算符

类似string类(及其他标准库类)，如果我们自己的类也同时支持移动和拷贝，那 么也能从中受益。为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移 动赋值运算符。这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是 拷贝资源。

类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝 构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，

任何额外的参数都必须有默认实参。

除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态一销毁 它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资 源的所有权已经归属新创建的对象。

作为一个例子，我们为StrVec类定义移动构造函数，实现从一个StrVec到另一个＜M] StrVec的元素移动而非拷贝：

StrVec: :StrVec (StrVec &&s) noexcept //移动操作不应抛出任何异常 //成员初始化器接管s中的资源

:elements(s.elements), first_free(s.first_free), cap(s.cap)

{

//令s进入这样的状态——对其运行析构函数是安全的 s.elements = s.first_f ree = s.cap = nullptr;

}

我们将简短解释noexcept (它通知标准库我们的构造函数不抛出任何异常)，但让我们 先分析一下此构造函数完成什么工作。

与拷贝构造函数不同，移动构造函数不分配任何新内存；它接管给定的StrVec中的 内存。在接管内存之后，它将给定对象中的指针都置为nullptro这样就完成了从给定 对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行 析构函数。StrVec的析构函数在first_free上调用deallocate。如果我们忘记了 改变s.firSt_free,则销毁移后源对象就会释放掉我们刚刚移动的内存。

移动操作、标准库容器和异常

由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出 任何异常。当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库。我们将看 至IJ,除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象 时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。

一■种通知标准库的方法是在我们的构造函数中指明noexcept。noexcept是新标准 引入的，我们将在18.1.4节(第690页)中讨论更多细节。目前重要的是要知道，noexcept (^] 是我们承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表后指定 noexcept。在一个构造函数中，noexcept出现在参数列表和初始化列表开始的冒号之 间：

class StrVec {

public:

StrVec (StrVec&&) noexcept; // 移动构造函数 //其他成员的定义，如前

}；

StrVec: : StrVec (StrVec &&s) noexcept : /* 成员初始化器 */

{ /*构造函数体★/ }

我们必须在类头文件的声明中和定义中(如果定义在类外的话)都指定noexcept。

不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。

C§36>    搞清楚为什么需要noexcept能帮助我们深入理解标准库是如何与我们自定义的类

型交互的。我们需要指出一个移动操作不抛出异常，这是因为两个相互关联的事实：首先， 虽然移动操作通常不抛出异常，但抛出异常也是允许的；其次，标准库容器能对异常发生 时其自身的行为提供保障。例如，vector保证，如果我们调用pUSh_baCk时发生异常， vector自身不会发生改变。

现在让我们思考puSh_back内部发生了什么。类似对应的StrVec操作(参见13.5 节，第466页)，对一个vector调用push_back可能要求为vector重新分配内存空 间。当重新分配vector的内存时，vector将元素从旧空间移动到新内存中，就像我们 在reallocate中所做的那样(参见13.5节，第469页)。

如我们刚刚看到的那样，移动一个对象通常会改变它的值。如果重新分配过程使用了 移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题。旧空 间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。在此情况下， vector将不能满足自身保持不变的要求。

另一方面，如果vector使用了拷贝构造函数且发生了异常，它可以很容易地满足要 求。在此情况下，当在新内存中构造元素吋，旧元素保持不变。如果此时发生了异常， vector可以释放新分配的(但还未成功构造的)内存并返回。vector原有的元素仍然 存在。

为了避免这种潜在问题，除非vector知道元素类型的移动构造函数不会抛出异常， 否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。如果希 望在vector重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就 必须显式地告诉标准库我们的移动构造函数可以安全使用。我们通过将移动构造函数(及 移动赋值运算符)标记为noexcept来做到送一点。

移动赋值运算符

移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样， 如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcept。类似拷 贝赋值运算符，移动赋值运算符必须正确处理自赋值：

StrVec &StrVec::operator:(StrVec &&rhs) noexcept

{

//直接检测自賦值 if (this != &rhs) {

free () ;    //释放已有元素

elements = rhs . elements; // 从 rhs 接管资源 first free = rhs.first free;

cap = rhs.cap;

//将rhs置于可析构状态

rhs.elements = rhs.first_free = rhs.cap = nullptr;

}

return *this;

}

在此例中，我们直接检查this指针与rhs的地址是否相同。如果相同，右侧和左侧运算＜5373 对象指向相同的对象，我们不需要做任何事情。否则，我们释放左侧运算对象所使用的内 存，并接管给定对象的内存。与移动构造函数一样，我们将rhs中的指针置为nullptr。

我们费心地去检查自赋值情况看起来有些奇怪。毕竟，移动赋值运算符需要右侧运算 对象的一个右值。我们进行检查的原因是此右值可能是move调用的返回结果。与其他任 何赋值运算符一样，关键点是我们不能在使用右侧运算对象的资源之前就释放左侧运算对 象的资源（可能是相同的资源）。

移后源对象必须可析构

从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。

因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。我们的 StrVec的移动操作满足这一要求，这是通过将移后源对象的指针成员置为nullptr来 实现的。

除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效 的。一般来说，对象有效就是指可以安全地为其赋予新值或者可以安全地使用而不依赖其 当前值。另一方面，移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序 不应该依赖于移后源对象中的数据。

例如，当我们从一个标准库string或容器对象移动数据时，我们知道移后源对象仍 然保持有效。因此，我们可以对它执行诸如empty或size这些操作。但是，我们不知 道将会得到什么结果。我们可能期望一个移后源对象是空的，但这并没有保证。

我们的StrVec类的移动操作将移后源对象置于与默汄初始化的对象相同的状态。因 此，我们可以继续对移后源对象执行所有的StrVec操作，与任何其他默认初始化的对象 一样。而其他内部结构更为复杂的类，可能表现出完全不同的行为。

WARNING



在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能 对其值进行任何假设,



合成的移动操作

与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋 值运算符。但是，合成移动操作的条件与合成拷贝操作的条件大不相同。

回忆一下，如果我们不声明自己的拷贝构造函数或拷贝赋值运算符，编译器总会为我 们合成这些操作（参见13.1.1节，第440页和13.1.2节，第444页）。拷贝操作要么被定 义为逐成员拷贝，要么被定义为对象赋值，要么被定义为删除的函数。

与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义＜538] 了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造 函数和移动赋值运算符了。因此，某些类就没有移动构造函数或移动赋值运算符。如我们 将在第477页所见，如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷

贝操作来代替移动操作。

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成 员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动 内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这 个成员：

//编译器会为X和hasX合成移动操作 struct X {

int i;    //内置类型可以移动

std:-.string s;    // string定义了自己的移动操作

Instruct hasX {

X mem; // X有合成的移动操作

}；

X x, x2 = std: :move (x) ;    //使用合成的移动构造函数

hasX hx, hx2 = std: :move (hx) ;    //使用合成的移动构造函数

B只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都 能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运 算符„

与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式地 要求编译器生成=0^£31；1七的(参见7.1+4节，第237页)移动操作，且编译器不能移动 所有成员，则编译器会将移动操作定义为删除的函数。除了 -个重要例外，什么时候将合 成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则(参见13.1+6 节，第449页)：

•与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义 了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝 构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。

•如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的， 则类的移动构造函数或移动赋值运算符被定义为删除的。

•类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访W的，则类的移动 构造函数被定义为删除的。

•类似拷贝赋值运算符，如果有类成员是const的或是引用，则类的移动赋值运算 符被定义为删除的。

El39＞例如，假定Y是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数：

II假定Y是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数 struct hasY {

hasY () = default; hasY(hasY&&) = default;

Y mem; // hasY将有一个删除的移动构造函数

}；

hasY hy, hy2 = std: :move (hy) ; //错误：移动构造函数是删除的

编译器可以拷贝类型为Y的对象，但不能移动它们。类hasY显式地要求一个移动构造函 数，但编译器无法为其生成。因此，hasY会有一个删除的移动构造函数。如果hasY忽 略了移动构造函数的声明，则编译器根本不能为它合成一个。如果移动操作可能被定义为

删除的函数，编译器就不会合成它们。

移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自 己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动 赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。

![img](C++  Primer 5-122.jpg)



定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作、 否则，这些成员默认地被定义为删除的

移动右值，拷贝左值

如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则 来确定使用哪个构造函数(参见6.4节，第208页)。赋值操作的情况类似。例如，在我们 的StrVec类中，拷贝构造函数接受一个const StrVec的引用。因此，它可以用于任 何可以转换为StrVec的类型。而移动构造函数接受一个StrVec&&,因此只能用于实参 是(非static)右值的情形：

StrVec vl, v2;

vl = v2;

StrVec getVec(istream &); v2 = getVec(cin);



// v2是左值；使用拷贝賦值

// getVec返回一个右值

// getVec (cin)是一个右值；使用移动轼值

在第一个赋值中，我们将v2传递给赋值运算符。v2的类型是StrVec,表达式v2是一 个左值。因此移动版本的赋值运算符是不可行的(参见6.6节，第217页)，因为我们不能 隐式地将一个右值引用绑定到一个左值。因此，这个赋值语句使用拷贝赋值运算符。

在第二个赋值中，我们赋予v2的是getVec调用的结果。此表达式是一个右值。在 此情况下，两个赋值运算符都是可行的——将getVec的结果绑定到两个运算符的参数都 是允许的。调用拷贝赋值运算符需要进行一次到const的转换，而StrVec&S则是精确 匹配。因此，第二个赋值会使用移动赋值运算符。

<54CT|



……但如果没有移动构造函数，右值也被拷贝

如果一个类有一个拷贝构造函数但未定义移动构造函数，会发生什么呢？在此情况 下，编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数但不会有移动构造函 数。如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们 试图通过调用move来移动它们时也是如此：

class Foo { public:

Foo() = default;

Foo (const Foo&) ; //拷贝构造函数 //其他成员定义，但Foo未定义移动构造函数

}；

Foo X;

Foo y (x) ;    //拷贝构造函数；x是一个左值

Foo z (std: :move (x) ) ; //拷贝构造函数，因为未定义移动构造函数

在对z进行初始化时，我们调用了 move (x),它返回一个绑定到x的Foo&&。Foo的拷 贝构造函数是可行的，因为我们可以将一个Foo&&转换为一个const Foo&。因此，z的 初始化将使用Foo的拷贝构造函数。

值得注意的是，用拷贝构造函数代替移动构造函数几乎肯定是安全的(赋值运算符的

情况类似)。一般情况下，拷贝构造函数满足对应的移动构造函数的要求：它会拷贝给定 对象，并将原对象置于有效状态。实际上，拷贝构造函数甚至都不会改变原对象的值。

![img](C++  Primer 5-123.jpg)



如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过 拷贝构造函数来“移动”的。:拷贝赋值运算符和移动赋值运算符的情况类似

拷贝并交换赋值运算符和移动操作

我们的HasPtr版本定义了一个拷贝并交换赋值运算符(参见13.3节，第459页)， 它是函数匹配和移动操作间相互关系的一个很好的示例。如果我们为此类添加一个移动构 造函数，它实际上也会获得一个移动赋值运算符：

class HasPtr { public:

//添加的移动构造函数

HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;}

//賦值运算符既是移动賦值运算符，也是拷贝赋值运算符 HasPtrS operator=(HasPtr rhs)

{ swap(*this, rhs); return *this; }

//其他成员的定义，同13.2.1节(第453页)

}；

在这个版本中，我们为类添加了一个移动构造函数，它接管了给定实参的值，构造函数体 r54?＞将给定的HasPtr的指针置为0,从而确保销毁移后源对象是安全的。此函数不会抛出异

常，因此我们将其标记为noexcept (参见13.6.2节，第473页)-

现在让我们观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷 贝初始化(参见13.1.1节，第441页)。依赖于实参的类型，拷贝初始化要么使用拷贝构 造函数，要么使用移动构造函数一左值被拷贝，右值被移动。因此，单一的赋值运算符 就实现了拷贝赋值运算符和移动赋值运算符两种功能。

例如，假定hp和hp2都是HasPtr对象：

hp = hp2; // hp2是一个左值；hp2通过拷贝构造函数来拷贝 hp = std: :move (hp2) ; //移动构造函数移动hp2

在第一个赋值中，右侧运算对象是一个左值，因此移动构造函数是不可行的。rhs将使用 拷贝构造函数来初始化=拷贝构造函数将分配一个新string,并拷贝hP2指向的 string。

在第二个赋值中，我们调用std：： move将一个右值引用绑定到hp2上。在此情况 下，拷贝构造函数和移动构造函数都是可行的。但是，由于实参是一个右值引用，移动构 造函数是精确匹配的。移动构造函数从hp2拷贝指针，而不会分配任何内存。

不管使用的是拷贝构造函数还是移动构造函数，赋值运算符的函数体都swap两个运 算对象的状态。交换HasPtr会交换两个对象的指针(及int)成员。在swap之后，rhs 中的指针将指向原来左侧运算对象所拥有的string。当rhs离开其作用域时，这个 string将被销毁。

建议：更新三/五法则

所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个

拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷 贝赋值运算符和析构函数才能正确工作（参见13.1.4节，第447页）。这些类通常拥有 一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。 在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免 此问题9

Message类的移动操作

定义了自己的拷贝构造函数和拷贝赋值运算符的类通常也会从移动操作受益。例如，

我们的Message和Folder类（参见13.4节，第460页）就应该定义移动操作。通过定 义移动操作，Message类可以使用string和set的移动操作来避免拷贝contents和 folders成员的额外开销。

但是，除了移动folders成员，我们还必须更新每个指向原Message的Folder。

我们必须删除指向旧Message的指针，并添加一个指向新Message的指针。

移动构造函数和移动赋值运算符都需要更新Folder指针，因此我们首先定义一个操＜M2Zi 作来完成这一共同的工作：

//从本Message移动Folder指针

void Message::move_Folders(Message *m)

{

folders = std: :move (m->folders) ; // 使用 set 的移动賦值运算符 for (auto f : folders) { // 对每个 Folder

f->remMsg (m) ;    // 从 Folder 中删除旧 Message

f->addMsg (this) ;    // 将衣 Message 添加到 Folder 中

}

m-〉folders.clear();



//确保销毀m是无害的



此函数首先移动folders集合。通过调用move,我们使用了 set的移动赋值运算符而 不是它的拷贝赋值运算符。如果我们忽略了 move调用，代码仍能正常工作，但带来了不 必要的拷贝。函数然后遍历所有Folder,从其中删除指向原Message的指针并添加指 向新Message的指针。

值得注意的是，向set插入一个元素可能会抛出一个异常一向容器添加元素的操作 要求分配内存，意味着可能会抛出一个bad_alloc异常（参见12.1.2节，第409页）。 因此，与我们的HasPtr和StrVec类的移动操作不同，Message的移动构造函数和移 动赋值运算符可能会抛出异常。因此我们未将它们标记为noexcept （参见13.6.2节，第 473 页）。

函数最后对m. folders调用clear。在执行了 move之后，我们知道m. folders 是有效的，但不知道它包含什么内容。由于Message的析构函数遍历folders，我们希 望能确定set是空的。

Message的移动构造函数调用move来移动contents，并默认初始化自己的 folders 成员：

Message::Message(Message &&m): contents(std::move(m.contents))

move Folders (&m) ; // 移动 folders 并更新 Folder 指针

在构造函数体中，我们调用了 move_Folders来删除指向m的指针并插入指向本 Message的指针-

移动赋值运算符直接检查自赋值情况：

Messages Message::operator:(Message &&rhs)

{

if (this != &rhs) {    //直接检查自赋值情况

remove_f rom_Folders ();

contents = std: :move (rhs . contents) ; // 移动绒值运算符 move_Folders (&rhs) ;    // 重置 Folders 指向本 Message

}

return *this;

}

LM3＞与任何赋值运算符一样，移动赋值运算符必须销毁左侧运算对象的旧状态。在本例中，销 毁左侧运算对象要求我们从现有folders中删除指向本Message的指针，我们调用 remove_f rom_Folders来完成这一工作。完成删除工作后，我们调用move从rhs将 contents移动到this对象。剩下的就是调用move Messages来更新Folder指针 了。

移动迭代器

StrVec的reallocate成员(参见13.5节，第469页)使用了一个for循环来调 用construct从旧内存将元素拷贝到新内存中。作为一种替换方法，如果我们能调用 uninitialized_copy来构造新分配的内存，将比循环更为简单。但是， uninitialized_COpy恰如其名：它对元素进行拷贝操作。标准库中并没有类似的函数 将对象“移动”到未构造的内存中。

[Cy ]    新标准库中定义了一种移动迭代器(move iterator)适配器(参见10.4节，第358页)。

一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说， 一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的 解引用运算符生成一个右值引用。

我们通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个 移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。

原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭 代器操作，我们可以将一对移动迭代器传递给算法。特别是，可以将移动迭代器传递给 uninitialized_copy：

void StrVec::reallocate()

{

//分配大小两倍于当前规模的内存空间

auto newcapacity = size () ? 2 * size ()    : 1;

auto first = alloc.allocate(newcapacity);

//移动元素

auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);

free () ;    //释放旧空间

elements = first; // 更新指针 first free = last;

cap = elements + newcapacity;

}

uninitialized_copy对输入序列中的每个兀素调用construct来将兀素“拷贝”到 目的位置。此算法了吏用迭代器的解引用运算符从输入序列中提取元素。由于我们传递给它 的是移动迭代器，因此解引用运算符生成的是一个右值引用，这意味着construct将使 用移动构造函数来构造元素。

值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个 对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户 定义的函数后不再访问它时，才能将移动迭代器传递给算法。

建议：不要随意使用移动操作

由于一个移后源对象具有不确定的状态，对其调用std: :move是危险的当我们 调用move时，必须绝对确认移后源对象没有其他用户/

通过在类代码中小心地使用move,可以大幅度提升性能&而如果随意在普通用户 代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误， 而难以提升应用程序性能。

在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信 需要进行移动操作且移动操作是安全的，才可以使用std：： move.o\

###### 13.6.2节练习

练习13.49：为你的StrVec、String和Message类添加一个移动构造函数和一个移 动赋值运算符。

练习13.50:在你的String类的移动操作中添加打印语句，并重新运行13.6.1节（第 473页）的练习13.48中的程序，它使用了一个vector<String>,观察什么时候会避 免拷贝。

练习13.51：虽然unique_Ptr不能拷贝，但我们在12丄5节（第418页）中编写了~ 个clone函数，它以值方式返回一个unique_ptr»解释为什么函数是合法的，以及 为什么它能正确工作。

练习13.52:详细解释第478页中的HasPtr对象的赋值发生了什么？特别是，一步一 步描述hp、hP2以及HasPtr的赋值运算符中的参数rhs的值发生了什么变化。

练习13.53：从底层效率的角度看，HasPtr的赋值运算符并不理想，解释为什么。为 HasPtr实现一个拷贝赋值运算符和一个移动赋值运算符，并比较你的新的移动赋值运 算符中执行的操作和拷贝并交换版本中执行的操作。

练习13.54:如果我们为HasPtr定义了移动赋值运算符，但未改变拷贝并交换运算符, 会发生什么？编写代码验证你的答案。

###### 13.6.3右值引用和成员函数    婦

除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也 能从中受益。这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的<545] 参数模式-个版本接受一个指向const的左值引用，第二个版本接受一个指向非

const的右值引用。

例如，定义了 push_back的标准库容器提供两个版本：一个版本有一个右值引用参 数，而另一个版本有一个const左值引用。假定X是元素类型，那么这些容器就会定义 以下两个push_back版本：

void push_back(const X&) ;    //拷贝：鄉定到任意类型的X

void push_back (X&&) ;    //移动：只能禅定到类型X的可修改的右值

我们可以将能转换为类型X的任何对象传递给第一个版本的push_backo此版本从其参 数拷贝数据。对于第二个版本，我们只可以传递给它非const 右值。此版本对于非 const的右值是精确匹配(也是更好的匹配)的，因此当我们传递一个可修改的右值(参 见13.6.2节，第477页)时，编译器会选择运行这个版本。此版本会从其参数窃取数据。

一般来说，我们不需要为函数操作定义接受一个const X&&或是一个(普通的)X& 参数的版本。当我们希望从实参“窃取”数据时，通常传递一个右值引用。为了达到这一 目的，实参不能是const的。类似的，从一个对象进行拷贝的操作不应该改变该对象。 因此，通常不需要定义一个接受一个(普通的)X&参数的版本。

?    区分移动和拷贝的重载函数通常有一个版木接受一个const T&,而另一个版

本接受一个T&&:

作为一个更具体的例子，我们将为StrVec类定义另一个版本的push_back：

class StrVec { public:

void push_back (const std: : strings) ;    // 拷贝元素

void push_back (std: : string&&) ;    // 移动元素

//其他成员的定义，如前

}；

//与13.5节(第466页)中的原版本相同 void StrVec::push_back(const strings s)

{

chk_n_alloc () ; //确保有空间容纳新元素 //在first_free指向的元素中构造s的一个副本 alloc.construct(first_free++, s);

}

void StrVec::push_back(string &&s)

chk_n_alloc () ; //如果需要的话为StrVec重新分配内存 alloc.construct(first_free++, std::move(s));

}

这两个成员几乎是相同的。差别在于右值引用版本调用move来将其参数传递给 construct。如前所述，construct函数使用其第二个和随后的实参的类型来确定使用

I 546＞哪个构造函数。由于move返回一个右值引用，传递给construct的实参类型是 string&&o因此，会使用string的移动构造函数来构造新元素。

当我们调用push_back时，实参类型决定了新元素是拷贝还是移动到容器中：

StrVec vec; // 空 StrVec

string s = "some string or another*';

vec .push_back (s) ;    // 调用 push_back (const strings)

vec.push_back ("done") ;    // 调用 push_back (string&&)

这些调用的差别在于实参是一个左值还是一个右值(从"done"创建的临时string)，具 体调用哪个版本据此来决定。

右值和左值引用成员函数

通常，我们在一个对象上调用成员函数，而不管该对象是一个左值还是一个右值。例如：

string si = "a value", s2 = "another"; auto n = (si + s2) .find(f ar );

此例中，我们在一个string右值上调用find成员(参见9.5.3节，第325页)，该string 右值是通过连接两个string而得到的。有时，右值的使用方式可能令人惊讶：

sl + s2 = "wow!";

此处我们对两个string的连接结果--个右值，进行了赋值。

在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库类仍 然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。在此情况下，我们 希望强制左侧运算对象(即，this指向的对象)是一个左值。

我们指出this的左值/右值属性的方式与定义const成员函数相同(参见7.1.2节，jCy j 第231页)，即，在参数列表后放置一个引用限定符(reference qualifier):

class Foo {

public:

Foo &operator= (const Foo&) &; //只食皂向可修改的左值賦值 // Foo的其他参数

}；

Foo &Foo::operator=(const Foo &rhs) &

{

//执行将rhs賦予本对象所需的工作 return *this;

}

引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。类似const限定符, 引用限定符只能用于(非static)成员函数，且必须同时出现在函数的声明和定义中。

对于&限定的函数，我们只能将它用于左值；对于&&限定的函数，只能用于右值:

Foo SretFoo(); Foo retVal();



//返回一个引用；retFoo调用是一个左值 //返回一个值；retVal调用是一个右值



<547~1



Foo i, j; i = j；

retFoo() = j; retVal() = j; i = retVal();



// i和j是左值

//正确：i是左值

//正确：retFoo ()返回一个左值

//错误：retVal ()返回一个右值

//正确：我们可以将一个右值作为赋值操作的右侧运算对象



一个函数可以同时用const和引用限定。在此情况下，引用限定符必须跟随在const 限定符之后：



class Foo {

public:

Foo someMem() & const;

Foo anotherMem() const &; }；



//错误：const限定符必须在前 //正确：const限定符在前



重载和引用函数

就像一个成员函数可以根据是否有const来区分其重载版本一样(参见7.3.2节，第 247页)，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和const来 区分一个成员函数的重载版本。例如，我们将为Foo定义一个名为data的vector成 员和一"名为sorted的成员函数，sorted返0—个Foo对象的副本，其中vector 已被排序：

class Foo { public:

Foo sorted () &&;    //可用于可改变的右值

Foo sorted () const &;    //可用于任何类型的Foo

// Foo的其他成员的定义

private:

vector<int> data;

}；

//本对象为右值，因此可以原址排序

Foo Foo::sorted() &&

{

sort(data.begin(), data.end()); return *this;

}

//本对象是const或是一个左值，哪种情况我们都不能对其进行原址排序

Foo Foo::sorted() const & {

Foo ret (*this) ;    // 拷贝一个副本

sort (ret .data .begin () , ret.data .end () ) ;    // 排序副本

return ret;    //返回副本

I

当我们对一个右值执行sorted时，它可以安全地直接对data成员进行排序。对象是一 个右值，意味着没有其他用户，因此我们可以改变对象。当对一个const右值或一个左 值执行sorted时，我们不能改变对象，因此就需要在排序前拷贝data。

编译器会根据调用sorted的对象的左值/右值属性来确定使用哪个sorted版本：

| 548〉    retVal () . sorted () ; // retVal ()是一个右值，调用 Foo: : sorted () &&

retFoo () . sorted () ; // retFoo ()是一个左值，调用 Foo: : sorted () const &

当我们定义const成员函数时，可以定义两个版本，唯一的差别是一个版本有const 限定而另一个没有。引用限定的函数则不一样。如果我们定义两个或两个以上具有相同名 字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加：

class Foo {

public:

Foo sorted() &&;

Foo sorted () const; //错误：必须加上引用限定符 // Comp是函数类型的类型别名(参见6.7节，第222页)

//此函数类型可以用来比较int值

using Comp = bool(const int&, const int&);

Foo sorted (Comp*) ;    //正确：不同的参数列表

Foo sorted (Comp*) const;    //正确：两个版本都没有引用限定符

}；

本例中声明了一个没有参数的const版本的sorted,此声明是错误的。因为Foo类中 还有一个无参的sorted版本，它有一个引用限定符，因此const版本也必须有引用限 定符。另一方面，接受一个比较操作指针的sorted版本是没问题的，因为两个函数都没 有引用限定符。

e如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引 用限定符,，

###### 13.6.3节练习

练习13.55:为你的StrBlob添加一个右值引用版本的push_back。

练习13.56:如果sorted定义如下，会发生什么：

Foo Foo::sorted() const & {

Foo ret(*this); return ret.sorted();

}

练习13.57:如果sorted定义如下，会发生什么：

Foo Foo::sorted() const & { return Foo(*this) .sorted (); }

练习13.58:编写新版本的Foo类，其sorted函数中有打印语句，测试这个类，来验 证你对前两题的答案是否正确。

I 549〉 小结

每个类都会控制该类型对象拷贝、移动、赋值以及销毁时发生什么。特殊的成员函数一 拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符和析构函数定义了这些 操作。移动构造函数和移动赋值运算符接受一个(通常是非const的)右值引用；而拷 贝版本则接受一个(通常是const的)普通左值引用。

如果一个类未声明这些操作，编译器会自动为其生成。如果这些操作未定义成删除的， 它们会逐成员初始化、移动、赋值或销毁对象：合成的操作依次处理每个非static数据 成员，根据成员类型确定如何移动、拷贝、赋值或销毁它。

分配了内存或其他资源的类几乎总是需耍定义拷贝控制成员来管理分配的资源。如果 一•个类需要析构函数，则它几乎肯定也需要定义移动和拷贝构造函数及移动和拷贝赋值运 算符。

##### 术语表

拷贝并交换(copy and swap)涉及赋值

运算符的技术，首先拷贝右侧运算对象， 然后调用swap来交换副本和左侧运算对 象。

拷贝赋值运算符(copy-assignment operator)接受--个本类型对象的.赋值运 算符版本。通常，拷贝赋值运算符的参数 是一个const的引用，并返回指向本对象 的引用。如果类未敁式定义拷贝赋值运算 符，编译器会为它合成一个。

拷贝构造函数(copy constructor) •-种

构造函数，将新对象初始化为同类型另一 个对象的副本。当向函数传递对象，或以 传值方式从函数返回对象吋，会隐式使用 拷贝构造函数。如果我们未提供拷贝构造 函数，编译器会为我们合成一个。

拷贝控制(copy control)特殊的成员函

数，控制拷贝、移动、赋值及销毁本类类 型对象吋发生什么。如果类未定义这些操 作，编译器会为它合成恰当的定义。

拷贝初始化(copy initialization)、一种初

始化形式，3我们使用=为-个新创建的对 象提供初始化器吋，会使用拷贝初始化。 如果我们向函数传递对象或以传值方式从 函数返回对象，以及初始化一个数组或一 个聚合类时，也会使用拷贝初始化。

删除的函数(deleted function)不能使用

的函数。我们在一个函数的声明上指定 =delete来删除它。删除的函数的一个常 见用途是告诉编译器不要为类合成拷贝 和/或移动操作。

析构函数(destructor)特殊的成员函数，

当对象离开作用域或被释放时进行清理工 作。编译器会自动销毁每个数据成员。类 类型的成员通过调用其析构函数来销毁； 而内置类型或复合类型的成员的销毁则不 需要做任何工作。特别是，析构函数不会 释放指针成员指向的对象。

左值引用(lvalue reference)可以绑定到

左值的引用。

画＞逐成员拷贝/赋值(memberwise copy/assign)合成的拷贝与移动构造函 数及拷贝与移动赋值运算符的工作方式。 合成的拷贝或移动构造函数依次处理每个 非static数据成员，通过从给定对象拷 贝或移动对应成员來初始化本对象成员； 拷贝或移动赋值运算符从右侧运算对象中 将每个成员拷贝赋值或移动赋值到左侧运 算对象中。内置类型或复合类型的成员直 接进行初始化或赋值。类类型的成员通过 成员对应的拷贝/移动构造函数或拷贝/移 动赋值运算符进行初始化或赋值。



move用来将一个右值引用绑定到•个左 值的标准库函数。调用move隐含地承诺 我们将不会再使用移后源对象，除了销毁 它或赋予它一个新值之外。

移动赋值运算符(move-assignment operator)接受一个本类型右值引用参数 的赋值运算符版本。通常，移动赋值运算 符将数据从右侧运算对象移动到左侧运算 对象。赋值之后，对右侧运算对象执行析 构函数必须是安全的。

移动构造函数(move constructor)…-种

构造函数，接受一个本类型的右值引用。 通常，移动构造函数将数据从其参数移动 到新创建的对象中。移动之后，对给定的 实参执行析构函数必须是安令的。

移动迭代器(move iterator)迭代器适配

器，它生成的迭代器在解引用时会得到-• 个右值引用=■

重载运算符(overloaded叩erator) •-种

函数，重定义了运算符应用于类类型的对 象吋的含义。本章介绍了如何定义赋值运 算符；第14章中将介绍重载运算符的更多 细节内容。

引用计数(reference count) 种程序设

计技术，通常用于拷贝控制成员的设计。 引用计数记录了有多少对象共享状态。构 造函数(不是拷贝/移动构造函数)将引用 计数置为1。每当创建一个新副本吋.计数

值递增。当一个对象被销毁时，计数值递 减。赋值运算符和析构函数检査递减的引 用计数是否为0,如果是，它们会销毁对象

引用限定符(reference qualifier)用来指

出一个非static成员函数可以用于左值 或右值的符号。限定符&和&&应该放在参 数列表之后或const限定符之后(如果有 的话)。被&限定的函数只能用T左值：被 &&限定的函数只能用F右值。

右值引用(rvalue reference)指向•个将

要销毁的对象的引用。

合成赋值运算符(synthesized assignment operator)编译器为朱显式定义赋值运算 符的类创建的(合成的)拷贝或移动赋值 运算符版本。除非定义为删除的，合成赋 值运算符会逐成员地将右侧运算对象赋予 (移动到)左侧运算对象。

合成拷贝/移动构造函数(synthesized c叩y/move constructor)編译器为未显式

定义对应的构造函数的类生成的拷贝或移 动构造函数版本。除非定义为删除的，合 成拷贝或移动构造函数分别通过从给定对 象拷贝或移动成员来逐成员地初始化新对 象。

合成析构函数(synthesized destructor)

编译器为未显式定义析构函数的类创建的 (合成的)版本。合成析构函数的函数体为 空。
