第19章

### 特殊工具与技术

内容

.....................................................................................................................762

..................................................................................................................762

本书的前三部分讨论了 C++语言的基本要素，这些要素绝大多数程序员都会用到。此 外，C#还定义了一些非常特殊的性质，对于很多程序员来说，他们一般很少会用到本章 介绍的内容。

r820>    C++语言的设计者希望它能处理各种各样的问题。因此，C++的某些特征可能对于一

些特殊的应用非常重要，而在另外一些情况下没什么作用。本章将介绍C++语言的几种未 被广泛使用的特征。

##### 19.1控制内存分配

某些应用程序对内存分配有特殊的需求，因此我们无法将标准内存管理机制直接应用 于这些程序。它们常常需要自定义内存分配的细节，比如使用关键字new将对象放置在 特定的内存空间中。为了实现这一目的，应用程序需要重载new运算符和delete运算 符以控制内存分配的过程。

###### 19.1.1 重载 new 和 delete

尽管我们说能够“重载new和delete”，但是实际上重载这两个运算符与重载其他 运算符的过程大不相同。要想真正掌握重载new和delete的方法，首先要对new表达 式和delete表达式的工作机理有更多了解。

当我们使用一条new表达式时：

// new表达式

string *sp = new string ("a value") ;    // 分配并初始化一个 string 对象

string *arr = new string[10] ;    // 分配 10 个默认初始化的 string 对象

实际执行了三步操作。第一步，new表达式调用一个名为operator new(或者operator new[])的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储 特定类型的对象(或者对象的数组)。第二步，编译器运行相应的构造函数以构造这些对 象，并为其传入初始值。第三步，对象被分配了空间并构造完成，返回一个指向该对象的 指针。

当我们使用一条delete表达式删除一个动态分配的对象时：

delete sp;    II销毁.*sp,然后释放sp指向的内存空间

delete [] arr;    //销毁数组中的元素，然后释放对应的内存空间

实际执行了两步操作。第一步，对sp所指的对象或者arr所指的数组中的元素执行对应

的析构函数。第二步，编译器调用名为operator delete (或者operator delete [])

的标准库函数释放内存空间。

如果应用程序希望控制内存分配的过程，则它们需要定义自己的operator new函 数和operator delete函数。即使在标准库中已经存在这两个函数的定义，我们仍旧 可以定义自己的版本。编译器不会对这种重复的定义提出异议，相反，编译器将使用我们 自定义的版本替换标准库定义的版本。

![img](C++  Primer 5-190.jpg)



A

WARNING



当自定义了全局的operator new函数和operator delete函数后，我们 就担负起了控制动态内存分配的职责，这两个函数必须是正确的：因为它们是 程序整个处理过程中至关重要的一部分。

应用程序可以在全局作用域中定义operator new函数和operator delete函数， 也可以将它们定义为成员函数。当编译器发现一条new表达式或delete表达式后，将

在程序中查找可供调用的operator函数。如果被分配（释放）的对象是类类型，则编 译器首先在类及其基类的作用域中查找。此时如果该类含有operator new成员或 operator delete成员，则相应的表达式将调用这些成员。否则，编译器在全局作用域 查找匹配的函数。此时如果编译器找到了用户自定义的版本，则使用该版本执行new表 达式或delete表达式；如果没找到，则使用标准库定义的版本。

我们可以使用作用域运算符令new表达式或delete表达式忽略定义在类中的函数， 直接执行全局作用域中的版本。例如，：：new只在全局作用域中查找匹配的operator new函数，：：delete与之类似。

operator new 接口和叩erator delete 接口

标准库定义了 operator new函数和operator delete函数的8个重载版本。其 中前4个版本可能抛出bad_alloc异常，后4个版本则不会抛出异常：

//这些版本可能抛出异常



void *operator void *operator void *operator void *operator



new(size_t);

new[](size_t);

delete(void*) noexcept; delete[](void*) noexcept;



//分配一个对象 //分配一个数组 //释放一个对象 //释放一个数组



//这些版本承诺不会抛出异常，参见12.1.2节（第409页） void *operator new（size_t, nothrow_t&） noexcept; void *operator new[]（size_t, nothrow_t&） noexcept; void *operator delete（void*, nothrow_t&） noexcept; void *operator delete[]（void*, nothrow_t&） noexcept;

类型nothrow_t是定义在new头文件中的一个struct，在这个类型中不包含任何成员》 new头文件还定义了一个名为nothrow的const对象，用户可以通过这个对象请求new 的非抛出版本（参见12.1.2节，第408页）。与析构函数类似，operator delete也不 允许抛出异常（参见18.1.1节，第685页）。当我们重载这些运算符时，必须使用noexcept 异常说明符（参见18.1.4节，第690页）指定其不抛出异常。

应用程序可以自定义上面函数版本中的任意一个，前提是自定义的版本必须位于全局 作用域或者类作用域中。当我们将上述运算符函数定义成类的成员时，它们是隐式静态的 （参见7.6节，第270页）。我们无须显式地声明static,当然这么做也不会引发错误。 因为operator new用在对象构造之前而operator delete用在对象销毁之后，所以 这两个成员（new和delete）必须是静态的，而且它们不能操纵类的任何数据成员。

< 822 |



对于operator new函数或者operator new []函数来说，它的返回类型必须是 VOid*,第一个形参的类型必须是3126_七且该形参不能含有默认实参。当我们为一个对 象分配空间时使用operator new;为一个数组分配空间时使用operator new □。当 编译器调用operator new时，把存储指定类型对象所需的字节数传给size_t形参； 当调用operator new []时，传入函数的则是存储数组中所有元素所需的空间。

如果我们想要自定义operator new函数，则可以为它提供额外的形参。此时，用 到这些自定义函数的new表达式必须使用new的定位形式（参见12.1.2节，第409页） 将实参传给新增的形参。尽管在一般情况下我们可以自定义具有任何形参的operator new,但是下面这个函数却无论如何不能被用户重载：

void *operator new(size t, void*);



//不允许重新定义这个版本



这种形式只供标准库使用，不能被用户重新定义。

对于operator delete函数或者operator delete []函数来说，它们的返回类 型必须是void，第一个形参的类型必须是void*。执行一条delete表达式将调用相应 的operator函数，并用指向待释放内存的指针来初始化void*形参。

当我们将operator delete或operator delete []定义成类的成员时，该函数 可以包含另外一个类型为size_t的形参。此吋，该形参的初始值是第一个形参所指对象 的字节数。size_tB参可用于删除继承体系中的对象。如果基类有一个虚析构函数（参 见15.7.1节，第552页），则传递给operator delete的字节数将因待删除指针所指对 象的动态类型不同而有所区别。而且，实际运行的operator delete函数版本也由对象 的动态类型决定。

术语：new表达式与operator new困数

标准库®数operator new和operator delete的名字容易让人误解a和其他 operator函数不同（比知operator=），这两个函数并没有重载new表达式或delete 表达式。实际上，我们根本无法自定义new表达式或delete表达式的行为。

一条new表达式的执行过程总是先调用operator new函数以获取内存空间，然 后在得到的内存空间中构造对象。与之相反，•-条delete表达式的执行过程总是先销 毁对象，然后调用operator delete函数释放对象所占的空间。

我们提供新的operator new函数和operator delete函数的目的在于改变内 存分配的方式，但是不管怎样，我们都不能改变new运算符和delete运算符的基本 含义。

I 823> malloc函数与free函数

当你定义了自己的全局operator new和operator delete后，这两个函数必须 以某种方式执行分配内存与释放内存的操作。也许你的初衷仅仅是使用一个特殊定制的内 存分配器，但是这两个函数还应该同时满足某些测试的目的，即检验其分配内存的方式是 否与常规方式类似，

为此，我们可以使用名为malloc和free的函数，C++从C语言中继承了这些函数, 并将其定义在cstdlib头文件中。

malloc函数接受一个表示待分配字节数的size_t,返回指向分配空间的指针或者 返回0以表示分配失败。free函数接受一^void*,它是malloc返回的指针的副本， free将相关内存返回给系统。调用free （0）没有任何意义。

如下所不是编写operator new和operator delete的一种简单方式，其他版本 与之类似：

void *operator new(size_t size) { if (void *mem = malloc(size))

return mem;

else

throw bad_alloc();

}

void operator delete(void *mem) noexcept { free(mem); }

###### 19.1.1节练习

练习19.1:使用malloc编写你自己的operator new （size_t）函数，使用free编 写 operator delete （void *）函数。

练习19.2：默认情况下，allocator类使用operator new获取存储空间，然后使用 operator delete释放它。利用上一■题中的两个函数重新编译并运行你的StrVec程 序（参见13.5节，第465页）。

###### 19.1.2定位new表达式

尽管operator new函数和operator delete函数一般用于new表达式，然而它 们毕竟是标准库的两个普通函数，因此普通的代码也可以直接调用它们。

在C++的早期版本中，allocator类（参见12.2.2节，第427页）还不是标准库的 一部分。应用程序如果想把内存分配与初始化分离开来的话，需要调用operator new 和operator delete。这两个函数的行为与allocator的allocate成员和 deallocate成员非常类似，它们负责分配或释放内存空间，但是不会构造或销毁对象。

与allocator不同的是，对于operator new分配的内存空间来说我们无法使用＜ 824 | construct函数构造对象。相反，我们应该使用new的定位new （placement new）形式 （参见12.1.2节，第409页）构造对象。如我们所知，new的这种形式为分配函数提供了 额外的信息。我们可以使用定位new传递一个地址，此时定位new的形式如下所示：

new (place address) type

new (place address) type {initializers)

new (place address) type [size]

new {place address) type [size] { braced initializer list

其中必须是一个指针，同时在/w'Z/a/Zzew中提供一个（可能为空的）以逗号 分隔的初始值列表，该初始值列表将用于构造新分配的对象。

当仅通过Is"地址值调用时，定位new使用operator new（size_t, void*） “分 配”它的内存。这是一个我们无法自定义的operator new版本（参见19.1.1节，第727 页）。该函数不分配任何内存，它只是简单地返回指针实参；然后由new表达式负责在指 定的地址初始化对象以完成整个工作。事实上，定位new允许我们在一个特定的、预先 分配的内存地址上构造对象。

![img](C++  Primer 5-191.jpg)



new表达式构造对象但是不分配内存。



尽管在很多时候使用定位new与allocator的construct成员非常相似，但在它 们之间也有一个重要的区别。我们传给construct的指针必须指向同一个allocator 对象分配的空间，但是传给定位new的指针无须指向operator new分配的内存。实际 上如我们将在19.6节（第753页）介绍的，传给定位new表达式的指针甚至不需要指向 动态内存。

显式的析构函数调用

就像定位new与使用allocate类似一样，对析构函数的显式调用也与使用 destroy很类似。我们既可以通过对象调用析构函数，也可以通过对象的指针或引用调

用析构函数，这与调用其他成员函数没什么区别：

string *sp = new string ("a value") ;    // 分配并初始化一个 string 对象

sp->~string();

在这里我们直接调用了一个析构函数。箭头运算符解引用指针sp以获得sp所指的对象， 然后我们调用析构函数，析构函数的形式是波浪线(~)加上类型的名字。

和调用destroy类似，调用析构函数可以清除给定的对象但是不会释放该对象所在 的空间。如果需要的话，我们可以重新使用该空间。

![img](C++  Primer 5-192.jpg)



调用析构函数会销毁对象，但是不会释放内存，



##### 19.2运行吋类型识別

运行时类型识别(run-time type identification，RTTI)的功能由两个运算符实现：

•    typeid运算符，用于返回表达式的类型。

•    dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或 引用。

当我们将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将 使用指针或引用所绑定对象的动态类型(参见15.2.3节，第534页)。

这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生 类操作并且该操作不是虚函数。一般来说，只要有可能我们应该尽量使用虚函数。当操作 被定义成虚函数时，编译器将根据对象的动态类型自动地选择正确的函数版本。

然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一 个RTTI运算符。另一方面，与虚成员函数相比，使用RTTI运算符蕴含着更多潜在的风 险：程序员必须清楚地知道转换的目标类型并且必须检查类型转换是否被成功执行。

WARNING



使用RTTI必须要加倍小心、在可能的情况下，最好定义虚函数而非直接接管 类型管理的重任。:”

###### 19.2.1 dynamic_cast 运算符

dynamic__cast运算符(dynamic cast operator)的使用形式如下所示：

dynamic_cast<fype*>(e)    、

dynamic_cast<Zype&> (e) dynamic_cast<fype&&> (e)

其中，zype必须是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中， e必须是一个有效的指针(参见2.3.2节，第47页)；在第二种形式中，e必须是一个左值; 在第三种形式中，e不能是左值。

在上面的所有形式中，e的类型必须符合以下三个条件中的任意一个：e的类型是目 标妙e的公有派生类、e的类型是目标Cvpe的公有基类或者e的类型就是目标的类 型。如果符合，则类型转换可以成功。否则，转换失败。如果一条dynamic_cast语句 的转换目标是指针类型并且失败了，则结果为0»如果转换目标是引用类型#且失败了， 则dynamic_cast运算符将抛出一个bad_cast异常。

指针类型的dynamic_cast

举个简单的例子，假定Base类至少含有一个虚函数，Derived是Base的公有派生 类。如果有一个指向Base的指针bp,则我们可以在运行时将它转换成指向Derived的 指针，具体代码如下：

< 826 I



if (Derived *dp = dynamic_cast<Derived*>(bp))

{

//使用dp指向的Derived对象

} else { // bp指向一个Base对象 //使用bp指向的Base对象

}

如果bp指向Derived对象，则上述的类型转换初始化dp并令其指向bp所指的Derived 对象。此时，i_f语句内部使用Derived操作的代码是安全的。否则，类型转换的结果为 0，dp为0意味着if语句的条件失败，此时else子句执行相应的Base操作。

我们可以对一个空指针执行dynamic_cast，结果是所需类麼的空指针。

值得注意的一点是，我们在条件部分定义了 dP，这样做的好处是可以在一个操作中 同时完成类型转换和条件检查两项任务。而且，指针dp在if语句外部是不可访问的。 一旦转换失败，即使后续的代码忘了做相应判断，也不会接触到这个未绑定的指针，从而 确保程序是安全的。

Best

PwLetie«



在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一条 表达式中完成。

引用类型的dynamic_cast

引用类型的dynamic_cast与指针类型的dynamic_cast在表示错误发生的方式 上略有不同。因为不存在所胃的空引用，所以对于引用类&来说无法使用与指针类型完全 相同的错误报告策略。当对引用的类型转换失败时，程序抛出一个名为std::bad_Cast 的异常，该异常定义在typeinfo标准库头文件中。

我们可以按照如下的形式改写之前的程序，令其使用引用类型：

void f(const Base &b)

{

try {

const Derived &d = dynamic_cast<const Derived&>(b); //使用b引用的Derived对象 } catch (bad_cast) {

//处理类i转换失败的情况

}

###### 19.2.1节练习

练习19.3:已知存在如下的类继承体系，其中每个类分别定义了一个公有的默认构造函 数和一个虚析构函数：

class A { /* ...*/ }; class B : public A { /* ...*/ }; class C : public B { /*...*/ }; class D : public B, public A { /*••.*/ }; 下面的哪个dynamic_cast将失败？

| ⑻A   | *pa = new C; | cast< | B*       | > (pa) |      |        |
| ---- | ------------ | ----- | -------- | ------ | ---- | ------ |
|      | B            | *pb   | =dynamic |        |      |        |
| (b)  | B            | *pb   | =new B;  |        |      |        |
|      | C            | *pc   | =dynamic | cast<  | C*   | > (pb) |
| (c)  | A            | *pa   | =new D;  |        |      |        |
|      | B            | *pb   | =dynamic | _cast< | B*   | > (pa) |

练习19.4:使用上一个练习定义的类改写下面的代码，将表达式+pa转换成类型C&:

if (C *pc = dynamic_cast< C* >(pa))

}

//使用C的成员 } else {

//使用A的成员

}

练习19.5:在什么情况下你应该使用dynamic cast替代虚函数？

###### 19.2.2 typeid 运算符

为RTTI提供的第二个运算符是typeid运算符(typeid operator),它允许程序向表 达式提问：你的对象是什么类型？

1~827>



typeid表达式的形式是typeid (e),其中e可以是任意表达式或类型的名字。 typeid操作的结果是一个常量对象的引用，该对象的类型是标准库类型type_infO或 者type_info的公有派生类型》type_info类定义在typeinfo头文件中，19.2.4节 (第735 i)将介绍更多关于type_info的细节。

typeid运算符可以作用于任意类型的表达式。和往常一样，顶层const (参见2.4.3 节，第57页)被忽略，如果表达式是一个引用，则typeid返回该引用所引对象的类型。 不过当typeid作用于数组或函数时，并不会执行向指针的标准类型转换(参见4.11.2节， 第143页)。也就是说，如果我们对数组a执行typeid (a),则所得的结果是数组类型而 非指针类型。

当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示 的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid 的结果直到运行时才会求得。

使用typeid运算符

通常情况下，我们使用typeid比较两条表达式的类型是否相同，或者比较一条表达 式的类型是否与指定类型相同：

I 828〉



Derived *dp = new Derived;

Base *bp = dp;    //两个指针都指向Derived对象

//在运行时比较两个对象的类型

if (typeid(*bp) == typeid(*dp))    {

// bp和dp指向同一类型的对象

}

//检查运行时类型是否是某种指定的类型 if (typeid(*bp) == typeid(Derived))    {

// bp实际指向Derived对象

}

在第一个if语句中，我们比较bp和dp所指的对象的动态类型是否相同。如果相同， 则条件成功。类似的，当bp当前所指的是一个Derived对象时，第二个if语句的条件 满足。

注意，typeid应该作用于对象，因此我们使用*bp而非bp:

//下面的检查永远是失败的：bp的类型是指向Base的指针 if (typeid(bp) == typeid(Derived))    {

//此处的代码永远不会执行

}

这个条件比较的是类型Base*和Derived,尽管指针所指的对象类型是一个含有虚函数 的类，但是指针本身并不是一个类类型的对象。类型Base*将在编译时求值，显然它与 Derived不同，因此不论bp所指的对象到底是什么类型，上面的条件都不会满足。

WARNING



当typeid作用于指针时(而非指针所指的对象)，返回的结果是该指针的静 态编译时类型。

typeid是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时， 编译器才会对表达式求值。反之，如果类型不含有虚函数，则typeid返回表达式的静态 类型：编译器无须对表达式求值也能知道表达式的静态类型。

如果表达式的动态类型可能与静态类型不同，则必须在运行时对表达式求值以确定返 回的类型。这条规则适用于typeid (*p)的情况。如果指针p所指的类型不含有虚函数， 则p不必非得是一个有效的指针。否则，*p将在运行时求值，此时p必须是一个有效的 指针。如果p是一个空指针，则typeid (*p＞将抛出—名为bad_typeid的异常。

###### 19.2.2节练习

练习19.6:编写一条表达式将Query_base指针动态转换为AndQuery指针(参见 15.9.1节，第564页)。分别使用AndQ_uery的对象以及其他类型的对象测试转换是否 有效。打印一条表示类型转换是否成功的信息，确保实际输出的结果与期望的一致。

练习19.7:编写与上一个练习类似的转换，这一次将Query_base对象转换为 AndQuery的引用。重复上面的测试过程，确保转换能正常工作。

练习19.8：编写一条typeid表达式检查两个Query_base对象是否指向同一种类型■, 再检查该类型是否是AndQuery。

###### 19.2.3 使用 RTTI

在某些情况下RTTI非常有用，比如当我们想为具有继承关系的类实现相等运算符时 (参见14.3.1节，第497页)。对于两个对象来说，如果它们的类型相同并且对应的数据成

员取值相同，则我们说这两个对象是相等的。在类的继承体系中，每个派生类负责添加自 己的数据成员，因此派生类的相等运算符必须把派生类的新成员考虑进来。

029>    一种容易想到的解决方案是定义一套虚函数，令其在继承体系的各个层次上分别执行

相等性判断。此时，我们可以为基类的引用定义一个相等运算符，该运算符将它的工作委 托给虚函数equal，由equal负责实际的操作。

遗憾的是，上述方案很难奏效。虚函数的基类版本和派生类版本必须具有相同的形参 类型(参见15.3节，第537页)。如果我们想定义一个虚函数equal,则该函数的形参必 须是基类的引用。此时，equal函数将只能使用基类的成员，而不能比较派生类独有的成员。

要想实现真正有效的相等比较操作，我们需要首先清楚一个事实：即如果参与比较的 两个对象类型不同，则比较结果为false。例如，如果我们试图比较一个基类对象和一个 派生类对象，则==运算符应该返回false。

基于上述推论，我们就可以使用RTTI解决问题了。我们定义的相等运算符的形参是 基类的引用，然后使用typeid检查两个运算对象的类型是否一致。如果运算对象的类型 不一致，则==返回false；类型一致才调用equal函数。每个类定义的equal函数负 责比较类型自己的成员。这些运算符接受Bases形参，但是在进行比较操作前先把运算对 象转换成运算符所属的类类型，

类的层次关系

为了更好地解释上述概念，我们定义两个示例类： class Base {

friend bool operator==(const Bases, const Bases); public:

// Base的接口成员 protected:

virtual bool equal(const Base&) const;

// Base的数据成员和其他用于实现的成员

}；

I 830〉    class Derived: public Base {

public:

// Derived的其他接口成员 protected:

bool equal(const Bases) const;

// Derived的数据成员和其他用于实现的成员

}；

类型敏感的相等运算符

接下来介绍我们是如何定义整体的相等运算符的：

bool operator==(const Base &lhs, const Base &rhs)

{

//如果typeid不相同，返回false;否则虚调用equal return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);

}

在这个运算符中，如果运算对象的类型不同则返回false。否则，如果运算对象的类型相 同，则运算符将其工作委托给虚函数equal。当运算对象是Base的对象时，调用 Base : :equal；当运算对象是Derived的对象时，调用Derived: :equal。

虚equal函数

继承体系中的每个类必须定义自己的equal函数。派生类的所有函数要做的第一件 事都是相同的，那就是将实参的类型转换为派生类类型：

bool Derived::equal(const Base &rhs) const {

//我们清楚这两个类型是相等的，所以转换过程不会抛出异常 auto r = dynamic_cast<const Derived&>(rhs);

//执行比较两个Derived对象的操作并返回结果

}

上面的类型转换永远不会失败，因为毕竟我们只有在验证了运算对象的类型相同之后才会 调用该函数。然而这样的类型转换是必不可少的，执行了类型转换后，当前函数才能访问 右侧运算对象的派生类成员。

基类equal函数

下面这个操作比其他的稍微简单一点：

bool Base::equal(const Base &rhs) const {

//执行比较Base对象的操作

}

无须事先转换形参的类型。*this和形参都是Base对象，因此当前对象可用的操作对于 形参类型同样有效。

###### 19.2.4 type_info 类

<830



type_info类的精确定义随着编译器的不同而略有差异。不过，C++标准规定 type_info类必须定义在typeinfo头文件中，并且至少提供表19.1所列的操作。

| 表 19.1： typejnfo 的操作 |             |                                                              |
| ------------------------- | ----------- | ------------------------------------------------------------ |
| ti                        | ==t2        | 如果type_info对象tl和t2表示同一种类型，返回true；否则返 回 false |
| ti                        | != t2       | 如果type_info对象tl和t2表示不同的类型，返回true;否则返 回 false |
| t.                        | name()      | 返回一•个C风格字符串，表示类型名字的可打印形式。类型名字的生成 方式因系统而异 |
| ti                        | .before(t2) | 返回一个bool值，表示tl是否位于t2之前。before所采用的顺序 关系是依赖于编译器的 |

除此之外，因为type info类一般是作为一个基类出现，所以它还应该提供一个公有 的虚析构函数。当编译器希 1提供额外的类型信息时，通常在tyPe_info的派生类中完成。

type_info类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都 被定义成删除的(参见13.1.6节，第450页)。因此，我们无法定义或拷贝type_info 类型的对象，也不能为type_:Lnfo类型的对象赋值。创建type_info对象的唯一途径 是使用typeid运算符。

type info类的name成员函数返回一个C风格字符串，表示对象的类型名字。对

于某种给定的类型来说，name的返回值因编译器而异并且不一定与在程序中使用的名字 一致。对于name返回值的唯一要求是，类型不同则返回的字符串必须有所区别。例如：

int arr[10]; Derived d; Base *p = &d;

cout « typeid(42).name() « ”，"

« typeid(arr).name() « ","

« typeid(Sales_data).name() « « typeid(std::string).name() « « typeid(p).name() « ","

« typeid(*p).name() « endl;

在作者的计算机上运行该程序，输出结果如下：

i, A10__i, 10Sales_data, Ss, P4Base, 7Derived

type_info类在不同的编译器上有所区别。有的编译器提供了额外的成员函 数以提供程序中所用类型的额外信息。读者应该仔细阅读你所用编译器的使用 手册，从而获取关于type_info的更多细节。

I 832〉



###### 19.2.4 节习

练习19.9:编写与本节最后一个程序类似的代码，令其打印你的编译器为一些常见类型 所起的名字。如果你得到的输出结果与本书类似，尝试编写一个函数将这些字符串翻译 成人们更容易读懂的形式。

练习19.10:已知存在如下的类继承体系，其中每个类定义了一个默认公有的构造函数 和一个虚析构函数。下面的语句将打印哪些类型名字？

class A { /* ...★/ };

class B : public A { /* ...*/ };

class C : public B { /*...*/ };

(a)    A *pa = new C;

cout << typeid(pa).name(} « endl;

(b)    C cobj;

A& ra = cobj;

cout << typeid(&ra).name() « endl;

(c)    B *px = new B;

A& ra = *px;

cout « typeid(ra).name() « endl;

##### 19.3枚举类型

枚举类型(enumeration)使我们可以将一组整型常量组织在一起。和类一样，每个枚 举类型定义了一种新的类型。枚举属于字面值常量类型(参见7.5.6节，第267页)。

C++包含两种枚举：限定作用域的和不限定作用域的。OH1新标准引入了限定作用 _域的枚举类型(scoped enumeration)。定义限定作用域的枚举类型的一般形式是：首先是 LuJ关键字enum class (或者等价地使用enum struct)，随后是枚举类型名字以及用花括

号括起来的以逗号分隔的枚举成员（enumerator）列表，最后是一个分号： enum class open_modes {input, output, append};

我们定义了一个名为open_modes的枚举类型，它包含三个枚举成员：input、output 和 append。

定义不限定作用域的枚举类型（unscoped enumeration）时省略掉关键字class （或 struct）,枚举类型的名字是可选的：

enum color {red, yellow, green};    //不限定作用域的枚举类型

//未命名的、不限定作用域的枚举类型

enum {floatPrec = 6, doublePrec = 10, double_doublePrec = 10};

如果enum是未命名的，则我们只能在定义该enum时定义它的对象。和类的定义类似， 我们需要在enum定义的右侧花括号和最后的分号之间提供逗号分隔的声明列表（参见

2.6.1 节，第 64 页）。

枚举成员 <8331

在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类 型的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用 域与枚举类型本身的作用域相同：

enum color { red, yellow, green};    //不限定作用域的枚举类型

enum stoplight {red, yellow, green};    // 错误：重复定义了枚举成员

enum class peppers {red, yellow, green};    // 正确：枚举成员被隐藏了

color eyes = green; //正确：不限定作用域的枚举类型的枚举成贾位于有效的作用域中 peppers p = green; //错误：peppers的枚举成员不在有效的作用域中

// color: :green在有效的作用域中，但是类型错误 color hair = color: : red;    //正确：允许显式地访问枚举成员

peppers p2 = peppers : : red;    // 正确：使用 pappers 的 red

默认情况下，枚举值从0开始，依次加1。不过我们也能为一个或几个枚举成员指定 专门的值：

enum class intTypes {

charTyp = 8, shortTyp = 16, intTyp = 16, longTyp = 32, long_longTyp = 64

由枚举成员intTyp和shortTyp可知，枚举值不一定唯一。如果我们没有显式地提供 初始值，则当前枚举成员的值等于之前枚举成员的值加1。

枚举成员是const,因此在初始化枚举成员时提供的初始值必须是常量表达式（参见 2.4.4节，第58页）。也就是说，每个枚举成员本身就是一条常量表达式，我们可以在任何 需要常量表达式的地方使用枚举成员。例如，我们可以定义枚举类型的constexpr变量:

constexpr intTypes charbits = intTypes::charTyp;

类似的，我们也可以将一个enum作为switch语句的表达式，而将枚举值作为case标 签（参见5.3.2节，第160页）。出于同样的原因，我们还能将枚举类型作为一个非类型模 板形参使用（参见16.1.1节，第580页）：或者在类的定义中初始化枚举类型的静态数据 成员（参见7.6节，第270页）。

和类_样，枚举也定义新的类型

只要enum有名字，我们就能定义并初始化该类型的成员。要想初始化enum对象或 者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象：

open_modes om = 2;    // 错误：2 不属于类型 open_modes

om = open_modes : : input;    // 正确：input 是 open_modes 的一个枚举成员

一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整型。因此，我们可以 在任何需要整型值的地方使用它们：

int i = color: : red; //正确：不限定作用域的枚举类型的枚举成员隐式地转换成int int j = peppers: : red; //错误：限定作用域的枚举类型不会进行隐式特换

指定enum的大小

尽管每个enum都定义了唯一的类型，但实际上enum是由某种整数类型表示的=在 岡C++11新标准中，我们可以在enum的名字后加上冒号以及我们想在该enum中使用的类

型：

enum intValues : unsigned long long {

charTyp = 255, shortTyp = 65535, intTyp = 65535, longTyp = 4294967295UL,

long_longTyp = 18446744073709551615ULL

}；

如果我们没有指定enum的潜在类型,则默认情况下限定作用域的enum成员类型是int。 对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在 类型足够大，肯定能够容纳枚举值。如果我们指定了枚举成员的潜在类型（包括对限定作 用域的enum的隐式指定），则一旦某个枚举成员的值超出了该类型所能容纳的范围，将 引发程序错误。

指定enum潜在类型的能力使得我们可以控制不同实现环境中使用的类型，我们将可 以确保在一种实现环境中编译通过的程序所生成的代码与其他实现环境中生成的代码一 致。

枚举类型的前置声明

在C++11新标准中，我们可以提前声明enum，enum的前置声明（无论隐式地还是 显示地）必须指定其成员的大小：

//不限定作用域的枚举类型intValues的前置声明

enum intValues : unsigned long long; //不限定作用域的，必须指定成员类型 enum class open_modes; //限定作用域的枚举类4!可以使用默认成员类型int

因为不限定作用域的enum未指定成员的默认大小，因此每个声明必须指定成员的大小。 对于限定作用域的enum来说，我们可以不指定其成员的大小，这个值被隐式地定义成into

和其他声明语句一样，enum的声明和定义必须匹配，这意味着在该enum的所有声 明和定义中成员的大小必须一致。而且，我们不能在同一个上下文中先声明一个不限定作 用域的enum名字，然后再声明一个同名的限定作用域的enum：

//错误：所有的声明和定义必须对该enum是限定作用域的还是不限定作用域的保持一致 enum class intValues;

enum intValues;    //错误：intValues已经被声明成限定作用域的enum

enum intValues : long; // 错误：intValues 已经被声明成 int

形参匹配与枚举类型

要想初始化一个enum对象，必须使用该enum类型的另一个对象或者它的一个枚举 成员(参见19.3节，第737页)。因此，即使某个整型值恰好与枚举成员的值相等，它也 不能作为函数的enum实参使用：

//不限定作用域的枚举类型，潜在类型因机器而异

enum Tokens {INLINE = 128, VIRTUAL = 129};

void ff(Tokens);

void ff(int);

int main()    {

Tokens curTok = INLINE;

ff (128) ;    // 精确匹配 ff (int)

ff (INLINE) ;    // 精确匹S己 ff (Tokens)

f f (curTok) ;    // 津奇确匹 S己 ff (Tokens)

return 0;

}

尽管我们不能直接将整型值传给enum形参，但是可以将一个不限定作用域的枚举类 型的对象或枚举成员传给整型形参。此时，enum的值提升成int或更大的整型，实际提 升的结果由枚举类型的潜在类型决定：

void newf(unsigned char);

void newf(int);

unsigned char uc = VIRTUAL;

newf (V工RTUAL);    "调用 newf (int)

newf (uc) ;    // 调用 newf (unsigned char)

枚举类型Tokens只有两个枚举成员，其中较大的那个值是129。该枚举类型可以用 unsigned char来表示，因此很多编译器使用unsigned char作为Tokens的潜在类 型，不管Tokens的潜在类型到底是什么，它的对象和枚举成员都提升成int。尤其是， 枚举成员永远不会提升成unsigned char,即使枚举值可以用unsigned char存储也 是如此。

##### 19.4类成员指针

成员指针(pointer to member)是指可以指向类的非静态成员的指针。一般情况下， 指针指向一个对象，但是成员指针指示的是类的成员，而非类的对象。类的静态成员不属 于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针与普通指针没有 什么区别。

成员指针的类型囊括了类的类型以及成员的类型。当初始化一个这样的指针时，我们 令其指向类的某个成员，但是不指定该成员所属的对象：直到使用成员指针时，才提供成 员所属的对象。

为了解释成员指针的原理，不妨使用7.3.1节(第243页)的Screen类：

class Screen { public:

typedef std::string::size_type pos;

char get_cursor() const { return contents[cursor]; } char get() const;

< 835 |



<836 I



char get（pos ht, pos wd） const; private:

std::string contents;

pos cursor;

pos height, width;

};

19.4.1数据成员指针

和其他指针一样，在声明成员指针时我们也使用*来表示当前声明的名字是一个指针。 与普通指针不同的是，成员指针还必须包含成员所属的类。因此，我们必须在*之前添加 classname::以表示当前定义的指针可以指向c2assname的成员。例如：

// pdata可以指向一个常量（非常量）Screen对象的string成员 const string Screen::*pdata;

上述语句将pdata声明成“一个指向Screen类的const string成员的指针”。常量 对象的数据成员本身也是常量，因此将我们的指针声明成指向const string成员的指 针意味着pdata可以指向任何Screen对象的一个成员，而不管该Screen对象是否是 常量，作为交换条件，我们只能使用pdata读取它所指的成员，而不能向它写入内容。

当我们初始化一个成员指针（或者向它赋值）时，需指定它所指的成员。例如，我们 可以令pdata指向某个非特定Screen对象的contents成员：

pdata = SScreen::contents;

其中，我们将取地址运算符作用于Screen类的成员而非内存中的一个该类对象。

当然，在C^ll新标准中声明成员指针最简单的方法是使用auto或decltype： auto pdata = SScreen::contents;

使用数据成员指针

读者必须清楚的一点是，当我们初始化一个成员指针或为成员指针赋值时，该指针并 没有指向任何数据。成员指针指定了成员而非该成员所属的对象，只有当解引用成员指针 时我们才提供对象的信息。

r837>    与成员访问运算符.和->类似，也有两种成员指针访问运算符：.*和->*,这两个运

算符使得我们可以解引用指针并获得该对象的成员：

Screen myScreen, *pScreen = &myScreen;

// . *解引用pdata以获得myScreen对象的contents成员 auto s = myScreen.*pdata;

// ->*解引用pdata以疾.得pScreen所指对象的contents成员 s = pScreen->*pdata;

从概念上来说，这些运算符执行两步操作：它们首先解引用成员指针以得到所需的成员； 然后像成员访问运算符一样，通过对象（.*）或指针（->*）获取成员。

返回数据成员指针的函数

常规的访问控制规则对成员指针同样有效。例如，Screen的contents成员是私有 的，因此之前对于pdata的使用必须位于Screen类的成员或友元内部，否则程序将发 生错误。

因为数据成员一般情况下是私有的，所以我们通常不能直接获得数据成员的指针。如 果一个像Screen这样的类希望我们可以访问它的contents成员，最好定义一个函数， 令其返回值是指向该成员的指针：

class Screen { public:

// data是一个挣态成员，返回一个成员指针 static const std::string Screen::*data（）

{ return &Screen::contents; }

//其他成员与之前的版本一致

}；

我们为Screen类添加了一个静态成员，令其返回指向contents成员的指针。显然该 函数的返回类型与最初的pdata指针类型一致。从右向左阅读函数的返回类型，可知data 返回的是一个指向Screen类的const string成员的指针。函数体对contents成员 使用了取地址运算符，因此函数将返回指向Screen类contents成员的指针。

当我们调用data函数时，将得到一个成员指针：

// data （）返回一个指向Screen类的contents成员的指针 const string Screen::*pdata = Screen::data（）;

一如往常，pdata指向Screen类的成员而非实际数据。要想使用pdata,必须把它绑 定到Screen类型的对象上：

//获得myScreen对象的contents成员 auto s = myScreen.*pdata;

###### 19.4.1节练习

<838~|



练习19.11:普通的数据指针与指向数据成员的指针有何区别？

练习19.12:定义一个成员指针，令其可以指向Screen类的cursor成员。通过该指 针获得Screen: : cursor的值。

练习19.13:定义一个类型，使其可以表示指向SaleS data类的bookNo成员的指针。

19.4.2成员函数指针

我们也可以定义指向类的成员函数的指针。与指向数据成员的指针类似，对于我们来 说要想创建一个指向成员函数的指针，最简单的方法是使用auto来推断类型：

// pmf是一个指针，它可以指向Screen的某个常量成员函数 II前提是该函数不接受任何实参，并且送回一个char auto pmf = sScreen::get_cursor;

和指向数据成员的指针一样，我们使用cJassname: : *的形式声明一个指向成员函数的 指针。类似于任何其他函数指针（参见6.7节，第221页），指向成员函数的指针也需要指 定目标函数的返回类型和形参列表。如果成员函数是const成员（参见7.1.2节，第231 页）或者引用成员（参见13.6.3节，第483页），则我们必须将const限定符或引用限定 符包含进来。

和普通的函数指针类似，如果成员存在重载的问题，则我们必须显式地声明函数类型 以明确指出我们想要使用的是哪个函数（参见6.7节，第211页）。例如，我们可以声明一

个指针，令其指向含有两个形参的get：

char (Screen::*pmf2)(Screen::pos, Screen::pos) const; pmf2 = &Screen::get;

出于优先级的考虑，上述声明中Screen: :*两端的括号必不可少。如果没有这对括号的 话，编译器将认为该声明是一个(无效的)函数声明：

//错读：非成员函数p不能使用const限定符

char Screen::*p(Screen::pos, Screen::pos) const;

这个声明试图定义一个名为P的普通函数，并且返回Screen类的一个char成员。因为 它声明的是一个普通函数，所以不能使用const限定符。

和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则：

// pmf指向一个Screen成员，该成员不接受任何实参且返回类型是char

pmf = &Screen: :get;    //必须显式地使用取地址运算符

pmf = Screen: : get;    //错误：在成员函数和指针之间不存在自动梓换规则



□39>使用成员函数指针

和使用指向数据成员的指针一样，我们使用.*或者->*运算符作用于指向成员函数的 指针，以调用类的成员函数：

Screen myScreen, *pScreen = SmyScreen;

//通过pScreen所指的对象调用pmf所指的函数 char cl = (pScreen->*pmf)();

//通过myScreen对象将实参0, 0传给含有两个形参的get函数 char c2 = (myScreen.*pmf2)(0, 0);

之所以(myScreen-〉*pmf)()和(pScreen. *pmf2) (0,0)的括号必不可少，原因 是调用运算符的优先级要高于指针指向成员运算符的优先级。

假设去掉括号的话， myScreen.*pmf()

其含义将等同于下面的式子： myScreen.*(pmf())

这行代码的意思是调用一个名为pmf的函数，然后使用该函数的返回值作为指针指向成 员运算符(.*)的运算对象。然而pmf并不是一个函数，因此代码将发生错误。

因为函数调用运算符的优先级较高，所以在声明指向成员函数的指针并使用这 y样的指针进行函数调用时，括号必不可少：(C: : *p) (parms)和

(obj . *p) (args) o

使用成员指针的类型别名

使用类型别名或typedef (参见2.5.1节，第60页)可以让成员指针更容易理解。 例如，下面的类型别名将Action定义为两参数get函数的同义词：

// Action是一种可以指向Screen成员函数的指针，它接受两个pos实参，返回一个char using Action =

char (Screen::*)(Screen::pos, Screen::pos) const;

Action是某类型的另外一个名字，该类型是“指向Screen类的常量成员函数的指针， 其中这个成员函数接受两个pos形参，返回一个char”。通过使用Action,我们可以 简化指向get的指针定义：

Action get = &Screen : : get;    // get 指向 Screen 的 get 成员

和其他函数指针类似，我们可以将指向成员函数的指针作为某个函数的返回类型或形 参类型。其中，指向成员的指针形参也可以拥有默认实参：

// action接受一个Screen的引用，和一个指向Screen成员函数的指针 Screens action(Screens, Action = &Screen::get);

action是包含两个形参的函数，其中一个形参是Screen对象的引用，另一个形参是指 向Screen成员函数的指针，成员函数必须接受两个pos形参并返回一个char。当我们 调用action吋，只需将Screen的一个符合要求的函数的指针或地址传入即可：.

Screen myScreen;

//等价的调用：

action (myScreen) ;    // 使用默认实参

action (myScreen, get) ;    //使用我们之前定义的变量get

action (myScreen, SScreen: :get) ;    // 显式地传入地址

![img](C++  Primer 5-195.jpg)



通过使用类型别名，可以令含有成员指针的代码更易读写。

成员指针函数表

对于普通函数指针和指向成员函数的指针来说，一种常见的用法是将其存入-个函数 表当中(参见14.8.3节，第511页)。如果一个类含有几个相同类型的成员，则这样一张 表可以帮助我们从这些成员中选择一个。假定Screen类含有几个成员函数，每个函数负 责将光标向指定的方向移动：

class Screen {

public:

//其他接口和实现成贾与之前一致

}；



Screens

Screens

Screens

Screens

Screens



home(); forward() back(); up (); down();



II光标移动函数



这几个新函数有一个共同点：它们都不接受任何参数，并且返回值是发生光标移动的 Screen的弓I用。

我们希望定义一个move函数,使其可以调用上面的任意一个函数并执行对应的操作。 为了支持这个新函数，我们将在Screen中添加一个静态成员，该成员是指向光标移动函 数的指针的数组：

class Screen {

public:

//其他接口和实现成员与之前一致

// Action是一个指针，可以用任意一个光标移动函数对其赋值 using Action = Screens (Screen::*)();

//指定具体要移动的方向，其中enum参见19.3节(第736页)

enum Directions { HOME, FORWARD, BACK, UP, DOWN };

Screens move(Directions);

private:

static Action Menu [ ] ;    // 函数表

}；

|~841>数组Menu依次保存每个光标移动函数的指针，这些函数将按照Directions中枚举成 员对应的偏移量存储。move函数接受一个枚举成员并调用相应的函数：

Screens Screen::move(Directions cm)

{

//运行this对象中索引值为cm的元素

return (this->*Menu [cm] )0;    // Menu [cm]指向一个成员函数

}

move中的函数调用的原理是，首先获取索引值为cm的Menu元素,该元素是指向Screen 成员函数的指针。我们根据this所指的对象调用该元素所指的成员函数。

当我们调用move函数时，给它传入一个表示光标移动方向的枚举成员：

Screen myScreen;

myScreen .move (Screen: : HOME) ; // 调用 myScreen . home myScreen.move (Screen: : DOWN) ; // 调用 myScreen .down

剩下的工作就是定义并初始化函数表本身了：

Screen::Action Screen::Menu[] = { SScreen::home,

&Screen::forward,

SScreen::back,

SScreen::up,

&Screen::down,

}；

###### 19.4.2节练习

练习19.14:下面的代码合法吗？如果合法，代码的含义是什么？如果不合法，解释原 因。

auto pmf = SScreen::get_cursor; pmf = SScreen::get;

练习19.15：普通函数指针和指向成员函数的指针有何区别？

练习19.16：声明一个类型别名，令其作为指向Sales_data的avg_price成员的指 针的同义词。

练习19.17:为Screen的所有成员函数类型各定义一个类型别名。

###### 19.4.3将成员函数用作可调用对象

如我们所知，要想通过一个指向成员函数的指针进行函数调用，必须首先利用.*运算 符或->*运算符将该指针绑定到特定的对象上。因此与普通的函数指针不同，成员指针不 是一个可调用对象，这样的指针不支持函数调用运算符(参见10.3.2节，第346页)。

因为成员指针不是可调用对象，所以我们不能直接将一个指向成员函数的指针传递给 算法。举个例子，如果我们想在一个string的vector中找到第一个空string.显然

不能使用下面的语句：

auto fp = &string: :empty; // fp 指向 string 的 empty 函数 //错误，必须使用.*或->*调用成员指针 find_if(svec.begin() , svec.end(), fp);

find_if算法需要一个可调用对象，但我们提供给它的是一个指向成员函数的指针fp。 因此去find_if的内部将执行如下形式的代码，从而导致无法通过编译：

//检查对当前元素的断言是否为真

if (fp(*it))    //错误：要想通过成员指针调用函数，必须使用->*运算符

显然该语句试图调用的是传入的对象，而非函数。

使用function生成一^可调用对象

从指向成员函数的指针获取可调用对象的一种方法是使用标准库模板function (参 见14.8.3节，第511页)：

function<bool (const strings)> fen = Sstring::empty; find_if(svec.begin(), svec.end(), fen);

我们告诉function 一个事实：即empty是一个接受string参数并返回bool值的函 数。通常情况下，执行成员函数的对象将被传给隐式的this形参。当我们想要使用 function为成员函数生成一个可调用对象时，必须首先“翻译"该代码，使得隐式的形 参变成显式的。

当一个function对象包含有一个指向成员函数的指针时，function类知道它必 须使用正确的指向成员的指针运算符来执行函数调用。也就是说，我们可以认为在 find_if当中含有类似于如下形式的代码：

//假设it是find_if内部的迭代器，则+it是给定范围内的一个对象 if (fcn(*it) )    //假设fen是find_if内部的一个可调用对象的名字

其中，function将使用正确的指向成员的指针运算符。从本质上来看，function类将 函数调用转换成了如下形式：

//假设it是f ind_if内部的迭代器，则*it是给定范围内的一个对象 if (((*it) .*p) ())    //假设p是fen内部的一个指向成员函数的指针

当我们定义一个function对象时，必须指定该对象所能表示的函数类型，即可调 用对象的形式。如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个 (一般是隐式的)对象上执行的。同时，我们提供给function的形式中还必须指明对象 是否是以指针或引用的形式传入的。

以定义fen为例，我们想在string对象的序列上调用find_if,因此我们要求 function生成一个接受string对象的可调用对象。又因为我们vector保存的是 string的指针，所以必须指定function接受指针：

vector<string*> pvec;

function<bool (const string*)> fp = &string::empty;

// fp接受一个指向string的指针，然后使用->*调用empty find_if(pvec.begin(), pvec.end(), fp);

使用mem_fn生成一个可调用对象

通过上面的介绍可知，要想使用function,我们必须提供成员的调用形式。我们也

rc^Tj可以采取另外一种方法，通过使用标准库功能mem_fn来让编译器负责推断成员的类型。 和function —■样，mem_fn也定义在functional头文件中，并且可以从成员指针生 成一个可调用对象；和function不同的是，mein_fn可以根据成员指针的类型推断可调 用对象的类型，而无须用户显式地指定：

find_if(svec.begin()z svec.end(), mem_fn(Sstring::empty));

我们使用mem_fn (&string: :empty)生成一个可调用对象，该对象接受一个string 实参，返回一个bool值。

rnem_fn生成的可调用对象可以通过对象调用，也可以通过指针调用：

auto f = mem_fn (&string: : empty) ;    // f 接受一个 string 或者一string*

f (* svec . begin () ) ;    // 正确：传入一个 string 对象，f 使用.* 调用 empty

f (&svec [0] ) ;    //正确：传入一个string的指针，f使用-〉*调用empty

实际上，我们可以认为mem_fn生成的可调用对象含有一对重载的函数调用运算符：一个 接受string*，另一个接受string&。

使用bind生成一个可调用对象

出于完整性的考虑，我们还可以使用bind (参见10.3.4节，第354页)从成员函数 生成一个可调用对象：

//选择范围中的每个string，并将其bind到empty的第一个隐式实参上 auto it = find_if(svec.begin(), svec.end(),

bind(&string::empty, _1));

和function类似的地方是，当我们使用bind时，必须将函数中用于表示执行对象的隐 式形参转换成显式的。和类似的地方是，bind生成的可调用对象的第一个实参 既可以是string的指针，也可以是string的引用：

auto f = bind(&string::empty, _1);

f (*svec .begin () ) ;    // 正确：实参是一个 string, f 使用.*调用 empty

f (&svec [0] ) ;    //正确：实参是一个string的指针，f使用->*调用empty

###### 19.4.3节练习

练习19.18:编写一个函数，使用count_if统计在给定的vector中有多少个空 string。

练习19.19:编写一个函数，令其接受vector<Sales_data〉并查找平均价格高于某 个值的第一个元素。

##### 19.5嵌套类

个类可以定义在另一个类的内部，前者称为嵌套类(nested class)或嵌套类型(nested type)。嵌套类常用于定义作为实现部分的类，比如我们在文本查询示例中使用的 QueryResult 类(参见 12.3 节，第 430 页)。

C^>    嵌套类是一个独立的类，与外层类基本没什么关系。特别是，外层类的对象和嵌套类

的对象是相互独立的。在嵌套类的对象中不包含任何外层类定义的成员；类似的，在外层 类的对象中也不包含任何嵌套类定义的成员。

嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。和其他嵌套 的名字一样，嵌套类的名字不会和别的作用域中的同一个名字冲突，

嵌套类中成员的种类与非嵌套类是一样的。和其他类类似，嵌套类也使用访问限定符 来控制外界对其成员的访问权限。外层类对嵌套类的成员没有特殊的访问权限，同样，嵌 套类对外层类的成员也没有特殊的访问权限。

嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外 层类决定。位于外层类public部分的嵌套类实际上定义了一种可以随处访问的类型；位 于外层类protected部分的嵌套类定义的类型只能被外层类及其友元和派生类访问：位 于外层类private部分的嵌套类定义的类型只能被外层类的成员和友元访问。

声明一个嵌套类

我们为12.3.2节（第432页）的TextQuery类定义了一个名为QueryResult的配 套类，这两个类密切相关。QueryResult类的主要作用是表示TextQuery对象上query 操作的结果，显然将QueryResult用作其他目的没有任何意义。为了充分体现这种紧密 的相关性，我们可以把QueryResult定义成TextQuery的成员。

class TextQuery { public:

class QueryResult;    //嵌套类稍后定义

//其他成员与12.3.2节（第432页）一致

}；

我们只需对原来的TextQuery类做一处改动，即将QueryResult声明成嵌套类。因为 QueryResult是一个类型成员（参见7.4.1节，第254页），所以我们必须对它先声明后 使用，尤其是必须先声明QueryResult,再将它作为query成员的返回类型。类的其 他成员没有任何变化。

在外层类之外定义一个嵌套类

<845~|



我们在TextQuery内声明了 QueryResult,但是没有给出它的定义。和成员函数 一样，嵌套类必须声明在类的内部，但是可以定义在类的内部或者外部。

当我们在外层类之外定义一个嵌套类时，必须以外层类的名字限定嵌套类的名字：

// QueryResult是TextQuery的成员，下面的代码负责定义QueryResult class TextQuery::QueryResult {

//位于类的作用域内，因此我们不必对QueryResult形参进行限定 friend std::ostream&

print（std::ostream&, const QueryResultS）;

public:

// 无须定义 QueryResult: : line_no

//嵌套类可以直接使用外层类的成无须对该成员的名字进行限定 QueryResult（std::string,

std: : shared_ptr<std: : set<line_no»,

std: : shared_ptr<std: : vector<std: : string»）;

//其他成员与12.3.2节（第43孓页）一致

}；

和原来的类相比唯一的改动是，我们无须在QueryResult内定义line no成员了。因 为该成员属于TextQuery,所以QueryResult可以直接访问它而不必再定义一次。

在嵌套类在其外层类之外完成真正的定义之前，它都是一个不完全类型(参见 7.3.3 节，第 250 页)。



WARNING

定义嵌套类的成员

在这个版本的QueryResult类中，我们并没有在类的内部定义其构造函数。要想为 其定义构造函数，必须指明QueryResult是嵌套在TextQuery的作用域之内的。具体 做法是使用外层类的名字限定嵌套类的名字：

// QueryResult 类戒套在 TextQuery 类中

//下面的代码为QueryResult类定义名为QueryResult的成员

TextQuery::QueryResult::QueryResult(string s, shared_ptr<set<line_no>> pf shared_ptr<vector<string» f):

sought (s), lines (p), file(f)    { }

从右向左阅读函数的名字可知我们定义的是QueryResult类的构造函数，而 QueryResult类是嵌套在TextQuery类中的。该构造函数除了把实参值赋给对应的数 据成员之外，没有做其他工作。

嵌套类的静态成员定义

如果QueryResult声明了一个静态成员，则该成员的定义将位于TextQuery的作 I 846>用域之外。例如，假设QueryResult有一个静态成员，则该成员的定义将形如：

// QueryResult 类喪套在 TextQuery 类中，

//下面的代码为QueryResult定义一个静态成员

int TextQuery: -.QueryResult: : static_mem = 1024;

嵌套类作用域中的名字查找

名字查找的一般规则(参见7.4.1节，第254页)在嵌套类中同样适用。当然，因为 嵌套类本身是一个嵌套作用域，所以还必须查找嵌套类的外层作用域。这种作用域嵌套的 性质正好可以说明为什么我们不在QueryResult的嵌套版本中定义line_no„原来的 QueryResult类定义了该成员，从而使其成员可以避免使用TextQuery: :line_no的 形式。然而QueryResult的嵌套类版本本身就是定义在TextQuery中的，所以我们不 需要再使用typedef。嵌套的QueryResult无须说明line_no属于TextQuery就可 以直接使用它。

如我们所知，嵌套类是其外层类的一个类型成员，因此外层类的成员可以像使用任何 其他类型成员一样使用嵌套类的名字。因为QueryResult嵌套在TextQuery中，所以 TextQuery的query成员可以直接使用名字QueryResult：

//返回类型必须指明QueryResult是一个嵌套类

TextQuery::QueryResult

TextQuery::query(const string Ssought) const

{

//如果我们没有找到sought,则返回set的指针

static shared_ptr<set<line_no» nodata(new set<line_no>); //使用find而罪下标以避免向wi中添加单词 auto loc = wm.find(sought); if (loc == wm.end())

return QueryResult (sought, nodata, file) ;    // 没有找到

else

return QueryResult(sought, loc-〉second, file);

}

和过去一样，返回类型不在类的作用域中(参见7.4节，第253页)，因此我们必须指明函 数的返回值是TextQuery: :QueryResult类型。不过在函数体内部我们可以直接访问 QueryResult,比如上面的return语句就是这样。

嵌套类和外层类是相互独立的

尽管嵌套类定义在其外层类的作用域中，但是读者必须谨记外层类的对象和嵌套类的 对象没有任何关系。嵌套类的对象只包含嵌套类定义的成员：同样，外层类的对象只包含 外层类定义的成员，在外层类对象中不会有任何嵌套类的成员。

说得再具体一些，TextQuery: :query的第二条return语句 return QueryResult(sought, loc->second, file);

使用了 TextQuery对象的数据成员，而query正是用它们来初始化QueryResult对 象的。因为在一个QueryResult对象中不包含其外层类的成员，所以我们必须使用上述 成员构造我们返回的QueryResult对象。

###### 19.5节练习

练习19.20：将你的QueryResult类嵌套在TextQuery中，然后重新运行12.3.2节 (第435页)中使用了 TextQuery的程序。

##### 19.6 union: 一种节省空间的类

联合(union)是一种特殊的类。一个union可以有多个数据成员，但是在任意时刻 只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其他成 员就变成未定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的 数据成员。和其他类一样，一个union定义了一种新类型。

类的某些特性对union同样适用，但并非所有特性都如此。union不能含有引用类 型的成员，除此之外，它的成员可以是绝大多数类型。在C++11新标准中，含有构造函数 或析构函数的类类型也可以作为union的成员类型。union可以为其成员指定public、 protected和private等保护标记。默认情况下，union的成员都是公有的，这一点 与struct相同■>

union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能 继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。

定义union

union提供了一种有效的途径使得我们可以方便地表示一组类型不同的互斥值。举个 例子，假设我们需要处理一些不同种类的数字数据和字符数据，则在此过程中可以定义一 个union来保存这些值：

// Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种 union Token {

//默认情况下成员是公有的 char cval; int ival; double dval;

}；

在定义一个union时，首先是关键字union，随后是该union的（可选的）名字以及花 括号内的一组成员声明。上面的代码定义了一个名为Token的union,它可以保存一个 值，这个值的类型可能是char、int或double中的一种。

I 848〉使用union类型

union的名字是一个类型名。和其他内置类型一样，默认情况下union是未初始化 的。我们可以像显式地初始化聚合类（参见7.5.5节，第266页）一样使用一对花括号内 的初始值显式地初始化一个union：

Token f irst_token = {z az };    // 初始化 cval 成员

Token last_token;    // 未初始化的 Token 对象

Token *pt = new Token;    //指向一个未初始化的Token对象的指针

如果提供了初始值，则该初始值被用于初始化第一个成员。因此，firSt_token的初始 化过程实际上是给cval成员赋了一个初值。

我们使用通用的成员访问运算符访问一个union对象的成员：

last_token.cval = z zr; pt->ival = 42;

为union的一个数据成员赋值会令其他数据成员变成未定义的状态。因此，当我们使用 union时，必须清楚地知道当前存储在union中的值到底是什么类型。如果我们使用错 误的数据成员或者为错误的数据成员赋值，则程序可能崩溃或出现异常行为，具体的情况 根裾成员的类型而有所不同。

匿名union

匿名union （anonymous union）是一个未命名的union，并且在右花括号和分号之 间没有任何声明（参见2.6.1节，第65页）。一旦我们定义了一个匿名union,编译器就 自动地为该union创建一个未命名的对象：

union {    // 匿名 union

char cval; int ival; double dval;

}; //定义一个未命名的对象，我们可以直接访问它的成员

cval = 'c';    //为刚刚定义的未命名的匿名union对象陚一个新值

ival = 42;    //该对象当前保存的值是42

在匿名union的定义所在的作用域内该union的成员都是可以直接访问的。

匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。：

含有类类型成员的union

C++的早期版本规定，在union中不能含有定义了构造函数或拷贝控制成员的类类型

成员。C++11新标准取消了这一限制。不过，如果union的成员类型定义了自己的构造 函数和/或拷贝控制成员，则该union的用法要比只含有内置类型成员的union复杂得多。

当union包含的是内置类型的成员吋，我们可以使用普通的赋值语句改变union保 存的值。但是对于含有特殊类类型成员的union就没这么简单了。如果我们想将union 的值改为类类型成员对应的值，或者将类类型成员的值改为一个其他值，则必须分别构造 或析构该类类型的成员：当我们将union的值改为类类型成员对应的值时，必须运行该 类型的构造函数；反之，当我们将类类型成员的值改为一个其他值吋，必须运行该类型的 析构函数。

当union包含的是内置类型的成员时，编译器将按照成员的次序依次合成默认构造 函数或拷贝控制成员。但是如果union含有类类型的成员，并且该类型自定义了默认构 造函数或拷贝控制成员，则编译器将为union合成对应的版本并将其声明为删除的(参 见13.1.6节，第450页)。

例如，string类定义了五个拷贝控制成员以及一个默认构造函数。如果union含 有string类型的成员，并且没有自定义默认构造函数或某个拷贝控制成员，则编译器将 合成缺少的成员并将其声明成删除的。如果在某个类中含有一个union成员，而且该 union含有删除的拷贝控制成员，则该类与之对应的拷贝控制操作也将是删除的。

使用类管理union成员

对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我 们通常把含有类类型成员的union内嵌在另一个类当中。这个类可以管理并控制与 union的类类型成员有关的状态转换。举个例子，我们为union添加一■个string成员，

并将我们的union定义成匿名union,最后将它作为Token类的一个成员■■此时,Token 类将可以管理union的成员。

为了追踪union中到底存储了什么类型的值，我们通常会定义一个独立的对象，该 对象称为union的判别式(discriminant)。我们可以使用判别式辨认 union存储的值。

为了保持union与其判别式同步，我们将判别式也作为Token的成员。我们的类将定义 一个枚举类型(参见19.3节，第736页)的成员来追踪其union成员的状态。

在我们的类中定义的函数包括默认构造函数、拷贝控制成员以及一组赋值运算符，这 些赋值运算符可以将union的某种类型的值赋给union成员：

class Token { public:

//因为union含有一个string成员，所以Token必须定义拷贝控制成员 //定义移动构造函数和移动赋值运算符的任务留待本节练习完成 Token(): tok(INT), ival{0} { }

Token(const Token &t): tok(t.tok) { copyUnion(t); }

Token &operator=(const Tokens);

//如果union含有一个string成员，则我们必须销毁它，参见19.1.2节(第729页)

〜Token()    { if (tok == STR) sval.〜string(); }

//下面的赋值运算符负责设置union的不同成员    < 850 |

Token &operator=(const std::strings);

Token &operator=(char);

Token &operator=(int);

Token &operator=(double);

private:

enum {INT, CHAR, DBL, STR} tok; // 判别式 union { // 匿名 union

char cval; int    ival;

double dval; std::string sval;

} ； //每个Token对象含有一个该未命名union类型的未命名成员 //检查利别式，然后酌情拷贝union成员 void copyUnion(const Tokens);

}；

我们的类定义了一个嵌套的、未命名的、不限定作用域的枚举类型(参见19.3节，第736 页)，并将其作为tok成员的类型。其中，tok的声明位于枚举类型定义的右侧花括号之 后，以及表示该枚举类型定义结束的分号之前，因此，tok的类型就是当前这个未命名的 enum类型(参见2.6.1节，第65页

我们使用tok作为判别式。当union存储的是一个int值时，tok的值是INT:当 union存储的是一'个string值时，tok的值是STR;以此类推。

类的默认构造函数初始化判别式以及union成员，令其保存int值0。

因为我们的union含有一个定义了析构函数的成员，所以必须为union也定义一个 析构函数以销毁string成员。和普通的类类型成员不一样，作为union组成部分的类 成员无法自动销毁。因为析构函数不清楚union存储的值是什么类型，所以它无法确定 应该销毁哪个成员。’

我们的析构函数检查被销毁的对象中是否存储着string值。如果有，则类的析构函 数显式地调用string的析构函数(参见19.1.2节，第729页)释放该string使用的内 存；反之，如果union存储的值是内置类型，则类的析构函数什么也不做。

管理判别式并销毁string

类的赋值运算符将负责设置tok并为union的相应成员赋值。和析构函数一样，这 些运算符在为union赋新值前必须首先销毁string：

Token &Token::operator=(int i)

{

if (tok == STR) sval. -string () ; // 如果当前存储的是 string,释放它 ival = i;    //为成员赋值

tok = INT;    //更新判别式

return *this;

}

如果union的当前值是string,则我们必须先调用string的析构函数销毁这个 □51> string,然后再为union赋新值。清除了 string成员之后，我们将给定的值赋给与运

算符形参类型相匹配的成员。在此例中，形参类型是int,所以我们赋值给ival。随后 更新判别式并返回结果。

double和char版本的赋值运算符与int赋值运算符非常相似，读者可以在本节的 练习中尝试使用这两个运算符。string版本与其他几个有所区别，原因是string版本 必须管理与string类型有关的转换：

Token &Token::operator=(const std::string &s)

if (tok == STR)    //如果当前存储的是string，可以直接赋值

sval = s;

else

new (&sval) string (s) ;    // 否则需要先构造一个 string

tok = STR;    //更新判别式

return *this;

}

在此例中，如果union当前存储的是string,则我们可以使用普通的string赋值运 算符直接为其赋值。如果union当前存储的不是string,则我们找不到一个已存在的 string对象供我们调用赋值运算符。此时，我们必须先利用定位new表达式(参见19.1.2 节，第729贾)在内存中为sval构造一个string,然后将该string初始化为string 形参的副本，最后更新判别式并返回结果。

管理需要拷贝控制的联合成员

和依赖于类型的赋值运算符一样，拷贝构造函数和赋值运算符也需要先检验判别式以 明确拷贝所采用的方式。为了完成这一任务，我们定义一个名为copyUnion的成员。

当我们在拷贝构造函数中调用copyUnion时，union成员将被默认初始化，这意味 着编译器会初始化union的第一个成员。因为string不是第一个成员，所以显然union 成员保存的不是string,在赋值运算符中情况有些不一样，有可能union已经存储了 一个string。我们将在赋值运算符中直接处理这种情况。copyUnion假设如果它的形 参存储了 string,则它一定会构造自己的string:

void Token::copyUnion(const Token &t)

{

switch (t.tok) {

case Token::INT: ival = t.ival; break; case Token::CHAR: cval = t.cval; break; case Token::DBL: dval = t.dval; break;

//要想拷贝一个string可以使用定位new表达式构造它，参见19.1.2节(第729页) case Token::STR: new(&sval) string(t.sval); break;

}

}

该函数使用一个switch语句(参见5.3.2节，第159页)检验判别式。对于内置类型来＜852~| 说，我们把值直接赋给对应的成员；如果拷贝的是一个string,则需要构造它。

赋值运算符必须处理string成员的三种可能情况：左侧运算对象和右侧运算对象都 是string.两个运算对象都不是string,只有一个运算对象是string：

Token &Token::operator=(const Token &t)

{

//如果此对象的值是string而t的值不是，则我们必须释放原来的string if (tok == STR && t.tok != STR) sval•〜string(); if (tok == STR && t.tok == STR)

sval = t.sval; // 无须构造一个新 string

else

copyUnion (t) ;    // 如果 t. tok 是 STR，则需要构造一个 string

tok = t.tok; return *this;

如果作为左侧运算对象的union的值是string但右侧运算对象的值不是，则我们必须 先释放原来的string再给union成员赋一新值。如果两侧运算对象的值都是string, 则我们可以使用普通的string赋值运算符完成拷贝。否则，我们调用copyUnion进行 赋值。在copyUnion内部，如果右侧运算对象是string,则我们在左侧运算对象的 union成员内构造一个新string;如果两端都不是string,则直接执行普通的赋值操 作就可以了。

###### 19.6节练习

练习19.21:编写你自己的Token类。

练习19.22：为你的Token类添加一个Sales_data类型的成员。

练习19.23:为你的Token类添加移动构造函数和移动赋值运算符。

练习19.24：如果我们将一个Token对象赋给它自己将发生什么情况？

练习19.25:编写一系列赋值运算符，令其分别接受union中各种类型的值。

##### 19.7局部类

类可以定义在某个函数的内部，我们称这样的类为局部类(local class)。局部类定义 的类型只在定义它的作用域内可见。和嵌套类不同，局部类的成员受到严格限制。

![img](C++  Primer 5-196.jpg)



局部类的所有成员(包括函数在内)都必须完整定义在类的内部。因此，局部 类的作用与嵌套类相比相差很远.

C853>    在实际编程的过程中，因为局部类的成员必须完整定义在类的内部，所以成员函数的

复杂性不可能太高。局部类的成员函数一般只有几行代码，否则我们就很难读懂它了。

类似的，在局部类中也不允许声明静态数据成员，因为我们没法定义这样的成员。

局部类不能使用函数作用域中的变量

局部类对其外层作用域中名字的访问权限受到很多限制，局部类只能访问外层作用域 定义的类型名、静态变量(参见6.1.1节，第185页)以及枚举成员。如果局部类定义在 某个函数内部，则该函数的普通局部变量不能被该局部类使用：

int a, val; void foo(int val)

{

static int si;

enum Loc { a = 1024, b };

// Bar是foo的局部类 struct Bar {

Loc locVal;    //正确：使用一个局部类型名

int barVal;

void fooBar (Loc 1 = a)    // 正确：默认实参是 Loc: :a

{

barVal = val;



//错误：val是foo的局部变量



|          | barVal = ::val;barVal = si;locVal = b; | //正确：使用一个全局对象 //正确：使用一个静态局部对象 //正确：使用一个枚举成员 |
| -------- | -------------------------------------- | ------------------------------------------------------------ |
| } };// •• |                                        |                                                              |

}

常规的访问保护规则对局部类同样适用

外层函数对局部类的私有成员没有任何访问特权。当然，局部类可以将外层函数声明 为友元；或者更常见的情况是局部类将其成员声明成公有的。在程序中有权访问局部类的 代码非常有限。局部类已经封装在函数作用域中，通过信息隐藏进一步封装就显得没什么 必要了。

局部类中的名字查找

局部类内部的名字查找次序与其他类相似。在声明类的成员时，必须先确保用到的名 字位于作用域中，然后再使用该名字。定义成员时用到的名字可以出现在类的任意位置， 如果某个名字不是局部类的成员，则继续在外层函数作用域中查找；如果还没有找到，则 在外层函数所在的作用域中查找。

<854~|



嵌套的局部类

可以在局部类的内部再嵌套一个类。此时，嵌套类的定义可以出现在局部类之外。不 过，嵌套类必须定义在与局部类相同的作用域中。

void foo()

{

class Bar { public:

// ...

class Nested; // 声明 Nested 类

}；

//定义Nested类 class Bar::Nested {

// ...

}；

}

和往常一样，当我们在类的外部定义成员时，必须指明该成员所属的作用域。因此在上面 的例子中，Bar : : Nested的意思是Nested是定义在Bar的作用域内的一个类。

局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。嵌套类的所有成员 都必须定义在嵌套类内部。

##### 19.8间有的不可移梢的特性

为了支持低层编程，C++定义了一些固有的不可移植(nonportable)的特性。所谓不 可移植的特性是指因机器而异的特性，当我们将含有不可移植特性的程序从一台机器转移 到另一台机器上时，通常需要重新编写该程序。算术类型的大小在不同机器上不一样(参 见2.1.1节，第30页)，这是我们使用过的不可移植特性的一个典型示例。

本节将介绍C++从C语言继承而来的另外两种不可移植的特性：位域和volatile 限定符。此外，我们还将介绍链接指示，它是C++新增的一种不可移植的特性。

###### 19.8.1位域

类可以将其(非静态)数据成员定义成位域(bit-field),在一个位域中含有一定数量 的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。

位域在内存中的布局是与机器相关的

r^5>    位域的类型必须是整型或枚举类型(参见19.3节，第736页)》因为带符号位域的行

为是由具体实现确定的，所以在通常情况下我们使用无符号类型保存一个位域=位域的声 明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占 的二进制位数：

typedef unsigned int Bit; class File {

| Bit  | mode: 2;     |      | //   | mode占2位        |            |
| ---- | ------------ | ---- | ---- | ---------------- | ---------- |
| Bit  | modified: 1, |      | //   | modified 占 1 位 |            |
| Bit  | prot owner:  | 3;   | //   | prot_            | owner占3位 |
| Bit  | prot_group:  | 3;   | //   | prot             | group占3位 |
| Bit  | prot world:  | 3;   | //   | prot             | world占3位 |

// File的操作和数据成员 public:

//文件类型以八进制的形式表示，参见2.1.3节(第35页) enum modes { READ = 01, WRITE = 02, EXECUTE =03 };

File &open(modes);

void close (); void write (); bool isRead() const; void setWrite();

}；

mode位域占2个二进制位，modified只占1个，其他成员则各占3个。如果可能的话, 在类的内部连续定义的位域压缩在M—整数的相邻位，从而提供存储压缩。例如在之前的 声明中，五个位域可能会存储在同一个'unsigned int中。这些二进制位是否能压缩到 一个整数中以及如何压缩是与机器相关的。

取地址运算符(&)不能作用于位域，因此任何指针都无法指向类的位域。

WARNING



通常情况下最好将位域设为无符号类型，存储在带符号类型中的位域的行为将 因具体实现而定..

使用位域

访问位域的方式与访问类的其他数据成员的方式非常相似:

void File::write()

modified = 1;

"...

}

void File::close()

{

if (modified)

//……保存内容

}

通常使用内置的位运算符(参见4.8节，第136页)操作超过1位的位域：

< 856 I



File &File : : open (File : :modes m)

{

mode | = READ;    //按默认方式设置READ

II其他处理

if (m & WRITE)    // 如果打开了 READ 和 WRITE

//按照读/写方式打开文件 return *this;

}

如果一个类定义了位域成员，则它通常也会定义一组内联的成员函数以检验或设置位域的 值：

inline bool File::isRead() const { return mode & READ; } inline void File::setWrite()    { mode |= WRITE; }

19.8.2



volatile限定符

WARNING



volatile的确切含义与机器有关，只能通过阅读编译器文档来理解。要想让 使用了 volatile的程序在移植到新机器或新编译器后仍然有效，通常需要 对该程序进行某些改变。.

直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程 控制。例如，程序可能包含一个由系统时钟定时更新的变量=当对象的值可能在程序的控 制或检测之外被改变时，应该将该对象声明为volatileo关键字volatile告诉编译 器不应对这样的对象进行优化。

volatile限定符的用法和const很相似，它起到对类型额外修饰的作用:

volatile int display_register; volatile Task. *curr_task; volatile int iax[max_size]; volatile Screen bitmapBuf;



//该int值可能发生改变

// curr_task 指向一个 volatile 对象 / / iax 的每个元素都是volatile // bitmapBuf的每个成员都是volatile



const和volatile限定符互相没什么影响，某种类型可能既是const的也是 volatile的，此时它同时具有二者的属性。



就像一个类可以定义const成员函数一样，它也可以将成员函数定义成volatile 的。只有volatile的成员函数才能被volatile的对象调用。

2A2节(第56页)描述了 const限定符和指针的相互作用，在volatile限定符 和指针之间也存在类似的关系。我们可以声明volatile指针、指向volatile对象的 指针以及指向volatile对象的volatile指针：

int *volatile vip; // vip 是一个 volatile 指针，它指向 int volatile int *ivp; // ivp 是一个指针，它指向一个 volatile int // vivp 是一个 volatile 指针，它指向一个 volatile int

volatile int *volatile vivp;

int *ip = &v; ivp = &v; vivp = &v;



//错误：必须使用指向volatile的指针

//正确：ivp是一个指向volatile的指针

//正确：vivp是一个指向volatile的volatile指针

和const 一样，我们只能将一个volatile对象的地址（或者拷贝一个指向 volatile类型的指针）赋给一个指向volatile的指针。同时，只有当某个引用是 volatile的时，我们才能使用一个volatile对象初始化该引用。

合成的拷贝对volatile对象无效

const和volatile的一个重要区别是我们不能使用合成的拷贝/移动构造函数及赋 值运算符初始化volatile对象或从volatile对象赋值。合成的成员接受的形参类型 是（非volatile）常量引用，显然我们不能把一个非volatile引用绑定到一个 volatile对象上。

如果一个类希望拷贝、移动或赋值它的volatile对象，则该类必须自定义拷贝或 移动操作。例如，我们可以将形参类型指定为const volatile引用，这样我们就能利 用任意类型的Foo进行拷贝或赋值操作了：

class Foo {

public:

Foo (const volatile Foo&) ; // 从一个 volatile 对象进行拷贝 //将一个volatile对象賦值给一个非volatile对象 Foo& operator=(volatile const Foo&);

//将一个volatile对象赋值给一个volatile对象 Foo& operator=(volatile const Foo&) volatile;

// Foo类的剩余部分

尽管我们可以为volatile对象定义拷贝和赋值操作，但是一个更深层次的问题是拷贝 volatile对象是两有意义呢？不同程序使用volatile的目的各不相同，对上述问题 的回答与具体的使用目的密切相关。

###### 19.8.3 链接指示：extern "C"

C++程序有时需要调用其他语言编写的函数，最常见的是调用C语言编写的函数。像 所有其他名字一样，其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指 定返回类型和形参列表。对于其他语言编写的函数来说，编译器检查其调用的方式与处理 r858＞普通C++函数的方式相同，但是生成的代码有所区别。C++使用链接指示（linkage directive）

指出任意非C++函数所用的语言。

要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用，要求我 们必须有权访问该语言的编译器，并且这个编译器与当前的C++编译器是兼 容的。

声明一个非C++的函数

链接指示可以有两种形式：单个的或复合的=链接指示不能出现在类定义或函数定义 的内部。同样的链接指示必须在函数的每个声明中都出现。

举个例子，接下来的声明显示了 cstring头文件的某些C函数是如何声明的：

//可能出现在C++头文件〈cstring〉中的链接指示

//单语句链接指示

extern "C" size_t strlen (const char *);

//复合语句链接指^ extern "C*' {

int strcmp(const char*, const char*); char *strcat (char*, const char*);

}

链接指示的第一种形式包含一个关键字extern,后面是一个字符串字面值常量以及一个 “普通的”函数声明。

其中的字符串字面值常量指出了编写函数所用的语言。编译器应该支持对C语言的链 接指示。此外，编译器也可能会支持其他语言的链接指示，如extern MAda。、extern "FORTRAN "等，



链接指示与头文件

我们可以令链接指示后面跟上花括号括起来的若干函数的声明，从而一次性建立多个 链接。花括号的作用是将适用于该链接指示的多个声明聚合在一起，否则花括号就会被忽 略，花括号中声明的函数名字就是可见的，就好像在花括号之外声明的一样。

多重声明的形式可以应用于整个头文件。例如，C++的cstring头文件可能形如：

II复合语句链接指示 extern nC" {

\#include〈string.h>    //操作C风格字符串的C函数

}

当一个#inclUde指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声 明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含带自带<859] 链接指示的函数，则该函数的链接不受影响。

C++从C语言继承的标准库函数可以定义成C函數，但并非必须：决定使用C 还是C++实现c标准库，是每个C++实现的事情。

指向extern ”C"函数的指针

编写函数所用的语言是函数类型的一部分„因此，对于使用链接指示定义的函数来说，

它的每个声明都必须使用相同的链接指示。而且，指向其他语言编写的函数的指针必须与 函数本身使用相同的链接指示：

// pf指向一个C函数，该函数接受一■个int返回void extern "C" void (*pf) (int);

当我们使用pf调用函数时，编译器认定当前调用的是一个c函数。

指向C函数的指针与指向C++函数的指针是不一样的类型。一个指向C函数的指针

不能用在执行初始化或赋值操作后指向C++函数，反之亦然。就像其他类型不匹配的问题 一样，如果我们试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生错误：

void (*pfl) (int);    "指向一个 C++函数

extern "C" void (*pf2) (int) ;    // 指向一个 C 函数

pfl = pf2;    //错误：pfl和pf2的类型不同

有的C++编译器会接受之前的这种赋值操作并将其作为对语言的扩展，尽管从 严格意义上来看它是非法的,



![img](C++  Primer 5-199.jpg)



WARNING

链接指示对整个声明都有效

当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数 指针也有效：

// fl是一个C函数，它的形参是一个指向C函数的指针 extern "C" void f1(void(*)(int));

这条声明语句指出fl是一个不返回任何值的C函数。它有一个类型是函数指针的形参， 其中的函数接受一个int形参返回为空。这个链接指示不仅对fl有效，对函数指针同样 有效。当我们调用fl时.必须传给它一个C函数的名字或者指向C函数的指针。

因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给C++函数传入 一个指向C函数的指针，则必须使用类型别名(参见2.5.1节，第60页)：

1~860>    // FC是一个指向C函數的指针

extern nC” typedef void FC(int);

// f2是一个C++函数，该函数的形参是指向C函数的指针 void f2 (FC ”；

导出C++函数到其他语言

通过使用链接指示对函数进行定义，我们可以令一个C++函数在其他语言编写的程序 中可用：

// calc函数可以被C程序调用

extern "C" double calc(double dparm) { /*...*/ }

编译器将为该函数生成适合于指定语言的代码。

值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。例如， 我们不太可能把一个C++类的对象传给C程序，因为C程序根本无法理解构造函数、析 构函数以及其他类特有的操作。

对链接到C的顶处理器的支持

有时需要在C和C++中编译同一个源文件，为了实现这一目的，在编译C#版本的 程序时预处理器定义_ _cplusplus (两个下画线)。利用这个变量，我们可以在编译 C++程序的时候有条件地包含进来一些代码：

\#ifdef _cplusplus

//正确：1们正在编译C++租序 extern "C"

\#endif

int strcmp(const char*, const char*);

重载函数与链接指示

链接指示与重载函数的相互作用依赖r目标语言。如果目标语言支持重载函数，则为 该语言实现链接指示的编译器很可能也支持重载这些C++的函数。

C语言不支持函数重载，因此也就不难理解为什么一个C链接指示只能用于说明一组 重载函数中的某一个了：

//错误：两个extern "C"函数的名字相同 extern "C” void print(const char*); extern "C" void print(int);

如果在一组重载函数中有一个是C函数，则其余的必定都是C++函数：

<86T|



class SmallInt { /* . ..*/ }; class BigNum { /★...*/ };

// C函数可以在C或C++程序中调用 // C++函数重载了该函数，可以在C++程序中调用 extern "Cn double calc(double); extern Small工nt calc (const Smalllnt&); extern BigNum calc(const BigNumS);

C版本的calc函数可以在C或C++程序中调用，而使用了类类型形参的C++函数只能在 CM程序中调用，上述性质与声明的顺序无关。

###### 19.8.3节练习

练习19.26：说明下列声明语句的含义并判断它们是否合法:

extern "C" int compute(int *, int); extern "C” double compute(double *, double);

Cs§2＞小结

C++为解决某些特殊问题没置了一系列特殊的处理机制，

有的程序需耍精确控制内存分配过程,它们可以通过在类的内部或在全局作用域中自 定义operator new和operator delete来实现这•••-目的.如果应用程序为这两个操 作定义了自己的版本，则new和delete表达式将优先使用应用程序定义的版本。

冇的程序需要在运行时直接获取对象的动态类型，运行吋类型识别(RTTI)为这种程 序提供了语言级别的支持。RTTI只对定义了虚函数的类有效:对没有定义虚函数的类， 虽然也可以得到其类型信息，伹只是静态类型。

治我们定义指向类成妃的指针时，在指针类型中包含了该指针所指成员所属类的类型 信，0、。成员指针可以绑定到该类当中任意一个具有指定类型的成员上。当我们解引用成员 指针时，必须提供获取成员所需的对象。

C++定义了另外几种聚集类型：

•嵌套类，定义在其他类的作用域中，嵌变类通常作为外层类的实现类。

• union,是一种特殊的类，它可以定义几个数据成员但是在任意吋刻只有--个成员 有值，union通常嵌套在其他类的内部。

•局部类，定义在函数的内部，局部类的所有成员都必须定义在类内，局部类不能含 有静态数据成员。

C++支持儿种固有的不可移植的特性，其中位域和volatile使得程序更容易访问硬 件；链接指示使得程序更容易访W用其他语言编写的代码。

##### 术语农

匿名 union (anonymous union)未命名的 union,不能用于定义对象。匿名union 的成员也足外层作用域的成员，匿名union 不能包含成员函数，也不能包含私有成员 或受保护的成员。

位域(bit-field)特殊的类成员，该成员含 有-个整型值以指定为其分配的r:进制位 数。如果可能的话，在类中连续定义的位 域将被压缩在一个普通的整数值当中。

判别式(discriminant)是^ "■种使用一个对 象判断union的尚前值类型的编程技术。

dynamic_cast楚•一个运算符：执行从基类 向派牛:类的带检齊的强制类型转换。当基 类中至少含有一个虚函数时，该运算符负

0§3＞资检齊指针或引用所绑定的对象的动态类 型。如果对象类型与目标类型(或其派生 类)•致，则类型转换完成。否则，指针

转换将返回一个值为0的指针；引用转换 将抛出-个异常，

枚举类型(enumeration)将一组整型常量

命名后聚合在起形成的类型.

枚举成员(enumerator)是枚举类型的成

员。枚举成员是常量，町以用在任何耑耍 整型常量的地方。

free是定义在cstdlib中的低层函数， 负责释放内抒=free只能释放由malloc 分配的内存=

链接指示(linkage directive)支持C++程

序调用其他语言编写的函数的-•种机制。 所有编译器都应支持调用C++和C函数， 至于是否支特其他语言则由编译器决定。

局部类(local class)定义在函数中的类■, 局部类只有在其外展函数内町见。《部类



的所有成员都必须定义在类的内部。局部 类不能含有静态成员。局部类成员不能访 问外层函数的非静态变量，只能访问类型 名字、静态变量或枚举成员，

malloc是定义在cstdlib中的低层函数， 负责分配内存。malloc分配的内存必须 由free释放。

mem_fn是一个标准库类模板，根据指向 成员函数的指针生成一个可调用对象。

嵌套类(nestedclass)定义在其他类内部 的类，嵌套类定义在它的外层作用域中： 在外层类的作用域中嵌套类的名字必须唯 一，在外层类之外可以被重用=在外层类 之外W W嵌套类需要用作用域运算符指明 嵌套类所属的范围。

嵌套类型(nested type) “嵌套类”的同

义词。

不可移植(nonportable)固有的与机器有

关的特性，当程序转移到其他机器或编泽 器上时需要修改代码。

operator delete是一个标准序•函数，用于

释放由operator new分配的未指明类型 的、末构造的内存空间。相应的， operator delete []释放由 operator new []为数组分配的内存。

operator new是一个标准库函数，用于分

配一个给定大小的、未指明类型的、未构 造的内存空间。标准库函数operator new []为数组分配原始内存。与 allocator类相比，这两个标准库函数提 供的内存分配机制更低级。现代的C++程 序应该使用allocator而不是这两个函 数。

定位 new 表达式(placement new expression)是new的一种特殊形式，在 给定的内存中构造对象。它不分配内存， 而是根据实参指定在哪儿构造对象。它是 对allocator类的construct成员的 行为的一种低级模拟，

成员指针(pointer to member)其中既包

含类类型，也包含指针所指的成员类型。

成员指针的定义必须同时指定类的名字以 及指针所指的成员类型，

T C::*pmem = &C::member;

该语句将pmem定义为一个指针，它可以 指向类C的成员，并且该成员的类型是T,

然后初始化pmem令其指向类C的名为 member的成员。要使用该指针，我们必 须提供C的一个对象或指针：

classobj.*pmem； classptr->*pmem;

从classptr所指的对象classobj中获〈864 1 取 membero

运行时类型识别(run-time type identification)是C++的一种特性，允许 在运行时获取指针或引用的动态类型。

RTTI 运算符包括 typeid 和 dynamic_cast.为含有慮函数的类的指 针或引用&供动态类型。当作用于其他类 型时，返阿的结果是指针或引用的静态类 型。

限定作用域的枚举类型(scoped enumeration)是-…•种新的枚举类型，它 的枚举成员不能波外层作用域直接i方问。

typeid 运算符(typeid operator)是一个

一元运算符，返回标准库类型type_info 的引用，表示给定表达式的类型。表达 式是某个含有虚函数的类型的对象时，返 回表达式的动态类型：此类表达式在运行 时求值。如果表达式的类型是指针、引用 或其他未定义虚函数的类型，则返回指针、

引用或对象的静态类型；此类表达式不会 被求值=

typejnfo typeid运算符返回的标准库 类型。type_info的细节因机器而异，但 是必须提供一组操作，其中名为name的 函数负责返回一个表示类型名字的字符 串。type_info对象不能被拷贝、移动或 赋值。

联合(union)是一种和类有些相似的类 型。可以包含多个数据成员，但是同一时 刻只能有一个成员有值。联合可以有包括

构造函数和析构函数在内的成员函数。联 合不能被用作基类。在C++11新标准中， 联合可以含有类类型的成员，前提是这些 类自定义了拷贝控制成员，对于这样的联 合來说，如果它们没有定义自己的拷贝控 制成员，则编译器将为它们生成删除的 版本。

不限定作用域的枚举类型(unscoped enumeration)该枚举类型的枚举成员在 枚举类型的外层作用域中可以访问。

volatile是一种类型限定符，告诉编译器变 跫可能在程序的直接控制之外发生改变。 它起到一种标示的作用，令编译器不对代 码进行优化操作。
