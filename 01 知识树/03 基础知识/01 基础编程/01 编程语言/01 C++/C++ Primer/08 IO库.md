### 第n部分 C++标准库

<307]



内容

随着C++版本的一次次修订，标准库也在不断成长。确实，新的C++标准中有三分之 二的文本都用來描述标准库。虽然我们不能深入讨论所有标准库设施，俏有些核心库没施 是每个C++程序员都应该熟练掌握的，第二部分将介绍这些内容。

我们首先在第8拳中介绍基本的IO库设施。除了使用标准库读写与控制台窗口相关 联的流之外，我们还将学习其他一些库类型，可以帮助我们读写命名文件以及完成到 string对象的内存1O操作。

标准库的核心是很多容器类和一族泛型算法，这辟没施能帮助我们编写简洁高效的程 序，标准库会去关注那些簿记操作的细节，特别是内存管理，这样我们的程序就可以将令 部注意力投入到需要求解的问题上。

我们在第3章中已经介绍了容器类型vector,在第9章中将介绍更多vector相关 的内容，这一章也会涉及其他顺序容器，我们还会介绍更多string类型所支持的操作， 可以将string看作一种只包含字符元素的特殊容器。string支持很多容器操作，但并 不是全部。

< 308 I



第10章介绍泛型算法。这类算法通常在顺序容器一定范围内的元素上或其他类型的 序列上进行操作。算法库为各种经典算法提供了高效的实现，如排序和搜索算法，还提供 了其他一些常用操作。例如，标准庳提供了 copy算法，完成一个序列到另一个序列的元 素拷贝；还提供了 find算法，实现给定元素的查找，等等。泛型算法的通用性体现在两 个层面：可应用于不同类型的序列；对序列中元素的类型限制小，大多数类型都是允许的。

标准库还提供了一些关联容器，第11章介绍这部分内容。关联容器中的元素是通过 关键字来访问的，关联容器支持很多顺序容器的操作，也定义了一些自己特有的操作，

第12章是第二部分的最后一章，这一章介绍动态内存管理相关的一些语言特性和库 设施。这一章介绍智能指针的一个标准版本，它是新标准库中最重要的类之一。通过使用 智能指针，我们可以大幅度提高使用动态内存的代码的鲁棒性。这一章最后将给出一个较 大的例子，使用了第n部分介绍的所有标准库设施。

#### 第8章

< 309 j

 IO库

内容

..................................................................................................................290

C杆语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理10。这些 类型支持从设备读取数裾、向设备写入数据的IO操作，没备可以是文件、控制台脔口等。 还有一些类型允许内存10,即，从string读取数据，向string写入数据。

10库定义了读写内置类型值的操作。此外，一些类，如string,通常也会定义类似 的1O操作，来读写自己的对象。

本章介绍10库的基本内容。后续章节会介绍更多IO库的功能：第14章将会介绍如 何编写自己的输入输出运算符，第17章将会介绍如何控制输出格式以及如何对文件进行 随机访问。

ESD>    我们的程序已经使用了很多IO库设施了。我们在1.2节（第5页）已经介绍了大部

分IO库设施：

•    istream （输入流）类型，提供输入操作。

•    ostream （输出流）类型，提供输出操作。

•    cin, 一个istream对象，从标准输入读取数裾。

•    cout，一个ostream对象，向标准输出写入数据。

•    cerr, 一个ostream对象，通常用于输出程序错误消息，写入到标准错误。

•〉〉运算符，用来从一个istream对象读取输入数据。

•    «运算符，用来向一个ostream对象写入输出数据。

•    getline函数（参见3.3.2节，第78页），从一个给定的istream读取一行数据， 存入一个给定的string对象中。

袒8.1 IO类

到目前为止，我们已经使用过的IO类型和对象都是操纵char数据的。默认情况下， 这些对象都是关联到用户的控制台窗口的。当然，我们不能限制实际应用程序仅从控制台 窗口进行IO操作，应用程序常常需要读写命名文件。而且，使用IO操作处理string中 的字符会很方便。此外，应用程序还可能读写需要宽字符支持的语言。

为了支持这些不同种类的IO处理操作，在istream和ostream之外，标准库还定 义了其他一些10类型，我们之前都已经使用过了，表8.1列出了这些类型，分别定义在 三个独立的头文件中：iostream定义了用于读写流的基本类型，fstream定义了读写 命名文件的类型，sstream定义了读写内存string对象的类型。

| 表8.1: I0库类型和头文件 |                                                              |
| ----------------------- | ------------------------------------------------------------ |
| 头文件                  | 类型                                                         |
| iostream                | istream, wistream从流读取数据 ostream，wostream向流写入数据 iostream, wiostream 读写流 |
| fstream                 | if stream, wif stream从文件读取数据 of stream, wof stream向文件写入数据 fstream，wfstream 读写文件 |
| sstream                 | istringstream, wistringstream 从 string 读取数据 ostringstream, wostringstream 向 string 写入数据 stringstream, wstringstream 读写 string |

rW>    为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t类型的

数据（参见2.1.1节，第30页）。宽字符版本的类型和函数的名字以一个w开始。例如， wcin、wcout和wcerr是分别对应cin、cout和cerr的宽字符版对象。宽字符版本 的类型和对象与其对应的普通char版本的类型定义在同一个头文件中。例如，头文件 fstream 定义了 if stream 和 wif stream 类型。

IO类型间的关系

概念上，设备类型和字符大小都不会影响我们要执行的IO操作。例如，我们可以用 >>读取数据，而不用管是从一个控制台窗口，一个磁盘文件，还是一个string读取。类 似的，我们也不用管读取的字符能存入一个char对象内，还是需要一个wchar_t对象 来存储。

标准库使我们能忽略这些不同类型的流之间的差异，这是通过继承机制（inheritance） 实现的。利用模板（参见3.3节，第87页），我们可以使用具有继承关系的类，而不必了 解继承机制如何工作的细节=我们将在第15章和18.3节（第710页）介绍C++是如何支 持继承机制的。

简单地说，继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将 一个派生类（继承类）对象当作其基类（所继承的类）对象来使用。

类型ifstream和istringstream都继承自istream。因此，我们可以像使用 istream对象一样來使用if stream和istringstream对象。也就是说，我们是如何 使用cin的，就可以同样地使用这些类型的对象。例如，可以对一个ifstream或 istringstream对象调用getline ,也可以使用 >> 从-•个ifstream或 istringstream对象中读取数裾。类似的，类型of stream和ostringstream都继 承自ostream。因此，我们是如何使用cout的，就可以同样地使用这些类型的对象。

![img](C++  Primer 5-76.jpg)



本节剩下部分所介绍的标准库流特性都可以无差别地应用于普通流、文件流和 string流，以及char或宽字符流版本•

###### 8.1.1 IO对象无拷贝或赋值

如我们在7.1.3节（第234页）所见，我们不能拷贝或对10对象赋值： ofstream outl, out2;

outl = out2;    //错误：不能对流对象賦值

ofstream print （of stream） ;    // 错误：不能初始化 of stream 参数

out2 = print （out2） ;    //错误：不能拷贝流对象

由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型（参见6.2.1节， 第188页）。进行1O操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变 其状态，因此传递和返回的引用不能是const的。

###### 8.1.2条件状态    <3ia

io操作一个与生俱来的问题是可能发生错误。一些错误是可恢复的，而其他错误则 发生在系统深处，已经超出了应用程序可以修iE的范围。表8.2列出了 IO类所定义的一 些函数和标志，可以帮助我们访问和操纵流的条件状态（condition state）。

| 表8.2: IO库条件状态 |                                                              |
| ------------------- | ------------------------------------------------------------ |
| strm : : iostate    | strm是一种10类型，在表8.1 （第278页）中已列出。iostate 是一种机器相关的类型，提供了表达条件状态的完整功能 |
| strm: : badbit      | strm: : badbi t用来指出流已崩溃                              |
| strm: : failbit     | strm:: failbit用来指出一个IO操作失败了                       |

续表

| strm: : eofbit    | strm: : eofbit用来指出流到达了文件结束                       |
| ----------------- | ------------------------------------------------------------ |
| strm: : goodbit   | : goodbit用来指出流未处于错误状态。此值保证为零              |
| s . eof()         | 若流s的eofbit置位，则返回true                                |
| s.failO           | 若流s的failbit或badbit置位，则返回true                       |
| s.bad()           | 若流s的badbit置位，则返回true                                |
| s.good()          | 若流s处于有效状态，则返回true                                |
| s.clear ()        | 将流s中所有条件状态位复位，将流的状态设置为有效。返回void    |
| s•clear (flags)   | 根据给定的flags标志位，将流s中对应条件状态位复位。flags 的类型为於削：：iostate。返回void |
| s.setstate(flags) | 根据给定的flags标志位，将流s中对应条件状态位置位。flags 的类型为於⑽：：iostate。返回void |
| s.rdstate()       | 返回流s的当前条件状态，返回值类型为strm: : iostate           |

下面是一个IO错误的例子：

int ival; cin » ival;

如果我们在标准输入上键入Boo,读操作就会失败。代码中的输入运算符期待读取一个 int,但却得到了一个字符B。这样，cin会进入错误状态。类似的，如果我们输入一个 文件结束标识，cin也会进入错误状态。

一个流一旦发生错误，其上后续的1O操作都会失败。只有当一个流处于无错状态时， 我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该 在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将 它当作一个条件来使用：

while （cin » word）

//ok:读操作成功......

while循环检查》表达式返回的流的状态。如果输入操作成功，流保持有效状态，则条 件为真。

查询流的状态

将流作为条件使用，只能告诉我们流是否有效，而无法告诉我们具体发生了什么。有 时我们也需要知道流为什么失败。例如，在键入文件结束标识后我们的应对措施，可能与 遇到一个IO设备错误的处理方式是不同的。

10库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。这 个类型应作为一个位集合来使用，使用方式与我们在4.8节中（第137页）使用quizl 的方式一样。IO库定义了 4个iostate类型的constexpr值（参见2.4.4节，第58页）， 表示特定的位模式。这些值用来表示特定类型的10条件，可以与位运算符（参见4.8节， 第137页）一起使用来一次性检测或设置多个标志位。

badbit表示系统级错误，如不可恢复的读写错误。通常情况下，一旦badbit被置 位，流就无法再使用了。在发生可恢复错误后，failbit被置位，如期望读取数值却读 出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。如果到达文件结束 位置，eofbit和failbit都会被置位。goodbit的值为0，表示流未发生错误。如果 badbit、failbit和eofbit任一个被置位，则检测流状态的条件会失败。

标准库还定义了一组函数来查询这些标志位的状态。操作good在所有错误位均未置 位的情况下返回true,而bad、fail和eof则在对应错误位被置位时返回true。此<3»] 外，在badbit被置位时，fail也会返回true。这意味着，使用good或fail是确定 流的总体状态的正确方法。实际上，我们将流当作条件使用的代码就等价于！ fail ()»而 eof和bad操作只能表示特定的错误。

管理条件状态

流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操 作将给定条件位置位，表示发生了对应错误。clear成员是一个重载的成员(参见6.4节， 第206页)：它有一个不接受参数的版本，而另一个版本接受一个iostate类型的参数。

clear不接受参数的版本清除(复位)所有错误标志位。执行clear ()后，调用good 会返回true。我们可以这样使用这些成员：

//记住cin的当前状态



auto old_state = cin.rdstate();



//记住cin的当前状态 //使cin有效 //使用cin //将cin置为原有状态



cin.clear();

process_input(cin); cin.setstate(old_state);

带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件 状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新 的状态。例如，下面的代码将failbit和badbit复位，但保持eofbit不变：    <2KI

//复位failbit和badbit,保持其他标志位不变

cin.clear(cin.rdstate() & 〜cin.failbit & 〜cin.badbit};

###### 8.1.2节练习

练习8.1:编写函数，接受一个istream&参数，返回值类型也是istream&。此函数 须从给定流中读取数据，直至遇到文件结束标识时停止。它将读取的数据打印在标准输 出上。完成这些操作后，在返回流之前，对流进行复位，使其处于有效状态。

练习8.2:测试函数，调用参数为cin»

练习8.3:什么情况下，下面的while循环会终止？ while (cin » i) /* ... ★/

###### 8.1.3管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下面的代码 os << "please enter a value:

文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。有了缓 冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的 写操作可能很耗吋，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大 的性能提升。

导致缓冲刷新(即，数据真正写到输出设备或文件)的原因有很多：

•程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。

•缓冲区满时.需要刷新缓冲，而后新的数据才能继续写入缓冲区。

•我们可以使用操纵符如endl （参见1.2节，第6页）来显式刷新缓冲区。

•在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓 冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立 即刷新的。

• 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到 的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout，因此， 读cin或写cerr都会导致cout的缓冲区被刷新=

刷新输出缓冲区

我们已经使用过操纵符endl,它完成换行并刷新缓冲区的工作。IO库中还有两个类 似的操纵符：flush和ends。flush刷新缓冲区，但不输出任何额外的字符：ends向 缓冲区插入一个空字符，然后刷新缓冲区：

cout << "hi!" << endl;    //输出hi和一个换行，然后刷新缓冲区

cout « "hi!n « flush; //输出hi,然后刷新缓冲区，不附加任何额外字符

cout « "hi ! " << ends;    //输出hi和一个空字符，然后刷新缓冲区

unitbuf操纵符

如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流 在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流， 使其恢复使用正常的系统管理的缓冲区刷新机制：

cout << unitbuf;    //所有輪■出操作后都会立即刷新缓冲区

//任何输出都立即刷新，无缓冲

cout « nounitbuf;    //回到正常的緩冲方式

笞告：如果程序崩溃，输出缓冲区不会被刷新

如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的 数据很可能停留在输出缓冲区中等待打印。

当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新 了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行 了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。

关联输入和输出流

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新 关联的输出流，标准库将cout和cin关联在一起，因此下面语句

cin » ival;

导致cout的缓冲区被刷新。

![img](C++  Primer 5-77.jpg)



交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示 信息，都会在读操作之前被打印出来

tie有两个重载的版本（参见6.4节，第206页）：一个版本不带参数，返回指向输

出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果 对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将 自己关联到此ostream。即，x. tie （&o）将流x关联到输出流o。

我们既可以将一个istream对象关联到另一个ostream,也可以将一个ostream 关联到另一个ostream：

cin. tie （Scout） ;    //仅仅是用来展示：标准库将cin和cout关联在一起

// old_tie指向当前关联到cin的流（如果有的话）

ostream *old_tie = cin. tie （nullptr） ; // cin 不再与其他流关联

//将cin与cerr关联；这不是一个好主意，因为cin应•该关联到cout cin.tie （&cerr） ;    // 读取 cin 会刷新 cerr 而不是 cout

cin. tie （old_tie） ;    //重建cin和cout间的正常关联

在这段代码中，为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了 tie。为了彻底解开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流，

但多个流可以同时关联到同一个ostream。

##### 8.2文件输入输出    粗

头文件fstream定义了三个类型来支持文件10: if stream从一个给定文件读取数据， ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。在17.5.3节中 （第676页）我们将介绍如何对同一个文件流既读又写。

这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样。特别是，

我们可以用IO运算符（＜＜和＞＞）来读写文件，可以用getline （参见3.2.2节，第79 页）从一个if stream读取数据，包括8.1节中（第278页）介绍的内容也都适用于这些 类型。

除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的 成员来管理与流关联的文件，在表8.3中列出了这些操作，我们可以对fstream、 if stream和ofstream对象调用这些操作，但不能对其他IO类型调用这些操作。

| 表8.3: fstream特有的操作  |                                                              |
| ------------------------- | ------------------------------------------------------------ |
| fstream fstrm;            | 创建一个未绑定的文件流。fstream是头文件fstream中定义的 一个类型 |
| fstream fstrm (s);        | 创建一个并打开名为s的文件。s可以是string类型，或者是一个指向C风格字符串的指针（参见3.5.4节，第109页）。 这些构造函数都是explicit的（参见7.5.4节，第265页）。默 认的文件模式mode依赖于fstream的类型 |
| fstream f strm (s, mode); | 与前一个构造函数类似，但按指定mode打开文件                   |
| fstrm.open (s)            | 打开名为s的文件，并将文件与fstrm绑定。s可以是一个 string或一个指向C风格字符串的指针。默认的文件mode依 赖于fstream的类型。返回void |
| f strm.close ()           | 关闭与fstrm绑定的文件。返回void                              |
| f strm.is_open ()         | 返回一个bool值，指出与fstrm关联的文件是资成功打开且尚 未关闭 |

###### 8.2.1使用文件流对象

当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。 每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位 给定的文件，并视情况打开为读或写模式。

创建文件流对象时，我们可以提供文件名（可选的k如果提供了一个文件名，则open 会自动被调用：

if stream in （ifile） ;    II构造一个：Lf stream并打开给定文件

of stream out;    II输出文件流未关联到任何文件

这段代码定义了一个输入流in，它被初始化为从文件读取数据，文件名由string类型 的参数ifile指定。第二条语句定义了一个输出流out,未与任何文件关联。在新C++

間标准中，文件名既可以是库类型string对象，也可以是C风格字符数组（参见3.5.4节， 1 第109页）。旧版本的标准库只允许C风格字符数组。

用 fstream 代替 iostream&

我们在8.1节（第279页）已经提到过，在要求使用基类型对象的地方，我们可以用 继承类型的对象来替代。这意味着，接受一个iostream类型引用（或指针）参数的函 数，可以用一个对应的fstream （或sstream）类型来调用。也就是说，如果有一个函 数接受一个ostreamS参数，我们在调用这个函数时，可以传递给它一个ofstream对 象，对istream&和if stream也是类似的。

例如，我们可以用7.1.3节中的read和print函数来读写命名文件。在本例中，我 们假定输入和输出文件的名字是通过传递给main函数的参数来指定的（参见6.2.5节， 第196页）：

//打开销售记录文件 //打开输出文件 //保存销售总额的变量 //读取第一条销售记录 //保存下一条销售记录的变量



ifstream input(argv[1]); ofstream output(argv[2]); Sales_data total; if (read(input, total))    {

Sales_data trans;

//读取剩余记录



//检查isbn //更新销售总额

//打印结果 //处理下一本书



while(read(input, trans))    {

if (total.isbn () == trans.isbn()) total.combine(trans);

else {

print(output, total) « endl; total = trans;

}

}

print （output, total） « endl; //打印最后一本书的销售额 else    //文件中无输入数据

cerr « "No data?!" « endl;

除了读写的是命名文件外，这段程序与229页的加法程序几乎是完全相同的。重要的部分 是对read和print的调用。虽然两个函数定义时指定的形参分别是istream&和 ostream&,但我们可以向它们传递fstream对象。

I 318〉成员函数open和close

如果我们定义了一个空文件流对象，可以随后调用open来将它与文件关联起来:

ifstream in (ifile) ;    //构筑一个if stream并打开给定文件

of stream out;    / /愉出文件流未与任何文件相关联

out. open (if ile + ".copy");    / / 打开指定文件

如果调用open失败，failbit会被置位(参见8丄2节，第280页)。因为调用open 可能失败，进行open是否成功的检测通常是一个好习惯：

if (out) //检查open是否成功

// open成功，我们可以使用文件了

这个条件判断与我们之前将cin用作条件相似。如果open失败，条件会为假，我们就不 会去使用out 了。

一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的 文件流调用open会失败，并会导致failbit被置位。随后的试图使用文件流的操作都 会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一旦文件成 功关闭，我们可以打开新的文件：

in. close () ;    // 关闭文件

in.open (ifile + "2"〉；    // 打幵另一个文件

如果open成功，则open会设置流的状态，使得good ()为true。

自动构造和析构

考虑这样一个程序，它的main函数接受一个要处理的文件列表(参见6.2.5节，第 196页)。这种程序可能会有如下的循环：

//对每个传递给程序的文件执行循环操作

for (auto p = argv + 1; p != argv + argc; ++p)    {

ifstream input (*p);    //创建输出流并打开文件

if (input) {    //如果文件打开成功，“处理”此文件

process(input);

} else

cerr « "couldn't open: ’’ + string (*p);

} //每个循环步input都会离开作用域，因此会被销毁

每个循环步构造一个新的名为input的ifstream对象，并打开它来读取给定的文件。 像之前一样，我们检查open是否成功。如果成功，将文件传递给一个函数，该函数负责 读取并处理输入数据，如果open失败，打印一条错误信息并继续处理下一个文件。

因为input是while循环的局部变量，它在每个循环步中都要创建和销毁一次(参 见5.4.1节，第165页)。当一个fstream对象离开其作用域时，与之关联的文件会自动 关闭。在下一步循环中，input会再次被创建。

###### 50 8.2.2文件模式

每个流都有一个关联的文件模式(file mode),用來指出如何使用文件。表8.4列出了 文件模式和它们的含义。

表8.4:文件模式

| in     | 以读方式打开                 |
| ------ | ---------------------------- |
| out    | 以写方式打开                 |
| app    | 每次写操作前均定位到文件末尾 |
| ate    | 打开文件后立即定位到文件末尾 |
| trunc  | 截断文件                     |
| binary | 以二进制方式进行IO           |

无论用哪种方式打开文件，我们都可以指定文件模式，调用open打开文件时可以， 用一个文件名初始化流来隐式打开文件时也可以。指定文件模式有如下限制：

•只可以对of stream或f stream对象设定out模式。

•只可以对if stream或f stream对象设定in模式。

•只有当out也被设定时才可设定trunc模式。

•只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定 out模式，文件也总是以输出方式被打开。

•默认情况下，即使我们没有指定trtmc,以out模式打开的文件也会被截断。为 了保留以out模式打开的文件的内容，我们必须同时指定app模式，这样只会将 数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作(参 见17.5.3节，第676页，将介绍对同一个文件既进行输入又进行输出的方法)。

• ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组 合使用。

每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认 模式。与ifstream关联的文件默认以in模式打幵；与ofstream关联的文件默认以 out模式打开；与f stream关联的文件默认以in和out模式打幵。

□20＞以out模式打开文件会丢弃已有数据

默认情况下，当我们打开一个of stream时，文件的内容会被丢弃。阻止一个 of stream清空给定文件内容的方法是同时梢定app模式：

//在这几条语句中，filel都被截断

of stream out ("filel"); //隐含以输出模式打开文件并截断文件 of stream out2 ("filel", ofstream: :out) ; // 隐含地截断文件 ofstream out3("filel", ofstream::out | ofstream::trunc);

//为了保留文件内容，我们必须显式指定app模式

ofstream app("file2", of stream: : app) ; // 隐含为输出模式 ofstream app2("file2", ofstream::out | ofstream::app);

WARNING



保留被ofstream打开的文件中已有数据的唯一方法是显式指定或in 模式、

每次调用open时都会确定文件模式

对于一个给定流，每当打开文件时，都可以改变其文件模式。

of stream out; //未指定文件打开模式

out.open ("scratchpad"}; //模式隐含设置为输出和截断

out. close () ; //关闭out,以便我们将其用于其他文件

out. open ("precious", of stream: : app) ; // 模式为输出和追加

out.close ();

第一个open调用未显式指定输出模式，文件隐式地以out模式打幵。通常情况下，out 模式意味着同时使用trtmc模式。因此，当前目录下名为scratchpad的文件的内容将 被清空。当打开名为precious的文件时，我们指定了 append模式。文件中已有的数 据都得以保留，所有写操作都在文件末尾进行。

![img](C++  Primer 5-80.jpg)



在每次打开文件时，都要设置文件模式，可能是显式地设置，也可能是隐式地 设置。当程序未指定模式时，就使用默认值。

###### 8.2.2节练习

练习8.7:修改上一节的书店程序，将结果保存到一个文件中。将输出文件名作为第二 个参数传递给main函数。

练习8.8:修改上一题的程序，将结果追加到给定的文件末尾。对同一个输出文件，运 行程序至少两次，检验数据是否得以保留。

##### 8.3 string 流

<32T|



sstream头文件定义了三个类型来支持内存［O,这些类型可以向string写入数据， 从string读取数据，就像string是一个10流一样。

istringstream 从 string 读耳又数据，ostringstream 向 string 写入数据， 而头文件stringstream既可从string读数据也可向string写数据。与fstream 类型类似，头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件 中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理 与流相关联的string。表8.5列出了这些操作，可以对stringstream对象调用这些 操作，但不能对其他10类型调用这些操作。

| 表8.5: stringstream特有的操作 |                                                              |
| ----------------------------- | ------------------------------------------------------------ |
| sstream s t rm;               | strm是一个未绑定的stringstream对象。sstream是头文件 sstream中定义的一个类型 |
| sstream strm (s);             | strm是一个sstream对象，保存string s的一个拷贝。此构造函 数是explicit的(参见7.5.4节，第265页) |
| strm.str()                    | 返回strm所保存的string的拷贝                                 |
| strm.str(s)                   | 将string s拷贝到strm中。返回void                             |

###### 8.3.1 使用 istringstream

当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单同

时，通常可以使用istringstreamo

考虑这样一个例子，假定有一个文件，列出了一些人和他们的电话号码。某些人只有 —个号码，而另一些人则有多个——家庭电话、工作电话、移动电话等。我们的输入文件 看起来可能是这样的：

morgan 2015552368 8625550123 drew 9735550130

lee 6095550132 2015550175 8005550000

文件中每条记录都以一个人名开始，后面跟随一个或多个电话号码。我们首先定义一个简 单的类来描述输入数据：

//成员默认为公有；参见7.2节(第240页) struct Personlnfo {

string name; vector<string> phones;

}；

类型Personlnfo的对象会有一个成员来表示人名，还有一个vector来保存此人的所 有电话号码。

I 322〉    我们的程序会读取数据文件，并创建一个Personlnfo的vector。vector中每个

元素对应文件中的一条记录。我们在一个循环中处理输入数据，每个循环步读取一条记录， 提取出一个人名和若干电话号码：

string line, word;    //分别保存来自输入的一行和单词

vector<Person工nfo> people;    //保存来自输入的所有记录

//逐行从输入读取数据，直至cin遇到文件尾(或其他错误) while (getline(cin, line))    {

Personlnfo info;    //创建一个保存此记录数据的对象

istringstream record (line) ;    // 将i己录彭P定至0冈1J读入的4亍

record » info.name;    // 读取名字

while (record >> word)    //读耳又电话号码

info .phones .push—back (word) ; // 保持它们

people .push_back (info) ;    // 将分匕i己录追加至4 people 末尾

}

这里我们用getline从标准输入读取整条记录。如果getline调用成功，那么line 中将保存着从输入文件而来的一条记录。在while中，我们定义了一个局部Personlnfo 对象.來保存当前记录中的数据。

接下来我们将一个istringstream与刚刚读取的文本行进行绑定，这样就可以在 此istringstream上使用输入运算符来读取当前记录中的每个元素。我们首先读取人 名，随后用一个while循环读取此人的电话号码。

当读取完line中所有数据后，内层while循环就结束了。此循环的工作方式与前 面章节中读取cin的循环很相似，不同之处是，此循环从一个string而不是标准输入 读取数据。当string中的数据全部读出后，同样会触发“文件结束”信号，在record 上的下一个输入操作会失败。

我们将刚刚处理好的Personlnfo追加到vector中，外层while循环的一个循环 步就随之结束了。外层while循环会持续执行，直至遇到cin的文件结朿标识。

###### 8.3.1节练习

练习8.9：使用你为8.1.2节（第281页）第一个练习所编写的函数打印一个 istringstream对象的内容。

练习8.10:编写程序，将来自一个文件中的行保存在一个vector<string>中。然后 使用一个istringstream从vector读取数据元素，每次读取一个单词。

练习8.11:本节的程序在外层while循环中定义了 istringstream对象。如果 record对象定义在循环之外，你需要对程序进行怎样的修改？重写程序，将record 的定义移到while循环之外，验证你设想的修改方法是否正确。

练习8.12：我们为什么没有在Personlnfo中使用类内初始化？

###### 8.3.2 使用 ostringstream

< 323 I



当我们逐步构造输出，希望最后一起打印吋，ostringstream是很有用的。例如， 对上一节的例子，我们可能想逐个验证电话号码并改变其格式。如果所有号码都是有效的， 我们希望输出一个新的文件，包含改变格式后的号码。对于那些无效的号码，我们不会将 它们输出到新文件中，而是打印一条包含人名和无效号码的错误信息。

由于我们不希望输出有无效电话号码的人，因此对每个人，直到验证完所有电话号码 后才可以进行输出操作。但是，我们可以先将输出内容“写入”到一个内存 ostringstream 中：

for (const auto Sentry : people) { // 对 people 中每一项

ostringstream formatted, badNums; // 每个循琢步创建的对象 for (const auto &nums : entry .phones) { // 对每个数

if (!valid(nums))    {

badNums <<”’’<< nums; //将数的字符串形式存入badNums } else

//将格式化的字符串“写入” formatted

formatted « " " << format(nums);

}

if (badNums . str () . empty () )    // 没有错误的数

os « entry.name « "    // 打印名字

« formatted. str () « endl;    // 和格式化的数

else //否则，打印名字和错误的数

cerr « "input error: " « entry.name

« " invalid number(s) " « badNums.str() « endl;

在此程序中，我们假定已有两个函数，valid和format,分别完成电话号码验证和改变 格式的功能。程序最有趣的部分是对字符串流formatted和badNums的使用。我们使 用标准的输出运算符（《）向这些对象写入数据，但这些“写入”操作实际上转换为string 操作，分别向formatted和badNums中的string对象添加字符。

###### 8.3.2节练习

练习8.13:重写本节的电话号码程序，从一个命名文件而非cin读取数据。 练习8.14:我们为什么将entry和nums定义为const auto&?

1~324> 小结    _

C++使用标准库类来处理面向流的输入和输出：

•    iostream处理控制台1O

•    fstream处理命名文件IO

•    stringstream 完成内存 string 的 10

类fstream和stringstream都是继承自类iostream的。输入类都继承自 istream，输出类都继承自ostream。因此，可以在istream对象上执行的操作，也 可在if stream或istringstream对象上执行。继承自ostream的输出类也有类似 情况。

毎个IO对象都维护一组条件状态，用来指出此对象上是否可以进行10操作。如果遇 到了错误——例如在输入流上遇到了文件末尾，则对象的状态变为失效，所有后续输入操 作都不能执行，直至错误被纠正。标准库提供了一组函数，用來设置和检测这些状态。

##### 术语表

条件状态(condition state)可被任何流类

使用的一组标志和函数.用来指出给定流 是否可用，

文件模式(file mode)类f stream定义的 一组标志，在打开文件时指定，用来控制 文件如何被使用。

文件流(file stream)用来读写命名文件的

流对象。除了普通的iostream操作，文 件流还定义了 open和close成员。成员 函数open接受一个string或一个C风 格字符串参数，指定要打开的文件名，它 还可以接受一个可选的参数，指明文件打 开模式。成员函数close关闭流所关联的 文件，调用close后才可以调用open打 开另一个文件。

fstream用于同时渎写一个相同文件的文 件流。默认情况下，fstream以in和out 模式打开文件。

ifstream用于从输入文件读取数据的文件 流。默认情况下，ifstream以in模式打 开文件。



继承(inheritance)程序设计功能，令一

个类型可以从另一个类型继承接口。类 ifstream 和 istringstream 继承自 istream, ofstream 和 ©stringstream 继承自ostream。第15章将介绍继承。

istringstream用来从给定string读取数 裾的字符串流。

ofstream用来向输出文件写入数据的文 件流。默认情况下，of stream以out模 式打开文件。

字符串流(string stream )用于读写

string的流对象，除了普通的iostream 操作外，字符串流还定义了一个名为str 的重载成员。调用str的无参版本会返冋 字符串流关联的string.调用时传递给 它一个string参数，则会将字符串流与 该string的一个拷贝相关联。

stringstream用于读写治定string的字 符串流。

 
