#### 第3章

### 字符串、向量和数组

内容

除了第2章介绍的内置类型之外,C++语言还定义了…个内容丰富的抽象数裾类型厍。 其中，string和vector是两利1最重要的标准浑类型，前者支持可聚长字符串，后者则 表示可变长的集合。还有•种标准库类型是迭代器,它是string和vector的配套类型， 常被用于访M string中的字符或vector中的元素。

内置数组是一种更基础的类型，string和vector都是对它的某种抽象。本章将分 别介绍数飢以及标准阵类型string和vector。

□T＞第2章介绍的内置类型是由C++语言直接定义的。这些类型，比如数字和字符，体现了大 多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型，它们尚 未直接实现到计算机硬件中。

本章将介绍两种最重要的标准库类型：string和vector。string表示可变长的 字符序列，vector存放的是某种给定类型对象的可变长序列。本章还将介绍内置数组类 型，和其他内置类型一样，数组的实现与硬件密切相关。因此相较于标准库类型string 和vector,数组在灵活性上稍显不足。

在开始介绍标准库类型之前，先来学习一种访问库中名字的简单方法。

粗3.1命名空间的using声明

目前为止，我们用到的库函数基本上都属于命名空间std,而程序也显式地将这一点 标示了出来。例如，std: :cin表示从标准输入中读取内容。此处使用作用域操作符（::） （参见1.2节，第7页）的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那 个名字。因此，std: :cin的意思就是要使用命名空间std中的名字cin。

上面的方法显得比较烦琐，然而幸运的是，通过更简单的途径也能使用到命名空间中 的成员。本节将学习其中--种最安全的方法，也就是使用using声明（usingdeclaration）, 18.2.2节（第702页）会介绍另一种方法。

有了 using声明就无须专门的前缀（形如命名空间：：）也能使用所需的名字了。 using声明具有如下的形式：

using namespace::name;

一旦声明了上述语句，就可以直接访问命名空间中的名字:

\#include <iostream>

// using声明，当我们使用名字cin时，从命名空间std中获取它 using std::cin;

int main()

{

int i;

cin » i; cout « i; std::cout « i; return 0;



//正确：ciri和std: : cin含义相同

//错误：没有对应的using声明，必须使用完整的名字 //正确：显式地从std中使用cout

每个名字都需要独立的using声明

按照规定，每个using声明引入命名空间中的一个成员。例如，可以把要用到的标 准库中的名字都以using声明的形式表示出来，重写1.2节（第5页）的程序如下：

I 83 >    #include <iostream>



//通过下列using声明，我们可以使用标准库中的名字 using std::cin;

using std::cout; using std::endl;

int main()

cout « "Enter two numbers:,' << endl;

int vl, v2; cin >> vl >> v2;

cout « "The sum of " « vl « " and " « v2 << "is " << vl + v2 << endl;

return 0;

}

在上述程序中，一开始就有对cin、cout和endl的using声明，这意味着我们不用再 添加std::形式的前缀就能直接使用它们。C++语言的形式比较自由，因此既可以一行只 放一条using声明语句，也可以一行放上多条。不过要注意，用到的每个名字都必须有 自己的声明语句，而且每句话都得以分号结束。

头文件不应包含using声明

位于头文件的代码（参见2.6.3节，第67页）一般来说不应该使用using声明。这 是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明， 那么每个使用了该头文件的文件就都会有这个声明。对下•某些程序来说，由于不经意间包 含了一些名字，反而可能产生始料未及的名字冲突。

一点注意事项

经本节所述，后面的所有例子将假设，但凡用到的标准库中的名字都已经使用using 语句声明过了。例如，我们将在代码中直接使用cin,而不再使用std: :cin»

为了让书中的代码尽量简洁，今后将不会再把所有using声明和#include指令一 一标出。附录A中的表A.1 （第766页）列出了本书涉及的所有标准库中的名字及对应的 头文件。

A

WARNING



读者请注意：在编译及运行本书的示例前请为代码添加必要的#include指令 和using声明；，

###### 3.1节练习

练习3.1:使用恰当的using声明重做I.4.1节（第11页）和2.6.2节（第67页）的练习。

##### 3.2    准库炎哦string    50

标准库类型string表示可变长的字符序列，使用string类型必须首先包含<~84~1 string头文件。作为标准库的一部分，string定义在命名空间std中。接下来的示例 都假定已包含了下述代码：

\#include <string> using std::string;

本节描述最常用的string操作，9.5节（第320页）还将介绍另外一些。

C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现 者做出一些性能上的需求' 因此，标准库类型对于一般应用场合来说有足够的 效率，

###### 3.2.1定义和初始化string对象

如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式， 只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。 表3.1列出了初始化string对象最常用的一些方式，下面是几个例子：

string si;    //默认初始化，si是一^空字符串

string s2 =    si;    //    s2 是 si 的副本

string s3 =    "hiya";    //    s3是该字符串字面值的副本

string s4 (10, ' c' ) ;    //    s4 的内容是 cccccccccc

可以通过默认的方式(参见2.2.1节，第40页)初始化一个string对象，这样就会得到 一个空的string，也就是说，该string对象中没有任何字符。如果提供了一个字符串 字面值(参见2.1.3节，第36页)，则该字面值中除了最后那个空字符外其他所有的字符 都被拷贝到新创建的string对象中去。如果提供的是一个数字和一个字符，则string 对象的内容是给定字符连续重复若干次肟得到的序列。

表3.1 ••初始化string对象的方式

| string | si           |             |
| ------ | ------------ | ----------- |
| string | s2           | (si)        |
| string | s2           | =si         |
| string | s3 ("value") |             |
| string | s3           | ="value     |
| string | s4           | (n,    'c') |



默认初始化，si是一个空串 s2是si的副本

等价于s2(sl)，s2是si的副本

S3是字面值"value”的副本，除了字面值最后的那个空字符外 等价于s3 ("value") , S3是字面值"value"的副本 把s4初始化为由连续n个字符c组成的串

直接初始化和拷贝初始化

由2.2.1节(第39页)的学习可知，C++语言有几种不同的初始化方式，通过string 我们可以清楚地看到在这些初始化方式之间到底有什么区別和联系。如果使用等号(=) 初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的 初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化

(direct initialization )o

当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果像上面的s4那样初 始化要用到的值有多个，一般来说只能使用直接初始化的方式：

string s5 = "hiya";    // 拷贝初始化

string s6(’’hiya");    // 直接初始化

string s7(10, ’ c’)；    // 直接初始化，s7 的内容是 cccccccccc

El5＞对于用多个值进行初始化的情况，非要用拷贝初始化的方式来处理也不是不可以，不过需 要显式地创建一个(临时)对象用于拷贝：

string s8 = string (10, r cf ) ; // 拷贝初始化，s8 的内容是 cccccccccc

s8的初始值是string (10,，c，)，它实际上是用数字10和字符c两个参数创建出来的 --个string对象，然后这个string对象又拷贝给了 s8。这条语句本质上等价于下面 的两条语句：

string temp (10, f cf ) ;    // temp 的内容是 cccccccccc

string s8 = temp;    // 将 temp 拷贝给 s8

其实我们可以看到，尽管初始化s8的语句合法.但和初始化s7的方式比较起来可读性 较差，也没有任何补偿优势。

###### 3.2.2 string对象上的操作    啦

一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，

类既能定义通过函数名调用的操作，就像SaleS_item类的isbn函数那样（参见1.5.2 节，第20页），也能定义＜＜、+等各种运算符在该类象上的新含义。表3.2中列举了 string 的大多数操作。

| 表3.2: string的操作 |                                                            |
| ------------------- | ---------------------------------------------------------- |
| os«s                | 将s写到输出流os当中，返回OS                                |
| is»s                | 从is中读取字符串赋给s,字符串以空白分隔，返回is             |
| getline (is, s)     | 从is中读取一行赋给s，返回is                                |
| s.empty()           | s为空返回true,否则返回false                                |
| s.size ()           | 返回s中字符的个数                                          |
| s [n]               | 返回s中第n个字符的引用，位置n从0计起                       |
| sl+s2               | 返回si和s2连接后的结果                                     |
| sl=s2               | 用s2的副本代替si中原来的字符                               |
| sl==s2              | 如果si和s2中所含的字符完全一样，则它们相等；string对象的相 |
| si!=s2              | 等性判断对字母的大小写敏感                                 |
| <,<=z >, >=         | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感       |

读写string对象

第I章曾经介绍过，使用标准库中的iostream来读写int、double等内置类型的 值。同样，也可以使用IO操作符读写string对象：

//注意：要想编译下面的代码还需要适当的#include语句和using声明 int main（）

{

string s;    //空字符串

cin » s;    //将string对象读入s，遇到空白停止

cout ＜＜ s « endl;    // 输出 s

return 0;

}

这段程序首先定义一个名为s的空string,然后将标准输入的内容读取到s中。在执行＜86~| 读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从 第一个真正的字符开始读起，直到遇见下一处空白为止。

如上所述，如果程序的输入是“    Hello World! ”（注意开头和结尾处的空

格），则输出将是“Hello”，输出结果中没有任何空格。

和内置类型的输入输出操作一样，string对象的此类操作也是返回运算符左侧的运 算对象作为其结果。因此，多个输入或者多个输出可以连写在一起：

string si, s2;

cin » si » s2;

cout « si « s2 « endl;



//把第一个输入读到si中，第二个输入读到s2中 //输出两个string对象

假设给上面这段程序输入与之前一样的内容“    Hello World! ”，输出将是

“HelloWorld!”。

读取未知数量的string对象

1.4.3节(第13页)的程序可以读入数量未知的整数，下面编写一个类似的程序用于 读取string对象：

int main()

{

string word;

while (cin >> word)    //反复读取.直至到达文件末尾

cout « word << endl;    //逐个输出单词，每个单词后面紧跟一个换行

return 0;

}

在该程序中，读取的对象是string而非int，但是while语句的条件部分和之前版本 的程序是一样的。该条件负责在读取时检测流的情况，如果流有效，也就是说没遇到文件

EJL>结朿标记或非法输入，那么执行while语句内部的操作。此时，循环体将输出刚刚从标 准输入读取的内容。重复若干次之后，一旦遇到文件结朿标记或非法输入循环也就结朿了。

使用getline读取一整行

有时我们希望能在最终得到的字符串中保留输入时的空白符，这吋应该用getline 函数代替原来的>>运算符。getline函数的参数是一个输入流和一个string对象，函 数从给定的输入流中读入内容，直到遇到换行符为止(注意换行符也被读进来了)，然后 把所读的内容存入到那个string对象中去(注意不存换行符)，getline只要一遇到换 行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的 一开始就是换行符，那么所得的结果是个空string。

和输入运算符一样，getline也会返回它的流参数，因此既然输入运算符能作为判 断的条件(参见1.4.3节，第13页)，我们也能用getline的结果作为条件。例如，可以 通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了：

int main()

{

string line;

//每次读入一整行，直至到达文件末尾 while (getline(cin, line))

cout << line << endl; return 0;

I

因为line中不包含换行符，所以我们手动地加上换行操作符。和往常一样，使用endl 结束当前行并刷新显示缓冲区。

![img](C++  Primer 5-30.jpg)



触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对 象中并不包含该换行符。

string 的 empty 和 size 操作

顾名思义，empty函数根据string对象是否为空返回一个对应的布尔值(参见第

2.1节，30页)。和Sales_item类(参见1.5.2节，第20页)的isbn成员一样，empty 也是string的一个成员数。调用该函数的方法很简单，只要使用点操作符指明是哪个 对象执行了 empty函数就可以了。

通过改写之前的程序，可以做到只输出非空的行：

II每次读入一整行，遇到空行直接跳过 while (getline(cinz line))

if (!line.empty())

cout « line « endl;

在上面的程序中，if语句的条件部分使用了逻辑非运算符(！)，它返回与其运算对象相 反的结果。此例中，如果str不为空则返回真。

size函数返回string对象的长度(即string对象中字符的个数)，可以使用size <88 | 函数只输出长度超过80个字符的行：

string line;

//每次读入一整行，输出其中超过80个字符的行 while (getline(cin, line))

if (line.size() > 80)

cout « line << endl;

string::size_type 类型

对于size函数来说，返回一个int或者如前面2.1.1节(第31页)所述的那样返回 —个unsigned似乎都是合情合理的。但其实size函数返回的是一个 string: : size_type类型的值，下面就对这种新的类型稍作解释。

string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了 标准库类型与机器无关的特性，类型siZe_type即是其中的一种。在具体使用的吋候， 通过作用域操作符来表明名字size_type是在类string中定义的。

尽管我们不太清楚string: : size_type类型的细节，但有一点是肯定的：它是一 个无符号类型的值(参见2.1.1节，第30 而且能足够存放下任何string对象的大小。 所有用于存放string类的size函数返回值的变量，都应该是string: : size_type 类型的。

过去，string: :size_type这种类型有点儿神秘，不太容易理解和使用。在C++11新 标准中，允许编译器通过auto或者decltype (参见2.5.2节，第61页)来推断变量的类型：岡

auto len = line .size () ; / / len 的类型是 string: : size_type

由于size函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符 号数和无符号数将可能产生意想不到的结果(参见2.1.2节，第33页)。例如，假设n是 -个具有负值的int，则表达式s . size () <n的判断结果几乎肯定是true-这是因为负

值n会自动地转换成一个比较大的无符号值。

![img](C++  Primer 5-31.jpg)



如果一条表达式中已经有了 size ()函数就不要再使用int 了，这样可以避免 混用int和unsigned可能带来的问题、

比较string对象

string类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较string

对象中的字符，并且对大小写敏感，也就是说，在比较时同一个字母的大写形式和小写形 式是不同的。

相等性运算符（==和!=）分别检验两个string对象相等或不相等，string对象相 等意味着它们的长度相同而且所包含的字符也全都相同。关系运算符＜、＜=、〉、＞=分别 检验一个string对象是否小于、小于等于、大于、大于等于另外一个string对象。上 述这些运算符都依照（大小写敏感的）字典顺序：

EZ^＞ 1.如果两个string对象的长度不同，而且较短string对象的每个字符都与较长 string对象对应位置上的字符相同，就说较短string对象小于较长string 对象。

2.如果两个string对象在某些对应的位置上不一致，则string对象比较的结果 其实是string对象中第一对相异字符比较的结果。

下面是string对象比较的一个示例：

string str = "Hello";

string phrase = "Hello World";

string slang = "Hiya";

根据规则1可判断，对象str小于对象phrase;根据规则2可判断，对象slang既大 于str也大于phrase。

为string对象赋值

一般来说，在设计标准库类型时都力求在易用性上向内置类型看齐，因此大多数库类 型都支持赋值操作。对于string类而言，允许把一个对象的值赋给另外一个对象：

string stl （10, ' c' ） , st2; // stl 的内容是 cccccccccc; st2 是一个空字符串 stl = st2;    //赋值：用st2的副本替换stl的内容

//此时stl和st2都是空字符串

两个string对象相加

两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右 侧的运算对象串接而成=也就是说，对string对象使用加法运算符（+ ）的结果是一个 新的string对象，它所包含的字符由两部分组成：前半部分是加号左侧string对象所 含的字符、后半部分是加号右侧string对象所含的字符。另外，复合赋值运算符（+=） （参见1.4.1节，第10页）负责把右侧string对象的内容追加到左侧string对象的 后面：

string si = "hello, ", s2 = "world\n";

string s3 = si + s2;    // s3 的内容是 hello, world\n

si += s2;    // 等价于 si = si + s2

字面值和string对象相加

如2.1.2节（第33页）所讲的，即使一种类型并非所需，我们也可以使用它，不过前 提是该种类型可以自动转换成所需的类型。因为标准库允许把字符字面值和字符串字面值 （参见2.1.3节，第36页）转换成string对象，所以在需要string对象的地方就可以 使用这两种字面值来替代。利用这一点将之前的程序改写为如下形式：

string si = "hello", s2 = "world"; // 在 si 和 s2 中都没有标点符号 string s3 = si + ", " + s2 + f\nr ;

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加 法运算符(+ )的两侧的运算对象至少有一个是string:

string s4 = si + ",，'；    //正确：把一个string对象和一个字面值相加    〈90 j

string s5 = "hello” + ", ••;    //错误：两个运算对象都不是string

//正确：每个加法运算符都有一个运算对象是string

string s6=sl+", "+ "world";

string s7 = "hello" + ", " + s2; //错误：不能把字面值直接相加

s4和s5初始化时只用到了一个加法运算符，因此很容易判断是否合法。s6的初始化形 式之前没有出现过，但其实它的工作机理和连续输入连续输出(参见1.2节，第6页)是 一样的，可以用如下的形式分组：

string s6 = (si + ", ") + "world";

其中子表达式sl + ”，"的结果是一个string对象，它同时作为第二个加法运算符的左 侧运算对象，因此上述语句和下面的两个语句是等价的：

string tmp = sl + *',    //正确：加法运算符有一个运算对象是string

s6 = tmp + "world" ;    //正确：加法运算符有一个运算对象是string

另一方面，s7的初始化是非法的，根据其语义加上括号后就成了下面的形式： string s7 = ("hello" + ", ") + s2; //错误：不能把字面值直接相加

很容易看到，括号内的子表达式试图把两个字符串字面值加在一起，而编译器根本没法做 到这一点，所以这条语句是错误的。

WARNING



因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是 标准库类型string的对象切记，字符串字面值与string是不同的类型。

###### 3.2.2节练习

练习3.2:编写一段程序从标准输入中一次读入一整行，然后修改该程序使其一次读入 一个词。

练习3.3:请说明string类的输入运算符和getline函数分别是如何处理空白字符 的。

练习3.4:编写一段程序读入两个字符串，比较其是否相等并输出结果。如果不相等， 输出较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长, 输出长度较大的那个字符串。

练习3.5:编写一段程序从标准输入中读入多个字符串并将它们连接在一起，输出连接 成的大字符串。然后修改上述程序，用空格把输入的多个字符串分隔开来。

###### 3.2.3处理string对象中的字符    啦

我们经常需要单独处理string对象中的字符，比如检查一个string对象是否包含 空白，或者把string对象中的字母改成小写，再或者査看某个特定的字符是否出现等。

这类处理的一个关键问题是如何获取字符本身。有时需要处理string对象中的每一 个字符，另外一些时候则只需处理某个特定的字符，还有些时候遇到某个条件处理就要停

下来。以往的经验告诉我们，处理这些情况常常要涉及语言和库的很多方面。

另一个关键问题是要知道能改变某个字符的特性。在cctype头文件中定义了一组标 准库函数处理这部分工作.表3.3列出了主要的函数名及其含义。

| 表3.3: cctype头文件中的函数 |                                                              |
| --------------------------- | ------------------------------------------------------------ |
| isalnum(c)                  | 当c是字母或数字时为真                                        |
| isalpha(c)                  | 当c是字母时为真                                              |
| iscntrl(c)                  | 当C是控制字符时为真                                          |
| isdigit(c)                  | 当C是数字吋为真                                              |
| isgraph(c)                  | 当C不是空格但可打印时为真                                    |
| islower(c)                  | 当C是小写字母时为真                                          |
| isprint(c)                  | 当C是可打印字符时为真（即C是空格或C具有可视形式）            |
| ispunct(c)                  | 当C是标点符号时为真（即C不是控制字符、数字、字母、可打印空白中的 一种） |
| isspace(c)                  | 当C是空白时为真（即C是空格、横向制表符、纵向制表符、回车符、换行 符、进纸符中的一种） |
| isupper(c)                  | 当C是大写字母时为真                                          |
| isxdigit(c)                 | 当C是十六进制数字时为真                                      |
| tolower(c)                  | 如果C是大写字母，输出对应的小写字母；否则原样输出C           |
| toupper(c)                  | 如果C是小写字母，输出对应的大写字母；否则原样输出C           |

进议：使用C++版本的C杉准库头文件

C++标准库中除了定义C++语言特有的功能外，也兼容了 C语言的标准库。C语言 的头文件形如C++则将这些文件命名为也就是去掉了 .h后缀，而在 文件名wazne之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。

因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上 来讲更符合C++语言的要求。特别的，在名为c/wme的头文件中定义的名字从属于命名 空间std,而定义在名为.h的头文件中的则不然。

一般来说，C++程序应该使用名为的头文件而不使用的形式，标准 库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不 时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。

处理每个字符？使用基于范围的for语句

如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11 新标准提供的一种语句：范围for （range for）语句。这种语句遍历给定序列中的每个元 素并对序列中的每个值执行某种操作，其语法形式是：

for （declaration : expression） statement

其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变 量，该变量将被用于访问序列中的基础元素。每次迭代，部分的变量会被初始 化为expression部分的下一个元素值。

一个string对象表示一个字符的序列，因此string对象可以作为范围for语句

中的expression部分。举一个简单的例子，我们可以使用范围for语句把string对象中 的字符每行一个输出出来：

string str ( "some string’’)；

//每行输出str中的一个字符

for (auto c : str)    //对于str中的每个字符

cout << c << endl;    //输出当前字符，后面紧跟一个换行符

for循环把变量c和str联系了起来，其中我们定义循环控制变量的方式与定义任意一 个普通变量是一样的。此例中，通过使用auto关键字(参见2.5.2节，第61页)让编译 器来决定变量c的类型，这里c的类型是char。每次迭代，str的下一个字符被拷贝给 c,因此该循环可以读作“对于字符串str中的每个字符c，”执行某某操作。此例中的“某 某操作”即输出一个字符，然后换行。

< 92 I



举个稍微复杂一点的例子，使用范围for语句和ispunct函数来统计string对象 中标点符号的个数：

string s ("Hello World!!!");

// punct_cnt的类型和s . size的返回类型一样；参见2.5.3节(第62页)

decitype(s.size()) punct cnt = 0;



//统计s中标点符号的数量 for (auto c : s)

if (ispunct(c)) ++punct_cnt;

cout « punct_cnt



//对于s中的每个字符 //如果该字符是标点符号 //将标点符号的计数值加1



« " punctuation characters in " << s « endl;



程序的输出结果将是:

3 punctuation characters in Hello World!!!

这里我们使用decltype关键字(参见2.5.3节，第62页)声明计数变量punct_cnt， 它的类型是s . size函数返回值的类型，也就是string: : size_type。使用范围for 语句处理string对象中的每个字符并检查其是否是标点符号。如"果是，使用递增运算符 (参见1+4+1节，第10页)给计数变量加1。最后，待范围for语句结束后输出统计结果。

<93~1



使用范围for语句改变字符串中的字符

如果想要改变string对象中字符的值，必须把循环变量定义成引用类型(参见2.3.1 节，第45页)。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制 变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改 变它绑定的字符。

新的例子不再是统计标点符号的个数了，假设我们想要把字符串改写为大写字母的形 式。为了做到这一点可以使用标准库函数toupper,该函数接收一个字符，然后输出其 对应的大写形式。这样，为了把整个string对象转换成大写，只要对其中的每个字符调 用toupper函数并将结果再赋给原字符就可以了：

string s ("Hello World!!!");

//转换成大写形式.

for (auto &c : s)    II对于s中的每个字符(注意：c是引用)

c = toupper (c) ;    // c是一个引用，因此赋值语句将改变s中字符的值

cout « s << endl;

上述代码的输出结果将是：

HELLO WORLD!!!

每次迭代时，变量c引用string对象s的下一个字符，赋值给c也就是在改变s 中对应字符的值。因此当执行下面的语句时，

c = toupper (c) ; // c是一引用，因此赋值语句将改变s中字符的值 实际上改变了 c绑定的字符的值。整个循环结束后，str中的所有字符都变成了大写形式。

只处理一部分字符？

如果要处理string对象中的每一个字符，使用范围for语句是个好主意。然而， 有时我们需要访问的只是其中一个字符，或者访问多个字符但遇到某个条件就要停下来。 例如，同样是将字符改为大写形式，不过新的要求不再是对整个字符串都这样做，而仅仅 把string对象中的第一个字母或第一个单词大写化。

要想访问string对象中的单个字符有两种方式：一种是使用下标，另外一种是使用 迭代器，其中关于迭代器的内容将在3.4节(第95页)和第9章中介绍。

下标运算符([])接收的输入参数是string : : size_type类型的值(参见3.2.2 节，第79页)，这个参数表示要访问的字符的位置：返回值i该位置上字符的引用。

string对象的下标从0计起。如果string对象s至少包含两个字符，则s[0]是 第1个字符、s[l]是第2个字符、s[s.size(>-l]是最后一个字符。

string对象的下标必须大于等于0而小于s . size ():.

![img](C++  Primer 5-33.jpg)



使用超出此范围的下标将引发不可预知的结果，以此推断，使用下标访问 空string也会引发不可预知的结果。

EK>    下标的值称作“下标”或“索引”，任何表达式只要它的值是一个整型值就能作为索

弓I。不过，如果某个索引是带符号类型的值将自动转换成由string: :SiZe_type (参 见2.1.2节，第33页)表达的无符号类型。

下面的程序使用下标运算符输出string对象中的第一个字符：

if (! s. empty () )    //确保确实有字符需要输出

cout « s[0] << endl;    //输出s的第一个字符

在访问指定字符之前，首先检查s是否为空。其实不管什么时候只要对string对象使用 了下标，都要确认在那个位置上确实有值。如果s为空，则3[0]的结果将是未定义的。

只要字符串不是常量(参见2.4节，第53页)，就能为下标运算符返回的字符赋新值。 例如，下面的程序将字符串的首字符改成了大写形式：

string s ("some string’’)；

if (! s .empty () )    //确保s [0]的位置确实有字符

s [0] = toupper (s [0] ) ;    //为s的第一个字符赋一个新值

程序的输出结果将是，

Some string

使用下标执行迭代

另一个例子是把S的第一个词改成大写形式：

//依次处理S中的字符直至我们处理完全部字符或者遇到一个空白 for (decltype(s.size()) index = 0;

index != s.size () && !isspace(s[index]); ++index)

s [index] = toupper (s [index] ) ; //将当前字符改成大写形式

程序的输出结果将是：

SOME string

在上述程序中，for循环使用变量index作为s的下标，index的类型是由decltype 关键字决定的。首先把index初始化为0,这样第一次迭代就会从s的首字符开始：之 后每次迭代将index加1以得到s的下一个字符。循环体负责将当前的字母改写为大写 形式。

for语句的条件部分涉及一点新知识，该条件使用了逻辑与运算符(&&)。如果参与 运算的两个运算对象都为真，则逻辑与结果为真；否则结果为假。对这个运算符来说最重 耍的一点是，C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况。如 此例所示，这条规定确保了只有当下标取值在合理范围之内时才会真的用此下标去访问字 符串。也就是说，只有在index达到s . size G之前才会执行s [index]。随着index 的增加，它永远也不可能超过s . size (>的值，所以可以确保index比s.size ()小。

捉尔：注意检查卜保的介法性

<95~1



使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0而小于字 符串的size ()的值a —种简便易行的方法是，总是设下标的类型为 string: : size_type,因为此类型是无符号数，可以确保下标不会小于0。此时，代 码只需保证下标7、于size()的值就可以了。

![img](C++  Primer 5-34.jpg)



C++标准并不要求标准库俭测下标是否合法，一旦使用了一个超出范围的下 标，就会产生不可预知的结果.

使用下标执行随机访问

在之前的示例中，我们让字符串的下标每次加1从而按顺序把所有字符改写成了大写 形式。其实也能通过计算得到某个下标值，然后直接获取对应位置的字符，并不是每次都 得从前往后依次访问。

例如，想要编写一个程序把0到15之间的十进制数转换成对应的十六进制形式，只 需初始化一个字符串令其存放16个十六进制“数字”：

const string hexdigits = "0123456789ABCDEF"; // 可能的十六进制数字 cout << "Enter a series of numbers between 0 and 15"

« " separated by spaces. Hit ENTER when finished:"

« endl;

string result;    //用于保存十六进制的字符串

string: :size_type n;    //用于保存从输入流读取的数

while (cin » n)

if (n < hexdigits.size () )    // 忽略无效输入

result += hexdigits [n] ;    //得到对应的十六进制数字

cout << "Your hex number is: " << result « endl;

假设输入的内容如下：

12 0 5 15 8 15

程序的输出结果将是：

Your hex number is: C05F8F

上述程序的执行过程是这样的：首先初始化变量hexdigits令其存放从0到F的十六进 制数字，注意我们把hexdigits声明成了常量(参见2.4节，第53页)，这是因为在后 面的程序中不打算再改变它的值。在循环内部使用输入值n作为hexdigits的下标， hexdigits [n]的值就是hexdigits内位置n处的字符。例如，如果n是15，则结果 是F;如果n是12,则结果是C,以此类推。把得到的十六进制数字添加到result内， 最后一并输出。

无论何时用到字符串的下标，都应该注意检查其合法性。在上面的程序中，下标n是 string: :SiZe_type类型，也就是无符号类型，所以n可以确保大于或等于0。在实 际使用吋，还需i查n是否小于hexdigits的长度。

###### 3.2.3节练习

练习3.6:编写一段程序，使用范围for语句将字符串内的所有字符用X代替。

练习3.7:就上一题完成的程序而言，如果将循环控制变量的类型设为char将发生什 么？先估计一下结果，然后实际编程进行验证。

练习3.8:分别用while循环和传统的for循环重写第一题的程序，你觉得哪种形式 更好呢？为什么？

练习3.9:下面的程序有何作用？它合法吗？如果不合法，为什么？ string s;

cout << s[0] « endl;

练习3.10:编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字 符串剩余的部分。

练习3.11:下面的范围for语句合法吗？如果合法，c的类型是什么？

const string s = "Keep out!"; for (auto-&c : s) {/*...*/}

###### 姆3.3标准库类型vector

标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对 象都有一个与之对应的索引，索引用于访问对象。因为vector “容纳着”其他对象，所 以它也常被称作容器(container).第II部将对容器进行更为详细的介绍。

要想使用vector,必须包含适当的头文件。在后续的例子中，都将假定做了如下 using声明：

^include <vector> using std::vector;

C++语言既有类模板(class template),也有函数模板，其中vector是一个类模板。 只有对C++有了相当深入的理解才能写出模板，事实上，我们直到第16章才会学习如何 自定义模板。幸运的是，即使还不会创建模板，我们也可以先试着用用它。

模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说 明。编译器根据模板创建类或函数的过程称为实例化(instantiation),当使用模板时，需 要指出编译器应把类或函数实例化成何种类型。

对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类， 需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括 号，在括号内放上信息。

以vector为例，提供的额外信息是vector内所存放对象的类型：

vector<int> ivec;    // ivec 保存 int 类型的对象

<97~|



vector<Sales_item> Sales_vec; // 保存 Sales_item 类型的对象 vector<vector<string>> file;    // 该向量的元素是 vector 对象

在上面的例子中，编译器根据模板vector生成了三种不同的类型：vector<int〉、 vector<Sales_item〉和 vector<vector<string〉〉0

![img](C++  Primer 5-35.jpg)



vector是模板而非类型，由vector生成的类型必须包含vector中元素的 类型，例如 vector<int〉o

vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象(参见2.3.1 节，第45页)，所以不存在包含引用的vector。除此之外，其他大多数(非引用)内置 类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。

需要指出的是，在早期版本的C++标准中如果vector的元素还是vector (或者其 他模板类型)，则其定义的形式与现在的C++11新标准略有不同。过去，必须在外层vector 对象的右尖括号和其元素类型之间添加一个空格，如应该写成vector<vector<int>〉 而非 vector<vector<int〉〉。

WARNING



某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对 象，如 vector<vector<int〉 >o

###### 3.3.1定义和初始化vector对象

和任何一种类类型一样，vector模板控制着定义和初始化向量的方法。表3.4列出 了定义vector对象的常用方法。

表3.4:初始化vector对象的方法

vector<T>

vector<T>

vector<T>

vector<T>

vector<T〉



vl

v2(vl) v2 = vl v3(n, val) v4 (n)



vector<T> v5 {a, b, c. . . } vector<T> v5={a,b,c...}



vl是一个空vector,它潜在的元素是T类型的，执行默认初始化

v2中包含有vl所有元素的副本

等价于v2(vl), v2中包含有vl所有元素的副本

v3包含了 11个重复的元素，每个元素的值都是val

v4包含了 n个重复地执行了值初始化的对象

v5包含了初始值个数的元素，每个元素被赋予相应的初始值

等价于 v5 {a,b, c. . .}



可以默认初始化vector对象（参见2.2.1节，第40页），从而创建一个指定类型的 空 vector：

vector<string> svec; //默认初始化，svec不含任何元素

看起来空vector好像没什么用，但是很快我们就会知道程序在运行时可以很高效地往 vector对象中添加元素。事实上，最常见的方式就是先定义一个空vector，然后当运 行时获取到元素的值后再逐一添加。

当然也可以在定义vector对象时指定元素的初始值。例如，允许把一个vector对 象的元素拷贝给另外一个vector对象。此时，新vector对象的元素就是原vector 对象对应元素的副本。注意两个vector对象的类型必须相同：

//初始状态为空



//把ivec的元素拷贝给ivec2

//把ivec的元素拷贝给ivec3

//错误：svec的元素是string对象，不是int



vector<int> ivec;

//在此处给ivec添加一些值 vector<int> ivec2(ivec); vector<int> ivec3 = ivec; vector<string> svec(ivec2);

1~98~>列表初始化vector对象

C^ll新标准还提供了另外一种为vector对象的元素赋初值的方法，即列表初始化（参 见2.2.1节，第39页）。此时，用花括号括起来的0个或多个初始元素值被赋给vector对象：

vector<string> articles = {"a", "an", "the"};

上述vector对象包含三个元素：第一个是字符串"a"，第二个是字符串"an",最后一个 是字符串"the"。

之前已经讲过，C++语言提供了几种不同的初始化方式（参见2.2.1节，第39页）。在 大多数情况下这些初始化方式可以相互等价地使用，不过也并非一直如此。目前已经介绍 过的两种例外情况是：其一，使用拷贝初始化时（即使用=时）（参见3.2+1节，第76页）， 只能提供一个初始值：其二，如果提供的是一个类内初始值（参见2.6.1节，第64页）， 则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊的要求是，如果提供的是 初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号 里：

vector<string> vl{"a", "an", "the"}; // 歹丨］表初始化 vector<string> v2（"a", "an", "the"）; // 错误

创建指定数量的元素

还可以用vector对象容纳的元素数量和所有元素的统一初始值来初始化vector对象:

vector<int> ivec （10, -1）;    // 10个int类型的元素，每个都被初始化为-1

vector<string> svec （10, "hi!"）;    // 10 个 string 类型的元素，

//每个都被初始化为"hi!"

值初始化

通常情况下，可以只提供vector对象容纳的元素数量而不用略去初始值。此时库会 创建一个值初始化的（value-initialized）元素初值，并把它赋给容器中的所有元素。这个 初值由vector对象中元素的类型决定。

如果vector对象的元素是内置类型，比如int,则元素初始值自动设为0。如果元 素是某种类类型，比如string,则元素由类默认初始化：

vector<int> ivec (10) ;    // 10个元素，每个都初始化为0

vector<string> svec (10) ;    // 10 个元素，每个都是空 string 对象

对这种初始化的方式有两个特殊限制:其一，有些类要求必须明确地提供初始值(参见2.2.1 节，第40页)，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始 的元素值，对这种类型的对象来说,只提供元素的数量而不设定初始值无法完成初始化工作。

其二，如果只提供了元素的数量而没有设定初始值，只能使用直接初始化： vector<int> vi = 10; //错误：必须使用直接初始化的形式指定向量大小    〈的J

这里的10是用来说明如何初始化vector对象的，我们用它的本意是想创建含有10个值 初始化了的元素的vector对象，而非把数字10 “拷贝"到vector中。因此，此时不 宜使用拷贝初始化，7.5.4节(第265页)将对这一点做更详细的介绍。

列表初始值还是元素数量？    eg

在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。例 如，用一个整数来初始化vector<int>时，整数的含义可能是vector对象的容量也可 能是元素的值。类似的，用两个整数来初始化veCtOr<intMt这两个整数可能一个是 vector对象的容量，另一个是元素的初值，也可能它们是容量为2的vector对象中两 个元素的初值。通过使用花括号或圆括号可以区分上述这些含义：

vector<int> vl(10); vector<int> v2(10};



vectorcint〉 v3(10, 1); vector<int> v4{10, 1};



// vl有10个元素，每个的值都是0 // v2有1个元素，该元素的值是10 // v3有10个元素，每个的值都是】 II v4有2个元素，值分别是10和]

如果用的是圆括号，可以说提供的值是用来构造(construct) vector对象的。例如，vl 的初始值说明了 vector对象的容量；v3的两个初始值则分别说明了 vector对象的容 量和元素的初值。

如果用的是花括号，可以表述成我们想列表初始化(list initialize)该vector对象。 也就是说，初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有 在无法执行列表初始化时才会考虑其他初始化方式。在上例中，给v2和v4提供的初始 值都能作为元素的值，所以它们都会执行列表初始化，vector对象v2包含一个元素而 vector对象v4包含两个元素。

另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，

就要考虑用这样的值来构造vector对象了。例如，要想列表初始化一个含有string对<J00] 象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要列表初 始化vector对象的元素还是用给定的容量值来构造vector对象：

vector<string>

vector<string>

vector<string>

vector<string>



v5{"hi’.}; // v6("hi"); // v7{10}; v8{10, "hi"}



列表初始化：v5有一个元素

错误：不能使用字符串字面值构建vector对象 // v7有10个默认初始化的元素 // v8有10个值为"hi"的元素

尽管在上面的例子中除了第二条语句之外都用了花括号，但其实只有v5是列表初始化。 要想列表初始化vector对象，花括号里的值必须与元素类型相同。显然不能用int初 始化string对象，所以v"7和v8提供的值不能作为元素的初始值。确认无法执行列表 初始化后，编译器会尝试用默认值初始化vector对象。

###### 3.3.1节练习

练习3.12:下列vector对象的定义有不正确的吗？如果有，请指出来。对于正确的, 描述其执行结果；对于不正确的，说明其错误的原因。

(a)    vector<vector<int» ivec;

(b)    vector<string> svec = ivec;

(c)    vector<string> svec(10, "null");

练习3.13:下列的vector对象各包含多少个元素？这些元素的值分别是多少？

(a) vector<int> vl;

(b) vector<int> v2 (10);

(d) vector<int> v4 {10 };

(f) vector<string> v6 {10 };



(c) vector<int> v3 (10, 42);

(e) vector<int> v5 {10, 42 };

(g)vector<string> v7{10, "hi"};

###### 3.3.2向vector对象中添加元素

对vector对象来说，直接初始化的方式适用于三种情况：初始值已知且数量较少、 初始值是另一个vector对象的副本、所有元素的初始值都一样。然而更常见的情况是： 创建一个vector对象吋并不清楚实际所需的元素个数，元素的值也经常无法确定。还有 些时候即使元素的初值已知，但如果这些值总量较大而各不相同，那么在创建vector对 象的时候执行初始化操作也会显得过于烦琐。

举个例子，如果想创建一个vector对象令其包含从0到9共10个元素，使用列表 初始化的方法很容易做到这一点；但如果vector对象包含的元素是从0到99或者从0 至IJ999呢？这时通过列表初始化把所有元素都一一罗列出来就不太合适了。对于此例来说， 更好的处理方法是先创建一个空vector,然后在运行时再利用vector的成员函数 push_back向其中添加元素。push_back负责把一个值当成vector对象的尾元素“压 至lj ( push) ” vector 对象的“尾端(back) ”。例如:

I 101〉 vector<int> v2;    // 空 vector 对象

for (int i = 0; i != 100; ++i)

v2 .push_back (i) ; //依次把整数值放到v2尾端

//循环结束后v2有100个元素，值从0到99

在上例中，尽管知道vector对象最后会包含100个元素，但在一开始还是把它声明成空 vector,在每次迭代时才顺序地把下一个整数作为v2的新元素添加给它。

同样的：如果直到运行时才能知道vector对象巾元素的确切个数，也应该使用刚刚 这种方法创建vector对象并为其赋值。例如，有时需要实时读入数据然后将其赋予 vector 对象：

//从标准输入中读取单词，将其作为vector对象的元素存储 string word;

vector<string> text;    // 空 vector 对象

while (cin » word) {

text. push_back (word) ;    // 把 word 添加到 text 后面

}

和之前的例子一样，本例也是先创建一个空vector,之后依次读入未知数量的值并保存 至lj text 中。

关键概念：vectoi•对象能高效增长 _

C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对 象能高效地增长，那么在定义vector对象的时候设定其大小也就没什么必要了，事实 上如果这么做性能可能更差。只有一种例外情况，就是所有（all）元素的值都一样。一 旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其 中添加具体值。此外，9.4节（苐317页）将介绍，vector还提供了方法，允许我们 进一步提升动态添加元素的性能。

开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言 及其他大多数语言中内置数组类型的用法不同。特别是如果用惯了 C或者Java,可以 预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰 恰相反。

向vector对象添加元素蕴含的编程假定

由于能高效便捷地向vector对象中添加元素，很多编程工作被极大简化了 =然而， 这种简便性也伴随着一些对编写程序更高的要求：其中一条就是必须要确保所写的循环正 确无误，特别是在循环有可能改变vector对象容量的时候。

随着对vector的更多使用，我们还会逐渐了解到其他一些隐含的要求，其中一条是 现在就要指出的：如果循环体内部包含有向vector对象添加元素的语句，则不能使用范 围for循环，具体原因将在5.4.3节（第168页）详细解释。

WARNING



范围for语句体内不应改变其所遍历序列的大小。



###### 3.3.2节练习

<ioT|

6



练习3.14:编写一段程序，用cin读入一组整数并把它们存入一个vector对象。 练习3.15:改写上题的程序，不过这次读入的是字符串。

###### 3.3.3其他vector操作

除了 push_back之外，vector还提供了几种其他操作，大多数都和string的相 关操作类似，£3.5列出了其中比较重要的一些。

| 表3.5: vector支持的操作 |                                                              |
| ----------------------- | ------------------------------------------------------------ |
| v.empty()               | 如果V不含有任何元素，返回真：否则返回假                      |
| v.size ()               | 返回V中元素的个数                                            |
| v.push_back(t)          | 向V的尾端添加一个值为t的元素                                 |
| v[n]                    | 返回V中第n个位置上元素的引用                                 |
| vl = v2                 | 用v2中元素的拷贝替换vl中的元素                               |
| vl = {a,b,c...]         | 用列表中元素的拷贝替换vl中的元素                             |
| vl == v2                | vl和V2相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| vl != v2                |                                                              |
| <=r    〉.    >=        | 顾名思义，以字典顺序进行比较                                 |

访问vector对象中元素的方法和访问string对象中字符的方法差不多，也是通过 元素在vector对象中的位置。例如，可以使用范围for语句处理vector对象中的所 有元素：

vector<int> v{l,2,3,4, for (auto &i : v)

i *= i;

for (auto i : v)

cout « i « "，.；

cout << endl;



5,6,7,8,9};

//对于V中的每个元素（注意：i是一个引用） //求元素值的平方 //对于V中的每个元素 //输出该元素

第一个循环把控制变量i定义成引用类型，这样就能通过i给V的元素赋值，其中i的 类型由auto关键字指定。这里用到了一种新的复合赋值运算符（参见1.4.1节，第10页）。 如我们所知，+=把左侧运算对象和右侧运算对象相加，结果存入左侧运算对象；类似的， *=把左侧运算对象和右侧运算对象相乘，结果存入左侧运算对象。最后，第二个循环输出 所有元素。

vector的empty和size两个成员与string的同名成员（参见3.2.2节，第78 页）功能完全一致：empty检查vector对象是否包含元素然后返回一个布尔值；size 则返回vector对象中元素的个数，返回值的类型是由vector定义的size_type类型。

![img](C++  Primer 5-38.jpg)



要使用size_type,需首先指定它是由哪种类型定义的vector对象的类 型总是包含着元素的类型（参见3.3节，第87页）：

vector<int>: : size_type    // 正确

vector: :size_type    // 错误

各个相等性运算符和关系运算符也与string的相应运算符（参见3.2.2节，第79页） 功能一致。两个vector对象相等当且仅当它们所含的元素个数相同，而且对应位置的元 素值也相同。关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但 是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对 象;若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。

只有当元素的值可比较时，vector对象才能被比较。一些类，如string等，确实 定义了自己的相等性运算符和关系运算符；另外一些，如Sales_item类支持的运算已 经全都罗列在1.5.1节（第17页）中了，显然并不支持相等性判&和关系运算等操作。因 此，不能比较两个vector<Sales_item>X寸象。

计算vector内对象的索引

使用下标运算符（参见3.2.3节，第84页）能获取到指定的元素。和string—样， vector对象的下标也是从0开始计起，下标的类型是相应的size_type类型。只要 vector对象不是一个常量，就能向下标运算符返回的元素赋值。此;5^,如3.2.3节（第 85页）所述的那样，也能通过计算得到vector内对象的索引，然后直接获取索引位置 上的元素。

举个例子，假设有一组成绩的集合，其中成绩的取值是从0到100。以10分为一个分 数段，要求统计各个分数段各有多少个成绩。显然，从0到100总共有101种可能的成绩 取值，这些成绩分布在11个分数段上：每10个分数构成一个分数段，这样的分数段有10 个，额外还有一个分数段表示满分100分。这样第一个分数段将统计成绩在0到9之间的 数量；第二个分数段将统计成绩在10到19之间的数量，以此类推。最后一个分数段统计 满分100分的数量。

按照上面的描述，如果输入的成绩如下：

42 65 95 100 39 67 95 76 88 76 83 92 76 93

则输出的结果应该是:

00011023241

结果显示：成绩在30分以下的没有、30分至39分有1个、40分至49分有1个、50分至 59分没有、60分至69分有2个、70分至79分有3个、80分至89分有2个、90分至99 分有4个，还有1个是满分。

在具体实现时使用一个含有11个元素的vector对象，每个元素分别用于统计各个＜JS 分数段上出现的成绩个数。对于某个成绩来说，将其除以10就能得到对应的分数段索引。

注意：两个整数相除，结果还是整数，余数部分被自动忽略掉了。例如，42/10=4、65/10=6、 100/10=10等。一旦计算得到了分数段索引，就能用它作为vector对象的下标，进而获 取该分数段的计数值并加1:

//以10分为一个分数段统计成绩的数量 vector<unsigned> scores (11, 0); unsigned grade;

0 〜9, 10 〜19，...，90-99, 100 // 11个分数段，全都初始化为0

//读取成绩

//只处理有效的成绩

II将对应分数段的计数值加1



while (cin » grade) { if (grade <= 100)

++scores[grade/10];

在上面的程序中，首先定义了一个vector对象存放各个分数段上成绩的数量。此例中， 由于初始状态下每个元素的值都相同，所以我们为vector对象申请了 11个元素，并把 所有元素的初始值都设为0、while语句的条件部分负责读入成绩，在循环体内部首先检 查读入的成绩是否合法（即是否小于等于100分），如果合法，将成绩对应的分数段的计 数值加1 ■»

执行计数值累加的那条语句很好地体现了 C++程序代码的简洁性。表达式 ++scores [grade/10] ; //将当前分数段的计数值加1

等价于

auto ind = grade/10;    //得到分数段索引

scores [ind] = scores [ind] + 1;    // 将计数值加 1

上述语句的含义是：用grade除以10来计算成绩所在的分数段，然后将所得的结果作为 变量scores的下标。通过运行下标运算获取该分数段对应的计数值，因为新出现了一个 属于该分数段的成绩，所以将计数值加1。

如前所述，使用下标的时候必须清楚地知道它是否在合理范围之内（参见3.2.3节， 第85页）。在这个程序里，我们事先确认了输入的成绩确实在0到100之间，这样计算 所得的下标就一定在0到10之间，属于0到scores, size （） -1规定的有效范围，一 定是合法的。

不能用下标形式添加元素

刚接触C++语言的程序员也许会认为可以通过vector对象的下标形式来添加元素， 事实并非如此。下面的代码试图为vector对象ivec添加10个元素：

vector<int> ivec; // 空 vector 对象

for (decitype(ivec.size()) ix = 0; ix != 10; ++ix) ivec[ix] = ix; //严重错误：ivec不包含任何元素

然而，这段代码是错误的：ivec是一个空vector,根本不包含任何元素，当然也就不 能通过下标去访问任何元素！如前所述，正确的方法是使用push_back:

I 105〉    for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)

ivec.push_back (ix) ; //正确：添加一个新元素，该元素的值是ix

WARNING



vector对象(以及string对象)的下标运算符可用于访问已存在的元素， 而不能用于添加元素

提示：只能对确知已存在的元素执行下标操作!

关于下标必须明确的一点是：只能对确知已存在的元素执行下标操作。例如，

vector<int> ivec;    // 空 vector 对象

cout « ivec [0] ;    //错误：ivec不包含任何元素

vector<int> ivec2 (10) ;    // 含有 10 个元素的 vector 对象

cout « ivec2 [10] ;    //错误：ivec2元素的合法索引是从0到9

试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发 现，而是在运行时产生一个不可预知的值。

不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的 后果。所谓的缓冲区溢出(buffer overflow)指的就是这类错误，这也是导致PC及其他 设备上应用程序出现安全问题的一个重要原因。

![img](C++  Primer 5-40.jpg)



确保下标合法的一种有效手段就是尽可能使用范围for语句

###### 3.3.3节练习

练习3.16:编写一段程序，把练习3.13中vector对象的容量和具体内容输出出来。 检验你之前的回答是否正确，如果不对，回过头重新学习3.3+1节(第87页)直到弄明 白错在何处为止。

练习3.17:从cin读入一组词并把它们存入一个vector对象，然后设法把所有词都 改写为大写形式。输出改变后的结果，每个词占一行。

练习3.18：下面的程序合法吗？如果不合法，你准备如何修改？

vector<int> ivec; ivec[0] = 42;

练习3.19:如果想定义一个含有10个元素的vector对象，所有元素的值都是42,请 列举出三种不同的实现方法。哪种方法更好呢？为什么？

练习3.20：读入一组整数并把它们存入一个vector对象，将每对相邻整数的和输出出 来。改写你的程序，这次要求先输出第1个和最后1个元素的和，接着输出第2个和倒 数第2个元素的和，以此类推。

##### 3.4迭代器介绍

$6



我们已经知道可以使用下标运算符来访问string对象的字符或vector对象的元＜M] 素，还有另外一种更通用的机制也可以实现同样的目的，这就是迭代器（iterator）。在第 11部分中将要介绍，除了 vector之外，标准库还定义了其他几种容器。所有标准库容器 都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。严格来说，string 对象不属于容器类型，但是string支持很多与容器类型类似的操作。vector支持下标 运算符，这点和string—样；string支持迭代器，这也和vector是一样的。

类似于指针类型（参见2.3.2节，第47页），迭代器也提供了对对象的间接访问。就 迭代器而言，其对象是容器中的元素或者string对象中的字符。使用迭代器可以访问某 个元素，迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分，这一点 和指针差不多。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其 他所有情况都属于无效。

###### 3.4.1使用迭代器

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭 代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责 返回指向第一个元素（或第一个字符）的迭代器。如有下述语句：

II由编译器决定b和e的类型；参见2.5.2节（第61页）

// b表示v的第一个元素，e表示v尾元素的下一位置

auto b = v.begin （） , e = v.end （） ; //b 和 e 的类型相同

end成员则负责返回指向容器（或string对象）“尾元素的下一位置（one past the end）" 的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的"尾后（offthe end）”元 素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所 有元素。end成员返网的迭代器常被称作尾后迭代器（off-the-end iterator）或者简称为尾 迭代器（end iterator）□特殊情况下如果容器为空，贝lj begin和end返回的是同一个迭 代器。

\如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。

一般来说，我们不清楚（不在意）迭代器准确的类型到底是什么。在上面的例子中， 使用auto关键字定义变量b和e （参见2.5.2节，第61页），这两个变量的类型也就是 begin和end的返冋值类型，第97页将对相关内容做更详细的介绍。

迭代器运算符

表3.6列举了迭代器支持的一些运算。使用==和！=来比较两个合法的迭代器是否相 等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等；否 则就说这两个迭代器不相等。

| 表3.6:标准容器迭代器的运算符 |                                                              |
| ---------------------------- | ------------------------------------------------------------ |
| *iter                        | 返回迭代器iter所指元素的引用                                 |
| iter-〉mem                   | 解引用iter并获取该元素的名为mem的成员，等价于(*iter) .mem    |
| ++iter                       | 令iter指示容器中的下一个元素                                 |
| ——iter                       | 令iter指示容器中的上一个元素                                 |
| iterl == iter2               | 判断两个迭代器是否相等(不相等)，如果两个迭代器指示的是同•个元 |
| iterl != iter2               | 素或者它们是同一个容器的尾后迭代器，则相等；反之，不相等     |

□oz>    和指针类似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必

须合法并确实指示着某个元素(参见2.3.2节，第48页)。试图解引用一个非法迭代器或 者尾后迭代器都是未被定义的行为。

举个例子，3.2.3节(第84页)中的程序利用下标运算符把string对象的第一个字 母改为了大写形式，下面利用迭代器实现同样的功能：

string s(.’some string");

if (s .begin ()    ! = s .end () )    {    // 确保 s 非空

auto it = s .begin () ;    // it 表示 s 的第一个字符

*it = toupper (*it) ;    //将当前字符改成大写形式

}

本例和原来的程序一样，首先检查S是否为空，显然通过检查begin和end返回的结果 是否一致就能做到这一点。如果返回的结果一样，说明s为空；如果返回的结果不一样， 说明s不为空，此时s中至少包含一个字符。

我们在if内部，声明了一个迭代器变量it并把begin返回的结果赋给它，这样就 得到了指示S中第一个字符的迭代器，接下来通过解引用运算符将第一个字符更改为大写 形式。和原来的程序一样，输出结果将是，

Some string

将迭代器从一个元素移动到另外一个元素

迭代器使用递增(++)运算符(参见1.4.1节，第11页)来从一个元素移动到下一个 元素。从逻辑上来说，迭代器的递增和整数的递增类似，整数的递増是在整数值上“加1”, 迭代器的递增则是将迭代器“向前移动一个位置”。

![img](C++  Primer 5-41.jpg)



因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解 引用的操作。

之前有一个程序把string对象中第一个单词改写为大写形式，现在利用迭代器及其 递增运算符可以实现相同的功能：

[JP8>    //依次处理s的字符直至我们处理完全部字符或者遇到空白

for (auto it = s.begin(); it != s.end() && !isspace (*it); ++it)

*it = toupper (*it) ; //将当前字符改成大写形式

和3.2.3节(第84页)的那个程序一样，上面的循环也是遍历s的字符直到遇到空白字符 为止，只不过之前的程序用的是下标运算符，现在这个程序用的是迭代器。

循环首先用s .begin的返回值来初始化it,意味着it指示的是s中的第一个字符 (如果有的话)=条件部分检查是否已到达s的尾部，如果尚未到达，则将it解引用的结

果传入isspace函数检查是否遇到了空白。每次迭代的最后，执行++it令迭代器刖移 ―个位置以访问s的下一个字符。

循环体内部和上一个程序if语句内的最后一句话一样，先解引用it,然后将结果传 入toupper函数得到该字母对应的大写形式，再把这个大写字母重新赋值给it所指示 的字符。

关键概念：泛概编程

原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！=而 非<进行判断有点儿奇怪，比如上面的这个程序以及85页的那个。C++程序员习惯性地 使用！=,其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标 准库提供的所有容器上都有效。    …

之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非 全都如此。与之类似，所有标准库容器的迭代器都定义了 ==和！=，但是它们中的大多 数都没有定义<运算符。因此，只要我们养成使用迭代器和！=的习惯，就不用太在意用 的到底是哪种容器类型。

迭代器类型

就像不知道string和vector的size_type成员（参见3.2.2节，第79页）到底 是什么类型一样，一般来说我们也不知道（其£是无须知道）迭代器的精确类型。而实际上， 那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：

veotor<int>: : iterator it; // it 能读写 vector<int>的元素 string: :iterator it2;    // it2 能读写 string 对象中的字符

vector<int>: :const_iterator it3; // it3 只能读元素，不能写元素 string: :const_iterator it4;    // it4 只能读字符，不能写字符

const_iterator和常量指针（参见2.4.2节，第56页）差不多，能读取佴不能修改它 所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是 一个常量，只能使用const_iterator;如果vector对象或string对象不是常量， 那么既能使用iterator也能使用const_iterator。

术语：迭代器和迭代器炎哦

<M]



迭代器这个名词有三种不同的含义：可能是迭代器概念本身，也可能是指容器定义 的迭代器类型，还可能是指某个迭代器对象。

重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支 持一套操作，这套操作使得我们能访伺容器的元素或者从某个元素移动到另外一个元素。

每个容器类定义了一个名为.iterator的类型，该类型支持迭代器概念所规定的 一套操作。

begin和end运算符

begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和 end返回const_iterator;如果对象不是常量，返回iterator:

vector<int> v;

const vector<int> cv;

auto itl = v.begin () ;    // itl 的类型是 vector<int>:: iterator

auto it2 = cv.begin () ;    // it2 的类型是 vector<int>: :const_iterator

有时候这种默认的行为并非我们所要。在6.2.3节(第191页)中将会看到，如果对象只 需读操作而无须写操作的话最好使用常量类型(比如const_iterator)o为了便于专门

卜：,j得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin 和 cend：

auto it3 = v. cbegin () ; // it3 的类3!是 vector<int>:: const_iterator

类似于begin和end,上述两个新函数也分别返回指示容器第一个元素或最后元素下一 位置的迭代器。有所不同的是，不论vector对象(或string对象)本身是否是常量， 返回值都是cons t_i ter ator»

结合解引用和成员访问操作

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望 进一步访问它的成员。例如，对于一个由字符串组成的vector对象来说，要想检查其元 素是否为空，令it是该vector对象的迭代器，只需检查it所指字符串是否为空就可 以了，其代码如下所示：

(*it) .empty()

注意，(*it> .empty()中的圆括号必不可少，具体原因将在4.1.2节(第121页)介绍， 该表达式的含义是先对it解引用，然后解引用的结果再执行点运算符(参见1.5.2节，第 20页)。如果不加圆括号，点运算符将由it来执行，而非it解引用的结果：

(*it) .empty ()    //解引用it,然后调用结果对象的empty成员

\* it. empty ()    //错误：试图访问it的名为empty的成员，但it是个迭代器，

//没有empty成员

EUD>上面第二个表达式的含义是从名为it的对象中寻找其empty成员，显然it是一个迭代 器，它没有哪个成员是叫empty的，所以第二个表达式将发生错误。

为了简化上述表达式，C++语言定义了箭头运算符(->)。箭头运算符把解引用和成 员访问两个操作结合在一起I也就是说，it->niem和(*it) .mem表达的意思相同。

例如，假设用一个名为text的字符串向量存放文本文件中的数据，其中的元素或者 是一句话或者是一个用于表示段落分隔的空字符串。如果要输出text中第一段的内容， 可以利用迭代器写一个循环令其遍历text,直到遇到空字符串的元素为止：

//依次输出text的每一行直至遇到第一个空白行为止 for (auto it = text.cbegin();

it != text.cend() && !it->empty(); ++it) cout « *it « endl;

我们首先初始化it令其指向text的第-个元素，循环重复执行直至处理完了 text的所 有元素或者发现某个元素为空。每次迭代时只要发现还有元素并且尚未遇到空元素，就输 出当前正在处理的元素。值得注意的是.因为循环从头到尾只是读取text的元素而未向 其中写值，所以使用了 cbegin和cend来控制整个迭代过程。

某些对vector对象的操作会使迭代器失效

3.3.2节(第90页)曾经介绍过，虽然vector对象可以动态地增长，何是也会有一

些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一 个限制是任何一种可能改变vector对象容量的操作，比如push_back,都会使该 vector对象的迭代器失效。9.3.6节（第315页）将详细解释迭代器是如何失效的。

谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素-

WARNING

###### 3.4.1节练习

练习3.21:请使用迭代器重做3.3.3节（第94页）的第一个练习。

练习3.22：修改之前那个输出text第一段的程序，首先把text的第一段全都改成大 写形式，然后再输出它。

练习3.23:编写一段程序，创建一个含有10个整数的vector对象，然后使用迭代器 将所有元素的值都变成原来的两倍。输出vector对象的内容，检验程序是否正确。

###### 3.4.2迭代器运算    ®

迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都有支持递增运算 的迭代器，类似的，也能用==和！=对任意标准库类型的两个有效迭代器（参见3.4节，第 95页）进行比较。

string和vector的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次 移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称作迭代器运算

（iterator arithmetic）.其细节由表 3.7 列出。

| 表3.7: vector和string迭代器支持的运算 |                                                              |
| ------------------------------------- | ------------------------------------------------------------ |
| iter + n                              | 迭代器加上--个整数值仍得一个迭代器，迭代器指示的新位置与原来相比 向前移动了若干个元素。结果迭代器或者指示容器内的-•个元素，或者指 示容器尾元素的下•位置 |
| iter - n                              | 迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比 向后移动了若干个元素，结果迭代器或者指示容器内的---个元素，或者指 示容器尾元素的下一位置 |
| iter1 += n                            | 迭代器加法的复合赋值语句，将iterl加n的结果赋给iterl          |
| iterl -= n                            | 迭代器减法的复合赋值语句，将iterl减n的结果赋给iterl          |
| iterl - iter2                         | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭 代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器 必须指向的是同一个容器中的元素或者尾元素的下-•位置 |
| ＞、＞=、＜、＜=                      | 迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指 位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一 个容器中的元素或者尾元素的下一位置 |

迭代器的算术运算

可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干 个位置的迭代器。执行这样的操作时，结果迭代器或者指示原vector对象（或string 对象）内的一个元素，或者指示原vector对象（或string对象）尾元素的下一位置。

举个例子，下面的代码得到一个迭代器，它指向某vector对象中间位置的元素：

//计算得到最接近vi中间元素的一个迭代器 auto mid = vi.begin() + vi.size() / 2;

如果vi有20个元素，vi . size (>/2得10，此例中即令mid等于vi .begin ()+10。 已知下标从0开始，则迭代器所指的元素是vi [10]，也就是从首元素开始向前相隔10 个位置的那个元素。

对于string或vector的迭代器来说，除了判断是否相等，还能使用关系运算符(<、 <=、>、>=)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的 元素(或者尾元素的下一位置)。例如，假设it和mid是同一个vector对象的两个迭 代器，可以用下面的代码来比较它们所指的位置孰前孰后：

if (it < mid)

//处理vi前半部分的元素

C5E>    只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相

减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能 追上左侧的迭代器，其类型是名为difference_type的带符号整型数。string和 vector都定义了 difference_type，因为这个距离可正可负，所以 dif ference_type是带符号类型的。

使用迭代器运算

使用迭代器运算的一个经典算法是二分搜索。二分搜索从有序序列中寻找某个给定的 值。二分搜索从序列中间的位置开始搜索，如果中间位置的元素正好就是要找的元素，搜 索完成；如果不是，假如该元素小于要找的元素，则在序列的后半部分继续搜素；假如该 元素大于要找的元素，则在序列的前半部分继续搜索。在缩小的范围中计算一个新的中间 元素并重复之前的过程，直至最终找到目标或者没有元素可供继续搜索。

下面的程序使用迭代器完成了二分搜索：

// text必须是有序的

// beg和end表示我们搜索的范围

auto beg = text.begin(), end = text.end();

auto mid = text.begin () + (end - beg) / 2; // 初始状态下的中间点 //当还有元素尚未检查并且我们还没有找到sought时执行循环

while (mid != end && *mid



sought) {



if (sought < *mid) end = mid;

else

beg = mid + 1; mid = beg + (end -



//我们要找的元素在前半部分吗？

//如果是，调整搜索范围使得忽略掉后半部分 //我们要找的元素在后半部分

//在mid之后寻找 beg) /2;    //新的中间点



程序的一开始定义了三个迭代器：beg指向搜索范围内的第一个元素、end指向尾元素的 下一位置、mid指向中间的那个元素。初始状态下，搜索范围是名为text的 vector〈string〉的全部范围。

循环部分先检查搜索范围是否为空，如果mid和end的当前值相等，说明已经找遍 了所有元素，此时条件不满足，循环终止。当搜索范围不为空时，可知mid指向了某个 元素，检查该元素是否就是我们所要搜索的，如果是，也终止循环。

当进入到循环体内部后，程序通过某种规则移动beg或者end来缩小搜索的范围。 如果mid所指的元素比要找的元素sought大，可推测若text含有sought,则必出现 在mid所指元素的前面。此时，可以忽略mid后面的元素不再查找，并把mid赋给end 即可。另一种情况，如果*mid比sought小，则要找的元素必出现在mid所指兀素的后 面。此时，通过令beg指向mid的下一个位置即可改变搜索范围。因为已经验证过mid 不是我们要找的对象，所以在接下来的搜索中不必考虑它。

循环过程终止时，mid或者等于end或者指向要找的元素。如果mid等于end，说 明text中没有我们要找的元素。

###### 3.4.2节练习

练习3.24:请使用迭代器重做3.3.3节（第94页）的最后一个练习。

练习3.25: 3.3.3节（第93页）划分分数段的程序是使用下标运算符实现的，请利用迭 代器改写该程序并实现完全相同的功能，

练习3.26:在100页的二分搜索程序中，为什么用的是mid = beg + （end - beg） / 2. 而非 mid = （beg + end） /2; ?

###### 3.5数组

数组是一种类似于标准库类型vector （参见3.3节，第86页）的数据结构，但是在 性能和灵活性的权衡上又与vector有所不同。与vector相似的地方是，数组也是存放 类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector 不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定， 因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。

![img](C++  Primer 5-42.jpg)



如果不清楚元素的确切个数，请使用vector



###### 3.5.1定义和初始化内置数组

数组是一种复合类型（参见2.3节，第45页）。数组的声明形如a [d],其中a是数 组的名字，d是数组的维度。维度说明了数组中元素的个数，因此必须大于0。数组中元 素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须 是一个常量表达式（参见2.4.4节，第58页）：

unsigned cnt = 42;    //不是常量表达式

constexpr unsigned sz = 42; // 常量表达式，关于 constexpr，参见2.4.4 节（第 59 页）

int arr [10] ;    //含有10个整数的数组

int *parr [sz] ;    //含有42个整型指针的数组

string bad [cnt] ;    //错误：cnt不是常量表达式

string strs [get_size （） ] ; // 当 get_size 是 constexpr 时正确；否则错误

默认情况下，数组的元素被默认初始化（参见2.2.1节，第40页）。

WARNING



和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默 认初始化会令数组含有未定义的值。

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类 型。另外和vector—样，数组的元素应为对象，因此不存在引用的数组。

□S＞显式初始化数组元素

可以对数组的元素进行列表初始化（参见3.3+1节，第88页），此时允许忽略数组的 维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反， 如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值 数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值（参见3.3.1 节，第88页）：

| const unsigned sz | =3;          |      |                                        |
| ----------------- | ------------ | ---- | -------------------------------------- |
| int ial[sz] = {0, | 1, 2};       | //   | 含有3个元素的数组，元素值分别是0, 1, 2 |
| int a2[] = {0, 1, | 2};          | //   | 维度是3的数组                          |
| int a3[5] = {0, 1 | r    2};     | //   | 等价于 a3[] = {0, 1, 2, 0, 0}          |
| string a4[3] = {" | hi", "bye"}; | //   | 等价于 a4[] = {"hi", "bye", ""}        |
| int a5[2] = {0,1, | 2}；         | //   | 错误：初始值过多                       |

字符数组的特殊性

字符数组有一种额外的初始化形式，我们可以用字符串字面值（参见2.1.3节，第36 页）对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个 空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：

char al[] = {'C'，'+，，，+'};    II列表初始化，没有空字符

char a2[] = {'C',    , '\0'};    //列表初始化，含有显式的空字符

char a3[] = "C++";    //自动添加表示字符串结束的空字符

const char a4 [6] = "Daniel";    //错误：没有空间可存放空字符！

al的维度是3, a2和a3的维度都是4, a4的定义是错误的。尽管字符串字面值"Daniel" 看起来只有6个字符，但是数组的大小必须至少是7,其中6个位置存放字面值的内容， 另外1个存放结尾处的空字符。

不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值： int a[] = {0, 1, 2};    //含有3个整数的数组

int a2[] = a;    //错误：不允许使用一个数组初始化另一个数组

a2 = a;    II错误：不能把一个数组直接赋值给另一个数组

„    一些编译器支持数组的赋值，这就是所谓的编译器矿展（compiler extension ）.、

/!\但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在 WARNING其他编译器上无法正常工作』

理解复杂的数组声明

和vector—样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数 组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中， 定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了:

int *ptrs [10];

int &refs[10] = /* ? */; int (*Parray)[10] = &arr; int (&arrRef)[10] = arr;



// ptrs是含有10个整型指针的数组 //错误：不存在引用的数组 // Parray指向一个含有10个整数的数组 // arrRef引用一个含有10个整数的数组

默认情况下，类型修饰符从右向左依次绑定。对于ptrs来说，从右向左（参见2.3.3节， 第52页）理解其含义比较简单：首先知道我们定义的是一个大小为10的数组，它的名字 是ptrs，然后知道数组中存放的是指向int的指针。

但是对于Parray来说，从右向左理解就不太合理了。因为数组的维度是紧跟着被声 明的名字的，所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮 助我们更好地理解Parray的含义：首先是圆括号括起来的部分，*Parray意味着 Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针， 最后观察左边，知道数组中的元素是int。这样最终的含义就明白无误了，Parray是一 个指针，它指向一个int数组，数组中包含10个元素。同理，（SarrRef）表示arrRef 是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是int。

当然，对修饰符的数量并没有特殊限制：

int * （sarry） [10] = ptrs; // arry是数组的引用，该数组含有10个指针

按照由内向外的顺序阅读上述语句，首先知道arry是一个引用，然后观察右边知道，arry 引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的 指针。这样，arry就是一个含有10个int型指针的数组的引用。

![img](C++  Primer 5-43.jpg)



要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺 序阅读。

###### 3.5.1节练习

练习3.27：假设txt_size是一个无参数的函数，它的返回值是into请回答下列哪 个定义是非法的？为^么？

unsigned buf_size = 1024;

(a) int ia [buf_size] ;    (b) int ia[4 * 7 - 14];

(c) int ia [txt_size () ] ;    (d) char st [ 11 ] = "fundamental";

练习3.28:下列数组中元素的值是什么？

string sa[10]; int ia [ 10]; int main()    {

string sa2[10 ]; int ia2[10];

}

练习3.29:相比于vector来说，数组有哪些缺点，请列举一些。

<~nn



###### 3.5.2访问数组元素

与标准库类型vector和string 一样，数组的元素也能使用范围for语句或下标 运算符来访问。数组的索引从0开始，以一个包含10个元素的数组为例，它的索引从0 到9,而非从1到10。

在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的 无符号类型，它被设计得足够大以便能表示内存中任意对象的大小f在cstddef头文件 中定义了 size t类型，这个文件是C标准库stddef.h头文件的C++语言版本。

数组除了大小固定这一特点外，其他用法与vector基本类似。例如，可以用数组来 记录各分数段的成绩个数，从而实现与3.3.3节(第93页)的程序一样的功能：

//以10分为一个分数段统计成绩的数量：0~9, 10~19，…，90-99, 100 unsigned scores [ 11 ] = {};    // 11个分数段，全部初始化为0

unsigned grade;

while (cin » grade) { if (grade <= 100)

++scores [grade/10] ;    //将当前分数段的计数值加1

}

与93页的程序相比，上面程序最大的不同是scores的声明。这里scores是一个含有 11个无符号元素的数组。另外一处不太明显的区别是，本例所用的下标运算符是由 语言直接定义的，这个运算符能用在数组类型的运算对象上。93页的那个程序所用的下标 运算符是库模板vector定义的，只能用于vector类型的运算对象。

与vector和string—样，当需要遍历数组的所有元素时，最好的办法也是使用范 围for语句。例如，下面的程序输出所有的scores:

for (auto i : scores)    //对于scores中的每个计数值

cout « i << "    //输出当前的计数值

cout « endl;

因为维度是数组类型的一部分，所以系统知道数组scores中有多少个元素，使用范围 for语句可以减轻人为控制遍历过程的负担。

检查下标的值

与vector和string—样，数组的下标是否在合理范围之内由程序员负责检查，所 谓合理就是说下标应该大于等于0而且小于数组的大小。要想防止数组下标越界，除了小 心谨慎注意细节以及对代码进行彻底的测试之外，没有其他好办法。对于一个程序来说， 即使顺利通过编译并执行，也不能肯定它不包含此类致命的错误。

/A 大多数常见的安全问题都源于缓冲区溢出错误当数组或其他类似数据结构的 下标越界并试图访问非法内存区域时，就会产生此类错误

###### 3.5.2节练习

练习3.30:指出下面代码中的索引错误。

constexpr size_t array_size = 10; int ia[array_size];

for (size_t ix = 1; ix <= array_size; ++ix) ia[ix] = ix;

练习3.31:编写一段程序，定义一个含有I0个int的数组，令每个元素的值就是其下 标值。

练习3.32：将上一题刚刚创建的数组拷贝给另外一个数组。利用vector重写程序，实 现类似的功能。

练习3.33：对于104页的程序来说，如果不初始化scores将发生什么？

###### 3.5.3指针和数组

在C++语言中，指针和数组有非常紧密的联系。就如即将介绍的，使用数组的时候编 译器一般会把它转换成指针。

通常情况下，使用取地址符（参见2.3.2节，第47页）来获取指向某个对象的指针，取 地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定 位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：

string nums [] = {"one", "two", "three"}; // 数组的元素是 string 对象 string *p = &nums [0] ;    // p 指向 nums 的第一个元素

然而，数组还有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换 为一个指向数组首元素的指针：

string *p2 = nums; // 等价于 p2 = &nums [0]

在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的 d指针。

由上可知，在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意 思。其中一层意思是当使用数组作为一个auto （参见2.5.2节，第61页）变量的初始值 时，推断得到的类型是指针而非数组：

int ia[] = {0,1,2, 3, 4,5, 6,7,8, 9}; // ia 是一个含有 10 个整数的教组 auto ia2 （ia） ;    // ia2是一个整型指针，指向ia的第一个元素

ia2 = 42;    //错误：ia2是一个指针，不能用int值给指针賦值

尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始 化过程类似于下面的形式：

<JK1



auto ia2 （&ia[0] ） ; //昱然 ia2 的类叟是 int*

必须指出的是，当使用decltype关键字（参见2.5.3节，第62页）时上述转换不会发 生，decltype （ia）返回的类型是由10个整数构成的数组：

II ia3是一个含有10个整数的数组 decltype（ia） ia3 = {0,1,2,3,4,5,6,7,8,9}; ia3 = p; //错误：不能用整型指针给数组赋值 ia3[4] = i; //正确：把i的值赋给ia3的一个元素

指针也是迭代器

与2.3.2节（第47页）介绍的内容相比，指向数组元素的指针拥有更多功能。vector 和string的迭代器（参见3.4节，第95页）支持的运算，数组的指针全都支持。例如， 允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

int arr[] = （0,1,2,3,4,5,6,7,8,91; int *p = arr; // p指向arr的第一个元素 ++P;    // p 指向 arr[l]

就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。 当然，这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位 置的指针。之前己经介绍过，通过数组名字或者数组中首元素的地址都能得到指向首元素 的指针；不过获取尾后指针就要用到数组的另外一个特殊性质了。我们可以设法获取数组

尾元素之后的那个并不存在的元素的地址：

int *e = &arr [10] ; //指向arr尾元素的下一位置的指针

这里显然使用下标运算符索引了一个不存在的元素，arr有10个元素，尾元素所在位置 的索引是9,接下来那个不存在的元素唯一的用处就是提供其地址用于初始化e»就像尾 后迭代器(参见3.4.1节，第95页)一样，尾后指针也不指向具体的元素。因此，不能对 尾后指针执行解引用或递增的操作。

利用上面得到的指针能重写之前的循环，令其输出arr的全部元素：

for (int *b = arr; b != e; ++b)

cout « *b « endl; // 输出 arr 的元素

标准库函数begin和end

尽管能计算得到尾后指针，但这种用法极易出错。为了让指针的使用更简单、更安全， C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成

®员(参见3.4.1节，第95页)功能类似，不过数组毕竟不是类类型，因此这两个函数不是 成员函数。正确的使用形式是将数组作为它们的参数：

int ia[] = { 0,1,2,3, 4,5, 6, 7,8, 9}; // ia 是一个含有 10 个整数的数组

int *beg = begin (ia);    //指向ia首元素的指针

int *last = end (ia) ;    //指向arr尾元素的下一位置的指针

\J^> begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针， 这两个函数定义在iterator头文件中。

使用begin和end可以很容易地写出一个循环并处理数组中的元素。例如，假设arr 是一个整型数组，下面的程序负责找到arr中的第一个负数：

// pbeg指向arr的首元素，pend指向arr尾元素的下一位置 int *pbeg = begin (arr), *pend = end(arr);

//寻找第一个负值元素，如果已经检查完全部元素则结束循环 while (pbeg != pend && *pbeg >= 0)

++pbeg;

首先定义了两个名为pbeg和pend的整型指针，其中pbeg指向arr的第一个元素,pend 指向arr尾元素的下一位置。while语句的条件部分通过比较pbeg和pend来确保可 以安全地对pbeg解引用，如果pbeg确实指向了一个元素，将其解引用并检查元素值是 否为负值。如果是，条件失效、退出循环：如果不是，将指针向前移动一位继续考査下一 个元素。

—个指针如果指向了某种内置类型数组的尾元素的“下一位置”，则其具备与 }vector的end函数返回的与迭代器类似的功能。特别要注意，尾后指针不能 <3/执行解引用和递增操作。

指针运算

指向数组元素的指针可以执行表3.6 (第96页)和表3.7 (第99页)列出的所有迭代 器运算，这些运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针 和用在迭代器上意义完全一致。

给(从)一个指针加上(减去)某整数值，结果仍是指针。新指针指向的元素与原来

的指针相比前进了(后退了)该整数值个位置，

constexpr size_t sz = 5; int arr[sz] = {1,2,3,4,5};

int *ip = arr;    // 等价于 int *ip = &arr [0]

int *ip2 = ip + 4;    // ip2 指向 arr 的尾元素 arr [4]

ip加上4所得的结果仍是一个指针，该指针所指的元素与ip原来所指的元素相比前进了 4个位置。

给指针加上一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向同一数 组的尾元素的下一位置：

//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置

int *p = arr + sz;    //使用警告：不要解引用！

int *p2 = arr + 10;    //错误：arr只有5个元素，p2的值未定义

当给arr加上SZ时，编译器自动地将arr转换成指向数组arr中首元素的指针。执行 加法后，指针从首元素开始向前移动了 sz (这里是5)个位置，指向新位置的元素。也<J2£] 就是说，它指向了数组arr尾元素的下一位置。如果计算所得的指针超出了上述范围就 将产生错误，而且这种错误编译器一般发现不了。

和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指 向同一个数组当中的元素：

auto n = end (arr) - begin (arr); // n的值是5，也就是arr中元素的数量

两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t 一样， ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负 值，所以ptrdiff_t是一种带符号类型。

只要两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一位置，就能利 用关系运算符对其进行比较。例如，可以按照如下的方式遍历数组中的元素：

int *b = arr, *e = arr + sz; while (b < e) {

//使用*b ++b;

}

如果两个指针分别指向不相关的对象，则不能比较它们：

int i=0, sz = 42; int *p = &i, *e = &sz;

//未定义的：p和e无关，因此比较毫无意义！ while (p < e)

尽管作用可能不是特别明显，但必须说明的是，上述指针运算同样适用于空指针(参 见Z3.2节，第48页)和所指对象并非数组的指针。在后一种情况下，两个指针必须指向 同一个对象或该对象的下一位置。如果p是空指针，允许给p加上或减去一个值为0的 整型常量表达式(参见2.4+4节，第58页)。两个空指针也允许彼此相减，结果当然是0。

解引用和指针运算的交互

指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许 解引用该结果指针：

int ia[] = {0,2,4,6,8};    //含有5个整数的数组

int last = * （ia + 4） ;    //正确：把last初始化成8,也就是ia[4]的值

表达式* （ia+4>计算ia前进4个元素后的新地址，解引用该结果指针的效果等价于表达 式 ia[4]。

回忆一下在3.4.1节（第98页）中介绍过如果表达式含有解引用运算符和点运算符， 最好在必要的地方加上圆括号。类似的，此例中指针加法的圆括号也不可缺少。如果写成 下面的形式：

last = *ia + 4; // 正确：last =4 等价于 ia[0] +4

含义就与之前完全不同了，此时先解引用ia,然后给解引用的结果再加上4。4.1.2节（第 121页）将对这一问题做进一步分析。

下标和指针

EZK> 如前所述，在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针。一 个典型的例子是当对数组使用下标运算符时，编译器会自动执行上述转换操作。给定

int ia[] = {0,2, 4,6, 8}; //含有5个整数的数组

此时，ia[0]是一个使用了数组名字的表达式，对数组执行下标运算其实是对指向数组元 素的指针执行下标运算：

int i = ia[2];

int *p = ia; i = * (p + 2);



// ia转换成指向数组首元素的指针 // ia[2]得到（ia + 2）所指的元素 // p指向ia的首元素

II等价于i = ia[2]

只耍指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算: int    *p = &ia [2] ;    II    p指向索引为2的元素

int    j = p [ 1 ];    //    p[l]等价于* （p + 1）,就是ia [3]表示的那个元素

int    k = p [-2] ;    //    p [-2]是ia [0]表示的那个元素

虽然标准库类型string和vector也能执行下标运算，但是数组与它们相比还是有 所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求，上 面的最后一个例子很好地说明了这一点。内置的下标运算符可以处理负值，当然，结果地 址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置X

A

WARNING



内置的下标运算符所用的索引值不是无符号类型， string 不一样o

这一点与 vector 和



###### 3.5.3节练习

练习3.34：假定pi和p2指向同一个数组中的元素，则下面程序的功能是什么？什么 情况下该程序是非法的？ pi += p2 - pi;

练习3.35:编写一段程序，利用指针将数组中的元素置为0。

练习3.36:编写一段程序，比较两个数组是否相等。再写一段程序，比较两个vector 对象是否相等。

3.5.4

WARNING



C风格字符申

尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们，这是因 为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全 问题的根本原因。

字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的C风格字符串 (C-style character string)。C风格字符串不是一种类型，而是为了表达和使用字符串而形成 的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束(null terminated)o以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符('\0,)。 一般利用指针来操作这些字符串。

C标准库String函数

表3.8列举了 C语言标准库提供的一组函数，这些函数可用于操作C风格字符串，它 们定义在cstring头文件中，cstring是C语言头文件string. h的C++版本。

表3.8: C风格字符串的函数

| strlen(p)      | 返回p的长度，空字符不计算在内                                |
| -------------- | ------------------------------------------------------------ |
| strcmp(pi, p2) | 比较pi和p2的相等性。如果pl==p2，返回0;如果pl>p2,返回一个正值；如果pl<p2,返回一个负值 |
| strcat(pi, p2) | 将p2附加到pi之后，返回pi                                     |
| strcpy(pi, p2) | 将p2拷贝给pi，返回pi                                         |

WARNING

表3.8所列的函数不负责验证其字符串参数。

传入此类函数的指针必须指向以空字符作为结束的数组：

char ca[] = {'C',    // 不以空字符结束

cout « strlen(ca) « endl;    //严重错误：ca没有以空字符结束

此例中，ca虽然也是一个字符数组但它不是以空字符作为结束的，因此上述程序将产生 未定义的结果。strlen函数将有可能沿着ca在内存中的位置不断向前寻找，直到遇到 空字符才停下来。

比较字符串

比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径 庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符：

string si = *'A string example"; string s2 = "A different string"; if (si < s2) // false： s2 小于 si

如果把这些运算符用在两个c风格字符串上，实际比较的将是指针而非字符串本身：

const char cal[] = "A string example"; const char ca2[] = "A different string"; if (cal < ca2) //未定义的：试图比较两个无关地址

谨记之前介绍过的，当使用数组的时候其实真正用的是指向数组首元素的指针(参见3.5.3 节，第105页)。因此，上面的if条件实际上比较的是两个const char*的值。这两个

<3221



<J23]



指针指向的并非同一对象，所以将得到未定义的结果。

要想比较两个C风格字符串需要调用strcmp函数，此时比较的就不再是指针了。如 果两个字符串相等，strcmp返回0;如果前面的字符串较大，返回正值；如果后面的字 符串较大，返回负值：

if (strcmp (cal, ca2) < 0) // 和两个 string 对象的比较 si < s2 效果一样

目标字符串的大小由调用者指定

连接或拷贝C风格字符串也与标准库string对象的同类操作差别很大。例如，要想 把刚刚定义的那两个string对象si和s2连接起来，可以直接写成下面的形式：

//将largeStr初始化成si、一个空格和s2的连接 string largeStr = si + " " + s2;

同样的操作如果放到cal和ca2这两个数组身上就会产生错误了。表达式cal + ca2 试图将两个指针相加，显然这样的操作没什么意义，也肯定是非法的。

正确的方法是使用strcat函数和strcpy函数。不过要想使用这两个函数，还必须 提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的 空字符。下面的代码虽然很常见，但是充满了安全风险，极易引发严重错误：

//如果我们计算错了 largeStr的大小将引发严重错误 strcpy (largeStr,    cal) ;    //    把 cal 拷贝给 largeStr

strcat (largeStr,    ’• ’’)；    //    在 largeStr 的末尾加上一个空格

strcat (largeStr,    ca2) ;    //    把 ca2 连接到 largeStr 后面

一个潜在的问题是，我们在估算largeStr所需的空间时不容易估准，而且largeStr 所存的内容一旦改变，就必须重新检查其空间是否足够。不幸的是，这样的代码到处都是, 程序员根本没法照顾周全。这类代码充满了风险而且经常导致严重的安全泄漏。

![img](C++  Primer 5-44.jpg)



对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高 效。

Pi24>



###### 3.5.4节练习

练习3.37:下面的程序是何含义，程序的输出结果是什么？

const char ca[] = {r hr, r 'lz, zlz, 1or }; const char *cp = ca; while (*cp)    {

cout « *cp << endl;

++cp;

}

练习3.38：在本节中我们提到，将两个指针相加不但是非法的，而且也没什么意义。请 问为什么两个指针相加没什么意义？

练习3.39：编写一段程序，比较两个string对象u再编写一段程序，比较两个C风 格字符串的内容。

练习3.40:编写一段程序，定义两个字符数组并用字符串字面值初始化它们；接着再定 义一个字符数组存放前两个数组连接后的结果。使用strcpy和strcat把前两个数组 的内容拷贝到第三个数组中。

###### 3.5.5与旧代码的接U

很多C++程序在标准库出现之前就已经写成了，它们肯定没用到string和vector 类型。而且，有一些C杆程序实际上是与C语言或其他语言的接口程序，当然也无法使用 C++标准厍。因此，现代的C杆程序不得不与那些充满了数组和/或C风格字符串的代码衔 接，为了使这一工作简单易行，C++专门提供了一组功能。

混用string对象和C风格字符串    O

3.2.1节(第76页)介绍过允许使用字符串字面值来初始化string对象： string s ("Hello World") ; // s 的内容是 Hello World

更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组來替 代：

•允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。

•在string对象的加法运算中允许使用以空字符结朿的字符数组作为其中一个运 算对象(不能两个运算对象都是)；在string对象的复合赋值运算中允许使用以 空字符结束的字符数组作为右侧的运算对象。

上述性质反过来就不成立了：如果程序的某处需要一个C风格字符串，无法直接用 string对象来代替它。例如，不能用string对象直接初始化指向字符的指针。为了完 成该功能，string专门提供了一个名为c_str的成员函数：

char *str = s; //错误：不能用string对象初始化char* const char *str = s.c_str(); // 正确

顾名思义，c_str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是<J25] 一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个 string对象的-样。结果指针的类型是const char*,从而确保我们不会改变字符数 组的内容。

我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返1]的数组失去效用。

/\ 如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数 组重新拷贝一份。

WARNING

使用数组初始化vector对象

3.5.1节(第102页)介绍过不允许使用一个数组为另一个内置类型的数组赋初值，也 不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。要 实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了：

int int_arr[] = {0, 1, 2, 3, 4, 5};

// ivec有6个元素，分别是int_arr中对应元素的副本 vector<int> ivec(begin(int_arr), end(int_arr));

在上述代码中，用于创建ivec的两个指针实际上指明了用來初始化的值在数组int_arr 中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。此例中，使用标牟函 数begin和end (参见3.5.3节，第106页)來分别计算int_arr的首指针和尾后指 针。在最终的结果中，ivec将包含6个元素，它们的次序和值jp与数组int arr完全

一样。，

用于初始化vector对象的值也可能仅是数组的一部分：

// 拷贝三个元素：int_arr[l]、int_arr[2]、int_arr [3] vector<int> subVec（int_arr + 1, int_arr + 4）;

这条初始化语句用3个元素创建了对象subVec, 3个元素的值分别來自int_arr[l]、 int_arr[2]和 int_arr[3]。

建议：尽a使川榇准库类型而非数组

使用指针和数组很容易出错。一部分原因是概念上的问题：指针常用于底层操作， 因此容易引发一些与烦琐细节有关的错误。其他问题则源于语法错误，特别是声明指针 时的语法错误。

现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该 尽量使用string,避免使用C风格的基于数组的字符串，

###### 3.5.5节练习

练习3.41:编写一段程序，用整型数组初始化一个vector对象。

练习3.42:编写-段程序，将含有整数元素的vector对象拷贝给一个整型数组。

###### O 3.6多维数绀

严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记 Ej26>这一点，对今后理解和使用多维数组大有益处。

当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本 身大小，另外-个维度表示其元素（也是数组）大小：

int ia[3] [4] ; //大小为3的数组，每个元素是含有4个整数的数组

//大小为10的数组，它的每个元素都是大小为20的教组，

//这些数组的元素是含有30个整数的教组

int arr [10] [20] [30] = {0}; //将所有元素初始化为0

如3.5.1节（第103页）所介绍的，按照由内而外的顺序阅读此类定义有助于更好地理解 其真实含义。在第一条语句中，我们定义的名字是ia，显然ia是一个含有3个元素的数 组。接着观察右边发现，ia的元素也有自己的维度，所以ia的元素本身又都是含有4个 元素的数组。再观察左边知道，真正存储的元素是整数。因此最后可以明确第一条语句的 含义：它定义了一个大小为3的数组，该数组的每个元素都是含有4个整数的数组。

使用同样的方式理解arr的定义。首先arr是一个大小为10的数组，它的每个元素 都是大小为20的数组，这些数组的元素又都是含有30个整数的数组。实际上，定义数组 时对下标运算符的数量并没有限制，因此只要愿意就可以定义这样一个数组：它的元素还 是数组，下-级数组的元素还是数组，再下一级数组的元素还是数组，以此类推。

对予二维数组来说，常把第-•个维度称作行，第二个维度称作列。

多维数组的初始化

允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面的初 始化形式中，多维数组的每一行分别用花括号括了起来：

int ia[3][4] = {



//三个元素，每个元素都是大小为4的数组



{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}



//第1行的初始值 //第2行的初始值 //第3行的初始值



其中内层嵌套着的花括号并非必需的，例如下面的初始化语句，形式上更为简洁，完成的 功能和上面这段代码完全一样：

//没有标识每行的花括号，与之前的初始化语句是等价的 int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

类似于一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表 之内。如果仅仅想初始化每一行的第一个元素，通过如下的语句即可：

//显式地初始化每行的首元素    <J27~|

int ia[3][4] = {{ 0 }, { 4 }, { 8 }};

其他未列出的元素执行默认值初始化，这个过程和一维数组（参见3.5.1节，第102页）

一样。在这种情况下如果再省略掉内层的花括号，结果就大不一样了。下面的代码

//显式地初始化第1行，其他元素执行值初始化 int ix[3][4] = {0, 3r 6, 9};

含义发生了变化，它初始化的是第一行的4个元素，其他元素被初始化为0。

多维数组的下标引用

可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。

如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类 型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将 是给定索引处的一个内层数组：

//用arr的首元素为ia最后一行的最后一个元素蛾值 ia[2] [3] = arr[0][0] [0];

int （&row） [4] = ia [ 1] ; //把row绑定到ia的第二个4元素数组上

在第一个例子中，对于用到的两个数组来说，表达式提供的下标运算符数量都和它们各自 的维度相同。在等号左侧，ia[2]得到数组ia的最后一行，此吋返回的是表示ia最后 一行的那个一维数组而非任何实际元素；对这个一维数组再取下标，得到编号为[3]的元 素，也就是这一行的最后一个元素。

类似的，等号右侧的运算对象包含3个维度。首先通过索引0得到最外层的数组，它 是一个大小为20的（多维）数组：接着获取这20个元素数组的第一个元素，得到一个大 小为30的一维数组；最后再取出其中的第一个元素。

在第二个例子中，把row定义成一个含有4个整数的数组的引用，然后将其绑定到 ia的第2行。

再举一个例子，程序中经常会用到两层嵌套的for循环来处理多维数组的元素：

constexpr size t rowCnt



\3. colCnt



4;



int ia [rowCnt] [colCnt] ; // 12 个未初始化的元素 //对于每一行

for (size_t i = 0; i != rowCnt; ++i)    {

//对手行内的每一列

for (size_t j = 0; j != colCnt; ++j)    {

//将晃素的位置索引作为它的值 ia[i][j] = i * colCnt + j;

}

}

外层的for循环遍历ia的所有元素，注意这里的元素是一维数组：内层的for循环则 遍历那些一维数组的整数元素。此例中，我们将元素的值设为该元素在整个数组中的序号。

<§使用范围for语句处理多维数组

CJ28> 由于在C^ll新标准中新增了范围for语句，所以前一个程序可以简化为如下形式:

size_t cnt = 0;

for (auto &row : ia)

for (auto &col : row)

col = cnt;

++cnt;



//对于外层数组的每一个元素 {    //对于内层数组的每一个元素

II将下一个值赋给该元素 //将cnt加1

这个循环赋给ia元素的值和之前那个循环是完全相同的，区别之处是通过使用范围for 语句把管理数组索引的任务交给了系统来完成。因为要改变元素的值，所以得把控制变量 row和col声明成引用类型(参见3.2.3节，第83页)„第一个for循环遍历ia的所有 元素，这些元素是大小为4的数组，因此row的类型就应该是含有4个整数的数组的引 用。第二个for循环遍历那些4元素数组中的某一个，因此col的类型是整数的引用。 每次迭代把cnt的值赋给ia的当前元素，然后将cnt加1。

在上面的例子中，因为要改变数组元素的值，所以我们选用引用类型作为循环控制变 量，但其实还有一个深层次的原因促使我们这么做。举一个例子，考虑如下的循环：

for (const auto &row : ia) //对于外层数组的每一个元素 for (auto col : row)    //对于内层数组的每一个元素

cout << col << endl;

这个循环中并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型， 这是为了避免数组被自动转成指针(参见3.5.3节，第105页)。假设不用引用类型，则循 环如下述形式：

for (auto row-: ia)

for (auto col : row)

程序将无法通过编译。这是因为，像之前一样第一个循环遍历ia的所有元素，注意这些 元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自 动将这些数组形式的元素(和其他类型的数组一样)转换成指向该数组内首元素的指针。 这样得到的row的类型就是int*,显然内层的循环就不合法了，编译器将试图在一个 int*内遍历，这显然和程序的初衷相去甚远。

![img](C++  Primer 5-45.jpg)



要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的 控制变量都应该是引用类型。

指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组••，    <J29~I

因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向 第一个内层数组的指针：

int ia[3] [4] ;    //大小为3的数组，每个元素是含有4个整数的数组

int (*p) [4] = ia;    // p指向含有4个整教的数组

p = &ia [2] ;    // p指向ia的尾元素

根据3.5.1节(第103页)提出的策略，我们首先明确(*p)意味着p是一个指针。接着观 察右边发现，指针p所指的是一个维度为4的数组；再观察左边知道，数组中的元素是整 数。因此，p就是指向含有4个整数的数组的指针。

在上述声明中，圆括号必不可少：

/    int *ip[4] ;    //整型指针的数组

int (*ip) [4];    //指向含有4个整数的数组

随着C++11新标准的提出，通过使用auto或者decltype (参见2.5.2节，第61 页)就能尽可能地避免在数组前面加上一个指针类型了：

//输出ia中每个元素的值，每个内层数组各占一行

// p指向含有4个整数的数组

for (auto p = ia; p != ia + 3; ++p)    {

// q指向4个整数数组的首元素，也就是说，q指向一个整数 for (auto q = *p; q != *p + 4; ++q)

cout « *q « cout « endl;

外层的for循环首先声明一个指针p并令其指向ia的第一个内层数组，然后依次迭代直 到ia的全部3行都处理完为止。其中递增运算++P负责将指针p移动到ia的下一行。

内层的for循环负责输出内层数组所包含的值。它首先令指针q指向p当前所在行 的第一个元素。*p是一个含有4个整数的数组，像往常一样，数组名被自动地转换成指 向该数组首元素的指针。内层for循环不断迭代直到我们处理完了当前内层数组的所有 元素为止。为了获取内层for循环的终止条件，再一次解引用P得到指向内层数组首元 素的指针，给它加上4就得到了终止条件。

当然，使用标准库函数begin和end (参见3.5.3节，第106页)也能实现同样的功 能，而且看起来更简洁一些：

// p指向ia的第一个数组

for (auto p = begin(ia); p != end(ia); ++p)    {

// q指向内层数组的首元素

for (auto q = begin(*p); q != end(*p); ++q)

cout « *q <<'’；//输出q所指的整数值



cout « endl;

1~130>在这一版本的程序中，循环终止条件由end函数负责判断。虽然我们也能推断出P的类 型是指向含有4个整数的数组的指针，q的类型是指向整数的指针，但是使用auto关键 字我们就不必再烦心这些类型到底是什么了。

类型别名简化多维数组的指针

读、写和理解一个指向多维数组的指针是一个让人不胜其烦的工作，使用类型别名（参 见2.5.1节，第60页）能让这项工作变得简单一点儿，例如：

using int_array = int [ 4 ] ; / /新标准下类型别名的声明，参见2.5.1节（第60页） typedef int int_array [ 4 ] ; / / 等价的 typedef 声明，参见 2.5•丨节（第 60 页）

//输出ia中每个元素的值，每个内层数组各占一行 for （int_array *p = ia; p != ia 4- 3; ++p）    {

for （int *q = *p; q != *p + 4; ++q） cout << *q << '';

cout « endl;

}

程序将类型“4个整数组成的数组”命名为int_array,用类型名int_array定义外 层循环的控制变量让程序显得简洁明了。

###### 3.6节练习

练习3.43：编写3个不同版本的程序，令其均能输出ia的元素。版本1使用范围for 语句管理迭代过程；版本2和版本3都使用普通的for语句，其中版本2要求用下标 运算符，版本3要求用指针。此外，在所有3个版本的程序中都要直接写出数据类型， 而不能使用类型别名、auto关键字或decltype关键字。

练习3.44:改写上一个练习中的程序，使用类型别名来代替循环控制变量的类型。

练习3.45:再一次改写程序，这次使用auto关键字。

##### 小结

<J3E



string和vector是两种最重耍的标准库类型。string对象是一个可变长的字符 序列，vector对象是一组同类型対象的容器。

迭代器允许对容器中的对象进行间接访问，对于string对象和vector对象來说， 可以通过迭代器访问元素或者在元素间移动。

数组和指向数组元素的指针在一个较低的层次上实现了与标准库类型string和 vector类似的功能。一般来说，应该优先选用标准库提供的类型，之后再考虑C++语言 内置的低层的替代品数组或指针。

##### 术语表

begin是string和vector的成员，返 回指向第• •个元素的迭代器。也是•个标 准庳函数，输入一个数组，返回指向该数 组首元素的指针。

缓冲区溢出(bufferoverflow) •种严重的

程序故障，：t耍的原因是试图通过一个越 界的索引访问容器内容，容器类型包括 string、vector 和数组等。

C风格字符串(C-style string)以空字符

结束的字符数组。字符串字面值是C风格 字符串，C风格字符串容易出错。

类模板(class template)用于创建具体类

类型的模板。要想使用类模板，必须提供 关于类型的辅助信息。例如，要定义一个 vector对象需要指定元素的类型： vector<int>包含int类型的元素。

编译器扩展(compilerextension)某个特

定的编译器为C++语言额外增加的特性。 基于编译器扩展编写的程序不易移植到其 他编译器上。

容器(container)是一种樂型，其对象容 纳了…组给定类型的对象。vector是一 种容器类型。

拷贝初始化(copy initialization)使用赋

值号(=)的初始化形式。新创建的对象是 初始值的一个副本。

difference_type 由 string 和 vector 定 义的-种带符号整数类型，表示两个迭代 器之间的距离。

直接初始化(direct initialization)不使用

赋值号(=)的初始化形式。

empty是string和vector的成员，返 回一个布尔值。当对象的大小为0吋返冋 真否则返回假。

end是string和vector的成员，返回 一个尾后迭代器。也是一个标准库函数， 输入一个数组，返回指向该数组尾元素的 下-位置的指针。

getline在string头文件中定义的__ -个函 数,以一个istream对象和••-个string 对象为输入参数。该函数首先读取输入流的 内容直到遇到换行符停止，然后将读入的数 据存入string对象，最后返回istream 对象。其中换行符谈入何是不保留。

索引(index)是下标运算符使用的值。 表示耍在string对象、vector对象或 者数组中访问的…个位置。

实例化(instantiation)编译器生成_—个

指定的模板类或函数的过程》

迭代器(iterator)是•种类型，用于访问

容器中的元素或者在元素之間移动。

迭代器运算(iterator arithmetic )是

string或vector的迭代器的运算：迭 代器与整数相加或相减得到一个新的迭代 器，与原來的迭代器相比，新迭代器向前 或向后移动了若干个位置。两个迭代器相 减得到它们之间的距离，此时它们必须指 向同一个容器的元素或该容器尾元素的下 一位置。

以空字符结束的字符串(null-terminated string)是一个字符串，它的最后一个字 符后而还跟着一个空字符('\0，)0

尾后迭代器(off-the-end iterator) end

函数返冋的迭代器，指向•个并不存在的 元素，该元素位丁•容器尾元素的下一•位置。

指针运算(pointer arithmetic)是指针类

型支持的算术运算。指向数组的指针所支 持的运算种类与迭代器运算-样。

prtdiff_t是cstddef头支件中定义的一种 与机器实现有关的带符吁整数类型，它的 空间足够人，能够表示数组中任意两个指 针之间的距离。

push_back 是 vector 的成 izj，|nj vector对象的末嵐添加元素。

范围for语句(range for)    ••种控制语句，

讨以在值的一个特定集合内迭代。

size是string和vector的成员，分别 返问字符的数S•或元素的数量。返回值的 类型是 size_typeo

size_t是cstddef头文件中定义的一•种 与机器实现有关的无符号整数类型，它的 空問足够大，能够表示任意数组的大小。

size」ype 是 string 和 vector 定义的 类型的名字，能存放下任意string对象 或vector对象的大小。在标准阵中， s i z e_type被定义为无符兮类型。 string是一种标准库类型，表示字符的序列。

using 声明(using declaration)令命名空

问中的某个名字可被程序直接使用。 using命名空间名字；

L:述语句的作用是令程序可以直接使用茗 字，而无须写它的前缀部分余名空7献：：。

值初始化(valueinitialization)是一-种初

始化过程。内置类型初始化为0,类类型由

类的默认构造函数初始化。只有当类包含 默认构造函数吋，该类的对象才会被值初 始化。对于容器的初始化来说，如果只说 明了容器的大小而没有指定初始值的话， 就会执行值初始化。此时编译器会生成…-个值，而容器的元素被初始化为该值。

vector是一种标准库类型、容纳某指定类 型的-组元素。

++运算符C++ operator)是迭代器和指针

定义的递增运算符。执行“加1”操作使得 迭代器指向下-…个元素。

[]运算符([]operator)下标运算符。ob j [ j ] 得到容器对象ob j中位置j的那个元素。 索引从0开始，第一个元素的索引是0，

尾元素的索引是obj . size ()-1。下标运 算符的返冋值是一个对象。如果P足指针、 n是整数，则p [n]与* (p+n)等价。

->运算符> operator)箭头运算符，该运

算符综合了解引用操作和点操作。a->b等 价于(*a) ,b.

<<运算符(《 operator)标准阼类型string 定义的输出运算符，负.责输出string对 象中的字符。

\>>运算符(>> operator)标准库类型

string定义的输入运算符，负责读入一 组字符，遇到空fi停止，读入的内容赋给 运算符右侧的运算对象，该运算对象应该 是一个string对象。

!运算符(！ operator)逻辑非运算符，将它

的运算对象的布尔值取反，如果运算对象 是假，则结果为真，如果运算对象是真， 则结果为假。

&&运算符(&& operator)逻辑与运算符，

如果两个运算对象都是真，结果为真。只 有当左侧运算对象为真时才会检査右侧运 算对象。

II运算符(|| operator)逻辑或运算符，任

何一个运算对象是真，结果就为真。只有 当左侧运算对象为假吋才会检査右侧运算 对象。
