.....................................................................................................................523

..................................................................................................................523

在第4章中我们看到，C++语言定义了大量运算符以及内置类型的自动转换规则。这 些特性使得程序员能编写出形式丰富、含有多种混合类型的表达式。

当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义：同时，我们 也能自定义类类型之间的转换规则。和内置类型的转换一样，类类型转换隐式地将一•种类 型的对象转换成另一种我们所需类型的对象。

□52>    当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含

义。明智地使用运算符重载能令我们的程序更易于编写和阅读。举个例子，因为在 Sales_item类（参见1.5.1节，第17页）中定义了输入、输出和加法运算符，所以可以 通过下述形式输出两个Sales_item的和：

cout « iteml + item2;    II 输出两个 Sales_item 的和

相反的，由于我们的Sales_data类（参见7.1节，第228页）还没有重载这些运算符, 因此它的加法代码显得比较冗长而不清晰：

print （cout, add （datal, data2） ） ; II 输出两个 Sales_data 的和

##### 14.1基本概念

重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定 义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及 函数体。

重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一 个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，而 右侧运算对象传递给第二个参数。除了重载的函数调用运算符operator （）之外，其他重 载运算符不能含有默认实参（参见6.5.1节，第211页）。

如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this 指针上（参见7.1.2节，第231页），因此，成员运算符函数的（显式）参数数量比运算符 的运算对象总数少一个。

![img](C++  Primer 5-124.jpg)



当一个重载的运算符是成员函数时，this绑定到左侧运算对象成员运算符 函数的（显式）参数数量比运算对象的数量少一个

对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数：

//错误：不能为int重定义内置的运算符 int operators（int, int）;

这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的 含义，

我们可以重载大多数（但不是全部）运算符。表14.1指明了哪些运算符可以被重载， 哪些不行。我们将在19.1.1节（第726页）介绍重载new和delete的方法。

我们只能重载已有的运算符，而无权发明新的运算符号。例如，我们不能提供 operator**来执行幂操作。

有四个符号（+、-、*、&）既是一元运算符也是二元运算符，所有这些运算符都能 被重载，从参数的数量我们可以推断到底定义的是哪种运算符。

H53>    对于一个重载的运算符来说，其优先级和结合律（参见4.1.2节，第121页）与对应

的内置运算符保持一致。不考虑运算对象类型的话，

x == y + z;

永远等价于x = （y + z）。

|                    | 表 14.1： | 运算符 |        |        |           |
| ------------------ | --------- | ------ | ------ | ------ | --------- |
| 可以被重载的运算符 |           |        |        |        |           |
| +                  | 一        | ★      | /      | %      |           |
| &                  | I         |        | 1      | r      | =         |
| <                  | >         | <=     | >=     | ++     | —         |
| «                  | »         | ==     | 1 =    |        | II        |
| +=                 | —=        | /=     | %=     | 八=    | &=        |
| 1 =                | *=        | <<=    | »=     | []     | 0         |
| —>                 | ->*       | new    | new [] | delete | delete [] |
| 不能被重载的运算符 |           |        |        |        |           |
|                    |           | *      |        |        |           |

直接调用一个重载的运算符函数

通常情况下，我们将运算符作用于类型正确的实参，从而以这种间接方式“调用”重 载的运算符函数。然而，我们也能像调用普通函数一样直接调用运算符函数，先指定函数 名字，然后传入数量正确、类型适当的实参：

// 一个非成员运算符函数的等价调用

datal + data2 ；    //普通的表达式

operators- （datal, data2） ；    // 等价的函数调用

这两次调用是等价的，它们都调用了非成员函数operator,传入datal作为第一个实 参、传入data2作为第二个实参。

我们像调用其他成员函数一样显式地调用成员运算符函数。具体做法是，首先指定运 行函数的对象（或指针）的名字，然后使用点运算符（或箭头运算符）访问希望调用的函 数：

datal += data2;    //基于“调用”的表达式

datal. operator+= （data2） ;    //对成员运算符函数的等价调用

这两条语句都调用了成员函数operator+=，将this绑定到datal的地址、将data2 作为实参传入了函数。

某些运算符不应该被重载

回忆之前介绍过的，某些运算符指定了运算对象求值的顺序。因为使用重载的运算符 本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符 上。特别是，逻辑与运算符、逻辑或运算符（参见4.3节，第126页）和逗号运算符（参 见4.10节，第140页）的运算对象求值顺序规则无法保留下来。除此之外，&&和||运算＜5^ 符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。

因为上述运算符的重载版本无法保留求值顺序和/或短路求值属性，因此不建议重载它 们。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规 则不再适用了。

还有一个原因使得我们一般不重载逗号运算符和取地址运算符：C++语言已经定义了 这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两 种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于 常态，从而导致类的用户无法适应。

通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符,.

使用与内置类型一致的含义

当你开始设计一个类时，首先应该考虑的是这个类将提供哪些操作。在确定类需耍哪 些操作之后，才能思考到底应该把每个类操作设成普通函数还是重载的运算符。如果某些 操作在逻辑上与运算符相关，则它们适合于定义成重载的运算符：

•如果类执行［0操作，则定义移位运算符使其与内置类型的10保持一致。

•如果类的某个操作是检查相等性，则定义operator==:如果类有了 operator==,意味着它通常也应该有operator !=。

•如果类包含一个内在的单序比较操作，则定义operator< ；如果类有了 operators则它也应该含有其他关系操作。

•重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：逻辑运算符 和关系运算符应该返回bool,算术运算符应该返回一个类类型的值，赋值运算符 和复合赋值运算符则应该返回左侧运算对象的-个引用。

提示：尽量明智地使用运算符甫载

每个运算符在用于内置类型时都有比较明确的含义。以二元+运算符为例，它明显 执行的是加法操作。因此，把二元+运算符映射到类类型的一个类似操作上可以极大地 简化记忆。例如对于标准库类型string来说，我们就会使用+把一个string对象连 接到另一个后面，很多编程语言都有类似的用法。

当在内置的运算符和我们自己的操作之间存在逻辑映射关系时，运算符重载的效果 最好/.此时，使用重载的运算符显然比另起一个名字更自然也更直观。不过，过分滥用 运算符重载也会使我们的类变得难以理解。

在实际编程过程中，一般没有特别明显的滥用运算符重载的情况。例如，一般来说 没有哪个程序员会定义Operator+并让它执行减法操作。然而经常发生的一种情况是， 程序员可能会强行扭曲了运算符的“常规”含义使得其适应某种给定的类型，这显然是 我们不希望发生的。因此我们的建议是：只有当操作的含义对于用户来说清晰明了时才 使用运算符。如果用户对运算符可能有几种不同的理解，则使用这样的运算符将产生二 义性。

赋值和复合赋值运算符

赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值 相等，并且运算符应该返回它左侧运算对象的一个引用。重载的赋值运算应该继承而非违 背其内置版本的含义。

□§§>    如果类含有算术运算符（参见4.2节，第124页）或者位运算符（参见4.8节，第136

页），则最好也提供对应的复合赋值运算符。无须赘言，+=运算符的行为显然应该与其内 置版本一致，即先执行+，再执行=。

选择作为成员或者非成员

当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一 个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员：另一些

情况下，运算符作为普通函数比作为成员更好。

下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：

•赋值( = )、下标([])、调用(())和成员访问箭头(->)运算符必须是成员。

•复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。

•改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用 运算符，通常应该是成员。

•具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位 运算符等，因此它们通常应该是普通的非成员函数。

程序员希望能在含有混合类型的表达式中使用对称性运算符。例如，我们能求一个 int和一个double的和，因为它们中的任意一个都可以是左侧运算对象或右侧运算对象， 所以加法是对称的。如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成 非成员函数。

当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对 象。例如：

string s = "world";

string t = s +    //正确：我们能把一个const char*加到一个string对象中

string u = "hi" + s; //如果+是string的成员，则产生错误

如果operator+是string类的成员，则上面的第一个加法等价于s.operator+ ("!")» 同样的，"hi"+s 等价于"hi" . operator+(s)。显然"hi"的类型是 const char*，这 是一种内置类型，根本就没有成员函数。

因为string将+定义成了普通的非成员函数，所以”hi”+s等价于 operator+("hi",s)o和任何其他函数调用一样，每个实参都能被转换成形参类型。唯 一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成 string。

###### 14.1节练习

练习14.1:在什么情况下重载的运算符与内置运算符有所区别？在什么情况下重载的运 算符又与内置运算符一样？

练习14.2:为sales_data编写重载的输入、输出、加法和复合赋值运算符。

练习14.3: string和vector都定义了重载的=以比较各自的对象，假设svecl和 svec2是存放string的vector,确定在下面的表达式中分别使用了哪个版本的==?

(a) "cobble" == "stone"    (b) svecl [0] == svec2 [0]

(c) svecl == svec2    (d) "svecl [0] == "stone"

练习14.4:如何确定下列运算符是否应该是类的成员？

(a) %    (b) %=    (c) ++    (d) ->    (e) «    (f) &&    (g) ==    (h)()

练习14.5:在7.5.1节的练习7.40 (第261页)中，编写了下列类中某一个的框架，请 问在这个类中应该定义重载的运算符吗？如果是，请写出来。

(a) Book (d) Vehicle



(b) Date (e) Object



(c) Employee (f) Tree



##### 14.2输入和输出运算符

如我们所知，io标准库分别使用>>和《执行输入和输出操作。对于这两个运算符来 L557>说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支

持io操作。

組14.2.1重载输出运算符《

通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以 ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法 直接复制一个ostream对象。

第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形 参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量是因为(通常情况 F)打印对象不会改变对象的内容。

为了与其他输出运算符保持-'致，operator<<_般要返回它的ostream形参。

Sales_data的输出运算符

举个例子，我们按照如下形式编写Sales_data的输出运算符：

ostream &operator«(ostream &os, const Sales_data &item)

{

os « item.isbn() << " " « item.units_sold « ""

<< item.revenue << " " << item.avg_price();

return os;

}

除了名字之外，这个函数与之前的print函数(参见7.1.3节，第234页)完全一样。打 印一个SaleS_data对象意味着要分别打印它的三个数据成员以及通过计算得到的平均 销售价格，每个元素以空格隔开。完成输出后，运算符返回刚刚使用的ostream的引用。

输出运算符尽量减少格式化操作

用于内置类型的输出运算符不太考虑格式化操作，尤其不会打印换行符，用户希望类 的输出运算符也像如此行事。如果运算符打印了换行符，则用户就无法在对象的同一行内 接着打印一些描述性的文本了。相反，令输出运算符尽量减少格式化操作可以使用户有权 控制输出的细节。

Pest

Pwietiftes



通常，输出运算符应该主要⑦责打印对象的内容而非控制格式，输出运算符不 应该打印换行符

输入输出运算符必须是非成员函数

与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类 的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象：

Sales_data data;

data « cout;    // 如果 operator«A Sales_data 的成员

假设输入输出运算符是某个类的成员，则它们也必须是istream或ostream的成员。 然而，这两个类属于标准库，并J1.我们无法给标准序中的类添加任何成员。

因此，如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数。当然， IO运算符通常需要读写类的非公有数据成员，所以1O运算符一般被声明为友元（参见7.2.1 节，第241页）。

###### 14.2.1节练习    —

练习14.6:为你的Sales_data类定义输出运算符。

练习14.7:你在13.5节的练习（第470页）中曾经编写了一个String类，为它定义 一个输出运算符。

练习14.8:你在7.5.1节的练习7.40 （第261页）中曾经选择并编写了一个类，为它定 义一个输出运算符。

###### 14.2.2重载输入运算符》 ®

通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是 将要读入到的（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形 参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。

Sales_data的输入运算符

举个例子，我们将按照如下形式编写Sales_data的输入运算符：

istream &operator»（istream &is, Sales_data &item）

{

double price;//不需要初始化，因为我们将先读入数据到price,之后才使用它 is » item.bookNo » item.units_sold » price; if （is）    //检查输入是否成功

item.revenue = item.units_sold * price;

else

item = Sales_data （） ; //输入失败：对象被賊予默认的状态 return is;

}

除了 if语句之外，这个定义与之前的read函数（参见7.1.3节，第234页）完全一样。 if语句检查读取操作是否成功，如果发生了 IO错误，则运算符将给定的对象重置为空 Sales_data,这样可以确保对象处于正确的状态。

输入运算符必须处理输入可能失败的情况，而输出运算符不需要

输入时的错误    <S

在执行输入运算符时可能发生下列错误：

•当流含有错误类型的数据吋读取操作可能失败。例如在读取完bookNo后，输入运 算符假定接下来读入的是两个数字数据，一旦输入的不是数字数据，则读取操作及 后续对流的其他使用都将失败。

•当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。

在程序中我们没有逐个检查每个读取操作，而是等读取了所有数据后赶在使用这些数据前 一次性检查：

if (is)    //检查输入是否成功

item.revenue = item.units_sold * price;

else

item = Sales_data () ;    //输入失败：对象被赋予默认的状态

如果读取操作失败，则price的值将是未定义的=因此，在使用price前我们需要首先 检查输入流的合法性，然后才能执行计算并将结果存入revenueo如果发生了错误，我 们无须在意到底是哪部分输入失败，只要将一个新的默认初始化的Sales_data对象赋 予item从而将其重置为空Sales_data就可以了。执行这样的赋值后，item的bookNo 成员将是一个空string, revenue和units_sold成员将等于0。

如果在发生错误前对象已经有一部分被改变，则适吋地将对象置为合法状态显得异常 重要。例如在这个输入运算符中，我们可能在成功读取新的bookNo后遇到错误，这意味 着对象的units_sold和revenue成员并没有改变，因此有可能会将这两个数据与一条 完全不匹配的bookNo组合在一起。

通过将对象置为合法的状态，我们能(略微)保护使用者免于受到输入错误的影响。 此吋的对象处于可用状态，即它的成员都是被正确定义的。而且该对象也不会产生误导性 的结果，因为它的数据在本质上确实是一体的。

当读取操作发生错误时，输入运算符应该负责从错误中恢复。



标示错误

一些输入运算符需要做更多数据验证的工作。例如，我们的输入运算符可能需要检查 bookNo是否符合规范的格式。在这样的例子中，即使从技术上来看IO是成功的，输入 运算符也应该设置流的条件状态以标示出失败信息(参见8.1.2节，第279页)。通常情况 下，输入运算符只设置failbit«除此之外，设置eofbit表示文件耗尽，而设置badbit 表示流被破坏。最好的方式是由10标准库自己来标示这些错误。

###### »    14.2.2节练习

练习14.9:为你的SaleS_data类定义输入运算符。

练习14.10:对于Sales_data的输入运算符来说如果给定了下面的输入将发生什么情 况？

(a) 0-201-99999-9 10 24.95    (b) 10 24.95 0-210-99999-9

练习14.11：下面的sales_data输入运算符存在错误吗？如果有，请指出来。对于这 个输入运算符如果仍然给定1个练习的输入将发生什么情况？

istream& operator〉〉(istream& in, Sales_data& s)

{

double price;

in >> s.bookNo » s.units_sold » price; s.revenue = s.units_sold * price; return in;

}

练习14.12：你在7.5.1节的练习7.40 (第261页)中曾经选择并编写了一个类，为它定 义一个输入运算符并确保该运算符可以处理输入错误。

##### 14.3算术和关系运算符

通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算 对象进行转换（参见14.1节，第492页）。因为这些运算符一般不需要改变运算对象的状 态，所以形参都是常量的引用。

算术运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运 算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果。如 果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的 方式是使用复合赋值来定义算术运算符：

//假设两个对象指向同一本书

Sales_data

operator^（const Sales_data &lhs, const Sales_data &rhs）

{

Sales data sum = lhs;    //把lhs的数据成员拷贝给sum

sum += rhs;    // 将 rhs 加到 sum 中

return sum;

}

这个定义与原来的add函数（参见7.1.3节，第234页）是完全等价的。我们把lhs 拷贝给局部变量sum,然后使用Sales_data的复合赋值运算符（将在第500页定义）

将rhs的值加到sum中，最后函数返回sum的副本。

如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使 <561~| 用复合賦值来实现算术运算符。

14.3节练习

练习14.13：你认为Sales_data类还应该支持哪些其他算术运算符（参见表4.1,第 124页）？如果有的话，请给出它们的定义。

练习14.14：你觉得为什么调用operator+=来定义operator+比其他方法更有效？

练习14.15：你在7.5.1节的练习7.40 （第261页）中曾经选择并编写了一个类，你认为 它应该含有其他算术运算符吗？如果是，请实现它们；如果不是，解释原因。

14.3.1相等运算符    ^6

通常情况下，C++中的类通过定义相等运算符来检验两个对象是否相等。也就是说，

它们会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相 等。依据这一思想，我们的Sales_data类的相等运算符不但应该比较bookNo,还应 该比较具体的销售数据：

bool operator==(const Sales_data &lhs, const Sales_data &rhs) {

return lhs.isbn() == rhs.isbn() &&

lhs.units_sold == rhs.units_sold && lhs.revenue == rhs.revenue;

}

bool operator!=(const Sales data &lhs, const Sales data &rhs)

return !（lhs == rhs）;

}

就上面这些函数的定义本身而言，它们似乎比较简单，也没什么价值，对于我们来说重要 的是从这些函数中体现出来的设计准则：

•如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成 oPeratOr==而非一个普通的命名函数：因为用户肯定希望能使用==比较对象， 所以提供了 ==就意味着用户无须再费时费力地学习并记忆一个全新的函数名字。 此外，类定义了==运算符之后也更容易使用标准库容器和算法。

•如果类定义了 oPerator==,则该运算符应该能判断一组给定的对象中是否含有 重复数据，

r562＞    •通常情况下，相等运算符应该具有传递性，换句话说，如果a==b和b==c都为真，

则a==c也应该为真。

•如果类定义了 operator==，则这个炎也应该定义operator !=。对于用户来说， 当他们能使用==时肯定也希望能使用！=,反之亦然。

•相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一 个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作 的运算符。

Best    如果某个类在逻辑上有相等性的含义，则该类应该定义operator==,这样做

可以使得用户更容易使用标准库算法来处理这个类。

###### 14.3.1节练习

练习14.16：为你的StrBlob类（参见12.1.1节，第405页）、StrBlobPtr类（参见 12—1.6节，第421页）、StrVec类（参见13.5节，第465页）和String类（参见13.5 节，第470页）分别定义相等运算符和不相等运算符。

练习14.17：你在7.5.1节的练习7.40 （第261页）中曾经选择并编写了一个类，你认为 它应该含有相等运算符吗？如果是，请实现它；如果不是，解释原因。

###### 14.3.2关系运算符

定义了相等运算符的类也常常（但不总是）包含关系运算符。特别是，因为关联容器 和一些算法要用到小于运算符，所以定义operatorc会比较有用。

通常情况下关系运算符应该

\1.    定义顺序关系，令其与关联容器中对关键字的要求一致（参见11.2.2节，第378 页）；并且

\2.    如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致。特别是， 如果两个对象是！=的，那么一个对象应该＜另外一个。

尽管我们可能会认为Sales_data类应该支持关系运算符，但事实证明并非如此， 其中的缘由比较微妙，值得读者深思。

一开始我们可能会认为应该像comparelsbn （参见11.2.2节，第379页）那样定义 ＜，该函数通过比较ISBN来实现对两个对象的比较。然而，尽管comparelsbn提供的

顺序关系符合要求1，但是函数得到的结果显然与我们定义的==不一致，因此它不满足要求2。

对于Sales_data的==运算符来说，如果两笔交易的revenue和units_sold成 员不同，那么即它们的ISBN相同也无济于事，它们仍然是不相等的。如果我h定义的 〈运算符仅仅比较ISBN成员，那么将发生这样的情况：两个ISBN相同但revenue和 Units_SOld不同的对象经比较是不相等的，但是其中的任何一个都不比另一个小。然而 实际情况是，如果我们有两个对象并且哪个都不比另一个小，则从道理上来讲这两个对象 应该是相等的。

< 563 I



基于上述分析我们也许会认为，只要让operatorc依次比较每个数据元素就能解决 问题了，比方说让operatorc先比较isbn，相等的话继续比较units_sold,还相等 再继续比较revenue。

然而，这样的排序没有任何必要。根据将来使用SaleS_data类的实际需要，我们 可能会希望先比较units_sold,也可能希望先比较revenue。有的时候，我们希® units_sold少的对象“小于”units_sold多的对象；另一些时候，则可能希望revenue 少的对象“小于” revenue多的对象。

因此对于Sales_data类来说，不存在一种逻辑可靠的＜定义，这个类不定义＜运算 符也许更好。

B«t    如果存在唯一一种逻辑可靠的＜定义，则应该考虑为这个类定义＜运算符如果

类同时还包含==，则当且仅当＜的定义和==产生的结果一致时才定义＜运算符。

###### 14.3.2节练习

练习14.18:为你的StrBlob类、StrBlobPtr类、StrVec类和String类定义关 系运算符。

练习14.19：你在7.5.1节的练习7.40 （第261页）中曾经选择并编写了一个类，你认为 它应该含有关系运算符吗？如果是，请实现它；如果不是，解释原因。

##### 14.4赋值运算符

之前已经介绍过拷贝赋值和移动赋值运算符（参见13.1.2节，第443页和13.6.2节， 第474页），它们可以把类的一个对象赋值给该类的另一个对象。此外，类还可以定义其 他赋值运算符以使用别的类型作为右侧运算对象。

举个例子，在拷贝赋值和移动赋值运算符之外，标准库vector类还定义了第三种赋 值运算符，该运算符接受花括号内的元素列表作为参数（参见9.2.5节，第302页）。我们 能以如下的形式使用该运算符：

vector＜string＞ v; v = {"a", "an", "the"};

同样，也可以把这个运算符添加到StrVec类中（参见13.5节，第465页）：

class StrVec { public:

StrVec &operator=（std::initializer_list＜std::string〉）；

//其他成员与13.5节（第465页）一致

}；

ri64>为了与内置类型的赋值运算符保持一致(也与我们己经定义的拷贝赋值和移动赋值运算一 致)，这个新的赋值运算符将返回其左侧运算对象的引用：

StrVec SStrVec::operator=(initializer_list<string> il)

{

// alloc_n_copy分配内存空间并从给定范围内拷贝元素 auto data = alloc_n_copy(il.begin() , il.end()); free() ;    _ _    //销毁对象中的元素并释放内存空间

elements = data . first;    //更新数据成员使其指向新空间

first_free = cap = data.second;

return *this;

}

和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间， 再创建一片新空间。不同之处是，这个运算符无须检查对象向自身的赋值，这是因为它的 形参 initializer_list<string> (参见 6.2.6 节，第 198 页)确保 il 与 this 所指 的不是同•个对象。_

![img](C++  Primer 5-125.jpg)



我们可以重载赋值运算符。不论形参的类型是什么，賦值运算符都必须定义为 成员函数。

复合赋值运算符

复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有 赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致，类中的复合赋值运算 符也要返回其左侧运算对象的引用。例如，下面是Sales_data类中复合赋值运算符的 定义：

//作为成员的二元运算符：左侧运算对象绑定到隐式的this指针

//假定两个对象表示的是同一本书

Sales_data& Sales_data::operator+=(const Sales_data Srhs)

{

units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;

}

Bert    赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。

这两类运算符都应该返回左侧运算对象的引用f ;

###### 14.4节练习

练习14.20：为你的Sales_data类定义加法和复合赋值运算符。

练习14.21:编写Sales_data类的+和+=运算符，使得+执行实际的加法操作而+=调 用+，相比于14.3节(第497页)和14.4节(第500页)对这两个运算符的定义，本题 的定义有何缺点？试讨论之。

练习14.22:定义赋值运算符的一个新版本，使得我们能把一个表示ISBN的string 赋给一个Sales_data对象。

练习14.23:为你的StrVec类定义一个initializer list赋值运算符。

练习14.24：你在7.5.1节的练习7.40 (第261页)中曾经选择并编写了一个类，你认为 它应该含有拷贝赋值和移动赋值运算符吗？如果是，请实现它们，

练习14.25：上题的这个类还需要定义其他赋值运算符吗？如果是，请实现它们；同时 说明运算对象应该是什么类型并解释原因。

##### 14.5下标运算符

表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运 算符 operator [] o

![img](C++  Primer 5-126.jpg)



下标运算符必须是成员函数。

< 565 |



为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样 做的好处是下标可以出现在赋值运算符的任意一端。进一步，我们最好同时定义下标运算 符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保 我们不会给返回的对象赋值。

Bert    如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，

另一个是类的常量成员并且返回常量引用,，

举个例子，我们按照如下形式定义StrVec (参见13.5节，第465页)的下标运算符：

class StrVec { public:

std::strings operator[](std::size_t n)

{ return elements[n]; }

const std::strings operator[](std::size_t n) const { return elements[n]; }

//其他成员与13.5 (第465页)一致 private:

std: : string *elements;    //指向数组首元素的指针

}；

上面这两个下标运算符的用法类似于vector或者数组中的下标。因为下标运算符返 回的是元素的引用，所以当StrVec是非常量时，我们可以给元素赋值：而当我们对常量 对象取下标时，不能为其赋值：

< 566 I



//假设svec是一个StrVec对象

const StrVec cvec = svec;    // 把 svec 的元素拷贝到 cvec 中

//如果svec中含有元素，对第一个元素运行string的empty函数 if (svec.size() && svec[0].empty())    {

svec[0] = "zero";    //正确：下标运算符返回string的引用

cvec[0] = "Zip";    //错误：对cvec取下标返回的是常量引用

###### 14.5节练习

练习14.26:为你的StrBlob类、StrBlobPtr类、StrVec类和String类定义下 标运算符。

##### 14.6递增和递减运算符

在迭代器类中通常会实现递增运算符(++)和递减运算符这两种运算符使得 类可以在元素的序列中前后移动。C++语言并不要求递增和递减运算符必须是类的成员， 但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。

对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应 该为类定义两个版本的递增和递减运算符。接下来我们首先介绍前置版本，然后实现后置 版本。

Best    定义递增和递减运算符的类应该同时定义前置版本和后置版本,，这些运算符通

PnU(it"常应该被定义成类的成员。

定义前置递增/递减运算符

为了说明递增和递减运算符，我们不妨在StrBlobPtr类(参见12.1.6节，第421 页)中定义它们：

class StrBlobPtr {

public:

//递增和递减运算符

StrBlobPtrS operator++ () ;    // 前置运算符

StrBlobPtrS operator--();

//其他成员和之前的版本一致

}；

为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用3

E56Z> 递增和递减运算符的工作机理非常相似：它们首先调用check函数检验 StrBlobPtr是否有效，如果是，接着检查给定的索引值是否有效。如果check函数没 有抛出异常，则运算符返回对象的引用。

在递增运算符的例子中，我们把curr的当前值传递给check函数。如果这个值小 于vector的大小，则check正常返回；否则，如果curr已经到达了 vector的末尾, check将抛出异常：

//前置版本：返回递增/递减对象的引用

StrBlobPtr& StrBlobPtr::operator++()

{

//如果curr已经指向了容器的尾后位置，则无法递增它 check (curr, "increment past end of StrBlobPtr*');

++curr;    //将curr在当前状态下向前移动一个元素

return *this;

StrBlobPtrS StrBlobPtr::operator--()

{

//如果curr是0,则继续递减它将产生一个无效下标

--curr;    //将curr在当前状态下向后移动一个元素

check(curr, "decrement past begin of StrBlobPtr"); return *this;

}

递减运算符先递减curr,然后调用check函数。此时，如果curr (—个无符号数)己 经是0 了，那么我们传递给check的值将是一个表示无效下标的非常大的正数值(参见

2.1.2 节，第 33 页)。

区分前置和后置运算符

要想同吋定义前置和后置运算符，必须首先解决一个问题，即普通的重载形式无法区 分这两种情况。前置和后置版本使用的是同一个符号，意味着其重载版本所用的名字将是 相同的，并且运算对象的数量和类型也相同。

为了解决这个问题，后置版本接受一个额外的(不被使用)int类型的形参。当我们 使用后置运算符时，编译器为这个形参提供一个值为0的实参。尽管从语法上来说后置函 数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参的唯一作用就 是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。

接下来我们为StrBlobPtr添加后置运算符：

class StrBlobPtr { public:

//递增和递减运算符

StrBlobPtr operator++(int) ;    // 后置运算符

StrBlobPtr operator——(int);

//其他成员和之前的版本一致

}；

< 568 |



Bast    为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前

Practices

的值)，返回的形式是一个值而非引用。

对于后置版本来说，在递增对象之前需要首先记录对象的状态：

//后置版本：递增/递减对象的值但是返回原值 StrBlobPtr StrBlobPtr::operator++(int)

{

//此处无须检查有效性，调用前置递增运算时才需要检查 StrBlobPtr ret = *this; // 记录当前的值

++*this;    //向前移动一个元素，前置++需要检查递增的有效性

return ret;    //返回之前记录的状态

}

StrBlobPtr StrBlobPtr::operator--(int)

{

//此处无须检查有效性，调用前置递减运算时才需要检查 StrBlobPtr ret = *this;    // 记录当前的值

--*this;    //向后移动一个元素，前置--需要检查递减的有效性

return ret;    //返回之前记录的状态

由上可知，我们的后置运算符调用各自的前置版本来完成实际的工作。例如后置递增运算 符执行

十+*this

该表达式调用前置递增运算符，前置递增运算符首先检查递增操作是否安全，根据检查的 结果抛出一个异常或者执行递増curr的操作。假定通过了检查，则后置函数返回事先存 好的ret的副本。因此最终的效果是，对象本身向前移动了一个元素，而返回的结果仍 然反映对象在未递增之前原始的值。

![img](C++  Primer 5-127.jpg)



因为我们不会用到int形参，所以无须为其命名



显式地调用后置运算符

如在第491页介绍的，可以显式地调用一个重载的运算符，其效果与在表达式中以运 算符号的形式使用它完全一样。如果我们想通过函数调用的方式调用后置版本，则必须为 它的整型参数传递一个值：

StrBlobPtr p (a 1) ;    // p 指向 al 中的 vector

p.operator++ (0) ;    // 调用后置版本的 operator++

p.operator++ () ;    // 调用前置版本的 operator++

尽管传入的值通常会被运算符函数忽略，但却必不可少，因为编译器只有通过它才能知道 应该使用后置版本。

I 569 >



###### 14.6节练习

练习14.27：为你的StrBlobPtr类添加递增和递减运算符。

练习14.28：为你的StrBlobPtr类添加加法和减法运算符，使其可以实现指针的算术 运算(参见3.5.3节，第106页乂

练习14.29：为什么不定义const版本的递增和递减运算符？

##### 14.7成员访问运算符

在迭代器类及智能指针类(参见12.1节，第400页)中常常用到解引用运算符(*) 和箭头运算符(->)。我们以如下形式向StrBlobPtr类添加这两种运算符：

class StrBlobPtr { public:

std::strings operator*() const

{ auto p = check(curr, "dereference past end"); return (*p) [curr] ;    // (*p)是对象所指的 vector

}

std::string* operator-> () const { //将实际工作委托给解引用运算符 return & this->operator*();

}

//其他成员与之前的版本一致

解引用运算符首先检查curr是否仍在作用范围内，如果是，则返回curr所指元素的一 个引用。箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元 素的地址。

![img](C++  Primer 5-128.jpg)



箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须 如此。

值得注意的是，我们将这两个运算符定义成了 const成员，这是因为与递増和递减 运算符不一样，获取一个元素并不会改变StrBlobPtr对象的状态。同时，它们的返回 值分别是非常量string的引用或指针，因为一个StrBlobPtr只能绑定到非常量的 StrBlob对象（参见12.1.6节，第421页）。

这两个运算符的用法与指针或者vector迭代器的对应操作完全一致：

StrBlob al = {"hi", "bye", "now"};



StrBlobPtr p(al);

*p = "okay";

cout « p->size() << endl; cout « (*p).size() « endl;



// p指向al中的vector //给al的首元素赋值 II打印4,这是al首元素的大小 // 等价于 p->size（>



对箭头运算符返回值的限定

<570~|



和大多数其他运算符一样（尽管这么做不太好），我们能令operator*完成任何我们 指定的操作。换句话说，我们可以让operator*返回一个固定值42,或者打印对象的内 容，或者其他。箭头运算符则不是这样，它永远不能丢掉成员访问这个最基本的含义。当 我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一事实 则永远不变。

对于形如point->mem的表达式来说，point必须是指向类对象的指针或者是一 个重载了 operator-〉的类的对象。根据point类型的不同，point->mem分别等 价于

（*point） .mem;    // point是一个内置的招针类麼

point. operator （） ->mem;    // point 是类的一个对象

除此之外，代码都将发生错误。pOint->mem的执行过程如下所示：

\1.    如果point是指针，则我们应用内置的箭头运算符，表达式等价于（*Point） .memo 首先解引用该指针，然后从所得的对象中获取指定的成员。如果point所指的类 型没有名为mem的成员，程序会发生错误。

\2.    如果point是定义了 operator-〉的类的一个对象，则我们使用point. operator-〉（） 的结果来获取mem。其中，如果该结果是一个指针，则执行第1步：如果该结果本 身含有重载的operator->（）,则重复调用当前步骤。最终，当这一过程结束时 程序或者返回了所需的内容，或者返回一些表示程序错误的信息。

重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对 d象。

###### 14.7节练习

练习14.30：为你的StrBlobPtr类和在12.1.6节练习12.22 (第423页)中定义的 ConstStrBlobPtr类分别添加解引用运算符和箭头运算符。注意：因为 ConstStrBlobPtr 的数据成员指向 const vector,所以 ConstStrBlobPtr 中的 运算符必须返回常量引用。

练习14.31:我们的StrBlobPtr类没有定义拷贝构造函数、赋值运算符及析构函数， 为什么？

练习14.32:定义一个类令其含有指向StrBlobPtr对象的指针，为这个类定义重载的 箭头运算符。

###### 6 14.8函数调用运算符

□zE>    如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这

样的类同时也能存储状态，所以与普通函数相比它们更加灵活。

举个简单的例子，下面这个名为abslnt的struct含有一个调用运算符，该运算符 负责返回其参数的绝对值：

struct abslnt {

int operator()(int val) const { return val < 0 ? -val : val;

}

}；

这个类只定义了一种操作：函数调用运算符，它负责接受一个int类型的实参，然后返 回该实参的绝对值。

我们使用调用运算符的方式是令一个abslnt对象作用于一个实参列表，这一过程看 起来非常像调用函数的过程：

int i = -42;

abslnt absObj ;    //含有函数调用运算符的对象

int ui = absObj(i);    // 将 i 传递给 absOb j . operator ()

即使absObj只是一个对象而非函数，我们也能“调用”该对象。调用对象实际上是在运 行重载的调用运算符。在此例中，该运算符接受一个int值并返回其绝对值。

![img](C++  Primer 5-129.jpg)



函数调用运算符必须是成员函数3 —•个类可以定义多个不同版本的调用运算 符，相互之间应该在参教数量或类型上有所区别。

如果类定义了调用运算符，则该类的对象称作函数对象(function object)«因为可以 调用这种对象，所以我们说这些对象的“行为像函数一样”。

含有状态的函数对象类

和其他类一样，函数对象类除了 operator ()之外也可以包含其他成员。函数对象类 通常含有一些数据成员，这些成员被用于定制调用运算符中的操作。

举个例子，我们将定义一个打印string实参内容的类。默认情况下，我们的类会将

内容写入到cout中，每个string之间以空格隔开。同吋也允许类的用户提供其他可写 入的流及其他分隔符，我们将该类定义如下：

class Printstring { public:

Printstring(ostream &o = cout, char c = ' r ): os(o), sep (c) { }

void operator()(const string &s) const { os « s « sep; } private:

ostream &os;    //用于写入的目的流

char sep;    //用于将不同输出隔开的字符

}；

我们的类有一个构造函数，它接受一个输出流的引用以及一个用于分隔的字符，这两个形 参的默认实参(参见6.5.1节，第211页)分别是cout和空格。之后的函数调用运算符 使用这些成员协助其打印给定的string。

当定义Printstring的对象时，对于分隔符及输出流既可以使用默认值也可以提供 我们自己的值：

Printstring printer;    // 使用默认值，打印到 cout

printer (s) ;    //在cout中打印s，后面跟一个空格

Printstring errors(cerr, f\nf );

errors (s) ;    //在cerr中打印s,后面跟一个换行符

函数对象常常作为泛型算法的实参。例如，可以使用标准库for_each算法(参见 10.3.2节，第348页)和我们自己的Printstring类来打印容器的容：

for_each(vs.begin(), vs.end(), Printstring(cerr, z\nr));

for_each的第三个实参是类型Printstring的一个临时对象，其中我们用cerr和换 行符i刀始化了该对象。当程序调用for_each时，将会把vs中的每个元素依次打印到 cerr中，元素之间以换行符分隔。

14.8节练习

练习14.33: —个重载的函数调用运算符应该接受几个运算对象？

练习14.34:定义一个函数对象类，令其执行if-then-else的操作：该类的调用运 算符接受三个形参，它首先检查第一个形参，如果成功返回第二个形参的值；如果不成 功返回第三个形参的值。

练习14.35：编写一个类似于Printstring的类，令其从istream中读取一行输入， 然后返回一个表示我们所读内容的string。如果读取失败，返回空string。

练习14.36：使用前一个练习定义的类读取标准输入，将每一行保存为vector的一个 元素。

练习14.37：编写一个类令其检查两个值是否相等。使用该对象及标准库算法编写程序, 令其替换某个序列中具有给定值的所有实例。

14.8.1 lambda是函数对象

在前一节中，我们使用一个Printstring对象作为调用for each的实参，这一

用法类似于我们在10.3.2节(第346页)中编写的使用lambda表达式的程序。当我们编 写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象(参见10.3.3

[$>节，第349页)。在lambda表达式产生的类中含有一个重载的函数调用运算符，例如，对 于我们传递给stable_sort作为其最后一个实参的lambda表达式来说：

//根据单词的长度对其进行排序，对于长度相同的单词按照字母表顺序排序 stable_sort(words.begin(), words.end(),

[](const string &a, const string &b)

{ return a.size () < b.size ();});

其行为类似于下面这个类的一个未命名对象

class ShorterString { public:

bool operator()(const string &sl, const string &s2) const { return si.size() < s2.size (); }

}；

产生的类只有一个函数调用运算符成员，它负责接受两个string并比较它们的长度，它 的形参列表和函数体与lambda表达式完全一样。如我们在10.3.3节(第352页)所见， 默认情况下lambda不能改变它捕获的变量。因此在默认情况下，由lambda产生的类当中 的函数调用运算符是一个const成员函数。如果lambda被声明为可变的，则调用运算符 就不是const的了。

用这个类替代lambda表达式后，我们可以重写并重新调用stable_sort： stable_sort(words.begin(), words.end(), ShorterString());

第三个实参是新构建的ShorterString对象，当stable_sort内部的代码每次 比较两个string时就会“调用”这一对象，此时该对象将调用£算符的函数体，判断第 一个string的大小小于第二个时返回true。

表示lambda及相应捕获行为的类

如我们所知，当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda 执行时引用所引的对象确实存在(参见10.3.3节，第350页)。因此，编译器可以直接使 用该引用而无须在lambda产生的类中将其存储为数据成员。

相反，通过值捕获的变量被拷贝到lambda中(参见10.3.3节，第350页)。因此，这 种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数， 令其使用捕获的变量的值来初始化数据成员。举个例子，在10.3.2节(第347页)中有一 个lambda,它的作用是找到第一个长度不小于给定值的string对象：

//获得第一个指向满足条件元素的迭代器，该元素满足size(> is >= sz auto wc = find_if(words.begin(), words.end(),

[sz] (const string &a)

{ return a.size() >= sz;});

该lambda表达式产生的类将形如：

I 574〉    class SizeComp {

SizeComp (size_t n) : sz (n) { }    //该形参对应捕获的变量

//该调用运算符的返回类型、形参和函数体都与lambda—致 bool operator()(const string &s) const

{ return s.size () >= sz; }

private:

size_t sz;    //该数据成员对应通过值捕获的变量

｝；

和我们的ShorterString类不同，上面这个类含有一个数据成员以及一个用于初始化 该成员的构造函数。这个合成的类不含有默认构造函数，因此要想使用这个类必须提供一 个实参：

//获得第一个指向满足条件元素的迭代器，该元素满足size () is >= sz auto wc = find_if(words.begin(), words.end(), SizeComp(sz));

lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数：它是否含有 默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定(参见13.1.6节，第450 页和13.6.2节，第475页)。

###### 14.8.1节练习

练习14.38:编写一个类令其检查某个给定的string对象的长度是否与一个阈值相等。 使用该对象编写程序，统计并报告在输入的文件中长度为1的单词有多少个、长度为2 的单词有多少个、……、长度为10的单词又有多少个。

练习14.39:修改上一题的程序令其报告长度在1至9之间的单词有多少个、长度在10 以上的单词又有多少个。

练习14.40：重新编写10.3.2节(第349页)的biggies函数，使用函数对象类替换 其中的lambda表达式。

练习14.41:你认为C++11新标准为什么要増加lambda?对于你自己来说，什么情况下 会使用lambda,什么情况下会使用类？

###### 14.8.2标准库定义的函数对象

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义 了一个执行命名操作的调用运算符。例如，plus类定义了一个函数调用运算符用于对一 对运算对象执行+的操作；modulus类定义了一个调用运算符执行二元的％操作； equal_to类执行==，等等。

这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调 用运算符的形参类型。例如，plus<string〉令string加法运算符作用于string对 象；plus<int>的运算对象是 int; plus<Sales_data〉对 Sales_data 对象执行加 法运算，以此类推：

plus<int> intAdd;    //可执行int加法的函数对

negate<int> intNegate;    //可对int值取反的函数对象

// 使用 intAdd: :operator (int, int)求 10 和 20 的和 int sum = int Add (10, 20);    // 等价于 sum = 30

sum = intNegate (intAdd (10, 20));    // 等价于 sum = 30

// 使用 intNegate: :operator (int｝生成-10

// 然后将-10 作为 intAdd: : operator (int, int)的第二个参数 sum = intAdd(10, intNegate(10) ) ;    // sum = 0

表14.2所列的类型定义在functional头文件中。

| 表14.2:标准库函数对象 |                     |                   |
| --------------------- | ------------------- | ----------------- |
| 算术                  | 关系                | 逻辑              |
| plus<Type>            | equal_to<Type>      | logical_and<Type> |
| minus<Type>           | not equal to<Type>  | logical_or<Type>  |
| multiplies<Type>      | greater<Type>       | logical not<Type> |
| divides<Type>         | greater equal<Type> |                   |
| modulus<Type>         | less<Type>          |                   |
| negate<Type>          | less equal<Type>    |                   |

在算法中使用标准库函数对象

表示运算符的函数对象类常用来替换算法中的默认运算符。如我们所知，在默认情况 下排序算法使用OperatOr<将序列按照升序排列。如果要执行降序排列的话，我们可以 传入一个greater类型的对象。该类将产生一个调用运算符并负责执行待排序类型的大 于运算。例如，如果svec是一个vector<string>,

//传入一个临时的函数对象用于执行两个string对象的>比较运算 sort(svec.begin(), svec.end(), greater<string>());

则上面的语句将按照降序对SVeC进行排序。第三个实参是型的一 个未命名的对象，因此当sort比较元素时，不再是使用默认的<运算符，而是调用给定 的greater函数对象。该对象负责在string元素之间执行>比较运算。

需要特别注意的是，标准库规定其函数对象对于指针同样适用。我们之前曾经介绍过 比较两个无关指针将产生未定义的行为(参见3.5.3节，第107页)，然而我们可能会希望 通过比较指针的内存地址来sort指针的vector。直接这么做将产生未定义的行为，因 此我们可以使用一个标准库函数对象来实现该目的：

vector<string *> nameTable;    // 指针的 vector

//错误：nameTable中的指针彼此之间没有关系，所以〈将产生未定义的行为 sort(nameTable.begin(), nameTable.end(),

[](string *a, string *b) { return a < b; });

//正确：标准库规定指针的less是定义良好的

sort(nameTable.begin(), nameTable.end(), less<string*>());

C5Z6>关联容器使用leSS<key_type>对元素排序，因此我们可以定义一个指针的set或者在 map中使用指针作为关键i而无须直接声明less。

###### 14.8.2节练习

练习14.42:使用标准库函数对象及适配器定义一条表达式，令其

(a)    统计大于1024的值有多少个。

(b)    找到第一个不等于pooh的字符串。

(c)    将所有的值乘以2。

练习14.43：使用标准库函数对象判断一个给定的int值是否能被int容器中的所有 元素整除。

###### 14.8.3可调用对象与function

C++语言中有几种可调用的对象：函数、函数指针、lambda表达式(参见10.3.2节，

第346页)、bind创建的对象(参见10.3.4节，第354页)以及重载了函数调用运算符的类。

和其他对象一样，可调用的对象也有类型。例如，每个lambda有它自己唯一的(未 命名)类类型；函数及函数指针的类型则由其返回值类型和实参类型决定，等等。

然而，两个不同类型的可调用对象却可能共享同一种调用形式(call signature).调用 形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应-•个函数类 型，例如：

int(int, int)

是一个函数类型，它接受两个int、返回一个int。

不同类型可能具有相同的调用形式

对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相 同的类型。例如，考虑下列不同类型的可调用对象：

//普通函数

int add(int i, int j)    { return i + j; }

// lambda,其产生一个未命名的函数对象类

auto mod = [](int i, int j)    { return i % j; };

//函数对象类

struct divide {

int operator () (int denominator, int divisor) { return denominator / divisor;

}

}；

上面这些可调用对象分别对其参数执行了不同的算术运算，尽管它们的类型各不相同，但<5ZE 是共享同一种调用形式：

int (int, int)

我们可能希望使用这些可调用对象构建一个简单的桌面计算器。为了实现这一目的，

需要定义一个函数表(function table)用于存储指向这些可调用对象的“指针”。当程序需 要执行某个特定的操作时，从表中查找该调用的函数。

在C++语言中，函数表很容易通过map来实现。对于此例来说，我们使用一个表示 运算符符号的string对象作为关键字；使用实现运算符的函数作为值。当我们需要求给 定运算符的值时，先通过运算符索引map,然后调用找到的那个元素。

假定我们的所有函数都相互独立，井且只处理关于int的二元运算，则map可以定 义成如下的形式：

//构建从运算符到函数指针的映射关系，其中函数接受两个int、返回一个int map<string, int (*) (int,int)> binops;

我们可以按照下面的形式将add的指针添加到binops中：

//正确：add是一个指向正确类型函数的指针

binops.insert ({" + "，add}); //    add}是一个 pair (参见 11.2.3 节，379 页)

但是我们不能将mod或者divide存入binops：

binops . insert ({ "%", mod});    / / 错误：mod 不是一个函数指针

问题在于mod是个lambda表达式，而每个lambda有它自己的类类型，该类型与存储在 binops中的值的类型不匹配。

标准库function类型

岡    我们可以使用一个名为function的新的标准库类型解决上述问题，function定

义在functional头文件中，表14.3列举出了 function定义的操作。

| 表 14.3: function 的操作      |                                                              |
| ----------------------------- | ------------------------------------------------------------ |
| function<T> f;                | f是一个用来存储可调用对象的空function,这些可调用对 象的调用形式应该与函数类型T相同(即T是retType(args)) |
| function<T> f (nullptr);      | 显式地构造一个空function                                     |
| function<T> f(obj);           | 在f中存储可调用对象obj的副本                                 |
| f                             | 将f作为条件：当f含有一个可调用对象时为真；否则为假           |
| f(args)                       | 调用f中的对象，参数是args                                    |
| 定义为function<T>的成员的类型 |                                                              |
| result_type                   | 该function类型的可调用对象返回的类型                         |
| argument type                 | 当T有一个或两个实参时定义的类型。如果T只有一个实参，         |
| first_argument type           | 则argument_type是该类型的同义词：如果T有两个实参，           |
| second argument type          | 贝1J first_argument type 和 second argument type 分别代表个实参的类i |

function是一个模板，和我们使用过的其他模板一样，当创建一个具体的 function类型时我们必须提供额外的信息。在此例中，所谓额外的信息是指该 function类型能够表示的对象的调用形式。参考其他模板，我们在一对尖括号内指定类 型：

function<int (int, int)>

在这里我们声明了一个function类型，它可以表示接受两个int、返回一个int的可 调用对象。因此，我们可以用这个新声明的类型表示任意一种桌面计算器用到的类型；

| function<int(int, | int)> f1 | =add;             | //函数指针         |
| ----------------- | -------- | ----------------- | ------------------ |
| function<int(int, | int)> f2 | =divide();        | //函数对象类的对象 |
| function<int(int, | int)> f3 | =[](int i, int j) | // lambda          |
|                   |          | { return i * j;   |                    |
| cout « f1(4,2) «  | endl;    | //打印6           |                    |
| cout « f2(4,2) «  | endl;    | //打印2           |                    |
| cout « f3 (4,2) « | endl;    | //打印8           |                    |

I-???〉使用这个function类型我们可以重新定义map:

II列举了可调用对象与二元运算符对应关系的表格 II所有可调用对象都必须接受两个int、返回一个int //其中的元素可以是函教指针、函数对象或者lambda map<string, function<int(int, int)» binops;

我们能把所有可调用对象，包括函数指针、lambda或者函数对象在内，都添加到这个map

map<string, function<int (int, int)» binops = { add},

//函数指针

//标准库函数对象 //用户定义的函数对象 //未命名的lambda //命名了的lambda对象



std::minus<int>()}, divide()},

[] (int i, int j) { return i * j; } }' mod} };

我们的map中包含5个元素，尽管其中的可调用对象的类型各不相同，我们仍然能够把 所有这些类型都存储在同一个function<int (int , int) >类型中。

一如往常，当我们索引map时将得到关联值的一个引用，如果我们索引binops，将 得到function对象的引用。function类型重载了调用运算符，该运算符接受它自己 的实参然后将其传递给存好的可调用对象：

| binops[ | +"] (io,  | 5)； | //   | 调用 add<10, 5)                 |
| ------- | --------- | ---- | ---- | ------------------------------- |
| binops[ | •-"] (io. | 5);  | //   | 使用minus<int〉对象的调用运算符 |
| binops[ | ./"](10,  | 5);  | //   | 使用divide对象的调用运算符      |
| binops[ | ’*"](10,  | 5);  | //   | 调用lambda函数对象              |
| binops[ | •%"](10,  | 5);  | //   | 调用lambda函数对象              |

我们依次调用了 binops中存储的每个操作。在第一个调用中，我们获得的元素存放着一 个指向add函数的指针，因此调用binops [”+ •’] (10, 5)实际上是使用该指针调用add， 并传入10和5»在接下来的调用中，binops ["-••]返回一个存放着std: :minus<int> 类型对象的function,我们将执行该对象的调用运算符。



重载的函数与function

我们不能(直接)将重载函数的名字存入function类型的对象中：

int add(int i, int j)    { return i + j; }

Sales_data add(const Sales_data&, const Sales_data&); map<string, functioncint (int, int)» binops; binops. insert ( {’’+n, add} ) ;    // 错误：哪个 add?

解决上述二义性问题的一条途径是存储函数指针(参见6.7节，第221页)而非函数的 名字：

int (*fp) (int, int) = add;    //指针所指的add是接受两个int的饭本

binops . insert ( {•’ + •', fp} ) ;    // 正确：fp 指向一个正确的 add 版本

同样，我们也能使用lambda来消除二义性：

<571]



//正确：使用lambda来指定我们希望使用的add版本

binops.insert (    [] (int a, int b) {return add(a, b);} });

lambda内部的函数调用传入了两个int,因此该调用只能匹配接受两个int的add版本， 而这也正是执行lambda时真正调用的函数。

![img](C++  Primer 5-130.jpg)



新版本标准库中的function类与旧版本中的unary function和 binary__function没有关联，后两个类已经被更通用的bind函数替代了(参 见10.3.4节，第357页)。

14.8.3节练习

练习14.44：编写-•个简单的桌面计算器使其能处理二元运算。

##### 驗14.9霜载、炎咽转换与运算符

在7.5.4节(第263页)中我们看到由一个实参调用的非显式构造函数定义了一种隐 式的类型转换.这种构造函数将实参类型的对象转换成类类型。我们同样能定义对于类类 型的类型转换，通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算

1_5§0>符則nj定义了类类型转换(class-type conversions),这样的转换有时也被称作用户定义的 类型转换(user-defined conversions)。

14.9.1类喂转换运算符

类型转换运算符(conversion operator)是类的一种特殊成员函数，它负责将一个类类

型的值转换成其他类型。类型转换函数的一般形式如下所示： operator type () const;

其中(vpe表示某种类型。类型转换运算符可以面向任意类型(除了 void之外)进行定义， 只耍该类型能作为函数的返冋类型(参见6.1节，第184页)。因此，我们不允许转换成数 组或者函数类型，何允许转换成指针(包括数组指针及函数指针)或者引用类型。

类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。 类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成 const成员。

一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必 须为空。类型转换函数通常应该是const。<

定义含有类型转换运算符的类

举个例子，我们定义一个比较简单的类，令其表示0到255之间的一个整数：

class Small工nt { public:

Smalllnt(int i = 0): val (i)

{

if (i < 0 || i > 255)

throw std::out_of_range("Bad Smalllnt value");

}

operator int() const { return val; } private:

std::size_t val;

}；

我们的Smalllnt类既定义了向类类型的转换，也定义了从类类型向其他类型的转换。 其中，构造函数将算术类型的值转换成Smalllnt对象，而类型转换运算符将Smalllnt 对象转换成int:

Small工nt si;

si = 4;    //首先将4隐式地转换成Smalllnt,然后调用Smalllnt: : operator。

si + 3;    //首先将si隐式地转换成int,然后执行整数的加法

尽管编译器一次只能执行一个用户定义的类型转换（参见4.11.2节，第144页），但＜^\ 是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后（参见4.11.1 节，第141页），并与其一起使用。因此，我们可以将任何算术类型传递给Smalllnt的 构造函数。类似的，我们也能使用类型转换运算符将一个Smalllnt对象转换成int,

然后再将所得的int转换成任何其他算术类型：

//内置类型转换将double实参转换成int

Smalllnt si = 3.14;    // 调用 Small工nt （int）构造函数

// Smalllnt的类型转换运算符将si转换成int

si + 3.14;    //内置类型转换将所得的int继续转换成double

因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型 转换运算符的定义中使用任何形参。同时，尽管类型转换函数不负责指定返回类型，但实 际上每个类型转换函数都会返回一个对应类型的值：

| class Smalllnt;                                 |           |       |                |                |
| ----------------------------------------------- | --------- | ----- | -------------- | -------------- |
| operator int(Smalllnt&)class Smalllnt { public: | r         | //    | 错误：         | 不是成员函数   |
| int operator int ()                             | const;    | //    | 错误:          | 指定了返回类型 |
| operator int(int =                              | 0) const; | //    | 错误:          | 参数列表不为空 |
| operator int* () const { return 42;}；          | } //      | 错误: | 42不是一个指针 |                |

提示：避免过度使用类艰转换闲数

和使用重载运算符的经验一样，明智地使用类型转换运算符也能极大地简化类设计 者的工作，同时使得使用类更加容易„然而，如果在类类型和转换类型之间不存在明显 的映射关系，则这样的类型转换可能具有误导性。

例如，假设某个类表示Date,我们也许会为它添加一个从Date到int的转换。

然而，类型转换函数的返回值应该是什么？ 一种可能的解释是，函数返回一个十进制数，

依次表示年、月、日，例如，July 30, 1989可能转换为int值19890730 ,同时还存在 另外一种合理的解释，即类型转换运算符返回的int表示的是从某个时间节点（比如 January 1, 1970 ）开始经过的天数。显然这两种理解都合情合理，毕竟从形式上看它们 产生的效果都是越靠后的日期对应的整数值越大，而且两种转换都有实际的用处,.，

问题在于Date类型的对象和int类型的值之间不存在明确的一对一映射关系。因 此在此例中，不定义该类型转换运算符也许会更好。作为替代的手段，类可以定义一个 或多个普通的成员函数以从各种不同形式中提取所需的信息。

类型转换运算符可能产生意外结果

在实践中，类很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生，

用户可能会感觉比较意外，而不是感觉受到了帮助。然而这条经验法则存在一种例外情况：＜582~| 对于类来说，定义向bool的类型转换还是比较普遍的现象。

在C++标准的早期版本中，如果类想定义一个向bool的类型转换，则它常常遇到一 个问题：因为bool是一种算术类型，所以类类型的对象转换成bool后就能被用在任何

需要算术类型的上下文中。这样的类型转换可能引发意想不到的结果，特别是当istream 含有向bool的类型转换时，下面的代码仍将编译通过：

int i = 42;

cin « i; //如果向bool的类型转换不是显式的，则该代码在编译器看来将是合法的！

这段程序试图将输出运算符作用于输入流。因为istream本身并没有定义《,所以本来 代码应该产生错误。然而，该代码能使用istream的bool类型转换运算符将cin转换 成bool,而这个bool值接着会被提升成int并用作内置的左移运算符的左侧运算对象， 这样一来，提升后的bool值（1或0）最终会被左移42个位置。这一结果显然与我们的 预期大相径庭。

显式的类型转换运算符

为了防止这样的异常情况发生，C++11新标准引入了显式的类型转换运算符（explicit conversion operator）：

class Smalllnt { public:

//编译器不会自动执行这一类型转换

explicit operator int （） const { return val; }

//其他成员与之前的版本一致

）；

和显式的构造函数（参见7.5.4节，第265页）一样，编译器（通常）也不会将一个显式 的类型转换运算符用于隐式类型转换：

Smalllnt si = 3;    //正确：Smalllnt的构造函数不是显式的

si + 3;    //错误：此处需要隐式的类型转换，但类的运算符是显式的

static_cast<int> （si） + 3;    //正确：显式地请求类型转换

当类型转换运算符是显式的时，我们也能执行类型转换，不过必须通过显式的强制类型转 换才可以。

该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式的类型转换自动 应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行：

•    if、while及do语句的条件部分

•    for语句头的条件表达式

•逻辑非运算符（！）、逻辑或运算符（II）、逻辑与运算符（&&）的运算对象 •条件运算符（？：）的条件表达式。

L^83＞转换为bool

在标准库的早期版本中，IO类型定义了向void*的转换规则，以求避免上面提到的 问题。在C++11新标准下，10标准库通过定义一个向bool的显式类型转换实现同样的目的。

无论我们什么时候在条件中使用流对象，都会使用为10类型定义的operator bool。例如：

while （std::cin >> value）

while语句的条件执行输入运算符，它负责将数据读入到value并返回cin。为了对条 件求值，cin被istream operator bool类型转换函数隐式地执行了转换。如果cin 的条件状态是good （参见8.1.2节，第280页），则该函数返回为真；否则该函数返回为假。

Best 卩 Kieticcs



向bool的类型转换通常用在条件部分，因此operator bool 一般定义成 explicit 的a

###### 14.9.1节练习

练习14.45：编写类型转换运算符将一个Sales_data对象分别转换成string和 double,你认为这些运算符的返回值应该是什么丁

练习14.46:你认为应该为Sales_data类定义上面两种类型转换运算符吗？应该把它 们声明成explicit的吗？为什么？

练习14.47：说明下面这两个类型转换运算符的区别。

struct Integral {

operator const int (); operator int() const;

}；

练习14.48：你在7.5.1节的练习7.40 C第261页)中曾经选择并编写了一个类，你认为 它应该含有向bool的类型转换运算符吗？如果是，解释原因并说明该运算符是否应该 是explicit的；如果不是，也请解释原因。

练习14.49:为上一题提到的类定义一个转换目标是bool的类型转换运算符，先不用 在意这么做是否应该。

###### 14.9.2避免有二义性的类型转换    驗

如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一 一种转换方式。否则的话，我们编写的代码将很可能会具有二义性。

在两种情况下可能产生多重转换路径。第一种情况是两个类提供相同的类型转换：例 如，当A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是 A类的类型转换运算符时，我们就说它们提供了相同的类型转换。

第二种情况是类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型＜5^1 转换联系在一起。最典型的例子是算术运算符，对某个给定的类来说，最好只定义最多一 个与算术类型有关的转换规则。

，人通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以 WAHMNfi 上转换源或转换目标是算术类型的转换

实参匹配和相同的类型转换

在下面的例子中，我们定义了两种将B转换成A的方法：一种使用B的类型转换运 算符、另一种使用A的以B为参数的构造函数：

II最好不要在两个类之间构建相同的类型转换 struct B; struct A {

A() = default;

A (const B&) ;    // 把一个 B 转换成 A

//其他数据成员

};

struct B {

operator A () const; //也是把一个B彝争换成A //其他数据成员

}；

A f (const A&);

B b;

A a = f (b) ;    // 二义性错误：含义是 f (B: : operator A ())

// 还是 f : A (const B&) ) ?

因为同时存在两种由B获得A的方法，所以造成编译器无法判断应该运行哪个类型转换， 也就是说，对f的调用存在二义性。该调用可以使用以B为参数的A的构造函数，也可 以使用B当中把B转换成A的类型转换运算符。因为这两个函数效果相当、难分伯仲， 所以该调用将产生错误。

如果我们确实想执行上述的调用，就不得不显式地调用类型转换运算符或者转换构造 函数：

A al = f (b. operator A () ) ;    //正确：使用B的类型转换运算符

A a2 = f (A(b) ) ;    //正确：使用A的构造函数

值得注意的是，我们无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也 面临二义性。

二义性与转换目标为内置类型的多重类型转换

另外如果类定义了一组类型转换，它们的转换源(或者转换目标)类型本身可以通过 其他类型转换联系在一起，则同样会产生二义性的问题。最简单也是最困扰我们的例子就 是类当中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转 换运算符。

例如，在下面的类中包含两个转换构造函数，它们的参数是两种不同的算术类型；同 时还包含两个类型转换运算符，它们的转换目标也恰好是两种不同的算术类型：

| 585〉    struct A {

A(int = 0) ;    //最好不要创建两个转换源都是算术类型的类型转换

A(double);

operator int() const; //最好不要创建两个转换对象都是其术类型的类型转换 operator double() const;

//其他成员

}；

void f2(long double);

A a;

f2 (a) ;    // 二义性错误：含义是 f (A: : operator int ())

// 还是 f (A: : operator double () ) ?

long lg;

A a2 (lg) ;    // 二义性错误：含义是 A: : A (int)还是 A: : A (double) ?

在对f2的调用中，哪个类型转换都无法精确匹配long double。然而这两个类型转换都 可以使用，只要后面再执行一次生成long double的标准类型转换即可。因此，在上面 的两个类型转换中哪个都不比另一个更好，调用将产生二义性。

当我们试图用long初始化a2时也遇到了同样问题，哪个构造函数都无法精确匹配 long类型。它们在使用构造函数前都要求先将实参进行类型转换：

•先执行long到double的标准类型转换，再执行A (double)

•先执行long到int的标准类型转换，再执行A(int)

编译器没办法区分这两种转换序列的好坏，因此该调用将产生二义性。

调用f2及初始化a2的过程之所以会产生二义性，根本原因是它们所需的标准类型 转换级别一致(参见6.6.1节，第219页)。当我们使用用户定义的类型转换时，如果转换 过程包含标准类型转换，则标准类型转换的级别将决定编译器选择最佳匹配的过程，

short s = 42;

//把short提升成int优于把short转换成double

A a3 (s) ;    // 使用 A:: A (int)

在此例中，把short提升成int的操作要优于把short转换成double的操作，因此 编译器将使用A:: A (int)构造函数构造a3,其中实参是s (提升后)的值。

![img](C++  Primer 5-131.jpg)



当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类 型转换，则标准类型转换将决定最佳匹配到底是哪个

提示：类型转换与运算符

< 586 |



要想正确地设计类的重载运算符、转换构造函数及类型转换函数，必须加倍小心。 尤其是当类同时定义了类型转换运算符及重载运算符时特别容易产生二义性^以下的经 验规则可能对你有所帮助：

•不要令两个类执行相同的类型转换：如果Foo类有一个接受Bar类对象的构造 函数，则不要在Bar类中再定义转换目标是Foo类的类型转换运算符。

•避免转换目标是内置算术类型的类型转换。特别是当你已经定义了一个转换成算 术类型的类型转换时，接下来

—不要再定义接受算术类型的重载运算符。如果用户需要使用这样的运算符， 则类型转换操作将转换你的类型的对象，然后使用内置的运算符。

—不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术 类型转换的工作。

一言以蔽之：除了显式地向bool类型的转换之外，我们应该尽量避免定义类型转换函 数并尽可能地限制那些“显然正确”的非显式构造函数。

重载函数与转换构造函数

当我们调用重载的函数时，从多个类型转换中进行选择将变得更加复杂。如果两个或 多个类型转换都提供了同一种可行匹配，则这些类型转换一样好。

举个例子，当几个重载函数的参数分属不同的类类型时，如果这些类恰好定义了同样 的转换构造函数，则二义性问题将进一步提升：

struct C {

C(int);

//其他成员

};

struct D {

D(int);

//其他成员

}；

void manip(const C&); void manip(const D&);

manip (10);    // 二义性错误：含义是 manip (C (10))还是 manip (D (10))

其中C和D都包含接受int的构造函数，两个构造函数各自匹配manip的•个版本。因 此调用将具有二义性：它的含义可能是把int转换成C,然后凋用manip的第一个版本： 也可能是把int转换成D,然后调用manip的第二个版本。

调用者可以显式地构造正确的类型从而消除二义性： manip (C (10) ) ; II 正确：调用 manip (const C&)

/ f \ 如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参 的类型，则这通常意味着程序的设计存在不足,..

重载函数与用户定义的类型转换

当调用重载函数时，如果两个(或多个)用户定义的类型转换都提供了可行匹配，则 我们汄为这些类型转换一样好。在这个过程中，我们不会考虑任何可能出现的标准类型转 换的级别。只有当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中出 现的标准类型转换。

例如当我们调用manip时，即使其中一个类定义了需要对实参进行标准类型转换的 构造函数，这次调用仍然会具有二义性：

struct E {

E(double);

//其他成员

}；

void manip2(const C&); void manip2(const E&);

//二义性错误：两个不同的用户定义的类型转换都能用在此处

manip2 (10) ;    II 含义是 manip2 (C (10>)还是 manip2 (E (double (10) > >

在此例巾，C有一个转换源为int的类型转换，E有一个转换源为double的类型转换。 对于manip2 (10)来说，两个manip2函数都是可行的：

•    manip2 (const C&>是可行的，因为C有-•个接受int的特换构造函数，该构造 函数与实参精确匹配。

•    manip2 (const E&)足可行的，因为E有-个接受double的转换构迫函数，而 且为了使用该函数我们可以利用标准类型转换把int转换成所需的类型。

因为调用重载函数所请求的用户定义的类型转换不止一个11彼此不向，所以该调用其有二 义性。即使其中一个调用需要额外的标准类型转换而另-个调用能精确匹配，编译器也会 将该调用标示为错误。

在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所 有可行函数都请求同一个用户定义的类盤转换时才有用。如果所需的用户定义 的类型转换不止一个，则该调用具有二义性

###### I 14.9.2节练习

练习14.50：在初始化exl和ex2的过程中，可能用到哪些类类型的转换序列呢？说 明初始化是否正确并解释原因。

struct LongDouble {

LongDouble(double = 0.0); operator double(); operator float();

I；

LongDouble ldObj; int exl = ldObj; float ex2 = ldObj;

练习14.51:在调用calc的过程中，可能用到哪些类型转换序列呢？说明最佳可行函 数是如何被选出来的。

void calc (int);

void calc(LongDouble);

double dval;

calc (dval) ;    // 哪个 calc?

###### 14.9.3函数匹配与重载运算符

重载的运算符也是重载的函数，因此，通用的函数匹配规则(参见6.4节，第208页) 同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载的运算符。不过当运 算符函数出现在表达式中时，候选函数集的规模要比我们使用调用运算符调用函数时更 大。如果a是一种类类型，则表达式a sym b可能是

a.operatorsym (b) ; // a 有一个 operatorsym 成员函数 operatorsyn? (a, b) ; // operatorsym 是一个普通函教

和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员 函数。

当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通 非成员版本和内置版本。除此之外，如果左侧运算对象是类类型，则定义在该类中的运算 符的重载版本也包含在候选函数内。

当我们调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载， 这是因为我们用来调用命名函数的语法形式对丁•成员函数和非成员函数来说是不相同的。 当我们通过类类型的对象(或者该对象的指针及引用)进行函数调用时，只考虑该类的成 员函数。而当我们在表达式中使用重载的运算符时，无法判断正在使用的是成员函数还是 非成员函数，因此二者都应该在考虑的范围内。

举个例子，我们为Smalllnt类定义一个加法运算符:

class Smalllnt { friend

Smalllnt operator+(const Smalllnt&, const Smalllnt&);

![img](C++  Primer 5-133.jpg)



//转换源为int的类型转换



operator int () const { return val; }    // 转换目标为 int 的类型转换

private:

std::size_t val;

r589＞可以使用这个类将两个Smalllnt对象相加，但如果我们试图执行混合模式的算术运算， 就将遇到二义性的问题：

Smalllnt si, s2; Smalllnt s3 = si + s2; int i = s3 + 0;

//使用重载的operator+ //二义性错误



第一条加法语句接受两个Smalllnt值并执行+运算符的重载版本。第二条加法语句具有 二义性：因为我们可以把0转换成Smalllnt，然后使用Smalllnt的+:或者把s3转 换成int,然后对于两个int执行内置的加法运算。

/j\ 如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载 的运算符，则将会遇到重载运算符与内置运算符的二义性问题.、

###### 14.9.3节练习

练习14.52：在下面的加法表达式中分别选用了哪个operator*?列出候选函数、可 行函数及为每个可行函数的实参执行的类型转换： struct LongDouble {

//用于演示的成员operator*;在通常情况下+是个非成员 LongDouble operator^(const SmalllntS);

//其他成员与14.9.2节(第521页)一致

}；

LongDouble operator+(LongDouble&, double);

Smalllnt si;

LongDouble Id;

Id = si + Id;

Id = Id + si;

练习14.53:假设我们已经定义了如第522页所示的Smalllnt,判断下面的加法表达 式是否合法。如果合法，使用了哪个加法运算符？如果不合法，应该怎样修改代码才能 使其合法？

Smalllnt si; double d = si + 3.14;

##### 小结

< 590 1



•-个重载的运算符必须是某个类的成员或者至少拥有--个类类型的运算对象。重载运 算符的运算对象数量、结合律、优先级与对应的用于内置类型的运算符完全一致。当运算 符被定义为类的成员时，类对象的隐式this指针绑定到第一个运算对象。赋值、下标、 函数调用和箭头运算符必须作为类的成员，

如果类重载了函数调用运算符operator (>,则该类的对象被称作“函数对象"。这 样的对象常用在标准函数中。lambda表达式是一种简便的定义函数对象类的方式。

在类中可以定义转换源或转换目的是该类型本身的类型转换，这样的类型转换将自动 执行。只接受单独一个实参的非显式构造函数定义了从实参类型到类类型的类型转换；而 非显式的类型转换运算符则定义了从类类型到其他类型的转换。

##### 术语表

调用形式(call signature)表示一个可调

用对象的接口。在调用形式中包括返回类 型以及•个实参类型列表，该列表在一对 圆括号内，实参类型之间以逗号分隔。

类类型转换(class-type conversion)包括•

由构造函数定义的从其他类型到类类型的 转换以及由类型转换运算符定义的从类类 型到其他类型的转换。只接受单独一个实 参的非显式构造函数定义了从实参类型到 类类型的转换；而类型转换运算符则定义 了从类类型到某个指定类型的转换。

类型转换运算符(conversion叩erator)是

类的成员函数，定义了从类类型到其他类 型的转换。类型转换运算符必须是它要转 换的类的成员，并且通常被定义为常量成 员。这类运算符既没有返回类型，也不接 受参数。它们返回一个可变为转换运算符 类型的值，也就是说，operator int返 圃一个 int, operator string 返回一 个string,依此类推。

显式的类型转换运算符(explicit conversion operator)由关键字explicit限定的类

型转换运算符。这样的运算符用于条件中 的隐式类型转换。

函数对象(function object)定义了重载凋

用运算符的对象。在需要使用函数的地方 都能使用函数对象。

函数表(function table) 形如map或

vector的容器，容器中所存的值可以被 调用。

函数模板(function template)能够表示任

意可调用类型的标准库模板。

重载的运算符(overloaded operator)電

定义了某种内置运算符的含义的函数。重 载的运算符函数含有关键字operator, 之后是要定义的符号。重载的运算符必须 含有至少一个类类型的运算对象。重载运 算符的优先级、结合律、运算对象数量都 与其内置版木一致。

用户定义的类型转换(user-defined conversion)类类型转换的同义词。
