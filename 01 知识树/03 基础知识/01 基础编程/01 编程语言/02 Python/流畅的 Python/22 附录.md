## 结语

Python 是给法定成年人使用的语言。

——Alan Runyan Plone 的联合创始人

Alan 的精辟定义道出了 Python 最好的特质之一：它不妨碍你，让你做你该做的事。这也 意味着，它不会给你提供工具，让你限制其他人能对你的代码和代码所构建的对象做什

么。

当然， Python 不完美。对我来说，最没法接受的是， Python 在标准库中混用驼峰式和蛇底 式，或者直接把单词连在一起。但是，语言的定义和标准库只是生态系统的一部分。用户 和贡献者组成的社区才是 Python 生态系统最重要的部分。

有一个例子可以说明社区的好处。一天早上，我在撰写 asyncio 包相关的内容时，感到 很沮丧，因为那个包的 API 有很多函数，其中有些是协程，可是协程必须使用 yield from 调用，而常规的函数不能这么做。这在 asyncio 包的文档中有说明，可是有时阅读 几段文字之后才能确定某个函数是不是协程。因此，我给 python-tulip 邮件列表发了一个 消息，题为“Proposal: make coroutines stand out in the asyncio

docs” ([https://groups.google.com/forum/#!topic/python-tulip/Y4bhLNbKs74](https://groups.google.com/forum/%23!topic/python-tulip/Y4bhLNbKs74)) 。 asyncio 包的 核心开发者 Victor Stinner、aiohttp 包的主要作者 Andrew Svetlov、Tornado 的首席开发 者 Ben Darnell，以及 Twisted 的发明者 Glyph Lefkowitz 加入了讨论。Darnell 提出了一个 方案， Alexander Shorin 解说如何在 Sphinx 中实现， Stinner 添加了所需的配置和标记。我 提出这个问题不到 12 小时， asyncio 包的整个线上文档都更新了，添加了今天你所看到 的“coroutine”标签([https://docs.python.org/3/library/asyncio-eventloop.html#executor](https://docs.python.org/3/library/asyncio-eventloop.html%23executor))。

在排外的社区中绝不会有这种事。任何人都能加入 python-tulip 邮件列表，我编写那个提 议之前只发布过几次消息而已。这个故事表明， Python 社区特别开放，广纳新想法和新成 员。 Guido van Rossum 也在 python-tulip 邮件列表中，即使是简单的问题也经常回答。

还有一个例子能说明Python的开放：Python软件基金会(Python Software Foundation，

PSF) —直在努力提升Python社区的多样性，而且己经达成一些令人欣喜的成果。2013— 2014年，PSF董事会首次选出了女性董事——Jessica McKellar和Lynn Root。2015年在蒙 特利尔举办的PyCon North America大会(Diana Clarke主持)，约1/3的演讲者是女性。

我还没见过其他 IT 大会如此追求性别平等。

如果你是 Python 程序员，但尚未加入社区，我建议你快点加入。寻找你所在地区的 Python用户组(Python Users Group，PUG)。如果没有，那就创建一个。任何地方都有人 使用Python，你并不孤独。如果可能的话，参加别处举办的会议。来参加PythonBrasil大 会吧，多年以来这个大会都有来自世界各地的演讲者。与其他 Python 程序员见面比任何 线上互动都好，除了可以获得别人分享的知识外，还有很多好处，例如工作机会和真正的 友谊。

我知道，如果没有多年来我在 Python 社区中结交的朋友的帮助，我不可能写出这本书。

我的父亲说过，“S6 erra quem trabalha”，这是葡萄牙语，意思是“只有真正做事的人才会

犯错”。这个建议很棒，能让你不再害怕失败，迈步向前。撰写这本书的过程中，我肯定

犯了错误。审校、编辑和预先发布版的读者帮我找出了很多错误。早期发布版刚发布几小

[时，就有一个读者在本书的勘误页面(](http://www.oreilly.com/catalog/errata.csp?isbn=0636920032519)[http: //www.oreilly.com/catalog/errata.csp?](http://www.oreilly.com/catalog/errata.csp?isbn=0636920032519) isbn=0636920032519)报告拼写错误。其他读者报告了更多错误，我的朋友还直接联系 我，提供建议和更正。我写完本书后， O'Reilly 的文字编辑会在出版过程中找出其他错 误。如果还有任何错误和词不达意的表述，责任都在我，在此向各位读者致歉。

终于写完这本书了，我特别高兴，无论有没有错误，我都十分感激一路上给我帮助的每个

人。

希望很快就能在会议上见到你。如果见到我，请过来打声招呼。

### 延伸阅读

在本书的最后，我要介绍一些“Python风格”的参考资料一这正是本书尝试解决的主要问 题。

Brandon Rhodes 是位出色的 Python 教师，他的演讲“A Python Esthetic: Beauty and Why I Python” ([https://www+youtube+com/watch?v=x-kB2o8sd5c](https://www.youtube.com/watch?v=x-kB2o8sd5c))很精影，从标题中使用的 Unicode字符U+00C6 (拉丁语大写字母AE)开始谈起。另一位出色的教师Raymond Hettinger，在 2013 年的 PyCon US 大会上谈了 Python 之美：“Transforming Code into Beautiful, Idiomatic Python” ([ ](https://www.youtube.com/watch?v=OSGv2VnC0go)[https ://www+youtube+ com/watch?v=OSGv2VnC0go](https://www.youtube.com/watch?v=OSGv2VnC0go) ) 。

Ian Lee 在 Python-ideas 邮件列表中发起的“Evolution of Style Guides”话题 ([ ](https://mail.python.org/pipermail/python-ideas/2015-March/032557.html)[https://mail+python+org/pipermail/python-ideas/2015-March/032557+html ](https://mail.python.org/pipermail/python-ideas/2015-March/032557.html))值得一读。 Lee 是

pep8包([https://pypi+python+org/pypi/pep8/](https://pypi.python.org/pypi/pep8/))的维护者，这个包的作用是检查Python代码

是否符合 PEP 8。检查书中的代码时，我用的是

flake8 ([https://pypi+python+org/pypi/flake8](https://pypi.python.org/pypi/flake8))，这个包融合了

pep8、 pyflakes ([https://pypi+python+org/pypi/pyflakes](https://pypi.python.org/pypi/pyflakes))和 Ned Batchelder 开发的 McCabe 复杂度插件([ ](https://pypi.python.org/pypi/mccabe)[https://pypi +python+org/pypi/mccabe ](https://pypi.python.org/pypi/mccabe)) 。

除了 PEP 8， Google 的 Python 风格指南(https://google-

[styleguide+googlecode+com/svn/trunk/pyguide+html](https://google-styleguide.googlecode.com/svn/trunk/pyguide.html)[)和 Poc](https://google-styleguide.googlecode.com/svn/trunk/pyguide.html)oo 风格指南 ([ ](http://www.pocoo.org/internal/styleguide/)[http://www+pocoo+org/internal/styleguide/ ](http://www.pocoo.org/internal/styleguide/))也有很大的影响。 Pocoo 团队为我们开发了

Flask、 Sphinx、 Jinja 2 和其他优秀的 Python 库。

The Hitchhiker's Guide to Python! ([http://docs+python-guide+org/en/latest/](http://docs.python-guide.org/en/latest/))由多人维护，说明 如何编写符号Python风格的代码。为这个项目贡献最多内容的是Kenneth Reitz，他因开发 特别符合 Python 风格的 requests 包而被社区视为英雄。 David Goodger 在 2008 年举办的 PyCon US 大会上办了一场教学活动，题为“Code Like a Pythonista: Idiomatic

Python” ([http://python+net/~goodger/projects/pycon/2007/idiomatic/handout+html](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html)) 。如果打印 出来，这个教程的教案有 30 页。当然，教案的 reStructuredText 源码能下载到，可以使用 docutils 将其渲染成 HTML 和 S5 幻灯片([http://meyerweb+com/eric/tools/s5/](http://meyerweb.com/eric/tools/s5/))。毕竟， reStructuredText 和 docutils 都是 Goodger 的作品。这两个工具是 Sphinx 的基础。 Sphinx 是优秀的 Python 文档系统，顺便提一下，

MongoDB ([https://docs+mongodb+org/manual/about/#about-the-documentation-process](https://docs.mongodb.org/manual/about/%23about-the-documentation-process))和很多 其他项目的官方文档系统都是 Sphinx。

Martijn Faassen 直接回答了 “什么是 Python 风格”这个问题 ([ ](http://blog.startifact.com/posts/older/what-is-pythonic.html)[http://blog+startifact+com/posts/older/what-is-pythonic+html ](http://blog.startifact.com/posts/older/what-is-pythonic.html)) ， python-list 邮件列表中也有一

个相同标题的话题([https://mail+python+org/pipermail/tutor/2003-October/025930+html](https://mail.python.org/pipermail/tutor/2003-October/025930.html))。 Martijn 的文章是 2005 年写的，那个话题是 2003 年讨论的，不过 Python 风格的思想没怎 么变化，Python 语言本身也是如此。“Pythonic way to sum n-th list element?”话题

[https://mail+python+org/pipermail/python-list/2003-April/192027+html](https://mail.python.org/pipermail/python-list/2003-April/192027.html))对 Python 风格做了深 入讨论，我在第 10 章的“杂谈”中有大量引用。

“PEP 3099 — Things that will Not Change in Python

3000” (<https://www.python.org/dev/peps/pep-3099/>)解释了经过 Python 3 大幅度的调整之

后，为何许多东西仍是现在的样子。长久以来，Python 3有个昵称-Python 3000，不过

诞生时间早了几个世纪，这让一些人失望。PEP 3099的作者是Georg Brandl，他收集了仁 慈的独裁者(即Guido van Rossum)的很多观点。Python Essays页面

(<https://www.python.org/doc/essays/>)列出了很多 Guido 自己写的文章。

## 附录 A 辅助脚本

有些脚本太长，在正文里放不下，这里将其完整列出。此外，有些脚本用于生成书中的表

格和数据，这里一并列出。

这里列出的脚本，以及书中几乎每个代码片段，见于本书的代码仓库

( [https ://github.com/fluentpython/example-code](https://github.com/fluentpython/example-code) ) 。

### A.1第3章：in运算符的性能测试

表 3-6 中的计时数据是我使用示例 A-1 中的代码生成的，这段代码用到了 timeit 模块。 这个脚本主要用于设置 haystack 和 needles 样本，并格式化输出。

编写示例 A-1 时，我发现的确能客观比较 dict 的性能。如果在“详细模式”(指定命令行

选项-v)中运行这个脚本，用时几乎是表3-5中的两倍。但是注意，对这个脚本来说，

在“详细模式”中，只是多了用于设置测试内容的四个 print 调用，以及在各个测试结束 后显示找到多少个 needles 的那个 print 调用。在 haystack 中搜索 needles 的那个循 环没有输出，不过这五个 print 调用耗费的时间与搜索 1000 个 needles 差不多。

#### 示例A-1 container_perftest.py：运行时以内置集合类型的名称为命令行参数(例如 container_perftest.py dict)

对容器的''in''运算符做性能测试

import sys

import timeit

SETUP = '''

import array

selected = array.array('d')

with open('selected.arr', 'rb') as fp: selected.fromfile(fp, {size})

if {container_type} is dict:

haystack = dict.fromkeys(selected, 1)

else:

haystack = {container_type}(selected)

if {verbose}:

print(type(haystack), end=' ') print('haystack: %10d' % len(haystack), end=' ')

needles = array.array('d')

with open('not_selected.arr', 'rb') as fp: needles.fromfile(fp, 500)

needles.extend(selected[::{size}//500])

if {verbose}:

print(' needles: %10d' % len(needles), end=' ')

TEST = '''

found = 0

for n in needles:

if n in haystack:

found += 1

if {verbose}:

print(' found: %10d' % found)

def test(container_type, verbose): MAX_EXPONENT = 7

for n in range(3, MAX_EXPONENT + 1):

size = 10**n

setup = SETUP.format(container_type=container_type, size=size, verbose=verbose)

test = TEST.format(verbose=verbose)

tt = timeit.repeat(stmt=test, setup=setup, repeat=5, number=1)

print('|{:{}d}|{:f}'.format(size, MAX_EXPONENT + 1, min(tt)))

if __name__=='__main__': if '-v' in sys.argv:

sys.argv.remove('-v') verbose = True

else:

verbose = False if len(sys.argv) != 2:

print('Usage: %s <container_type>' % sys.argv[0]) else:

test(sys.argv[1], verbose)

#### container_perftest_datagen+py脚本（见示例A-2）为示例A-1中的脚本生成固件数据。

#### 示例A-2 container_perftest_datagen+py：生成由不同的浮点数组成的数组，然后写入

文件，供示例 A-1 使用

生成容器性能测试所需的数据

import random

import array

MAX_EXPONENT = 7

HAYSTACK_LEN = 10 ** MAX_EXPONENT

NEEDLES_LEN = 10 ** (MAX_EXPONENT - 1)

SAMPLE_LEN = HAYSTACK_LEN + NEEDLES_LEN // 2

needles = array.array('d')

sample = {1/random.random() for i in range(SAMPLE_LEN)} print('initial sample: %d elements' % len(sample))

\# 完整的样本，防止丢弃了重复的随机数

while len(sample) < SAMPLE_LEN: sample.add(1/random.random())

print('complete sample: %d elements' % len(sample))

sample = array.array('d', sample)

random.shuffle(sample)

not_selected = sample[:NEEDLES_LEN // 2]

print('not selected: %d samples' % len(not_selected))

print(' writing not_selected.arr')

with open('not_selected.arr', 'wb') as fp: not_selected.tofile(fp)

selected = sample[NEEDLES_LEN // 2:]

print('selected: %d samples' % len(selected))

print(' writing selected.arr') with open('selected.arr', 'wb') as fp:

selected.tofile(fp)

### A.2第3章：比较散列后的位模式

示例 A-3 是个简单的脚本，告诉你相似浮点数（例如 1.0001、1.0002，等等）的位模式有 什么差异。这个脚本的输出在示例 3-16 中。

#### 示例A-3 hashdiff.py:显示散列值的位模式有何差异

import sys

MAX_BITS = len(format(sys.maxsize, 'b')) print('%s-bit Python build' % (MAX_BITS + 1))

def hash_diff(o1, o2): h1 = '{:>0{}b}'.format(hash(o1), MAX_BITS) h2 = '{:>0{}b}'.format(hash(o2), MAX_BITS) diff = ''.join('!' if b1 != b2 else ' ' for b1, b2 in zip(h1, h2)) count = '!= {}'.format(diff.count('!'))

width = max(len(repr(o1)), len(repr(o2)), 8) sep = '-' * (width * 2 + MAX_BITS)

return '{!r:{width} } {}\n{:{width} } {} {}\n{!r:{width} } {}\n{}'.format( o1, h1, ' ' * width, diff, count, o2, h2, sep, width=width)

if __name__ == '__main__': print(hash_diff(1, 1.0)) print(hash_diff(1.0, 1.0001)) print(hash_diff(1.0001, 1.0002)) print(hash_diff(1.0002, 1.0003))

A.3第9章：有或没有__slots__时，RAM的用量

#### memtest+py 脚本用于支持 9+8 节的一个演示——示例 9-12。

memtest+py 脚本从命令行中接收一个模块的名称，加载那个模块。假设模块中定义有一个 名为 Vector 的类， memtest+py 脚本会创建一个由一千万个实例组成的列表，然后报告创 建列表前后内存的用量。

#### 示例A-4 memtest+py：创建大量Vector实例，报告内存用量

import importlib import sys import resource

NUM_VECTORS = 10**7

if len(sys.argv) == 2:

module_name = sys.argv[1].replace('.py', '') module = importlib.import_module(module_name)

else:

print('Usage: {} <vector-module-to-test>'.format()) sys.exit(1)

fmt = 'Selected Vector2d type: {.__name__}.{.__name__}' print(fmt.format(module, module.Vector2d))

mem_init = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss print('Creating {:,} Vector2d instances'.format(NUM_VECTORS)) vectors = [module.Vector2d(3.0, 4.0) for i in range(NUM_VECTORS)]

mem_final = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss print('Initial RAM usage: {:14,}'.format(mem_init)) print(' Final RAM usage: {:14,}'.format(mem_final))

A.4第14章：转换数据库的isis2json.py脚本

示例 A-5 是 14.13 节讨论的 isis2json.py 脚本。这个脚本使用生成器函数，以惰性的方式

把 CDS/ISIS 数据库转换成 JSON 格式，以便载入到 CouchDB 或 MongoDB。

注意，这是个Python 2脚本，针对CPython或Jython，支持Python 2.5~2.7，不能使用 Python 3 运行。在 CPython 中，只能读取 .iso 文件；在 Jython 中，使用 GitHub 中 fluentpython/isis2json 仓库(<https://github.com/fluentpython/isis2json>)里的 Bruma 库，还可 以读取 .mst 文件。详情参见该仓库里的用法文档。

#### 示例 A-5 isis2json.py:依赖和文档在 GitHub 中的 fluentpython/i si s2j son 仓库里

\#这个脚本支持Python和Jython (版本＞=2.5且&lt;3)

import sys

import argparse

from uuid import uuid4

import os

try:

import json

except ImportError:

if os. name == 'java': # 在 Jython 中运行

from com.xhaus.jyson import JysonCodec as json

else:

import simplejson as json

SKIP_INACTIVE = True

DEFAULT_QTY = 2**31

ISIS_MFN_KEY = 'mfn'

ISIS_ACTIVE_KEY = 'active'

SUBFIELD_DELIMITER = 'A'

INPUT_ENCODING = 'cp1252'

def iter_iso_records(iso_file_name, isis_json_type): O from iso2709 import IsoFile from subfield import expand

iso = IsoFile(iso_file_name) for record in iso:

fields = {}

for field in record.directory: field_key = str(int(field.tag)) # 删除前导零 field_occurrences = fields.setdefault(field_key, []) content = field.value.decode(INPUT_ENCODING, 'replace') if isis_json_type == 1:

field_occurrences.append(content) elif isis_json_type == 2:

field_occurrences.append(expand(content)) elif isis_json_type == 3:

field_occurrences.append(dict(expand(content)))

else:

raise NotImplementedError('ISIS-JSON type %s conversion

yield fields iso.close()

def iter_mst_records(master_file_name, isis_json_type): & try:

from bruma.master import MasterFactory, Record except ImportError:

print('IMPORT ERROR: Jython 2.5 and Bruma.jar '

'are required to read .mst files') raise SystemExit

mst = MasterFactory.getInstance(master_file_name).open() for record in mst:

fields = {}

if SKIP_INACTIVE:

if record.getStatus() != Record.Status.ACTIVE: continue

else: # 仅当没有活动的记录时才保存状态

fields[ISIS_ACTIVE_KEY] = (record.getStatus() ==

Record.Status.ACTIVE)

fields[ISIS_MFN_KEY] = record.getMfn() for field in record.getFields():

field_key = str(field.getId())

field_occurrences = fields.setdefault(field_key, []) if isis_json_type == 3:

content = {}

for subfield in field.getSubfields(): subfield_key = subfield.getId() if subfield_key == '*':

content['_'] = subfield.getContent() else:

subfield_occurrences = content.setdefault(subfield_key, []) subfield_occurrences.append(subfield.getContent())

field_occurrences.append(content) elif isis_json_type == 1:

content = []

for subfield in field.getSubfields(): subfield_key = subfield.getId() if subfield_key == '*':

content.insert(0, subfield.getContent()) else:

content.append(SUBFIELD_DELIMITER + subfield_key + subfield.getContent())

field_occurrences.append(''.join(content))

else:

raise NotImplementedError('ISIS-JSON type %s conversion '

'not yet implemented for .mst input' % isis_json_type)

yield fields mst.close()

def write_json(input_gen, file_name, output, qty, skip, id_tag, © gen_uuid, mongo, mfn, isis_json_type, prefix, constant):

start = skip end = start + qty if id_tag:

id_tag = str(id_tag)

ids = set() else:

id_tag = ''

for i, record in enumerate(input_gen): if i >= end:

break

if not mongo:

if i == 0:

output.write('[')

elif i > start:

output.write(',') if start <= i < end:

if id_tag:

occurrences = record.get(id_tag, None)

if occurrences is None:

msg = 'id tag #%s not found in record %s' if ISIS_MFN_KEY in record:

msg = msg + (' (mfn=%s)' % record[ISIS_MFN_KEY]) raise KeyError(msg % (id_tag, i))

if len(occurrences) > 1:

msg = 'multiple id tags #%s found in record %s' if ISIS_MFN_KEY in record:

msg = msg + (' (mfn=%s)' % record[ISIS_MFN_KEY]) raise TypeError(msg % (id_tag, i))

else: #好吧，有且仅有一个id字段 if isis_json_type == 1:

id = occurrences[0] elif isis_json_type == 2:

id = occurrences[0][0][1] elif isis_json_type == 3:

id = occurrences[0]['_'] if id in ids:

msg = 'duplicate id %s in tag #%s, record %s'

if ISIS_MFN_KEY in record:

msg = msg + (' (mfn=%s)' % record[ISIS_MFN_KEY])

raise TypeError(msg % (id, id_tag, i)) record['_id'] = id

ids.add(id) elif gen_uuid:

record['_id'] = unicode(uuid4())

elif mfn:

record['_id'] = record[ISIS_MFN_KEY]

if prefix:

\# 迭代一个固定的标签序列 for tag in tuple(record):

if str(tag).isdigit():

record[prefix+tag] = record[tag] del record[tag] # 这就是迭代元组的原因 # 获取标签，但不直接从记录字典中获取

if constant:

constant_key, constant_value = constant.split(':') record[constant_key] = constant_value

output.write(json.dumps(record).encode('utf-8'))

output.write('\n')

if not mongo:

output.write(']\n')

def main(): ©

\# 创建解析器

parser = argparse.ArgumentParser(

description='Convert an ISIS .mst or .iso file to a JSON array')

\# 添加参数

parser.add_argument(

'file_name', metavar='INPUT.(mst|iso)', help='.mst or .iso file to read')

parser.add_argument(

'-o', '--out', type=argparse.FileType('w'), default=sys.stdout, metavar='OUTPUT.json',

help='the file where the JSON output should be written'

' (default: write to stdout)')

parser.add_argument(

'-c', '--couch', action='store_true',

help='output array within a "docs" item in a JSON document'

' for bulk insert to CouchDB via POST to db/_bulk_docs') parser.add_argument(

'-m', '--mongo', action='store_true',

help='output individual records as separate JSON dictionaries, one'

' per line for bulk insert to MongoDB via mongoimport utility')

parser.add_argument(

'-t', '--type', type=int, metavar='ISIS_JSON_TYPE', default=1,

help='ISIS-JSON type, sets field structure: 1=string, 2=alist,'

' 3=dict (default=1)')

parser.add_argument(

'-q', '--qty', type=int, default=DEFAULT_QTY,

help='maximum quantity of records to read (default=ALL)') parser.add_argument(

'-s', '--skip', type=int, default=0,

help='records to skip from start of .mst (default=0)') parser.add_argument(

'-i', '--id', type=int, metavar='TAG_NUMBER', default=0,

help='generate an "_id" from the given unique TAG field number'

' for each record')

parser.add_argument(

'-u', '--uuid', action='store_true',

help='generate an "_id" with a random UUID for each record')

parser.add_argument(

'-p', '--prefix', type=str, metavar='PREFIX', default='',

help='concatenate prefix to every numeric field tag'

' (ex. 99 becomes "v99")')

parser.add_argument(

'-n', '--mfn', action='store_true',

help='generate an "_id" from the MFN of each record'

' (available only for .mst input)')

parser.add_argument(

'-k', '--constant', type=str, metavar='TAG:VALUE', default='',

help='Include a constant tag:value in every record (ex. -k type:AS)')

\#    TODO:实现这个功能，导出大量记录供给CouchDB

parser.add_argument(

'-r', '--repeat', type=int, default=1, help='repeat operation, saving multiple JSON files'

' (default=1, use -r 0 to repeat until end of input)')

\#    解析命令行

args = parser.parse_args()

if args.file_name.lower().endswith('.mst'): input_gen_func = iter_mst_records ❺

else:



if args.mfn:

print('UNSUPORTED:

raise SystemExit input_gen_func = iter_iso_records © input_gen = input_gen_func(args.file_name, args.type) Q if args.couch:

args.out.write('{ write_json(input_gen, args.skip, args.type, if args.couch:



-n/--mfn option only available for .mst input.



"docs" : ')

args.file_name, args.out, args.qty,❻ args.id, args.uuid, args.mongo, args.mfn, args.prefix, args.constant)



args.out.write('}\n') args.out.close()



if __name__ == '__main__': main()

#### ❶ iter_iso_records 生成器函数读取 .iso 文件，产出记录。

❷ iter_mst_records 生成器函数读取 .mst 文件，产出记录。 ❸ write_json 函数迭代 input_gen 生成器，输出 .json 文件。 ❹ main 函数读取命令行参数，然后根据输入文件的扩展名选择

#### ❺......iter_mst_records生成器函数

❻ …… 或者 iter_iso_records 生成器函数。

#### ❼ 使用选中的生成器函数构建生成器对象。

❽ 把生成器作为第一个参数传给 write_json 函数。

### A.5    第16章：出租车队离散事件仿真

示例 A-6 是 16.9.2 节讨论的 taxi_sim.py 脚本的完整代码。

#### 示例A-6 taxi_sim.py：出租车队仿真程序

出租车仿真程序

在控制台中驱动出租车::

\>>> from taxi_sim import taxi_process

\>>> taxi = taxi_process(ident=13, trips=2, start_time=0)

\>>> next(taxi)

Event(time=0, proc=13, action='leave garage')

\>>> taxi.send(_.time + 7)

Event(time=7, proc=13, action='pick up passenger')

\>>> taxi.send(_.time + 23)

Event(time=30, proc=13, action='drop off passenger')

\>>> taxi.send(_.time + 5)

Event(time=35, proc=13, action='pick up passenger')

\>>> taxi.send(_.time + 48)

Event(time=83, proc=13, action='drop off passenger')

\>>> taxi.send(_.time + 1)

Event(time=84, proc=13, action='going home')

\>>> taxi.send(_.time + 10)

Traceback (most recent call last):

File "<stdin>", line 1, in <module>

StopIteration

#### 运行示例：有两辆出租车，随机种子是10。这是有效的doctest::

\>>> main(num_taxis=2, seed=10)

taxi: 0 Event(time=0, proc=0, action='leave garage') taxi: 0 Event(time=5, proc=0, action='pick up passenger') taxi: 1 Event(time=5, proc=1, action='leave garage') taxi: 1    Event(time=10, proc=1, action='pick up passenger')

taxi: 1    Event(time=15, proc=1, action='drop off passenger')

taxi: 0 Event(time=17, proc=0, action='drop off passenger') taxi: 1 Event(time=24, proc=1, action='pick up passenger') taxi: 0 Event(time=26, proc=0, action='pick up passenger') taxi: 0 Event(time=30, proc=0, action='drop off passenger') taxi: 0 Event(time=34, proc=0, action='going home') taxi: 1    Event(time=46, proc=1, action='drop off passenger')

taxi: 1    Event(time=48, proc=1, action='pick up passenger')

taxi: 1    Event(time=110,    proc=1,    action='drop    off passenger')

taxi: 1    Event(time=139,    proc=1,    action='pick    up passenger')

taxi: 1    Event(time=140,    proc=1,    action='drop    off passenger')

taxi: 1    Event(time=150,    proc=1,    action='going home')

*** end of events ***

#### 模块末尾有个更长的运行示例。

import random

import collections

import queue

import argparse

import time

DEFAULT_NUMBER_OF_TAXIS = 3

DEFAULT_END_TIME = 180

SEARCH_DURATION = 5

TRIP_DURATION = 20

DEPARTURE_INTERVAL = 5

Event = collections.namedtuple('Event', 'time proc action')

\#    BEGIN TAXI_PROCESS

def taxi_process(ident, trips, start_time=0):

"""每次状态变化时向仿真程序产出一个事件"""

time = yield Event(start_time, ident, 'leave garage') for i in range(trips):

time = yield Event(time, ident, 'pick up passenger') time = yield Event(time, ident, 'drop off passenger')

yield Event(time, ident, 'going home')

\# 结束出租车进程

\#    END TAXI_PROCESS # BEGIN TAXI_SIMULATOR

class Simulator:

def __init__(self, procs_map):

self.events = queue.PriorityQueue() self.procs = dict(procs_map)

def run(self, end_time):

"""调度并显示事件，直到时间结束 """

\#    调度各辆出租车的第一个事件

for _, proc in sorted(self.procs.items()): first_event = next(proc) self.events.put(first_event)

\#    此次仿真的主循环

sim_time = 0

while sim_time < end_time: if self.events.empty():

print('*** end of events ***')

break

current_event = self.events.get() sim_time, proc_id, previous_action = current_event print('taxi:', proc_id, proc_id * '    ', current_event)

active_proc = self.procs[proc_id]

next_time = sim_time + compute_duration(previous_action)

try:

except StopIteration:

del self.procs[proc_id]

else:

self.events.put(next_event)

else:

msg = '*** end of simulation time: {} events pending *** print(msg.format(self.events.qsize()))

\# END TAXI_SIMULATOR def compute_duration(previous_action):

"""使用指数分布计算操作的耗时 """

if previous_action in ['leave garage', 'drop off passenger']:

\# 新状态是四处徘徊 interval = SEARCH_DURATION

elif previous_action == 'pick up passenger':

\# 新状态是行程开始 interval = TRIP_DURATION

elif previous_action == 'going home': interval = 1

else:

raise ValueError('Unknown previous_action: %s' % previous_action) return int(random.expovariate(1/interval)) + 1

def main(end_time=DEFAULT_END_TIME, num_taxis=DEFAULT_NUMBER_OF_TAXIS,

seed=None):

"""初始化随机生成器，构建过程，运行仿真程序 """

if seed is not None:

random.seed(seed) # 获得可复现的结果

taxis = {i: taxi_process(i, (i+1)*2, i*DEPARTURE_INTERVAL) for i in range(num_taxis)}

sim = Simulator(taxis) sim.run(end_time)

if __name__ == '__main__':

parser = argparse.ArgumentParser(

description='Taxi fleet simulator.')

parser.add_argument('-e', '--end-time', type=int,

default=DEFAULT_END_TIME,

help='simulation end time; default = %s'

% DEFAULT_END_TIME)

parser.add_argument('-t', '--taxis', type=int,

default=DEFAULT_NUMBER_OF_TAXIS,

help='number of taxis running; default = %s

% DEFAULT_NUMBER_OF_TAXIS)

parser.add_argument('-s', '--seed', type=int, default=None,

help='random generator seed (for testing)')

args = parser.parse_args() main(args.end_time, args.taxis, args.seed)

\#    BEGIN TAXI_SAMPLE_RUN

$ python3 taxi_sim.py -s 3 -e 120

taxi: 0 Event(time=0, proc=0, action='leave garage')

taxi: 0 Event(time=2, proc=0, action='pick up passenger') taxi: 1    Event(time=5, proc=1, action='leave garage')

taxi: 1    Event(time=8, proc=1, action='pick up passenger')

taxi: 2    Event(time=10, proc=2, action='leave garage')

taxi: 2    Event(time=15,    proc=2,    action='pick    up passenger')

taxi: 2    Event(time=17,    proc=2,    action='drop    off passenger')

taxi: 0 Event(time=18, proc=0, action='drop off passenger') taxi: 2    Event(time=18,    proc=2,    action='pick    up passenger')

taxi: 2    Event(time=25,    proc=2,    action='drop    off passenger')

taxi: 1 Event(time=27, proc=1, action='drop off passenger') taxi: 2    Event(time=27, proc=2, action='pick up passenger')

taxi: 0 Event(time=28, proc=0, action='pick up passenger') taxi: 2    Event(time=40, proc=2, action='drop off passenger')

taxi: 2    Event(time=44, proc=2, action='pick up passenger')

taxi: 1    Event(time=55, proc=1, action='pick up passenger')

taxi: 1    Event(time=59, proc=1, action='drop off passenger')

taxi: 0 Event(time=65, proc=0, action='drop off passenger') taxi: 1 Event(time=65, proc=1, action='pick up passenger') taxi: 2    Event(time=65, proc=2, action='drop off passenger')

taxi: 2    Event(time=72, proc=2, action='pick up passenger')

taxi: 0 Event(time=76, proc=0, action='going home') taxi: 1    Event(time=80, proc=1, action='drop off passenger')

taxi: 1    Event(time=88, proc=1, action='pick up passenger')

taxi: 2    Event(time=95,    proc=2,    action='drop    off passenger')

taxi: 2    Event(time=97,    proc=2,    action='pick    up passenger')

taxi: 2    Event(time=98,    proc=2,    action='drop    off passenger')

taxi: 1 Event(time=106, proc=1, action='drop off passenger') taxi: 2    Event(time=109, proc=2, action='going home')

taxi: 1 Event(time=110, proc=1, action='going home')

*** end of events ***

\#    END TAXI_SAMPLE_RUN

### A.6    第17章：加密示例

这几个脚本用于展示如何使用 futures.ProcessPoolExecutor 执行 CPU 密集型任务。

示例 A-7 使用 RC4 算法加密并解密随机的字节数组，需要 arcfour+py 模块（见示例 A-8）

支持才能运行。

示例 A-7 arcfour_futures+py： futures.ProcessPoolExecutor 用法示例

import sys

import time

from concurrent import futures

from random import randrange

from arcfour import arcfour

JOBS = 12

SIZE = 2**18

KEY = b"'Twas brillig, and the slithy toves\nDid gyre STATUS = '{} workers, elapsed time: {:.2f}s'

def arcfour_test(size, key):

in_text = bytearray(randrange(256) for i in range(size))

cypher_text = arcfour(key, in_text)

out_text = arcfour(key, cypher_text)

assert in_text == out_text, 'Failed arcfour_test'

return size

def main(workers=None): if workers:

workers = int(workers)

t0 = time.time()

with futures.ProcessPoolExecutor(workers) as executor:

actual_workers = executor._max_workers

to_do = []

for i in range(JOBS, 0, -1):

size = SIZE + int(SIZE / JOBS * (i - JOBS/2))

job = executor.submit(arcfour_test, size, KEY) to_do.append(job)

for future in futures.as_completed(to_do): res = future.result()

print('{:.1f} KB'.format(res/2**10))

print(STATUS.format(actual_workers, time.time() - t0))

if __name__ == '__main__': if len(sys.argv) == 2:

workers = int(sys.argv[1])

else:

workers = None

main(workers)

#### 示例 A-8 纯粹使用 Python 实现 RC4 加密算法。

#### 示例A-8 arcfour.py：兼容RC4的算法

"""兼容RC4的算法"""

def arcfour(key, in_bytes, loops=20):

kbox = bytearray(256) # 创建存储键的数组 for i, car in enumerate(key): # 复制键和向量

kbox[i] = car j = len(key)

for i in range(j, 256):    # 重复到底

kbox[i] = kbox[i-j]

\#    [1]初始化sbox

sbox = bytearray(range(256))

\#按照CipherSaber-2的建议，不断打乱sbox

\#    [http://ciphersaber.gurus.com/faq.html#cs2](http://ciphersaber.gurus.com/faq.html%23cs2) j = 0

for k in range(loops): for i in range(256):

j = (j + sbox[i] + kbox[i]) % 256 sbox[i], sbox[j] = sbox[j], sbox[i]

\#    主循环

i = 0 j = 0

out_bytes = bytearray()

for car in in_bytes: i = (i + 1) % 256

\#    [2]打乱 sbox

j = (j + sbox[i]) % 256

sbox[i], sbox[j] = sbox[j], sbox[i]

\#    [3]计算t

t = (sbox[i] + sbox[j]) % 256 k = sbox[t] car = car A k out_bytes.append(car)

return out_bytes

def test():

from time import time

clear = bytearray(b'1234567890' * 100000)

t0 = time()

cipher = arcfour(b'key', clear) print('elapsed time: %.2fs' % (time() - t0)) result = arcfour(b'key', cipher)

assert result == clear, '%r != %r' % (result, clear) print('elapsed time: %.2fs' % (time() - t0)) print('OK')

if __name__ == '__main__': test()

#### 示例 A-9 使用 SHA-256 散列算法打乱字节数组。这个脚本使用标准库中的 hashlib 模块， 而这个模块使用 C 语言编写的 OpenSSL 库。

示例 A-9 sha_futures+py： futures.ProcessPoolExecutor 用法示例

import sys import time import hashlib

from concurrent import futures from random import randrange

JOBS = 12 SIZE = 2**20

STATUS = '{} workers, elapsed time: {:.2f}s

def sha(size):

data = bytearray(randrange(256) for i in range(size)) algo = hashlib.new('sha256') algo.update(data) return algo.hexdigest()

def main(workers=None): if workers:

workers = int(workers)

t0 = time.time()

with futures.ProcessPoolExecutor(workers) as executor:

actual_workers = executor._max_workers

to_do = (executor.submit(sha, SIZE) for i in range(JOBS)) for future in futures.as_completed(to_do): res = future.result()

print(res)

print(STATUS.format(actual_workers, time.time() - t0))

if __name__ == '__main__': if len(sys.argv) == 2:

workers = int(sys.argv[1])

else:

workers = None

main(workers)

A.7第17章：flags2系列HTTP客户端示例

#### 17.5节的flags2系列示例都使用了 flags2_common.py模块（见示例A-10）里的函数。 示例 A-10 flags2_common.py

"""为后续flag示例提供实用函数。

import os

import time

import sys

import string

import argparse

from collections import namedtuple from enum import Enum

Result = namedtuple('Result', 'status data')

HTTPStatus = Enum('Status', 'ok not_found error')

POP20_CC = ('CN IN US ID BR PK NG BD RU JP '

'MX PH VN ET EG DE IR TR CD FR').split()

DEFAULT_CONCUR_REQ = 1

MAX_CONCUR_REQ = 1

SERVERS = {

'REMOTE': '<http://flupy.org/data/flags'>,

'LOCAL': '<http://localhost:8001/flags'>,

'DELAY': '<http://localhost:8002/flags'>,

'ERROR': '<http://localhost:8003/flags'>,

}

DEFAULT_SERVER = 'LOCAL'

DEST_DIR = 'downloads/'

COUNTRY_CODES_FILE = 'country_codes.txt'

def save_flag(img, filename):

path = os.path.join(DEST_DIR, filename) with open(path, 'wb') as fp:

fp.write(img)

def initial_report(cc_list, actual_req, server_label): if len(cc_list) <= 10:

cc_msg = ', '.join(cc_list) else:

cc_msg = 'from {} to {}'.format(cc_list[0], cc_list[-1]) print('{} site: {}'.format(server_label, SERVERS[server_label])) msg = 'Searching for {} flag{}: {}'

plural = 's' if len(cc_list) != 1 else '' print(msg.format(len(cc_list), plural, cc_msg))

plural = 's' if actual_req != 1 else ''

msg = '{} concurrent connection{} will be used.

print(msg.format(actual_req, plural))

def final_report(cc_list, counter, start_time): elapsed = time.time() - start_time

print('-' * 20)

msg = '{} flag{} downloaded.'

plural = 's' if counter[HTTPStatus.ok] != 1 else '' print(msg.format(counter[HTTPStatus.ok], plural)) if counter[HTTPStatus.not_found]:

print(counter[HTTPStatus.not_found], 'not found.') if counter[HTTPStatus.error]:

plural = 's' if counter[HTTPStatus.error] != 1 else '' print('{} error{}.'.format(counter[HTTPStatus.error], plural))

print('Elapsed time: {:.2f}s'.format(elapsed))

def expand_cc_args(every_cc, all_cc, cc_args, limit): codes = set()

A_Z = string.ascii_uppercase if every_cc:

codes.update(a+b for a in A_Z for b in A_Z) elif all_cc:

with open(COUNTRY_CODES_FILE) as fp: text = fp.read()

codes.update(text.split())

else:

for cc in (c.upper() for c in cc_args): if len(cc) == 1 and cc in A_Z:

codes.update(cc+c for c in A_Z) elif len(cc) == 2 and all(c in A_Z for c in cc):

codes.add(cc)

else:

msg = 'each CC argument must be A to Z or AA to ZZ.

raise ValueError('*** Usage error: '+msg) return sorted(codes)[:limit]

def



process_args(default_concur_req):

server_options = ', '.join(sorted(SERVERS))

parser = argparse.ArgumentParser(

description='Download flags for country codes.



'Default: top 20 countries by population.') parser.add_argument('cc', metavar='CC', nargs='*',

help='country code or 1st letter (eg. B for BA...BZ)') parser.add_argument('-a', '--all', action='store_true',

help='get all available flags (AD to ZW)') parser.add_argument('-e', '--every', action='store_true',

help='get flags for every possible code (AA...ZZ)') parser.add_argument('-l', '--limit', metavar='N', type=int,

help='limit to N first codes', default=sys.maxsize) parser.add_argument('-m', '--max_req', metavar='CONCURRENT', type=int,

default=default_concur_req,

help='maximum concurrent requests (default={})



.format(default_concur_req))

parser.add_argument('-s', '--server', metavar='LABEL', default=DEFAULT_SERVER,

help='Server to hit; one of {} (default={})' .format(server_options, DEFAULT_SERVER))

parser.add_argument('-v', '--verbose', action='store_true', help='output detailed progress info')

args = parser.parse_args() if args.max_req < 1:

print('*** Usage error: --max_req CONCURRENT must be >= 1')

parser.print_usage()

sys.exit(1)

if args.limit < 1:

print('*** Usage error: --limit N must be >= 1')

parser.print_usage()

sys.exit(1)

args.server = args.server.upper() if args.server not in SERVERS:

print('*** Usage error: --server LABEL must be one of', server_options)

parser.print_usage()

sys.exit(1)

try:

cc_list = expand_cc_args(args.every, args.all, args.cc, args.limit) except ValueError as exc:

print(exc.args[0])

parser.print_usage()

sys.exit(1)

if not cc_list:

cc_list = sorted(POP20_CC)

return args, cc_list

def main(download_many, default_concur_req, max_concur_req): args, cc_list = process_args(default_concur_req) actual_req = min(args.max_req, max_concur_req, len(cc_list)) initial_report(cc_list, actual_req, args.server) base_url = SERVERS[args.server]

t0 = time.time()

counter = download_many(cc_list, base_url, args.verbose, actual_req) assert sum(counter.values()) == len(cc_list), \

'some downloads are unaccounted for' final_report(cc_list, counter, t0)

#### flags2_sequential.py脚本(见示例A-11)是对比两种并发实现的基准。flags2_threadpool.py 脚本(见示例 17-14)还使用了 flags2_sequential .py 脚本中的 get_flag 和 download_one 两个函数。

#### 示例 A-11 flags2_sequential .py

""" 下载多个国家的国旗(包含错误处理代码)。 依序下载版

运行示例::

$ python3 flags2_sequential.py -s DELAY b DELAY site: <http://localhost:8002/flags> Searching for 26 flags: from BA to BZ 1 concurrent connection will be used.

17 flags downloaded. 9 not found.

Elapsed time: 13.36s

import collections

import requests

import tqdm

from flags2_common import main, save_flag, HTTPStatus, Result

DEFAULT_CONCUR_REQ = 1

MAX_CONCUR_REQ = 1

\#    BEGIN FLAGS2_BASIC_HTTP_FUNCTIONS

def get_flag(base_url, cc):

url = '{}/{cc}/{cc}.gif'.format(base_url, cc=cc.lower()) resp = requests.get(url)

if resp.status_code != 200: resp.raise_for_status()

return resp.content

def download_one(cc, base_url, verbose=False): try:

image = get_flag(base_url, cc) except requests.exceptions.HTTPError as exc:

res = exc.response if res.status_code == 404:

status = HTTPStatus.not_found msg = 'not found'

else:

raise

else:

save_flag(image, cc.lower() + '.gif') status = HTTPStatus.ok msg = 'OK'

if verbose:

print(cc, msg)

return Result(status, cc)

\#    END FLAGS2_BASIC_HTTP_FUNCTIONS

\#    BEGIN FLAGS2_DOWNLOAD_MANY_SEQUENTIAL

def download_many(cc_list, base_url, verbose, max_req): counter = collections.Counter() cc_iter = sorted(cc_list) if not verbose:

cc_iter = tqdm.tqdm(cc_iter) for cc in cc_iter:

try:

res = download_one(cc, base_url, verbose) except requests.exceptions.HTTPError as exc:

error_msg = 'HTTP error {res.status_code} - {res.reason}

error_msg = error_msg.format(res=exc.response) except requests.exceptions.ConnectionError as exc:

error_msg = 'Connection error' else:

error_msg = '' status = res.status

if error_msg:

status = HTTPStatus.error

counter[status] += 1 if verbose and error_msg:

print('*** Error for {}: {}'.format(cc, error_msg)) return counter

\# END FLAGS2_DOWNLOAD_MANY_SEQUENTIAL

if __name__ == '__main__':

main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ)

### A.8第19章：处理OSCON日程表的脚本和测试

示例 A-12 是 schedule1.py 模块（示例 19-9）的测试脚本，使用 py.test 库和测试运行程

序实现。

示例 A-12 test_schedule1.py

import shelve

import pytest

import schedule1 as schedule @pytest.yield_fixture

def db():

with shelve.open(schedule.DB_NAME) as the_db: if schedule.CONFERENCE not in the_db:

schedule.load_db(the_db) yield the_db

def test_record_class():

rec = schedule.Record(spam=99, eggs=12) assert rec.spam == 99

assert rec.eggs == 12

def test_conference_record(db):

assert schedule.CONFERENCE in db

def test_speaker_record(db):

speaker = db['speaker.3471']

assert speaker.name == 'Anna Martelli Ravenscroft'

def test_event_record(db):

event = db['event.33950']

assert event.name == 'There *Will* Be Bugs

def test_event_venue(db):

event = db['event.33950'] assert event.venue_serial == 1449

#### 19.1.5 节分四部分列出了 schedule2.py 脚本里的代码，示例 A-13 是完整的代码清单。 示例 A-13 schedule2.py

\>>> import shelve

\>>> db = shelve.open(DB_NAME)

\>>> if CONFERENCE not in db: load_db(db)

\#    BEGIN SCHEDULE2_DEMO

\>>> DbRecord.set_db(db)

\>>> event = DbRecord.fetch('event.33950')

\>>> event

<Event 'There *Will* Be Bugs'>

\>>> event.venue

<DbRecord serial='venue.1449'>

\>>> event.venue.name 'Portland 251'

\>>> for spkr in event.speakers:

... print('{0.serial}: {0.name}'.format(spkr))

speaker.3471: Anna Martelli Ravenscroft speaker.5199: Alex Martelli

\#    END SCHEDULE2_DEMO

\>>> db.close()

\# BEGIN SCHEDULE2_RECORD import warnings import inspect import osconfeed

DB_NAME = 'data/schedule2_db' CONFERENCE = 'conference.115'

class Record:

def __init__(self, **kwargs): self.__dict__.update(kwargs)

def __eq__(self, other):

if isinstance(other, Record):

return self.__dict__ == other.__dict__ else:

return NotImplemented # END SCHEDULE2_RECORD

\# BEGIN SCHEDULE2_DBRECORD

class MissingDatabaseError(RuntimeError):

"""Raised when a database is required but was not set.

class DbRecord(Record):

__db = None

@staticmethod def set_db(db):

DbRecord.__db = db

@staticmethod def get_db():

return DbRecord.__db

@classmethod

def fetch(cls, ident):

db = cls.get_db() try:

return db[ident] except TypeError:

if db is None:

msg = "database not set; call '{}.set_db(my_db)'" raise MissingDatabaseError(msg.format(cls.__name__))

else:

raise

def __repr__(self):

if hasattr(self, 'serial'):

cls_name = self.__class__.__name__

return '<{} serial={!r}>'.format(cls_name, self.serial) else:

return super().__repr__()

\# END SCHEDULE2_DBRECORD

\#    BEGIN SCHEDULE2_EVENT

class Event(DbRecord):

@property def venue(self):

key = 'venue.{}'.format(self.venue_serial) return self.__class__.fetch(key)

@property

def speakers(self):

if not hasattr(self, '_speaker_objs'):

spkr_serials = self.__dict__['speakers'] fetch = self.__class__.fetch

self._speaker_objs = [fetch('speaker.{}'.format(key)) for key in spkr_serials]

return self._speaker_objs

def __repr__(self):

if hasattr(self, 'name'):

cls_name = self.__class__.__name__

return '<{} {!r}>'.format(cls_name, self.name)

else:

return super().__repr__()

\#    END SCHEDULE2_EVENT # BEGIN SCHEDULE2_LOAD

def load_db(db):

raw_data = osconfeed.load() warnings.warn('loading ' + DB_NAME)

for collection, rec_list in raw_data['Schedule'].items(): record_type = collection[:-1]

cls_name = record_type.capitalize()

cls = globals().get(cls_name, DbRecord)

if inspect.isclass(cls) and issubclass(cls, DbRecord):

factory = cls else:

factory = DbRecord for record in rec_list:

key = '{}.{}'.format(record_type, record['serial']) record['serial'] = key db[key] = factory(**record)

\# END SCHEDULE2_LOAD

#### 示例 A-14 使用 py.test 测试示例 A-13。 示例 A-14 test_schedule2.py

import shelve

import pytest

import schedule2 as schedule @pytest.yield_fixture

def db():

with shelve.open(schedule.DB_NAME) as the_db: if schedule.CONFERENCE not in the_db:

schedule.load_db(the_db) yield the_db

def test_record_attr_access():

rec = schedule.Record(spam=99, eggs=12) assert rec.spam == 99

assert rec.eggs == 12

def test_record_repr():

rec = schedule.DbRecord(spam=99, eggs=12) assert 'DbRecord object at 0x' in repr(rec) rec2 = schedule.DbRecord(serial=13)

assert repr(rec2) == "<DbRecord serial=13>"

def test_conference_record(db):

assert schedule.CONFERENCE in db

def test_speaker_record(db):

speaker = db['speaker.3471']

assert speaker.name == 'Anna Martelli Ravenscroft'

def test_missing_db_exception():

with pytest.raises(schedule.MissingDatabaseError):

schedule.DbRecord.fetch('venue.1585')

def test_dbrecord(db):

schedule.DbRecord.set_db(db)

venue = schedule.DbRecord.fetch('venue.1585') assert venue.name == 'Exhibit Hall B'

def test_event_record(db):

event = db['event.33950']

assert repr(event) == "<Event 'There *Will* Be Bugs'>

def test_event_venue(db):

schedule.Event.set_db(db)

event = db['event.33950'] assert event.venue_serial == 1449 assert event.venue == db['venue.1449'] assert event.venue.name == 'Portland 251

def test_event_speakers(db): schedule.Event.set_db(db)

event = db['event.33950']

assert len(event.speakers) == 2

anna_and_alex = [db['speaker.3471'], db['speaker.5199']]

assert event.speakers == anna_and_alex

def test_event_no_speakers(db): schedule.Event.set_db(db)

event = db['event.36848']

assert len(event.speakers) == 0



# Python 术语表

当然，这里列出的很多术语不是 Python 专用的，不过某些术语的定义对 Python 社区有特 殊的意义。

此外，也可以参阅官方的 Python 词汇表（[https://docs+python+org/3/glossary+html](https://docs.python.org/3/glossary.html)）。

ABC （编程语言）

Leo Geurts、Lambert Meertens 和 Steven Pemberton 创造的一门编程语言。 20 世纪 80 年代， Python 之父 Guido van Rossum 是实现 ABC 环境的程序员。 Python 的一些特色出自 ABC，例如使用缩进划分块、内置元组和字典、元组拆包、for循环的语义，以及对所有

序列类型的统一处理方式。

BDFL

Benevolent Dictator For Life 的简称，意为“仁慈的独裁者”，指代 Python 之父 Guido van Rossum。

BOM

Byte Order Mark 的简称，意为“字节序标记”，指可能出现在 UTF-16 编码文件开头的 字节序列。 BOM 是 U+FEFF 字符（零宽不换行空格），在大字节序的 CPU 中，编码成

b'\xfe\xff';在小字节序的CPU中，编码成b'\xff\xfe'。因为Unicode中没有

U+FFFE 字符，所以这些字节的作用只有一个——表示编码方式使用的字节序。虽然多 余，但是在 UTF-8 文件中可能会找到编码成 b'\xef\xbb\xbf' 的 BOM。

CPython

标准的 Python 解释器，使用 C 语言实现。讨论不同实现特有的行为，以及多个可用 的Python解释器（如PyPy）时才会使用这个术语。

CRUD

Create、 Read、 Update、 Delete 的首字母缩写，这是存储记录的应用程序中的四种基

本操作。

doctest

一个模块，其中的函数能解析并运行 Python 模块或纯文本文件的文档字符串中内嵌

的示例。也可以在命令行中使用，如下所示：

python -m doctest module_with_tests.py

DRY

Don't Repeat Yourself （不要自我重复）的缩写，一种软件工程原则，意思是：“系统 中的每一项知识都必须具有单一、无歧义、权威的表示。 ”首先由 Andy Hunt 与 Dave Thomas 的《程序员修炼之道：从小工到专家》一书提出。

dunder

首尾有两条下划线的特殊方法和属性的简洁读法（即把__len__读成“dunder len”）。

dunder 方法

参见 dunder 和特殊方法词条。

EAFP

“it's easier to ask forgiveness than permission” （取得原谅比获得许可容易）的首字母缩 写。人们认为这句话是计算机先驱 Grace Hopper 说的， Python 程序员使用这个缩写指代

一种动态编程方式，例如访问属性前不测试有没有属性，如果没有就捕获异常。 hasattr 函数的文档字符串是这样描述它的工作方式的： “调用 getattr（object,

name），然后捕获 AttributeError 异常。”

genexp

generator expression （生成器表达式）的简称。

GoF 书

指代《设计模式：可复用面向对象软件的基础》一书，作者是四个人，被称为“四人

组，，（Gang of Four， GoF），包括 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides。

KISS 原则

KISS是“Keep It Simple, Stupid”的首字母缩写。这个原则要求尽量寻找最简单的方 案，尽量减少可变部分。这个警句是 Kelly Johnson 首创的。 Kelly 是一位多才多艺的航空

工程师，在真实存在的 51 区工作，设计出了 20 世纪最先进的几架航天飞机。

listcomp

list comprehension （列表推导）的简称。

ORM

Object-Relational Mapper （对象关系映射器）的缩写，通过这种API可以使用Python 类和对象访问数据库中的表和记录，而且调用方法可以执行数据库操作。 SQLAlchemy 是 流行的独立 Python ORM， Django 和 Web2py 自带了 ORM。

PyPI

Python包索引([https://pypi+python.org/](https://pypi.python.org/))，里面有超过60 000个包可用。也叫奶酪店 (参见奶酪店词条)。为了防止与PyPy混淆，PyPI应该读作“pie-P-eye”。

PyPy

Python 编程语言的另一种实现，使用一个工具链把部分 Python 编译成机器码，因此

解释器的源码其实是使用Python编写的。PyPy还提供了 JIT，即时把用户的程序编译成机 器码——与 Java VM 的作用相同。根据 PyPy 公布的基准测试( [http://speed+pypy+org/ ](http://speed.pypy.org/)) ，

从 2014 年 11 月起， PyPy 平均比 CPython 快 6+8 倍。为了防止与 PyPI 混淆， PyPy 应该读 作“pie-pie”。

Pythonic

用于赞扬符合 Python 风格的代码，即充分利用 Python 语言的特性，写出简洁明了、 可读性强，通常运行速度也快的代码。还指 API 符合 Python 高手的编程方式。参见惯用 句法词条。

Python 之禅

从 Python 2+2 起，在 Python 控制台中输入 import this 后看到的输出。

REPL

read-eval-print loop (读取一求值一输出循环)的简称，一种交互式控制台，如标准 的 python 或非主流的 ipython 和 bpython，以及 Python Anywhere。

YAGNI

You Ain't Gonna Need It (你不需要这个)的首字母缩写，这个口号的意思是，根据对 未来需求的预测，不要实现非立即需要的功能。

绑定方法( bound method)

通过实例访问的方法会绑定到那个实例上。方法其实是描述符，访问方法时，会返回

一个包装自身的对象，把方法绑定到实例上。那个对象就是绑定方法。调用绑定方法时，

可以不传入 self 的值。例如，像 my_method = my_obj.method 这样赋值之后，可以通 过 my_method() 调用绑定方法。请与非绑定方法相比较。

编码解码器( codec)

(编码器 / 解码器)提供编码和解码函数的模块，通常在 str 和 bytes 之间转换， 不过Python也提供了在bytes和bytes，以及str和str之间转换的编码解码器。

变值方法( mutator)

参见存取方法词条。

别名( aliasing)

为同一个对象指定两个或多个名称。例如，在 a = []; b = a 中， a 和 b 是别名，

指向同一个列表对象。对于把对象引用存储在变量中的语言来说，别名无处不在。为了避

免混淆，要摒弃这种想法：变量是存储对象的盒子(毕竟同一个对象不可能放在两个盒子

里)。我们要把变量看做对象的标注(一个对象可以有多个标注)。

并行赋值( parallel assignment)

使用类似 a, b = [c, d] 这样的句法，把可迭代对象中的元素赋值给多个变量，也

叫解构赋值。这是元组拆包的常见用途。

抽象基类(abstract base class， ABC)

无法实例化，只能扩展的类。 Python 通过 ABC 实现接口。除了继承 ABC 之外，类还 可以注册成为 ABC 的虚拟子类，声明自己实现了接口。

初始化方法( initializer)

__init__ 方法更贴切的名称(取代构造方法)。 __init__ 方法的任务是初始化通 过 self 参数传入的实例。实例其实是由 __new__ 方法构建的。参见构造方法词条。

储存属性( storage attribute )

托管实例中的属性，用于存储由描述符管理的属性的值。另见托管属性词条。

存取方法( accessor)

用于存取单个数据属性的方法。有些作者把存取方法当作通用术语使用，包括读值 方法和设值方法；另一些作者则用存取方法指代读值方法，而用变值方法指代设值方法。 代码异味( code smell)

一种代码形式，表明程序的设计可能有问题。例如，过度使用 isinstance 检查具体 的类是一种代码异味，因为这样会导致程序以后难以扩展，无法处理新类型。

单例( singleton)

一个类唯一存在的实例——这通常不是巧合，而是故意为之，防止类创建多个实例。

有一种设计模式就叫单例模式，指明如何编写这样的类。在 Python 中， None 对象是单 例。

导入时( import time)

Python 解释器加载模块，从上到下计算，把里面的代码编译成字节码之后，开始执行 模块的那一刻。类和函数在此时定义，变成真实存在的对象。装饰器也在此时执行。

迭代器( iterator)

实现了无参数方法 __next__ 的对象；这个方法返回级数里的下一个元素，如果没有 元素了就抛出 StopIteration 异常。在 Python 中，迭代器还实现了 __iter__ 方法，因 此迭代器也是可迭代的对象。根据最初的设计模式，经典迭代器返回集合里的元素。生

成器也是迭代器，不过更灵活。参见生成器词条。

惰性求值( lazy)

指可迭代的对象按需生成元素。在 Python 中，生成器会惰性求值。请与及早求值相

比较。

二进制序列(binary sequence)

一个通用术语，表示元素是二进制数据的序列类型。内置的二进制序列类型有 byte、 bytearray 和 memoryview。

泛函数( generic function)

以不同的方式为不同类型的对象实现相同操作的一组函数。从 Python 3+4 起，创建泛 函数的标准方式是使用 functools.singledispatch 装饰器。在其他语言中，这叫多分

派方法。

非绑定方法(unbound method)

直接通过类访问的实例方法没有绑定到特定的实例上，因此把这种方法称为“非绑定 方法”。若想成功调用非绑定方法，必须显式传入类的实例作为第一个参数。那个实例会 赋值给方法的 self 参数。参见绑定方法词条。

非覆盖型描述符( nonoverriding descriptor)

未实现 __set__ 方法的描述符，不干涉托管实例中托管属性的设置。因此，托管 实例中的同名属性会遮盖实例中的描述符。也叫非数据描述符或遮盖型描述符。请与覆 盖型描述符相比较。

覆盖型描述符( overriding descriptor)

实现了 __set__ 方法的描述符，设置托管实例中的托管属性时会遭到拦截并覆盖相 关操作。也叫数据描述符或强制描述符。请与非覆盖型描述符相比较。

高阶函数( higher-order function)

以其他函数为参数的函数，例如sorted、map和filter；或者，返回值为函数的函 数，例如 Python 中的装饰器。

构造方法( constructor)

类的 __init__ 实例方法称为类的构造方法，因为这个方法的语义类似于 Java 中的

构造方法。然而，这样称呼并不规范， __init__ 更应该称为初始化方法，因为它并不会

构建实例，而是把实例传给 self 参数。 Python 在 __init__ 方法之前调用的 __new__

类方法更合乎构造方法这个术语， __new__ 方法才会创建实例并将其返回。参见初始化

方法词条。

惯用句法( idiom)

根据普林斯顿大学 WordNet 字典的定义，惯用句法指“说母语的人说话的方式”。 函数( function)

严格来说，是指 def 块或 lambda 表达式计算得到的对象。通常，函数这个词用于 表示任何可调用的对象，例如方法，有时甚至表示类。官方文档中的内置函数列表

([http://docs+python.org/library/functions+html](http://docs.python.org/library/functions.html))列出了几个内置的类，例如 diet、 range 和

str。另见可调用的对象词条。

猴子补丁 ( monkey patching)

在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。猴子补丁在内存中

发挥作用，不会修改源码，因此只对当前运行的程序实例有效。因为猴子补丁破坏了封

装，而且容易导致程序与补丁代码的实现细节紧密耦合，所以被视为临时的变通方案，不

是集成代码的推荐方式。

混入方法( mixin method)

抽象基类或混入类中方法的具体实现。

混入类( mixin class )

用于随着多重继承类树中的一个或多个类一起扩展的类。混入类绝不能实例化，它的

具体子类也应该是其他非混入类的子类。

活性( liveness)

异步系统、线程系统或分布式系统在“期待的事情终于发生”(即虽然期待的计算不会

立即发生，但最终会完成)时展现出来的特性叫活性。如果系统死锁了，活性也就没有

了。

及早求值( eager)

指可迭代对象一次构建好全部元素。在 Python 中，列表推导会及早求值。请与惰性

求值相比较。

集合( collection)

泛指由元素组成，可以单独访问各个元素的数据结构。有些集合可以包含任意类型的

对象(参见容器词条) ，有些则只能包含一种原子类型的对象(参见平坦序列词 条)。 list 和 bytes 都是集合，只不过 list 是容器，而 bytes 是平坦序列。

假值( falsy)

只要 bool(x) 返回 False， x 就是假值。需要布尔值时， Python 会隐式使用 bool 计 算对象，例如控制if和while循环的表达式。与此相对的是真值(truthy)。

尽早失败( fail-fast)

一种系统设计方式，建议应该尽早报告错误。 Python 比其他大多数动态编程语言更遵

守这一原则。例如， Python 中没有“未定义”的值：在初始化之前引用变量会报错；如果 k 不存在，my_dict[k]会抛出异常(JavaScript则不然)。还有一例：在Python中通过元 组拆包做并行赋值，必须显式处理元组的每一个元素才行；而在 Ruby 中，如果 = 两边的 元素数量不一致，右边未用到的元素会被忽略，或者把 nil 赋给左边多余的变量。

可迭代的( iterable)

使用内置的 iter 函数可以从中获得迭代器的对象。可迭代的对象为 for 循环、列表 推导和元组拆包提供元素。如果对象的 __iter__ 方法能返回迭代器，这就是可迭代的 对象。序列都是可迭代的对象；此外，实现 __getitem__ 方法的对象也是可迭代的对 象。

可迭代对象的拆包(iterable unpacking)

元组拆包更现代、更精确的同义词。另见并行赋值词条。

可散列的( hashable)

在散列值永不改变，而且如果a == b，那么hash(a) == hash(b)也是True的情 况下，如果对象既有 __hash__ 方法，也有 __eq__ 方法，那么这样的对象称为可散列的 对象。在内置的类型中，大多数不可变的类型都是可散列的；但是，仅当元组的每一个元 素都是可散列的时，元组才是可散列的。

可调用的对象( callable object)

可以使用调用运算符 () 调用，能返回结果或执行某项操作的对象。在 Python 中，可 调用的对象有七种：用户定义的函数、内置的函数、内置的方法、实例方法、生成器函 数、类，还有实现特殊方法 __call__ 的类的实例。

类( class)

定义新类型的程序结构，里面有数据属性，以及用于操作数据属性的方法。参见类

型词条。

类型( type)

程序中的各种数据，限定可取的值和可对数据做的操作。有些 Python 类型近似于机 器数据类型(例如float和bytes)，而另一些则是机器数据类型的扩展(例如，int 不受 CPU 字长的限制， str 包含多字节 Unicode 数据码位)和特别高层的抽象(例如

diet、deque，等等)。类型分为两类：用户定义的类型和解释器内置的类型。在 Python 2+2 统一类型和类之前，类型和类是不同的实体，用户定义的类不能扩展内置的类 型。而在那之后，内置的类型和新式类兼容了，类是 type 的实例。在 Python 3 中，所有 类都是新式类。参见类和元类词条。

列表推导( list comprehension)

放在方括号里的表达式，使用关键字for和in，通过处理和过滤一个或多个可迭代 对象里的元素构建列表。列表推导会及早求值。参见及早求值词条。

码位( code point)

介于 0~0x10FFFF 之间的整数，用于标识 Unicode 字符数据库中的字符。截至

Unicode 7+0，所有码位中只有不到 3% 指定了字符。在 Python 文档中，这个术语可能拼成 一个词，也可能拼成两个词。例如，在Python标准库参考手册的“2. Built-in Functions”一 章([http://docs+python+org/library/fUnctions+html](http://docs.python.org/library/functions.html))中，说 char 函数的参数是一个整数“码 位” (codepoint)，却说作用相反的ord函数返回一个“Unicode码位”(Unicode code point)。

描述符( descriptor)

一个类，实现 __get__、 __set__ 和 __delete__ 特殊方法中的一个或多个，其实 例作为另一个类(托管类)的类属性。描述符管理托管类中托管属性的存取和删除，数

据通常存储在托管实例中。

名称改写 ( name mangling)

Python 解释器在运行时自动把私有属性 __x 重命名为 _MyClass__x。

魔术方法( magic method)

同特殊方法。

奶酪店( Cheese Shop)

Python 包索引(Python Package Index， PyPI，[https://pypi+python+ org/pypi](https://pypi.python.org/pypi))原来的名

称，以“巨蟒剧团”表演的幽默短剧《奶酪店》命名。虽然是奶酪店，但是店里却什么奶酪

都没有。写作本书时， [https://cheeseshop+python+org](https://cheeseshop.python.org) 这个别名链接还有效。参见 PyPI 词

条。

内置函数( built-in function， BIF)

随 Python 解释器一起提供的函数，使用底层实现语言(也就是说， CPython 用 C 语 言，Jython用Java，以此类推)编写。这个术语通常指代无需导入就能使用的函数，参 见Python标准库参考手册中的“2+ Built-in Functions”一章

( [http: //docs+python+org/library/functions+html ](http://docs.python.org/library/functions.html)) 。不过，内置的模块(如 sys、 math、 re 等)也包含内置函数。

平坦序列( flat sequence )

这种序列类型存储的是元素的值本身，而不是其他对象的引用。内置的类型中，

str、 bytes、 bytearray、 memoryview 和 array.array 是平坦序列；而 list、 tuple

和 collections.deque 是容器序列。参见容器词条。

浅复制( shallow copy)

一种对象副本，引用源对象的全部属性对象。请与深复制相比较。另见别名词条。

强引用( strong reference )

让对象始终存在于 Python 中的引用。请与弱引用相比较。

切片( slicing)

使用切片表示法生成序列的子集，例如my_sequence[2:6]。切片经常复制数据， 生成新对象；然而， my_sequence[:] 是对整个序列的浅复制。不过， memoryview 对象 的切片虽是一个 memoryview 新对象，但会与源对象共享数据。

容器( container)

包含其他对象引用的对象。 Python 中的大多数集合类型都是容器，不过有些不是。请 与平坦序列相比较，这种序列是集合，但不是容器。

弱引用( weak reference )

一种特殊的对象引用方式，不计入指示对象的引用计数。弱引用使用 weakref 模块 里的某个函数和数据结构创建。

上下文管理器( context manager)

实现了 __enter__ 和 __exit__ 特殊方法的对象，在 with 块中使用。

蛇底式( snake_case )

标识符的一种命名约定，使用下划线(_)连接单词，例如 run_until_complete。 PEP-8 把这种风格称为“使用下划线分隔的小写单词”，建议用于命名函数、方法、参数和 变量。 PEP-8 建议包名直接把各个单词拼接起来，不使用分隔符。 Python 标准库中有很多 使用蛇底式命名的标识符，不过也有单词之间没有分隔的标识符(例

如，getattr、classmethod、isinstance、str.endswith，等等)。参见驼峰式词

条。

深复制(deep copy)

复制对象时把对象的所有属性一起复制。请与浅复制相比较。

生成器( generator)

使用生成器函数或生成器表达式构建的迭代器，无需迭代集合就可能生成值。生成斐

波纳契数列的生成器是个典型示例，这是一种无穷数列，在集合中绝对放不下。这个术语

除了表示调用生成器函数得到的对象之外，有时还表示生成器函数。

生成器表达式( generator expression)

放在括号里的表达式，句法与列表推导一样，不过返回的不是列表，而是生成器。

生成器表达式可以理解为列表推导的惰性版本。参见惰性求值词条。

生成器函数(generator function)

定义体中有 yield 关键字的函数。调用生成器函数得到的是生成器。

实参( argume nt )

调用函数时传给函数的表达式。按照 Python 习惯的说法，实参和形参几乎等价。关 于二者的区别以及各自的用途，参见形参词条。

视图( view)

在 Python 3 中，视图是一种特殊的数据结构，由字典的 .keys()、.values() 和

.items() 方法返回，作用是在不重复数据的前提下，提供字典的键和值的动态视图。在

Python 2 中，那些方法返回的是列表。字典视图都是可迭代的对象，支持 in 运算符。此 外，如果视图引用的元素都是可散列的对象，那么视图还实现了 collections.abc.Set 接口。 .keys() 方法返回的视图都是这样；对 .items() 方法返回的视图来说，如果其中

的值都是可散列的对象，那么也是如此。

视为有害( considered harmful)

Edsger Dijkstra 写过一封题为“Go To Statement Considered Harmful”的信函，这为批评 计算机科学技术的文章提供了一种标题格式。维基百科中的“Considered harmful”一文

([http://en+wikipedia+org/wiki/Considered_harmfui](http://en.wikipedia.org/wiki/Considered_harmful))列出了很多这种文章，包括 Eric A. Meyer 写的“Considered Harmful Essays Considered Harmful” ([http://meyerweb+com/eric/comment/chech+html](http://meyerweb.com/eric/comment/chech.html)) 。

属性( attribute )

在 Python 中，方法和数据属性(即 Java 术语中的“字段”)都是属性。方法也是属 性，只不过恰好是可调用的对象(通常是函数，但也不一定)。

特殊方法( special method)

名称特殊的方法，首尾各有两条下划线，例如 __getitem__。 Python 中的特殊方法 几乎都在Python语言参考手册中的“3. Data model” 一章

([https://docs+python+org/3/reference/datamodel+html ](https://docs.python.org/3/reference/datamodel.html))做了说明，不过在特定上下文中使用 的个别特殊方法在文档的其他部分里说明。例如，映射的 __missing__ 方法在 Python 标 准库文档的“4.10. Mapping Types”一节

([https://docs+python+org/3/library/stdtypes+html#mapping-types-dict](https://docs.python.org/3/library/stdtypes.html%23mapping-types-dict))提至lj。

统一访问原贝( uniform access principle)

Eiffel 语言之父 Bertrand Meyer 写道： “不管服务是由存储还是计算实现的，一个模块 提供的所有服务都应该通过统一的方式使用。 ”在 Python 中，可以使用特性和描述符实现 统一访问原贝。由于没有 new 运算符，函数调用和对象实例化看起来相似，这也体现了

这一原贝：调用方无需知道被调用的对象是类、函数，还是其他可调用的对象。

托管类( managed class)

使用描述符对象管理类中某个属性的类。参见描述符词条。

托管实例 ( managed instance)

托管类的实例。参见托管属性和描述符词条。

托管属性( managed attribute )

由描述符对象管理的公开属性。虽然托管属性在托管类中定义，但是作用相当于实 例属性(即各个实例通常有各自的值，存储在储存属性中) 。参见描述符词条。

驼峰式( CamelCase)

标识符的一种命名约定，单词的首字母大写，然后连接起来(例如 Connection RefusedError)。 PEP-8 建议类名使用驼峰式，但是 Python 标准库没有遵守这个建议。 参见蛇底式词条。

文档字符串( docstring)

documentation string 的简称。如果模块、类或函数的第一个语句是字符串字面量，那

个字符串会当作所在对象的文档字符串，解释器把那个字符串存储在对象的 __doc__ 属

性中。另见 doctest 词条。

瑕疵( wart)

指Python语言的不足。Andrew Kuchling发表过一篇著名的文章-“Python warts”，

仁慈的独裁者承认，他在设计 Python 3 的过程中受此文影响，决定不向后兼容，否贝无法 修正大多数缺陷。 Kuchling 提至的多数问题在 Python 3 中修正了。

像文件的对象(file-like object)

官方文档使用的一个非正式称呼，指代实现了文件协议的对象，有 read、 write 和 close 等方法。常见的变体有：逐行读写，包含编码字符串的纯文本文件；作为保存在内 存中的纯文本文件的 StringIO 实例；包含未编码的字节的二进制文件。最后一种可能有 缓冲，也可能没有缓冲。从 Python 2+6 起，这些标准文件类型的抽象基类在 io 模块里。

像字节的对象(bytes-like object)

泛指字节序列。最常见的像字节的类型有bytes、bytearray和memoryview;不

过，支持低层 CPython 缓冲协议的对象，如果元素是单个字节，那么也属于此类。

协程( coroutine)

用于并发编程的生成器，从调度程序，或者通过 coro.send(value) 方法从事件循 环中接收值。这个术语可以表示通过调用生成器函数获得的生成器函数或生成器对象。参 见生成器词条。

形参( parameter)

声明函数时指定的零个或多个“形式参数”，这些是未绑定的局部变量。调用函数时，

传入的实参(“实际参数”)会绑定给这些变量。在本书中，我尽量使用实参指代传给函

数的实际参数，使用形参指代声明函数时使用的形式参数。然而，并不一定会始终这样 做，因为 Python 文档和 API 经常混用形参和实参。参见实参词条。

虚拟子类(virtual subclass)

不继承自超类，而是使用 TheSuperClass.register(TheSubClass) 注册的类。参 见 abc.ABCMeta.register 方法的文档

([https://docs+python+org/3/library/abc+html#abc+ABCMeta+register](https://docs.python.org/3/library/abc.html%23abc.ABCMeta.register)) 。

序列( sequence)

泛指长度(例如，len(s))固定，可以使用从零开始的整数索引(例如s[0])获取 元素的数据结构。 Python 出现伊始，序列这个词就存在了，不过直到 Python 2+6 才由

collections.abc.Sequence 确定为一个抽象类。

序列化(serialization)

把对象在内存中的结构转换成便于存储或传输的二进制或文本格式，而且以后可以在 同一个系统或不同的系统中重建对象的副本。 pickle 模块能把任何 Python 对象序列化成 二进制格式。

鸭子类型(duck typing)

多态的一种形式，在这种形式中，不管对象属于哪个类，也不管声明的具体接口是什

么，只要对象实现了相应的方法，函数就可以在对象上执行操作。

一等函数( first-class function)

在语言中属于一等对象的函数(即能在运行时创建，赋值给变量，当作参数传入，以

及作为另一个函数的返回值)。 Python 中的函数都是一等函数。

引用计数( refcount)

CPython 内部对各个对象的引用计数，用于确定垃圾回收程序何时销毁对象。

用户定义的( user-defined)

在 Python 文档中，用户这个词几乎都是指我和你，即使用 Python 语言的程序员。用 户与实现 Python 解释器的开发者是相对的。因此， “用户定义的类”表示使用 Python 编写 的类，而不是使用 C 语言编写的内置类，如 str。

预激(prime，动词)

在协程上调用next(coro)，让协程向前运行到第一个yield表达式，准备好从后续 的 coro.send(value) 调用中接收值。

元编程( metaprogramming )

编写的程序使用程序的运行时信息改变程序的行为。例如， ORM 可能会内省模型类 的声明，确定如何验证数据库记录里的字段，以及如何把数据库类型转换成 Python 类 型。

元类( metaclass)

实例为类的类。默认情况下， Python 中的类是 type 类的实例；例如， type(int) 得 到的结果是 type 类，因此 type 是元类。用户可以通过扩展 type 类定义元类。

元组拆包( tuple unpacking)

把可迭代对象中的元素赋值给多个变量(例如， first, second, third == my_list)。 Python 高手通常使用这个术语，不过也有人使用可迭代对象的拆包。

真值( truthy)

只要 bool(x) 返回 True， x 就是真值。需要布尔值时， Python 会隐式使用 bool 计 算对象，例如控制 if 和 while 循环的表达式。与此相对的是假值。

指示对象( referent)

引用的目标对象。谈及弱引用时最常使用这个术语。

装饰器( decorator)

一个可调用的对象A，返回另一个可调用的对象B，在可调用的对象C的定义体之前 使用句法@A调用。Python解释器读取这样的代码时，会调用A(C)，把返回的B绑定给之 前赋予C的变量，也就是把C的定义体换成B。如果目标可调用对象C是函数，那么A是 函数装饰器；如果 C 是类，那么 A 是类装饰器。

字节字符串( byte string)

可惜，在Python 3中仍然使用这个名称指代bytes或bytearray。在Python 2

中， str 类型其实是字节字符串，为了把 str 和 unicode 字符串区分开，才用了这个名 称。在 Python 3 中没理由继续使用这个术语了，泛指字节序列时，我都尽量使用字节序

列(byte sequence)这个术语。



## 作者简介

Luciano Ramalho 在 1995 年 Netscape 首次公开募股以前就是一名 Web 开发者了，他先后

用过Perl和Java， 1998年开始使用Pyhon。自那以后，他在巴西的几个新闻门户网站工 作，使用 Python 做开发，还为巴西的媒体、银行和政府部门做 Python Web 开发培训。他 经常在开发者大会上演讲，比如 PyCon US（2013）、 OSCON（2002、 2013 和 2014）， 还有多年在PythonBrasil （在巴西举办的PyCon）以及FISL （南半球最大的FLOSS大会） 上做过的 15 次演讲。 Ramalho 是 Python 软件基金会的成员，还是巴西第一个众创空间 Garoa Hacker Clube 的联合创始人。他也是培训公司 Python.pro.br 的共同所有人。

## 关于封面

本书封面的动物是纳马沙蜥（学名：Pedioplanis namaquensis），身体细长，有一条呈红棕

色的长尾巴。这种沙蜥身体为黑色，有四条白纹；四肢呈棕色，带白点；腹部为白色。

纳马沙蜥白天活动，是速度最快的蜥蜴之一。它们栖息在草木稀疏的沙砾平地，冬季在灌 木丛边挖的洞穴里休眠。纳马沙蜥分布于纳米比亚全境的干旱稀树草原和半荒漠地区，以 小昆虫为食。在 11 月，雌性会产下 3~5 枚蛋。

O'Reilly 出版的图书，封面上很多动物都濒临灭绝。这些动物都是地球的至宝。如果你想

知道如何保护这些动物，请访问[ ](http://animals.oreilly.com)[animals+oreilly+com](http://animals.oreilly.com)。

封面图片出自 Wood 的 Natural History, Vol 3。

## 看完了

如果您对本书内容有疑问，可发邮件至contact@turingbook.com，会有编辑或作译者协助答 疑。也可访问图灵社区，参与本书讨论。

如果是有关电子书的建议或问题，请联系专用客服邮箱：ebook@turingbook.com。

在这里可以找到我们：

•微博@图灵教育：好书、活动每日播报 •微博@图灵社区：电子书和好文章的消息 •微博@图灵新知：图灵教育的科普小组 •微信图灵访谈：ituring_interview，讲述码农精彩人生 •微信图灵教育：turingbooks

图灵社区会员 boat([727442652@qq.com](mailto:727442652@qq.com)) 专享 尊重版权
