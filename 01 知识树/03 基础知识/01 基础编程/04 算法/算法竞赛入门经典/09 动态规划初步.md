 动态规划初步

学习目标

□理解状态和状态转移方程 □理解最优子结构和重叠子问题 □熟练运用递推法和记忆化搜索求解数字三角形问题 □熟悉DAG上动态规划的常见思路、两种状态定义方法和刷表法 □掌握记忆化搜索在实现方面的注意事项 □掌握记忆化搜索和递推中输出方案的方法 □掌握递推中滚动数组的使用方法 □熟练解决经典动态规划问题

动态规划的理论性和实践性都比较强，一方面需要理解“状态”、 “状态转移”、 “最优子 结构”、 “重叠子问题”等概念，另一方面又需要根据题目的条件灵活设计算法。可以这样 说，对动态规划的掌握情况在很大程度上能直接影响一个选手的分析和建模能力。

###### 9.1 数字三角形

动态规划是一种用途很广的问题求解方法，它本身并不是一个特定的算法，而是一种思

想，一种手段。下面通过一个题目阐述动态规划的基本思路和特点。

9.1.1 问题描述与状态定义

数字三角形问题。有一个由非负整数组成的三角形，第一行只有一个数，除了最下行

之外每个数的左下方和右下方各有一个数，如图9-1所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-160.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-161.jpg)



图 9-1 数字三角形问题

从第一行的数开始，每次可以往左下或右下走一格，直到走到最下行，把沿途经过的数

全部加起来。如何走才能使得这个和尽量大？

【分析】

如果熟悉回溯法，可能会立刻发现这是一个动态的决策问题：每次有两种选择——左下

或右下。如果用回溯法求出所有可能的路线，就可以从中选出最优路线。但和往常一样，回

溯法的效率太低：一个《层数字三角形的完整路线有2"-1条，当《很大时回溯法的速度将让人

无法忍受。

为了得到高效的算法，需要用抽象的方法思考问题：把当前的位置（i，力看成一个状态 （还记得吗？），然后定义状态（i，力的指标函数d（i，力为从格子（i，力出发时能得到的最大和 （包括格子（i，J）本身的值）。在这个状态定义下，原问题的解是硪1, 1）。

下面看看不同状态之间是如何转移的。从格子（i，力出发有两种决策。如果往左走，则走 到（i + 1,力后需要求“从（i + 1,力出发后能得到的最大和”这一问题,即成i+ 1,j）。类似地，往

右走之后需要求解硪/+ 1，J+1)。由于可以在这两个决策中自由选择，所以应选择成/+1力 和成1 + 1，/+ 1)中较大的一个。换句话说，得到了所谓的状态转移方程：

\+    1，;),卯 +    +

如果往左走，那么最好情况等于(/，/)格子里的值咖/)与“从(/ +1,/)出发的最大总和”之 和，此时需注意这里的“最大”二字。如果连“从(/ + 1，/)出发走到底部”这部分的和都不是最大 的，加上^(/，/)之后肯定也不是最大的。这个性质称为最优子结构(optimal substructure ), 也可以描述成“全局最优解包含局部最优解”。不管怎样，状态和状态转移方程一起完整地描 述了具体的算法。

提示9-1 ：动态规划的核心是状态和状态转移方程。

9.1.2 记忆化搜索与递推

有了状态转移方程之后，应怎样计算呢？

方法1：递归计算。程序如下(需注意边界处理)：

int solve(int i, int j){

return a[i][j] + (i == n ? 0 : max(solve(i+1,j),solve(i+1,j+1)));

这样做是正确的，但时间效率太低，其原因在于重复计算。

如图9-2所示为函数仍加(1，1)对应的调用关 系树。看到了吗？ solve(3，    2)被计算了两次(一

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-162.jpg)



次是solve(2,    1)需要的，—次是solve(2, 2)需要

的)。也许读者会认为重复算一两个数没有太大 影响，但事实是：这样的重复不是单个结点，而 是一棵子树。如果原来的三角形有n层，则调用 关系树也会有n层，一共有2n - 1个结点。

提示9-2：用直接递归的方法计算状态转移

方程，效率往往十分低下。其原因是相同的子问题被重复计算了多次。

方法2：递推计算。程序如下(需再次注意边界处理)：

int i, j;

for (j = 1; j < = n; j + +) d[n][j] = a[n][j];

for(i = n - 1; i > = 1; i——) for(j = 1; j <= i; j＋＋)

d[i][j]    = a[i][j] ＋ max(d[i＋1][j],d[i＋1][j＋1]);

程序的时间复杂度显然是O(n2),但为什么可以这样计算呢？原因在于：i是逆序枚举 的，因此在计算d[i]|j]前，它所需要的d[i + 1]|j]和d[i + 1]|j + 1]—定已经计算出来了。

提示9-3 ：可以用递推法计算状态转移方程。递推的关键是边界和计算顺序。在多数情 况下，递推法的时间复杂度是：状态总数x每个状态的决策个数x决策时间。如果不同状态 的决策个数不同，需具体问题具体分析。

方法3 :记忆化搜索。程序分成两部分。首先用“memset(d, - 1，slzeof(d));”把d全部初始化 为-1 ,然后编写递归函数[^](#bookmark7) :

int solve(int i, int j){

if(d[i][j] >= 0) return d[i][j];

return d[i][j] = a[i][j] + (i == n ? 0 : max(solve(i+1,j),solve(i+1,j+1)))

上述程序依然是递归的，但同时也把计算结果保存在数组d中。题目中说各个数都是非 负的，因此如果已经计算过某个d[i][j],则它应是非负的。这样，只需把所有d初始化为-1 ,即可通过判断是否d[i][j仨0得知它是否已经被计算过。

最后，千万不要忘记在计算之后把它保存在d[i][j]中。根据C语言“赋值语句本身有返回 值”的规定，可以把保存d[i][j]的工作合并到函数的返回语句中。

上述程序的方法称为记忆化( memoization) ，它虽然不像递推法那样显式地指明了计算 顺序，但仍然可以保证每个结点只访问一次，如图9-3所示。

由于i和j都在1〜n之间，所有不相同的结点一共只有0(n2)个。无论以怎样的顺序访问，

时间复杂度均为0(n2)。从2n~n2是一个巨大的优化，这正是利用了数字三角形具有大量重叠 子问题的特点。

提示9-4：可以用记忆化搜索的方法计算状

态转移方程。当采用记忆化搜索时，不必事先确

定各状态的计算顺序，但需要记录每个状态“是

否已经计算过”。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-163.jpg)



###### 9.2 DAG上的动态规划

有向无环图上的动态规划是学习动态规划的基础。很多问题都可以转化为DAG上的最长 路、最短路或路径计数问题。

9.2.1 DAG 模型

嵌套矩形问题。有《个矩形，每个矩形可以用两个整数仏描述，表示它的长和宽。矩 开奴（以）可以嵌套在矩形y（c，    4中，当且仅当，b<d，或者b<c，a < d （相当于把矩

形A旋转90° ）。例如，（1, 5）可以嵌套在（6, 2）内，但不能嵌套在（3, 4）内。你的任务是选出尽 量多的矩形排成一行，使得除了最后一个之外，每一个矩形都可以嵌套在下一个矩形内。如 果有多解，矩形编号的字典序应尽量小。

【分析】

矩形之间的“可嵌套”关系是一个典型的二元关系，二元关系可以用图来建模。如果矩 形A可以嵌套在矩形!里，就从到F连一条有向边。这个有向图是无环的，因为一个矩形无 法直接或间接地嵌套在自己内部。换句话说，它是一个DAG。这样，所要求的便是DAG上 的最长路径。

硬币问题。有《种硬币，面值分别为F2,…，匕，每种都有无限多。给定非负整数S，

可以选用多少个硬币，使得面值之和恰好为S?输出硬币数目的最小值和最大值。

1<«<100，0<5<10000，1深SS。

【分析】

此问题尽管看上去和嵌套矩形问题很不一样，但本题的本质也是DAG上的路径问题。将 每种面值看作一个点，表示“还需要凑足的面值”，则初始状态为^，目标状态为0。若当前在 状态i，每使用一个硬币j，状态便转移到i - Pj。

这个模型和上一题类似，但也有一些明显的不同之处：上题并没有确定路径的起点和终 点（可以把任意矩形放在第一个和最后一个），而本题的起点必须为^，终点必须为0 ;点固 定之后“最短路”才是有意义的。在上题中，最短序列显然是空（如果不允许空，就是单个矩 形，不管怎样都是平凡的），而本题的最短路却不容易确定。

9.2.2 最长路及其字典序

首先思考“嵌套矩形”。如何求DAG中不固定起点的最长路径呢？仿照数字三角形的做 法，设硪i)表示从结点i出发的最长路长度，应该如何写状态转移方程呢？第一步只能走到它 的相邻点，因此：

###### d{i) = max {d{j) +11 (/； j) e E}

其中，冗为边集。最终答案是所有硪i)中的最大值。根据前面的介绍，可以尝试按照递推 或记忆化搜索的方式计算上式。不管怎样，都需要先把图建立出来，假设用邻接矩阵保存在 矩阵6中(在编写主程序之前需测试和调试程序，以确保建图过程正确无误)。接下来编写 记忆化搜索程序(调用前需初始化d数组的所有值为0 ):

int dp(int i) { int& ans = d[i]; if(ans > 0) return ans; ans = 1;

for(int j = 1; j <= n; j++)

if(G[i][j]) ans = max(ans, dp(j) +1);

return ans;

这里用到了一个技巧：为表项d[i]声明一个引用ans。这样，任何对ans的读写实际上都是 在对d[i]进行。当d[i]换成d[i]Lj][kninm][n]这样很长的名字时，该技巧的优势就会很明显。

提示9-5：在记忆化搜索中，可以为正在处理的表项声明一个引用，简化对它的读写操

作。

原题还有一个要求：如果有多个最优解，矩形编号的字典序应最小。还记得第6章中的 例题“理想路径”吗？方法与其类似。将所有值计算出来以后，选择最大d[i]所对应的i。如 果有多个i ,则选择最小的i ,这样才能保证字典序最小。接下来可以选择硪0 =成/)+1且 (ij)⑶的任何一个j。为了让方案的字典序最小，应选择其中最小的j。程序如下[②](#bookmark16)：

void print_ans(int i) {2 printf("％d ", i);

print_ans(j);

break;

}

}

提示9-6：根据各个状态的指标值可以依次确定各个最优决策，从而构造出完整方案。

由于决策是依次确定的，所以很容易按照字典序打印出所有方案。

注意，当找到一个满足d[l]==d[j] + 1的结点/后就应立刻递归打印从/开始的路径，并在 递归返回后退出循环。如果要打印所有方案，只把break语句删除是不够的(想一想，为什 么)。正确的方法是记录路径上的所有点，在递归结束时才—次性输出整条路径。程序留给

读者编写。

有趣的是，如果把状态定义成“硪/)表示以结点/为终点的最长路径长度”，也能顺利求出 最优值，却难以打印出字典序最小的方案。想—想，为什么？你能总结出—些规律吗？

9.2.3 固定终点的最长路和最短路

接下来考虑“硬币问题”。最长路和最短路的求法是类似的，下面只考虑最长路。由于终 点固定，咏的确切含义变为“从结点/出发到结点0的最长路径长度”。下面是求最长路的代

码：

int dp(int S) { int& ans = d[S]; if(ans >= 0) return ans; ans = 0;

for(int i = 1; i <= n; i++) if(S >= V[i]) ans = max(ans, dp(S-V[i])+1); return ans;

注意到区别了吗？由于在本题中，路径长度是可以为0的(本身可以是0 ),所以不能 再用表0表示“这个值还没有算过”。相应地，初始化时也不能再把全设为0 ,而要设置为一 个负值——在正常情况下是取不到的。常见的方法是用- 1来表示“没有算过”，则初始化时 只需用memset(d, - 1, slzeof(d))即可。至此，已完整解释了上面的代码为什么把1f(ans > 0)改成

了 if(ans > =0)。

提示9-7：当程序中需要用到特殊值时，应确保该值在正常情况下不会被取到。这不仅

意味着特殊值不能有“正常的理解方式”，而且也不能在正常运算中“意外得到”。

不知读者有没有看出，上述代码有一个致命的错误，即由于结点不一定真的能到达结 点0，所以需要用特殊的d[S]值表示“无法到达”，但在上述代码中，如果根本无法继续往前 走，返回值是0，将被误以为是“不用走，已经到达终点”的意思。如果把ans初始化为-1 呢？别忘了- 1代表“还没算过”，所以返回-1相当于放弃了自己的劳动成果。如果把ans初 始化为一个很大的整数，例如230呢？如果一开始就这么大，ans = max(ans, dp(i)+1)还能把

ans变回“正常值”吗？如果改成很小的整数，例如-230呢？从目前来看，它也会被认为是“还

没算过”，但至少可以和所有d的初值分开-只需把代码中if(ans > =0)改为if(ans!= - 1)即

可，如下所示：

int dp(int S){ int& ans = d[S]; if(ans != -1) return ans; ans = -(1<<30);

for(int i = 1; i <= n; i++) if(S >= V[i]) ans = max(ans, dp(S-V[i])+1); return ans;

提示9-8：在记忆化搜索中，如果用特殊值表示“还没算过” ，则必须将其和其他特殊值 (如无解)区分开。

上述错误都是很常见的，甚至“顶尖高手”有时也会一时糊涂，掉入陷阱。意识到这些问

题，寻求解决方案是不难的，但就怕调试很久以后仍然没有发现是哪里出了问题。另一个解 决方法是不用特殊值表示“还没算过”，而用另外一个数组vis[i]表示状态i是否被访问过，如 下所示：

int dp(int S){

if(vis[S]) return d[S]; vis[S] = 1;

int& ans = d[S];

for(int i = 1; i <= n; i++) if(S >= V[i]) ans = max(ans, dp(S-V[i])+1); return ans;

}

尽管多了—个数组，但可读性增强了许多：再也不用担心特殊值之间的冲突了，在任何

情况下，记忆化搜索的初始化都可以用memset（vis，0，slzeof^vls）[）^](#bookmark20)实现。

提示9-9 :在记忆化搜索中，可以用vis数组记录每个状态是否计算过，以占用一些内存 为代价增强程序的可读性，同时减少出错的可能。

本题要求最小、最大两个值，记忆化搜索就必须写两个。在这种情况下，用递推更加方

便（此时需注意递推的顺序）：

| minv[0]        | =      | maxv[0] | =    | 0;   |      |         |
| -------------- | ------ | ------- | ---- | ---- | ---- | ------- |
| for(int        | i      | = 1; i  | <=   | S;   | i    | ++){    |
| minv[i}for(int | ]      | = INF;  | ma   | xv[  | i]   | = -INF; |
| i              | = 1; i | <=      | S;   | i    | ++)  |         |
| for(in         | t      | j = 1;  | j    | <=   | n;   | j ++)   |

if(i >= V[j]){

minv[i] = min(minv[i], minv[i-V[j]] + 1); maxv[i] = max(maxv[i], maxv[i-V[j]] + 1);

}

printf("%d %d\n", minv[S], maxv[S]);

如何输出字典序最小的方案呢？刚刚介绍的方法仍然适用，如下所示：

void print_ans(int* d, int S){ for(int i = 1; i <= n; i++)

if(S>=V[i] && d[S]==d[S-V[i]]+1){ printf("%d ", i); print_ans(d, S -V[i]);

break;

然后分别调用print_ans(min, S)(注意在后面要加一个回车符)和print_ans(max, S)即可。 输出路径部分和上题的区别是，上题打印的是路径上的点，而这里打印的是路径上的边。还 记得数组可以作为指针传递吗？这里需要强调的一点是：数组作为指针传递时，不会复制数 组中的数据，因此不必担心这样会带来不必要的时间开销。

提示9-10：当用递推法计算出各个状态的指标之后，可以用与记忆化搜索完全相同的

方式打印方案。

很多用户喜欢另外一种打印路径的方法：递推时直接用min_coin[S]记录满足min[S] ==>min[S - V[i]] + 1的最小的i ,则打印路径时可以省去print_ans函数中的循环，并可以方便 地把递归改成迭代(原来的也可以改成迭代，但不那么自然)。具体来说，需要把递推过程 改成以下形式：

for(int i = 1; i <= S; i++) for(int j = 1; j <= n; j++)

if(i >= V[j]){

if(min[i] > min[i - V[j]] + 1){ min[i] = min[i- V[j]] + 1; min_coin[i] = j;

}

if(max[i] < max[i - V[j]] + 1){ max[i] = max[i - V[j]] + 1; max_coin[i] = j;

}

}

注意，判断中用的是“>”和“<”，而不是“>=”和“<=”，原因在于“字典序最小解”要求 当min/max值相同时取最小的i值。反过来，如果/是从大到小枚举的，就需要把“ > ”和“ < ”改 成“>=”和“<=”才能求出字典序最小解。

在求出min_coin和max_coin之后，只需调用print_ans(min_coin, S)和print_ans(max_coin, S) 即可。

void print_ans(int* d, int S){ while(S){

printf("%d ", d[S]);

S -= V[d[S]];

}

}

该方法是一个“用空间换时间”的经典例子-用min_coin和max_coin数组消除了原来

print_ans中的循环。

提示9-11：无论是用记忆化搜索还是递推，如果在计算最优值的同时“顺便”算出各个

状态下的第一次最优决策，则往往能让打印方案的过程更加简单、高效。这是一个典型

的“用空间换时间”的例子。

9.2.4 小结与应用举例

本节介绍了动态规划的经典应用：DAG中的最长路和最短路。和9.1节中的数字三角形 问题一样，DAG的最长路和最短路都可以用记忆化搜索和递推两种实现方式。打印解时既可 以根据d值重新计算出每一步的最优决策，也可以在动态规划时“顺便”记录下每步的最优决 策。

由于DAG最长（短）路的特殊性，有两种“对称”的状态定义方式。

状态I :设（/（/＞为从/出发的最长路，则，「1=

状态2 :设为以^吉束的最长路，则。

如果使用状态2， “硬币问题”就变得和“嵌套矩形问题”几乎一样了（唯一的区别是： “嵌 套矩形问题”还需要取所有d（i）的最大值）！ 9.2.3节中有意介绍了比较麻烦的状态1，主要是 为了展示一些常见技巧和陷阱，实际比赛中不推荐使用。

使用状态2时，有时还会遇到一个问题：状态转移方程可能不好计算，因为在很多时 候，可以方便地枚举从某个结点i出发的所有边（ij），却不方便“反着”枚举（j，i）。特别是在有 些题目中，这些边具有明显的实际背景，对应的过程不可逆。

这时需要用“刷表法”。什么是“刷表法”呢？传统的递推法可以表示成“对于每个状态i，

计算/(/)”，或者称为“填表法”。这需要对于每个状态/,找到A/)依赖的所有状态，在某些情 况下并不方便。另一种方法是“对于每个状态/,更新/O')所影响到的状态”，或者称为“刷表 法”。对应到DAG最长路的问题中，就相当于按照拓扑序枚举'，对于每个'，枚举边(/力，然 后更新</] = max(dj], d[/] + 1)。注意，一般不把这个式子叫做“状态转移方程”，因为它不是 一个可以直接计算dj]的方程，而只是一个更新公式。

提示9-12 :传统的递推法可以表示成“对于每个状态i ,计算f⑴〃，或者称为“填表法〃。 这需要对于每个状态i ,找到f⑴依赖的所有状态，在某些时候并不方便。另一种方法是“对于 每个状态i ,更新f⑴所影响到的状态〃，或者称为“刷表法〃，有时比填表法方便。但需要注意 的是，只有当每个状态所依赖的状态对它的影响相互独立时才能用刷表法。

例题9-1    城市里的间谍( A Spy in the Metro, ACM/ICPC World Finals 2003,

UVa1025 )

某城市的地铁是线性的，有《 ( 2<«<50 )个车站，从左到右编号为1〜n。有M1辆列车从 第1站开始往右开，还有M2辆列车从第n站开始往左开。在时刻0 , Mario从第1站出发，目的 是在时刻丁( 0<r<200 )会见车站n的一个间谍。在车站等车时容易被抓，所以她决定尽量躲 在开动的火车上，让在车站等待的总时间尽量短。列车靠站停车时间忽略不计，且Mario身 手敏捷，即使两辆方向不同的列车在同一时间靠站，Mario也能完成换乘。

first station    second station    N**1 station

输入第1行为n ,第2行为r ,第3行有n - 1个整数t2,…，tn -1 ( 1<tz<70 ),其中t'表示地

铁从车站'到/+ 1的行驶时间(两个方向一样)。第4行为M1 ( 1<^1<50),即从第1站出发 向右开的列车数目。第5行包含M1个整数dh d2，…，dM1 ( 0<dz<250 , di<dz+ 1 ),即各列车的

出发时间。第6、7行描述从第n站出发向左开的列车，格式同第4、5行。输出仅包含一行， 即最少等待时间。无解输出impossible。

【分析】

时间是单向流逝的，是一个天然的“序”。影响到决策的只有当前时间和所处的车站，所

以可以用硪ij)表示时刻i,你在车站j (编号为1〜《),最少还需要等待多长时间。边界条件 是d(T,n)=0 ,其他d(T,i) ( i不等于n )为正无穷。有如下3种决策。

决策1：等1分钟。

决策2：搭乘往右开的车(如果有)。

决策3：搭乘往左开的车(如果有)。

主过程的代码如下：

for(int i = 1; i <= n-1; i++) dp[T][i] = INF;

dp[T][n] = 0;

for(int i = T- 1; i >= 0; i——) for(int j = 1; j >= n; j++) {

dp[i][j] = dp[i+1][j] + 1; //等待一个单位

if(j < n && has_train[i][j][0] && i+t[j] < = T)

dp[i][j] = min(dp[i][j], dp[i+t[j]][j+1]); //右 if(j > 1 && has_train[i][j][1] && i+t[j- 1] < = T)

dp[i][j] = min(dp[i][j], dp[i+t[j - 1]][j- 1]); // 左

}

//输出

cout << "Case Number " << ++kase << ": ";

if(dp[0][1] >= INF) cout << "impossible\n";

else cout << dp[0][1] << "\n";

上面的代码中有一个has_train数组，其中has_train[t][i][0]表示时刻Z ,在车站i是否有往右 开的火车，has_tram[t][i][1]类似，不过记录的是往左开的火车。这个数组不难在输入时计算 处理，细节留给读者思考。

状态有O(nT)个，每个状态最多只有3个决策，因此总时间复杂度为O(nT)。

例题9-2 巴比伦塔(The Tower of Babylon, UVa 437 )

有打(n<30)种立方体，每种都有无穷多个。要求选一些立方体摞成一根尽量高的柱子 (可以自行选择哪一条边作为高)，使得每个立方体的底面长宽分别严格小于它下方立方体

的底面长宽。

【分析】

在任何时候，只有顶面的尺寸会影响到后续决策，因此可以用二元组(W)来表示“顶面

尺寸为这个状态。因为每次增加一个立方体以后顶面的长和宽都会严格减小，所以这 个图是DAG，可以套用前面学过的DAG最长路算法。

这个算法没问题，不过落实到程序上时会遇到一个问题：不能直接用d(^幻表示状态 值，因为和可能会很大。怎么办呢？可以用(idx，幻这个二元组来“间接”表达这个状态，其 中idx为顶面立方体的序号，&是高的序号(假设输入时把每个立方体的3个维度从小到大排 序，编号为0〜2 )。例如，若立方体3的大小为：^*c (其中必衫c )，则状态(3,1)就是指这个

立方体在顶面，且高是b (因此顶面大小为)。因为idx是0〜n - 1的整数，k是0〜2的整 数，所以可以很方便地用二维数组来存取。状态总数是O(n)的，每个状态的决策有0(n)个， 时间复杂度为0(n2)。

例题9-3 旅行(Tour, ACM/ICPC SEERC 2005, UVa1347 )

给定平面上n ( n<1000 )个点的坐标(按照递增的顺序给出。各点坐标不同，且均为 正整数)，你的任务是设计一条路线，从最左边的点出发，走到最右边的点后再返回，要求 除了最左点和最右点之外每个点恰好经过一次，且路径总长度最短。两点间的长度为它们的

欧几里德距离，如图9-4所示。

(a)



(b)



图9-4 旅行路线示意图

分析】

“从左到右再回来”不太方便思考，可以改成：两个人同时从最左点出发，沿着两条不同

的路径走，最后都走到最右点，且除了起点和终点外其余每个点恰好被一个人经过。这样，

就可以用d(ij)表示第一个人走到i,第二个人走到j,还需要走多长的距离。

状态如何转移呢？仔细思考后会发现：好像很难保证两个人不会走到相同的点。例如，

计算状态d(ij)时，能不能让i走到i + 1呢？不知道，因为从状态里看不出来i + 1有没有被/走

过。换句话说，状态定义得不好，导致转移困难。

下面修改一下：d(ij)表示1〜max(ij)全部走过，且两个人的当前位置分别是i和j ,还需 要走多长的距离。不难发现d(ij)=d(/，i),因此从现在开始规定在状态中？＞人这样，不管是 哪个人，下一步只能走到i+ 1, i + 2,...这些点。可是，如果走到i + 2 ,情况变成了“1〜i和i + 2 ,但是i+ 1没走过”，无法表示成状态！怎么办？禁止这样的决策！也就是说，只允许其中 —个人走到i + 1 ,而不能走到i + 2, i + 3,…。换句话说，状态d(i，j)只能转移到d(i + 1j)和d(i + 1,i)[凶](#bookmark26)。

可是这样做产生了一个问题：上述“霸道”的规定是否可能导致漏解呢？不会。因为如果 第一个人直接走到了i + 2 ,那么它再也无法走到i+1了，只能靠第二个人走到i+1。既然如 此，现在就让第二个人走到i + 1 ,并不会丢失解。

边界是d(n - 1j)=dist(n - 1,n) + dist(j,n),其中dist(a»表示点和办之间的距离。因为根据 定义，所有点都走过了，两个人只需直接走到终点。所求结果是dist(1,2) + d(2,1),因为第一 步一定是某个人走到了第二个点，根据定义，这就是d(2,1)。

状态总数有0(n2)个，每个状态的决策只有两个，因此总时间复杂度为0(n2)。



###### 9.3多阶段决策问题

还记得“多阶段决策问题”吗？在回溯法中曾提到过该问题。简单地说，每做一次决策就

可以得到解的一部分，当所有决策做完之后，完整的解就“浮出水面”了。在回溯法中，每次

决策对应于给一个结点产生新的子树，而解的生成过程对应一棵解答树，结点的层数就

是“下一个待填充位置”cur。

9.3.1多段图的最短路

多段图是一种特殊的DAG ,其结点可以划分成若干个阶段，每个阶段只由上一个阶段所

决定。下面举一个例子：

例题 9-4 单向 TSP ( Unidirectional TSP, UVa 116 )

给一个rn行《列(m<10 , «<100 )的整数矩阵，从第一列任何一个位置出发每次往右、右

上或右下走一格，最终到达最后一列。要求经过的整数之和最小。整个矩阵是环形的，即第

一行的上一行是最后一行，最后一行的下一行是第一行。输出路径上每列的行号。多解时输

出字典序最小的。图9-5中是两个矩阵和对应的最优路线(唯一的区别是最后一行)。

| A    | 4    | 1    | 2    | 8    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| G    | \    | 8    | 2    | 7    | 4    |
| 5    | 9    |      | S    | 9    | 5    |
| 8    | 4    | 1    |      | A    | 6    |
| 3    | 7    | 2    | 3    | 6    | V    |



| A    | 4    | /    | 2    | 8    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 6    | y    | a    | 2    | 7    | 4    |
| 5    | 9    | 3    | 9    | 9    | 5    |
| 8    | 4    | i    | 3    | A    | 6    |
| 3    | 7    | 2    | /    | 2    | V    |



图9-5矩阵对应的最优路线

分析】

在这个题目中，每一列就是一个阶段，每个阶段都有3种决策：直行、右上和右下。

提示9-13：多阶段决策的最优化问题往往可以用动态规划解决，其中，状态及其转移

类似于回溯法中的解答树。解答树中的“层数〃，也就是递归函数中的“当前填充位置〃cur，描 述的是即将完成的决策序号，在动态规划中被称为“阶段”。

有了前面的经验，不难设计出状态：设d(ij)为从格子(ij)出发到最后一列的最小开销。 但是本题不仅要输出解，还要求字典序最小，这就需要在计算d(ij)的同时记录“下一列的行 号’的最小值(当然是在满足最优性的前提下)，细节参见代码：

| int ans = | INF, first = 0; |       |         |         |
| --------- | --------------- | ----- | ------- | ------- |
| for(int j | = n-1; j >= 0;  | j——   | ) {     | //逆推  |
| for(int   | i = 0; i < m; i | ＋＋) | {       |         |
| if(j      | == n-1) d[i][j] | = a   | [i][j]; | // 边界 |
| else      | {               |       |         |         |
| int       | rows[3] = {i, i | -1,   | i ＋1}; |         |

| if(i ==              | 0) rows[1] = m-1;                 | //第0行”上面”是第m - 1行 |
| -------------------- | --------------------------------- | ------------------------ |
| if(i ==              | m-1) rows[2] = 0;                 | //第m - 1行”下面”是第0行 |
| sort(rows, rows＋3); | // 重新排序，以便找到字典序最小的 |                          |
| d[i][j]              | = INF;                            |                          |
| for(int              | k = 0; k < 3; k ＋＋              | ) {                      |
| int v                | = d[rows[k]][j＋1]                | ＋ a[i][j];              |

if(v < d[i][j]) { d[i][j] = v; next[i][j] = rows[k]; }

}

}

if(j == 0 && d[i][j] < ans) { ans = d[i][j]; first = i; }

}

}

printf(" ％d", first＋1);    //输出第1列

for(int i = next[first][0], j = 1; j < n; i = next[i][j], j＋＋) printf(" %d", i＋1);    //输出其他列

printf("\n%d\n", ans);

} return 0;

9.3.2 0-1背包问题

0-1背包问题是最广为人知的动态规划问题之一，拥有很多变形。尽管在理解之后并不

难写出程序，但初学者往往需要较多的时间才能掌握它。在介绍0-1背包问题之前，先来看

一个引例。

物品无限的背包问题。有n种物品，每种均有无穷多个。第i种物品的体积为。，重量 为％。选一些物品装到一个容量为C的背包中，使得背包内物品在总体积不超过C的前提下 重量尽量大。 1<n<100， 1<Vi <C<10000， 1<Wi<106。

【分析】

很眼熟是吗？没错，它很像9.2节中的硬币问题，只不过“面值之和恰好为5”改成了“体积 之和不超过C”，另外增加了一个新的属性——重量，相当于把原来的无权图改成了带权图 （weighted graph ）。这样，问题就变为了求以C为起点（终点任意）的、边权之和最大的路 径。

与前面相比，DAG从“无权”变成了“带权”，但这并没有带来任何困难，此时只需将某处 代码从“ + 1”变成“ + W[i]”即可。你能找到吗？

提示9-14 ：动态规划的适用性很广。不少可以用动态规划解决的题目，在条件稍微变 化后只需对状态转移方程做少量修改即可解决新问题。

0-1背包问题。有n种物品，每种只有一个。第i种物品的体积为^ ,重量为％。选一些 物品装到一个容量为C的背包，使得背包内物品在总体积不超过C的前提下重量尽量大。 1<n<100， 1<Vi<C<10000， 1<Wi<10 6。

【分析】

不知读者有没有发现，刚才的方法已经不适用了：只凭“剩余体积”这个状态，无法得知

每个物品是否已经用过。换句话说，原来的状态转移太乱了，任何时候都允许使用任何一种

物品，难以控制。为了消除这种混乱，需要让状态转移（也就是决策）有序化。

引入“阶段”之后，算法便不难设计了：用d（i，j）表示当前在第i层，背包剩余容量为j时接

下来的最大重量和，则i 、= n i 、+L ,    +(…边界是，〉"时‘

j)=0 , j<0时为负无穷(一般不会初始化这个边界，而是只当它F[/]时才计算第二项)。

说得更通俗一点，硪/，j)表示“把第/，/+ 1,/+ 2,…，«个物品装到容量为/的背包中的最大

总重量”。事实上，这个说法更加常用——“阶段”只是辅助思考的，在动态规划的状态描述 中最好避免“阶段”、 “层”这样的术语。很多教材和资料直接给出了这样的状态描述，而本书 中则是花费了大量的篇幅叙述为什么会想到要划分阶段以及和回溯法的内在联系——如果对 此理解不够深入，很容易出现“每次碰到新题自己都想不出来，但一看题解就懂”的尴尬情

况。

提示9-15：学习动态规划的题解，除了要理解状态表示及其转移方程外，最好思考一

下为什么会想到这样的状态表示。

和往常一样，在得到状态转移方程之后，还需思考如何编写程序。尽管在很多情况下，

记忆化搜索程序更直观、易懂，但在0-1背包问题中，递推法更加理想。为什么呢？因为当

有了“阶段”定义后，计算顺序变得非常明显。

提示9-16：在多阶段决策问题中，阶段定义了天然的计算顺序。

下面是代码，答案是 d[1][C] ：

for(int i = n; i >= 1; i——) for(int j = 0; j <= C; j++){

d[i][j] = (i==n ? 0 : d[i+1][j]);

if(j >= V[i]) d[i][j] max(d[i][j],d[i+1][j－V[i]]+W[i]);

}

前面说过，/必须逆序枚举，但j的循环次序是无关紧要的。

规划方向。聪明的读者也许看出来了，还有另外一种“对称”的状态定义：用/(/j)表 示“把前/个物品装到容量为j的背包中的最大总重量”，其状态转移方程也不难得出：

f(i，j、=    -\J-V[i]) + W[i]}

边界是类似的：/=0时为0 , j<0时为负无穷，最终答案为/>，C)。代码也是类似的：

for(int j = 0; j <= C; j++){ f[i][j] = (i==1 ? 0 : f[i- 1][j]); if(j >= V[i]) f[i][j] = max(f[i][j], f[i - 1][j - V[i]]+W[i]);

}

看上去这两种方式是完全对称的，但其实存在细微区别：新的状态定义/(i，j)允许边读入 边计算，而不必把和m存下来。

for(int i = 1; i <= n; i++){ scanf("%d%d", &V, &W); for(int j = 0; j <= C; j++){

f[i][j] = (i==1 ? 0 : f[i- 1][j]);

if(j >= V) f[i][j] = max(f[i][j],f[i - 1][j - V]+W);

}

}

滚动数组。更奇妙的是，还可以把数组 /变成一维的：

memset(f, 0, sizeof(f));

for(int i = 1; i <= n; i++){ scanf("%d%d", &V, &W); for(int j = C; j >= 0; j——) if(j >= V) f[j] = max(f[j], = f[j- V]+W);

}

为什么这样做是正确的呢？下面来看一下/（i，j）的计算过程，如图9-6所示。

/数组是从上到下、从右往左计算的。在计算/（i，j）之前，/j]里保存的就是/>- 1 ,j）的 值，而/j -叼里保存的是/> - 1    -的而不是/（i，j - W）——别忘了j是逆序枚举的，此时/>，

/ - W）还没有算出来。这样，/j] =（maxj] ,/[j -V] + W）实际上是把保存在/j]中，覆盖掉/j]原 来的/（i - 1,j）。

提示9-17：在递推法中，如果计算顺序很特殊，而且计算新状态所用到的原状态不

多，可以尝试用滚动数组减少内存开销。

滚动数组虽好，但也存在一些不尽如人意的 地方，例如，打印方案较困难。当动态规划结束 之后，只有最后一个阶段的状态值，而没有前面 的值。不过这也不能完全归咎于滚动数组，规划 方向也有一定责任——即使用二维数组，打印方 案也不是特别方便。事实上，对于“前i个物 品’这样的规划方向，只能用逆向的打印方案， 而且还不能保证它的字典序最小（字典序比较是 从前往后的）。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-167.jpg)



提示9-18：在使用滚动数组后，解的打印变得困难了，所以在需要打印方案甚至要求

字典序最小方案的场合，应慎用滚动数组。

例题9-5 劲歌金曲(Jin Ge Jin Qu [h]ao, Rujia Liu's Present 6, UVa 12563 )

如果问一个麦霸：“你在KTV里必唱的曲目有哪些？”得到的答案通常都会包含一首“神 曲”：古巨基的《劲歌金曲》。为什么呢？一般来说，KTV不会在“时间到”的时候鲁莽地把 正在唱的歌切掉，而是会等它放完。例如，在还有15秒时再唱一首2分钟的歌，则实际上多 唱了 105秒。但是融合了37首歌曲的《劲歌金曲》长达11分18秒[切](#bookmark9)，如果唱这首，相当于多 唱了663秒！

假定你正在唱KTV，还剩Z秒时间。你决定接下来只唱你最爱的n首歌（不含《劲歌金 曲》）中的一些，在时间结束之前再唱一个《劲歌金曲》，使得唱的总曲目尽量多（包含 《劲歌金曲》），在此前提下尽量晚的离开KTV。

输入n（n<50），Z（Z<109）和每首歌的长度（保证不超过3分钟[巡](#bookmark11)），输出唱的总曲目 以及时间总长度。输入保证所有n+ 1首曲子的总长度严格大于Z。

【分析】

虽说Z<109，但由于所有n+1首曲子的总长度严格大于Z，实际上Z不会超过180n + 678。 这样就可以转化为0-1背包问题了。细节留给读者思考。

###### 9.4 更多经典模型

本节介绍一些常见结构中的动态规划，序列、表达式、凸多边形和树。尽管它们的形式

和解法千差万别，但都用到了动态规划的思想：从复杂的题目背景中抽象出状态表示，然后

设计它们之间的转移。

9.4.1 线性结构上的动态规划

最长上升子序列问题（LIS ）。给定n个整数A2，…，An ,按从左到右的顺序选出尽量

多的整数，组成一个上升子序列（子序列可以理解为：删除0个或多个数，其他数的顺序不 变）。例如序列1， 6， 2， 3， 7， 5,可以选出上升子序列1， 2， 3， 5,也可以选出1， 6， 7,但前者更 长。选出的上升子序列中相邻元素不能相等。

【分析】

设为以/结尾的最长上升子序列的长度，则,,_ r ...:，最终答案是

max｛硪i）｝。如果LIS中的相邻元素可以相等，把小于号改成小于等于号即可。上述算法的时

间复杂度为0（n2）。《算法竞赛入门经典》中介绍了 一种方法把它优化到O（nlogn）,有兴趣的 读者可以自行阅读。

最长公共子序列问题（LCS ）。给两个子序列A和B ,如图9-7所示。求长度最大的公共 子序列。例如1， 5， 2， 6， 8， 7和2， 3， 5， 6， 9， 8， 4的最长公共子序列为5， 6， 8（另一个解是2， 6， 8）。

图9-7子序列A和B

【分析】

设硪i，j）为AhA^.A^^^，...，^的LCS长度，则当A[i]=A[j]时硪i，j）=^（i - Aj - 7） + 1 ,否 则^（i，j）=max｛^（i - 1，j），d（i，j - 1）｝,时间复杂度为0（nrn）,其中n和rn分别是序列A和B的长度。

例题9-6 照明系统设计(Lighting System Design, UVa 11400 )

你的任务是设计一个照明系统。一共有《 ( ^<1000 )种灯泡可供选择，不同种类的灯泡 必须用不同的电源，但同一种灯泡可以共用一个电源。每种灯泡用4个数值表示：电压 值F( F<132000 ),电源费用尺(尺<1000 ),每个灯泡的费用C ( C<10 )和所需灯泡的数 量£ ( 1<L<100 )。

假定通过所有灯泡的电流都相同，因此电压高的灯泡功率也更大。为了省钱，可以把一

些灯泡换成电压更高的另一种灯泡以节省电源的钱(但不能换成电压更低的灯泡)。你的任

务是计算出最优方案的费用。

【分析】

首先可以得到一个结论：每种电压的灯泡要么全换，要么全不换。因为如果只换部分灯 泡，如F=100有两个灯泡，把其中一个换成F=200的，另一个不变，则F=100和F=200两种电 源都需要，不划算(若一个都不换则只需要F=100—种电源)。

先把灯泡按照电压从小到大排序。设小]为前/种灯泡的总数量(即L值之和)，</]为灯 泡1〜/的最小开销，则^[/] = min{dj] + (s[/] - s[/'])*c[z] +对/])},表示前j个先用最优方案 买，然后第j+1〜/个都用第/号的电源。答案为d[浏。

例题9-7 划分成回文串(Partitioning by Palindromes, UVa 11584 )

输入一个由小写字母组成的字符串，你的任务是把它划分成尽量少的回文串。例 如，racecar本身就是回文串；fastcar只能分成7个单字母的回文串，aaadbccb最少分成3个回 文串： aaa, d, b ccb 。字符串长度不超过 1000 。

【分析】

d[/]为字符0 ~ /•划分成的最小回文串的个数，则d[/] = min{dj] + 1 | sj+1~/]是回文 串}。注意频繁的要判断回文串。状态0(«)个，决策0(«)个，如果每次转移都需要0(«)时间 判断，总时间复杂度会达到0(«3)。

可以先用0(«2)时间预处理s[/.j]是否为回文串。方法是枚举中心，然后不断向左右延伸 并且标记当前子串是回文串，直到延伸的左右字符不同为止[m](#bookmark19)。这样一来，每次转移的时间 降为了0(1)，总时间复杂度为0(n2)。

例题9-8 颜色的长度(Color Length, ACM/ICPC Daejeon 2011, UVa1625 )

输入两个长度分别为打和讲(n,m<5000 )的颜色序列，要求按顺序合并成同一个序列， 即每次可以把一个序列开头的颜色放到新序列的尾部。

例如，两个颜色序列GBBY和YRRGB，至少有两种合并结果：GBYBRYRGB和 YRRGGBBYB。对于每个颜色c来说，其跨度£(幻等于最大位置和最小位置之差。例如，对 于上面两种合并结果，每个颜色的£(0和所有£(0的总和如图9-8所示。

| Color            | G    | Y    | B    | R    | Sum  |
| ---------------- | ---- | ---- | ---- | ---- | ---- |
| 1(c): Scenario 1 | 7    | 3    | 7    | 2    | 19   |
| £(c): Scenario 2 | 1    | 7    |      | 1    | 12   |

图9-8每个颜色的L(c)和L(c)的总和

你的任务是找一种合并方式，使得所有£(c)的总和最小[趣](#bookmark22)

【分析】

根据前面的经验，可以设硪ij)表示两个序列已经分别移走了i和j个元素，还需要多少费 用。等一下！什么叫“还需要多少费用”呢？本题的指标函数(即需要最小化的函数)比较复 杂。当某颜色第一次出现在最终序列中时，并不知道它什么时候会结束；而某个颜色的最后 一个元素已经移到最终序列里时，又“忘记”了它是什么时候第一次出现的。

怎么办呢？如果记录每个颜色的第一次出现位置，状态会变得很复杂，时间也无法承 受，所以只能把在指标函数的“计算方式”上想办法：不是等到一个颜色全部移完之后再算， 而是每次累加。换句话说，当把一个颜色移到最终序列前，需要把所有“已经出现但还没结 束”的颜色的£(c)值加1。更进一步地，因为并不关心每个颜色的£(c)，所以只需要知道有多 少种颜色已经开始但尚未结束。

例如，序列GBBY和YRRGB，分别已经移走了 1个和3个元素(例如，已经合并成了 YRRG )。下次再从序列2移走一个元素(即G )时，Y和G需要加1。下次再从序列1移走一 个元素(它是B )时，只有Y需要加1 (因为G已经结束)。

这样，可以事先算出每个颜色在两个序列中的开始和结束位置，就可以在动态规划时 在0(1)时间内计算出状态d(i，j)中“有多少个颜色已经出现但尚未结束”，从而在0(1)时间内完 成状态转移。状态总是为0(nrn)个，总时间复杂度也是0(nrn)。

最优矩阵链乘。一个nxm矩阵由n行m列共个数排列而成。两个矩阵4和可以相乘当且 仅当A的列数等于5的行数。一个nxm的矩阵乘以一个讲^的矩阵等于一个的矩阵，运算量 为 mnp。

矩阵乘法不满足分配律，但满足结合律，因此既可以按顺序(4xfi>C进行，也可 以按进行。假设4、fi、C分别是2x3 , 3x4和4x5的，则(4xfi)xC的运算量为2x34 + 2x4x5 = 64,4x(fixC)的运算量为3x4x5 + 2x3x5 = 90。显然第一种顺序节省运算量。

给出n个矩阵组成的序列，设计一种方法把它们依次乘起来，使得总的运算量尽量小。 假设第i个矩阵乂>是p:    y的。

【分析】

本题任务是设计一个表达式。在整个表达式中,一定有一个“最后一次乘法”。假设它是 第/、个乘号，则在此之前已经算出了    和4    4。由

于P和0的计算过程互不相干，而且无论按照怎样的顺序，户和0的值都不会发生改变，因此 只需分别让P和0按照最优方案计算(最优子结构！)即可。为了计算P的最优方案，还需要 继续枚举的“最后一次乘法”,把它分成两部分。不难发现,无论怎么分,在任意时候,需要 处理的子问题都形如“把為，為+1，…，4;乘起来需要多少次乘法？ ”如果用状态/X j)表示这 个子问题的值,不难列出如下的状态转移方程：

###### /(;；» = min    +    + p^PtPj}

边界为/(i，i)=0。上述方程有些特殊：记忆化搜索固然没问题，但如果要写成递推，无论 按照i还是/的递增或递减顺序均不正确。正确的方法是按照j - i递增的顺序递推，因为长区 间的值依赖于短区间的值。

最优三角剖分。对于一个n个顶点的凸多边形，有很多种方法可以对它进行三角剖分 (triangulation )，即用n - 3条互不相交的对角线把凸多边形分成n - 2个三角形。为每个三角 形规定一个权函数w(i，j，/)(如三角形的周长或3个顶点的权和)，求让所有三角形权和最大 的方案。

分析】

本题和最优矩阵链乘问题十分相似，但存在一个显著不同：链乘表达式反映了决策过

程，而剖分不反映决策过程。举例来说，在链乘问题中，方案（（人，2）（人3（人4人5）））只能是先把 序列分成A^2和A3A4A5两部分，而对于一个三角剖分，“第一刀”可以是任何一条对角线，如

图9-9所示。

如果允许随意切割，则“半成品”多边形的各个顶点是可以在原多边形中随意选取的，很

难简洁定义成状态，而“矩阵链乘”就不存在这个问题——无论怎样决策，面临的子问题一定

可以用区间表示。在这样的情况下，有必要把决策的顺序规范化，使得在规范的决策顺序

下，任意状态都能用区间表示。

定义d（/，j）为子多边形/, /+ 1,…,j - 1, j （ /<j ）的最优值，则边/ -j在最优解中一定对应 一个三角形/-j-k（/<k<j）,如图9-10所示（注意顶点是按照逆时针编号的）。

因此，状态转移方程为：

二    + d（k.f） +    \ i <k < j}

时间复杂度为0（«3）,边界为d（/，/+ 1）=0 ,原问题的解为d（0，《 - 1）。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-169.jpg)



图9-10 定义的子多边形



例题9-9 切木棍(Cutting Sticks, UVa 10003 ) 有一根长度为L （ L < 1000 ）的棍子，还有《 （ n < 50 ）个切割点的位置（按照从小到大排

列)。你的任务是在这些切割点的位置处把棍子切成n+1部分，使得总切割费用最小。每次 切割的费用等于被切割的木棍长度。例如，Z=10，切割点为2, 4, 7。如果按照2, 4, 7的顺序， 费用为10+8+6=24，如果按照4, 2, 7的顺序，费用为10+4+6=20。

【分析】

设山:/)为切割小木棍的最优费用，则.    I，其

中最后一项4/] - ^[i]代表第一刀的费用。切完之后，小木棍变成i〜&和两部分，状态转 移方程由此可得。把切割点编号为1〜n，左边界编号为0，右边界编号为n + 1，则答案 为 d(0,n+ 1)。

状态有0(n2)个，每个状态的决策有0(n)个，时间复杂度为0(n3)。值得一提的是，本题

可以用四边形不等式优化到0(n2)，有兴趣的读者请参见本书的配套《算法竞赛入门经典

——训练指南》或其他参考资料。

例题9-10 括号序列(Brackets Sequence, NEERC 2001, UVa1626 )

定义如下正规括号序列(字符串)：

□空序列是正规括号序列。

□如果是正规括号序列，那么(5)和[5]也是正规括号序列。

□如果乂和5都是正规括号序列，那么必也是正规括号序列。

例如，下面的字符串都是正规括号序列： ()， []， (())， ([])， ()[]， ()[()]，而如下字符串 则不是正规括号序列： (， [， ]， )(， ([()。

输入一个长度不超过100的，由“(”、“)”、“[”、“]”构成的序列，添加尽量少的括号，得

到一个规则序列。如有多解，输出任意一个序列即可。

【分析】

设串5至少需要增加d(5)个括号，转移如下：

□如果5形如(5')或者[5']，转移到d(5')。

□如果5至少有两个字符，则可以分成必，转移到d(A) + d(5)。

边界是：S为空时d(S)=0 , S为单字符时d(S)=1。注意(^，[S'，)之类全部属于第二种转 移,不需要单独处理。

注意：不管S是否满足第一条，都要尝试第二种转移，否则“[][]”会转移到“][”，然后就 只能加两个括号了。

当然,上述“方程”只是概念上的,落实到程序时要改成子串在原串中的起始点下标,即 用d(i，j)表示子串S[i〜j]至少需要添加几个括号。下面是递推写法，比记忆化写法要快好几 倍,而且代码更短。请读者注意状态的枚举顺序：

void dp() {

| for(int i =    | 0; i <  | n; i++)                                | {      |
| -------------- | ------- | -------------------------------------- | ------ |
| d[i+1][i]      | = 0;    |                                        |        |
| d[i][i] =1     | 1;      |                                        |        |
| }for(int i =   | n- 2; i | >= 0;                                  | i——)   |
| for(int j      | = i+1;  | j < n;                                 | j++) { |
| d[i][j]        | = n;    |                                        |        |
| if(match(S[i], | S[j]))  | d[i][j] = min(d[i][j], d[i+1][j - 1]); |        |
| for(int        | k = i;  | k < j;                                 | k++)   |

d[i][j] = min(d[i][j], d[i][k] + d[k+1][j]);

本题需要打印解，但是上面的代码只计算了 d数组，如何打印解呢？可以在打印时重新 检查一下哪个决策最好。这样做的好处是节约空间,坏处是打印时代码较复杂,速度稍慢, 但是基本上可以忽略不计(因为只有少数状态需要打印)。

void print(int i, int j) { if(i > j) return ; if(i == j) {

if(S[i] == '(' || S[i] == ')') printf("()"); else printf("[]");

return;

int ans = d[i][j];

if(match(S[i], S[j]) && ans == d[i+1][j-1]) { printf("%c", S[i]); print(i+1, j-1); printf("%c", S[j]); return;

}

for(int k = i; k < j; k++) if(ans == d[i][k] + d[k+1][j]) {

print(i, k); print(k+1, j); return;

}

}

本题唯一的陷阱是：输入串可能是空串，因此不能用scanf（”％s", s）的方式输入，只能用 getchar、fgets 或者 getline。

例题9-11 最大面积最小的三角剖分( Minimax Triangulation, ACM/ICPC NWERC 2004, UVa1331 )

三角剖分是指用不相交的对角线把一个多边形分成若干个三角形。如图9-11所示是一个

六边形的几种不同的三角剖分。

输入一个简单m （ 2<m<50 ）边形，找一个最大三角形面积最小的三角剖分。输出最大三 角形的面积。在图9-11的5个方案中，最左边（即左下角）的方案最优。

分析】

本题的程序实现要用到一些计算几何的知识，不过基本思想是清晰的：首先考虑凸多边 形的简单情况。和“最优三角剖分”一样，设d(/j)为子多边形/,/+1,...j-1j ( /<j )的最优解， 则状态转移方程为d(/j)= min^/jk), d(i,k), d(kj) | i<k<j},其中S(/j,k)为三角形/-j-k的面积。

回到原题。需要保证边i-j是对角线[您](#bookmark5)(唯一的例外是/=0且户n-1 )，具体方法是当 边i-j不满足条件时直接设d(ij)为无穷大，其他部分和凸多边形的情形完全一样。

9.4.2 树上的动态规划

树的最大独立集。对于一棵n个结点的无根树，选出尽量多的结点，使得任何两个结点 均不相邻(称为最大独立集)，然后输入n-1条无向边，输出一个最大独立集(如果有多 解，则任意输出一组)。

【分析】

用d(i)表示以i为根结点的子树的最大独立集大小。此时需要注意的是，本题的树是无根 的：没有所谓的“父子”关系，而只有一些无向边。没关系，只要任选一个根r ,无根树就变 成了有根树，上述状态定义也就有意义了。

结点i只有两种决策：选和不选。如果不选i ,则问题转化为了求出i的所有儿子的d值再 相加；如果选i ,则它的儿子全部不能选，问题转化为了求出i的所有孙子的d值之和。换句话 说，状态转移方程为：

J(/) = max{l+    d( j)}

其中，gs(i)和s(i)分别为i的孙子集合与儿子集合，如图9-12所示。

代码应如何编写呢？上面的方程涉及“枚举结点i的所有儿子和所有孙子”，颇为不便。 其实可以换一个角度来看：不从i找s(i)和gs(i)的元素，而从s(i)和gs(i)的元素找i。换句话 说，当计算出一个d(i)后，用它去更新i的父亲和袓父结点的累加值［』7)和［这样

jes(i)

一来，每个结点甚至不必记录其子结点有哪些，只需记录父结点即可。这就是前面提过 的“刷表法”。不过这个问题还有另外一种解法，在实践中更加常用，将在例题部分介绍。

树的重心（质心）。对于一棵n个结点的无根树，找到一个点，使得把树变成以该点为 根的有根树时，最大子树的结点数最小。换句话说，删除这个点后最大连通块（一定是树） 的结点数最小。

【分析】

和树的最大独立集问题类似，先任选一个结点作为根，把无根树变成有根树，然后

设表示以i为根的子树的结点个数。不难发现1| 1卜。程序实现也很简单：只需

要一次DFS ,在无根树转有根树的同时计算即可，连记忆化都不需要——因为本来就没有重 复计算。

那么，删除结点i后，最大的连通袂有多少个结点呢？结点i的子树中最大的有max{^（j）} 个结点，i的“上方子树”中有n-成i）个结点，如图9-13所示。这样，在动态规划的过程中就可 以顺便找出树的重心了。

P,

◦ M poo

◦’6 do o

图9-12结点的gs（）（浅灰色）和s（i）（深灰色）



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-173.jpg)



树的最长路径（最远点对）。对于一棵n个结点的无根树，找到一条最长路径。换句话 说，要找到两个点，使得它们的距离最远。

【分析】

和树的重心问题一样，先把无根树转成有根树。对于任意结点i ,经过i的最长路就是连 接i的两棵不同子树w和v的最深叶子的路径，如图9-14所示。

设d(i)表示根为结点i的子树中根到叶子的最大距离，不难写出状态转移方 程：d(i)=max{d⑺+1}。对于每个结点i，把所有子结点的d⑺都求出来之后，设d值前两大的 结点为w和v，则d⑻+d(v)+2就是所求。

本题还有一个不用动态规划的解法：随便找一个结点w，用DFS求出w的最远结点v，然 后再用一次DFS求出v的最远结点w，则v-w就是最长路径。

结合上述两个问题的解法，可以解决下面的问题：对于一棵n个结点的无根树，求出每 个结点的最远点，要求时间复杂度为0(n)。这个问题留给读者思考。

例题9-12 工人的请愿书(Another Crisis, UVa 12186)

某公司里有一个老板和打(n<105 )个员工组成树状结构，除了老板之外每个员工都有唯 一的直属上司。老板的编号为0，员工编号为1〜n。工人们(即没有直接下属的员工)打算 签署一项请愿书递给老板，但是不能跨级递，只能递给直属上司。当一个中级员工(不是工 人的员工)的直属下属中不小于7%的人签字时，他也会签字并且递给他的直属上司。问： 要让公司老板收到请愿书，至少需要多少个工人签字？

【分析】

设d(w)表示让w给上级发信最少需要多少个工人。假设w有&个子结点，则至少需要c=(女7-1)/100+1个直接下属发信才行。把所有子结点的d值从小到大排序，前c个加起来即可。最终 答案是d(0)。因为要排序，算法的时间复杂度为O(nlogn)。动态规划部分代码如下：

vector<int> sons[maxn]; //sons[i] 为结点i的子列表

int dp(int u) {

if(sons[u].empty()) return 1; int k = sons[u].size(); vector<int> d; for(int i = 0; i < k; i++)

d.push_back(dp(sons[u][i])); sort(d.begin(), d.end()); int c = (k*T - 1) / 100 + 1; int ans = 0;

for(int i = 0; i < c; i++) ans += d[i]; return ans;

}

例题9-13 Hali-Bula的晚会(Party at Hali-Bula, ACM/ICPC Tehran 2006, UVa1220 )

公司里有打（n<200 ）个人形成一个树状结构，即除了老板之外每个员工都有唯一的直属 上司。要求选尽量多的人，但不能同时选择一个人和他的直属上司。问：最多能选多少人， 以及在人数最多的前提下方案是否唯一。

【分析】

本题几乎就是树的最大独立集问题，不过多了一个要求：判断唯一性。设：

□"什，0）和/^，0）表示以权为根的子树中，不选w点能得到的最大人数以及方案唯一性 （Z（w，0）=1表示唯一，0表示不唯一）。

□    d（w，1）和Xw，1）表示以w为根的子树中，选w点能得到的最大人数以及方案唯一性。相应 地，状态转移方程也有两套。

□    d（w，1）的计算：因为选了w，所以w的子结点都不能选，因此d（w，1） = sum{d（v，0） | v是w的子 结点}。当且仅当所有f（v，0）=1时f（w，1）才是1。

□    d（w，0）的计算：因为w没有选，所以每个子结点v可选可不选，即d（w，0） = sum{ max（d（v，0），

d（v，1））    }。什么情况下方案是唯一的呢？首先，如果某个d（v，0）和d（v，1）相等，则不唯

一；其次，如果max取到的那个值对应的f=0，方案也不唯一（如d（v，0）    > d（v，1）

且f（v，0）=0，则f（w，0）=0 ）。

例题9-14 完美的服务(Perfect Service, ACM/ICPC Kaoshiung 2006, UVa1218 )

有八(n<10000 )台机器形成树状结构。要求在其中一些机器上安装服务器，使得每台不 是服务器的计算机恰好和一台服务器计算机相邻。求服务器的最少数量。如图9-15所示，图 9-15 ( a)是非法的，因为4同时和两台服务器相邻，而6不与任何一台服务器相邻。而图9-15 ( b )是合法的。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-175.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-176.jpg)



(b)



图9-15 非法与合法的树状结构

【分析】

有了前面的经验，这次仍然按照每个结点的情况进行分类。

□    d(u,0) : u是服务器，则每个子结点可以是服务器也可以不是。

□    d(u,1) : u不是服务器，但u的父亲是服务器，这意味着u的所有子结点都不是服务器。

□    d(u,2) : u和u的父亲都不是服务器。这意味着u恰好有一个儿子是服务器。 状态转移比前面复杂一些，但也不困难。首先可以写出：

d(u,0) = sum{min(d(v,0), d(v,1))} + 1 d(u,1) = sum(d(v,2))

而d(u,2)稍微复杂一点，需要枚举当服务器的子结点编号v ,然后把其他所有子结 点v'的d(v',2)加起来，再和d(v,0)相加。不过如果这样做，每次枚举v都需要0(k)时间(其 中k是u的子结点数目)，而v本身要枚举k次，因此计算d(u,2)需要花0(k2)时间。

刚才的做法有很多重复计算，其实可以利用已经算出的d(u,1)写出一个新的状态转移方 程：

d(w，2) = min(d(w，1) - d(v，2) + d(v，0))

这样一来，计算d(w，2)的时间复杂度变为了0(幻。因为每个结点只有在计算父亲时被用 了3次，总时间复杂度为0(n)。

9.4.3 复杂状态的动态规划

最优配对问题。空间里有n个点P。，^，…，Pn-1 ,你的任务是把它们配成n/2对(n是偶 数)，使得每个点恰好在一个点对中。所有点对中两点的距离之和应尽量小。n<20，^|，^|，^| <10000。

【分析】

既然每个点都要配对，很容易把问题看成如下的多阶段决策过程：先确定P0和谁配对，

然后是^ ,接下来是P2 , ,最后是Pn-1。按照前面的思路，设d(i)表示把前i个点两两配

对的最小距离和，然后考虑第i个点的决策——它和谁配对呢？假设它和点/配对(j<i ),那 么接下来的问题应是“把前i-1个点中除了j之外的其他点两两配对”，它显然无法用任何一 个d值来刻画——此处的状态定义无法体现出“除了一些点之外”这样的限制。

当发现状态无法转移后，常见的方法是增加维度，即增加新的因素，更细致地描述状 态。既然刚才提到了“除了某些元素之外”，不妨把它作为状态的一部分，设d(i，S)表示把 前i个点中，位于集合S中的元素两两配对的最小距离和，则状态转移方程为：

= min{|    \ +£/(/    -{/}-{/}) | y'G S}

其中，|p/yi表示点^和/j之间的距离。方程看上去很不错，但实现起来有问题：如何表

示集合s呢？由于它要作为数组d中的第二维下标，所以需要用整数来表示集合，确切地说， 是{0，1, 2,… ，n-1}的任意子集(subset)。

在第7章的“子集枚举”部分，曾介绍过子集的二进制表示，现在再次用到此知识：

for(int i = 0; i < n; i++)

for(int S = 0; S < (1<<n); S++) { d[i][S] = INF;

上述程序中故意用了很多括号，传达给读者的信息是：位运算的优先级低，初学者很容

易弄错。例如，“1<<n-1”的正确解释是“1<<(n-1)”，因为减法的优先级比左移要高。为了保 险起见，应多用括号。另一个技巧是利用C语言中“0为假，非0为真”的规定简化表达 式：“if(S & (1<<j))”的实际含义是“if((S & (1<<j)) != 0)”。

提示9-19：位运算的优先级往往比较低。如果不确定表达式的计算顺序，应多用括

由于大量使用了形如1<<n的表达式，此类表达式中，左移运算符“<<”的含义是“把各个 位往左移动，右边补0”。根据二进制运算法则，每次左移一位就相当于乘以2 ,因此a<<b相

当于a*2\而在集合表示法中，1<lt;i代表单元素集合{i}。由于0表示空集，“S& (1<<j)”不等 于0就意味着“词卩{j}的交集不为空”。

上面的方程可以进一步简化。事实上，阶段i根本不用保存，它已经隐含在中了 ——中的最大元素就是i。这样，可直接用d(S)表示“把中的元素两两配对的最小距离和”， 则状态转移方程为：

d(S)=min{PiPj |+d(S-{i}- {j})jeS, i=max{S} }

状态有2n个，每个状态有0(n)种转移方式，总时间复杂度为0(n2n)。

提示9-20：如果用二进制表示子集并进行动态规划，集合中的元素就隐含了阶段信

息。例如，可以把集合中的最大元素想象成“阶段”。

值得一提的是，不少用户一直在用这样的状态转移方程：

d(S)=min{ |pPj■+d(S-{jeS, }

它和刚才的方程很类似，唯一的不同是：i和j都是需要枚举的。这样做虽然也没错，但 每个状态的转移次数高达0(n2),总时间复杂度为O(n22n),比刚才的方法慢。这个例子再次 说明：即使用相同的状态描述，减少决策也是很重要的。

提示9-21：即使状态定义相同，过多地考虑不必要的决策仍可能会导致时间复杂度上

升。

接下来出现了一个新问题：如何求出中的最大元素呢？用一个循环判断即可。当取遍 {0，1, 2,…，n-1}的所有子集时，平均判断次数仅为2 (想一想，为什么)。

for(int S = 0; S < (1<<n); S++) { int i, j;

d[S] = INF;

for(i = 0; i < n; i++)

if(S & (1<<i)) break; for(j = i+1; j < n; j++)

if (S &    (1<<j) ) d[S] = max(d[S], dist(i, j) + d[SA(1>>i)A (1>>j)]);

}

注意，在上述的程序中求出的i是中的最小元素，而不是最大元素，但这并不影响答 案。另外，J的枚举只需从i+1开始——既然i是中的最小元素，则说明其他元素自然均 比i大。最后需要说明的是的枚举顺序。不难发现：如果是的真子集，则一定有，因 此若以递增的顺序计算，需要用到某个d值时，它一定已经计算出来了。

提示9-22 :如果S'是S的真子集，则一定有S'<S。在用递推法实现子集的动态规划时， 该规则往往可以确定计算顺序。

货郎担问题（TSP）。有n个城市，两两之间均有道路直接相连。给出每两个城 市7和/之间的道路长度&，求一条经过每个城市一次且仅一次，最后回到起点的路线，使得 经过的道路总长度最短。N<15，城市编号为0〜n-1。

【分析】

TSP是一道经典的NPC难题[⑽](#bookmark14)，不过因为本题规模小，可以用动态规划求解。首先注意 到可以直接规定起点和终点为城市0 （想一想，为什么），然后设d（i，5）表示当前在城市i，还 需访问集合中的城市各一次后回到城市0的最短长度，则

d(i, 5)=min{d(/'，S-{/}+disZ(i，j))jeS}

边界为d(i，{})=dist(0，i)。最终答案是d(0，{1,2,3,…，n-1}),时间复杂度为O(n22n)。

图的色数。图论有一个经典问题是这样的：给一个无向图G,把图中的结点染成尽量少 的颜色，使得相邻结点颜色不同。

【分析】

设d(S)表示把结点集S染色，所需要颜色数的最小值，则d(S)=d(S-S')+1 ,其中S'是S的子 集，并且内部没有边(即不存在S'内的两个结点w和v使得w和v相邻)。换句话说，S'是一 个“可以染成同一种颜色”的结点集。

首先通过预处理保存每个结点集是否可以染成同一种颜色(即“内部没有边”)，则算法 的主要时间取决于“高效的枚举一个集合S的所有子集”。

如何枚举S的子集呢？详见下面的代码(代码中的S0就是上面的S'):

d[0] = 0;

for(int S = 1; S < (1<<n); S++) { d[S] = INF;

for(int S0 = S; S0; S0 = (S0-1)&S) if(no_edges_inside[S0]) d[S] = min(d[S], d[S-S0]+1);

如何分析上述算法的时间复杂度？它等于全集{1，    2,…，n}的所有子集的“子集个数”之

和。如果不好理解，可以令c(S)表示集S的子集的个数(它等于2|S| ),则本题的时间复杂度 为sum{c(S0) | S^{1,2,3，...，n}的子集}。元素个数相同的集合，其子集个数也相同，可以按照

元素个数“合并同类项”。元素个数为&的集合有C(n，幻个，其中每个集合有2&个子集，因此本 题的时间复杂度为sum{C(n，^)2t}=(2+1)n=3n ,其中第一个等号用到了第10章即将学到的二项 式定理(不过是“反着”用的)。

提示9-23 :枚举1〜n的每个集合S的所有子集的总时间复杂度为O(3n)。

例题9-15 校长的烦恼(Headmaster's Headache, UVa 10817 )

某校有rn个教师和n个求职者，需讲授s个课程(1<5<8 , 1<m<20 , 1<n<100 )。已知每人

的工资c ( 10000<c<50000 )和能教的课程集合，要求支付最少的工资使得每门课都至少有两 名教师能教。在职教师不能辞退。

【分析】

本题的做法有很多。一种相对容易实现的方法是：用两个集合51表示恰好有一个人教的 科目集合，52表示至少有两个人教的科目集合，而成i,51,52)表示已经考虑了前i个人时的最小 花费。注意，把所有人一起从0编号，则编号0〜rn-1是在职教师，rn~«+rn-1是应聘者。状态 转移方程为硪i,51,52) = min{^(i+1, 51', 52')+c[i], d(i+1,51,52)},其中第一项表示“聘用”，第二 项表示“不聘用”。当i^rn时状态转移方程才出现第二项。这里51'和52'分别表示“招聘第i个人 之后51和52的新值”，具体计算方法见代码。

下面代码中的5Z[i]表示第i个人能教的科目集合(注意输入中科目从1开始编号，而代码 的其他部分中科目从0开始编号，因此输入时要转换一下)。下面的代码用到了一个技巧： 记忆化搜索中有一个参数50，表示没有任何人能教的科目集合。这个参数并不需要记忆(因 为有了51和52就能算出50)，仅是为了编程的方便(详见51'和52'的计算方式)。最终结果是 dp(0, (1<5)-1, 0, 0)，因为初始时所有科目都没有人教。

int m, n, s, c[maxn], st[maxn], d[maxn][1<<maxs][1<<maxs];

int dp(int i, int s0, int s1, int s2) {

| if(i == m+n) return s2 ==                                    | (1<<s)    | - 1         | ? 0 : INF; |
| ------------------------------------------------------------ | --------- | ----------- | ---------- |
| int& ans = d[i][s1][s2]; if(ans >= 0) return ans; ans = INF; |           |             |            |
| if(i >= m) ans = dp(i+1,                                     | s0, s1,   | s2);        | //不选     |
| int m0 = st[i] & s0, m1 =                                    | st[i] &   | s1;         |            |
| s 0 a= m0; si =    (s1 a ml)                                 | \| m0; s2 | \|=         | m1;        |
| ans = min(ans, c[i] + dp(i+1,    s0,return ans;              | s1,       | s2)); // 选 |            |

}

本题还有其他解法，例如，分别用0， 1， 2表示每个科目是没人教、恰好一个人教和至 少两个人教，这样就可以用一个三进制数来保存状态，而不是两个集合。不过这样做编程稍 微麻烦一些，而且时间效率差不多(在上面的代码中，虽然d数组有4"个元素，但因为记忆 化的关系，只用到了3外)。

例题9-16 20个问题(Twenty Questions, ACM/ICPC Tokyo 2009, UVa1252 )

有打(n<128 )个物体，rn ( m<11 )个特征。每个物体用一个m位01串表示，表示每个特 征是具备还是不具备。我在心里想一个物体(一定是这n个物体之一)，由你来猜。

你每次可以询问一个特征，然后我会告诉你：我心里的物体是否具备这个特征。当你确

定答案之后，就把答案告诉我(告知答案不算“询问”)。如果你采用最优策略，最少需要询

问几次能保证猜到？

例如，有两个物体： 1100和0110，只要询问特征1或者特征3，就能保证猜到。

【分析】

为了叙述方便，设“心里想的物体”为W。首先在读入时把每个物体转化为一个二进制整 数。不难发现，同一个特征不需要问两遍，所以可以用一个集合s表示已经询问的特征集。 在这个集合s中，有些特征是W所具备的，剩下的特征是W不具备的。用集合a来表示“已确认 物体W具备的特征集”，则a—定是s的子集。

设d(5^>表示已经问了特征集"，其中已确认W所具备的特征集为时，还需要询问的最小 次数。如果下一次提问的对象是特征& (这就是“决策”)，则询问次数为：

max{d("+{k}，a+{k})，d("+{k}， a)}+1

考虑所有的^，取最小值即可。边界条件为：如果只有一个物体满足“具备集合中的所 有特征，但不具备集合中的所有特征”这一条件，则d(¥)=0，因为无须进一步询问，已经 可以得到答案。

因为为"的子集，所以状态总数为3m，时间复杂度为0(m*3m)。对于每个"和^，可以先 把满足该条件的物体个数统计出来，保存在cntMb］，避免状态转移的时候重复计算。统计 cnt^M的方法是枚举"和物体，时间复杂度为0(n*2m)，所以总时间复杂度为0(n*2m    +

m*3m)。对于本题的规模来说0(^2，可以忽略不计。

例题9-17 基金管理(Fund Management, ACM/ICPC NEERC 2007, UVa1412 )

你有c ( 0.01<c<108 )美元现金，但没有股票。给你rn ( 1<m<100 )天时间和《 ( 1<n<8 ) 支股票供你买卖，要求最后一天结束后不持有任何股票，且剩余的钱最多。买股票不能赊 账，只能用现金买。

已知每只股票每天的价格(0.01〜999.99。单位是美元/股)与参数5Z和匀，表示一手股票

是5Z( 1<5Z<106 )股，且每天持有的手数不能超过M 1<k<k),其中k为每天持有的总手数上

限。每天要么不操作，要么选一只股票，买或卖它的一手股票。c和股价均最多包含两位小

数(即美分)。最优解保证不超过109。要求输出每一天的决策(HOLD表示不变，SELL表 示卖，BUY表示买)。

【分析】

根据前面的经验，可以用d(i,列表示经过i天之后，资产组合为时的现金的最大值。其 中是一个《元组表示第i只股票有^手。根据题目规定,P1+…+pn<k。因为0<p<8 ,理 论上最多只有98<5*107种可能，所以可以用一个九进制整数来表示p。

一共有3种决策：HOLD、BUY和SELL ,分别进行转移即可。注意在考虑购买股票时不 要忘记判断当前拥有的现金是否足够。细心的读者可能已经发现：正因为如此，本题并不是 一个标准的DAG最长/短路问题，因为某些边u->v的存在性依赖于起点到u的最短路值。也就 是说，本题的状态不能像之前的DAG问题一样“反着定义”：如果用d(i,p)表示资产组合为p , 从第i天开始到最后能拥有的现金的最大值，就没法转移了(想一想，为什么)。

这样的做法虽然不错[(11)](#bookmark3)，但是效率却不够高，因为九进制整数无法直接进行“买卖股 票”的操作，需要解码成n元组才行。因为几乎每次状态转移都会涉及编码、解码操作，状态

转移的时间大幅度提升，最终导致超时。

解决方法是事先计算出所有可能的状态并且编号(还记得第5章中的“集合栈计算

机”吗？)，代码如下：

vector<vector<int> > states; map<vector<int>, int> ID;

void dfs(int stock, vector<int>& lots, int totlot) {

if(stock == n) {

states.push_back(lots);

}

else for(int i = 0; i <= k[stock] && totlot + i <= kk; i++) { lots[stock] = i; dfs(stock+1, lots, totlot + i);

}

}

然后构造一个状态转移表，用buy_next[s][i]和sell_next[s][i]分别表示状态s进行“买股票 i”和“卖股票i”之后转移到的状态编号，代码如下：

int buy_next[maxstate][maxn], sell_next[maxstate][maxn];

void init() {

vector<int> lots(n);

states.clear();

ID.clear();

dfs(0, lots, 0);

for(int s = 0; s < states.size(); s++) {

| int totlot = 0 | ;    |                     |           |
| -------------- | ---- | ------------------- | --------- |
| for(int i = 0; | i    | < n; i++)           | totlot += |
| for(int i = 0; | i    | < n; i++)           | {         |
| buy_next[s][   | i]   | = sell_next[s][i] = |           |

if(states[s][i] < k[i] && totlot <



states[s][i];

-1;

kk) {



vector<int> newstate = states[s];

newstate[i]++;

buy_next[s][i] = ID[newstate];

}

if(states[s][i] > 0) {

vector<int> newstate = states[s];

newstate[i]——;

sell_next[s][i] = ID[newstate];

动态规划主程序采用刷表法（读者也可以试着改成倒推的填表法），为了方便起见，另 外编写了“更新状态”的函数update，读者可以自行体会它的好处。为了打印解，在更新解d时 还要更新最优策略opt和“上一个状态”prev。注意下面的price[i][day]表示第day天时一手股票i 的价格，而不是输入中的“每股价格”。

double d[maxm][maxstate];

int opt[maxm][maxstate], prev[maxm][maxstate];

void update(int day, int s, int s2, double v, int o) { if(v > d[day+1][s2]) {

d[day+1][s2] = v; opt[day+1][s2] = o; prev[day+1][s2] = s;

double dp() {

for(int day for(int s



0; day <= m; day++)

0; s < states.size(); s++)



d[day][s] = -INF;



d[0][0] = c;



for(int day = for(int s = double v =



0; day < m; day++)

0; s < states.size(); d[day][s];

s++)



if(v < -1) continue;

update(day, s, s, v, 0); //HOLD

for(int i = 0; i < n; i++) { if(buy_next[s][i] >= 0 && v >= price[i][day] - 1e-3)

update(day, s, buy_next[s][i], v - price[i][day], i+1); //BUY

if(sell_next[s][i] >= 0)

update(day, s, sell_next[s][i], v + price[i][day], -i-1); //SELL

}

}

return d[m][0];

}

最后是打印解的部分。因为状态从前到后定义，因此打印解时需要从后到前打印，用递

归比较方便。

void print_ans(int day, int s) { if(day == 0) return; print_ans(day-1, prev[day][s]); if(opt[day][s] == 0) printf("HOLD\n"); else if(opt[day][s] > 0) printf("BUY %s\n", name[opt[day][s]-1]); else printf("SELL %s\n", name[-opt[day][s]-1]);

}

###### 9.5 竞赛题目选讲

例题9-18 跳舞机(Tango Tango Insurrection, UVa 10618 )

你想学着玩跳舞机。跳舞机的踏板上有4个箭头：上、下、下、右。当舞曲开始时，屏

幕上会有一些箭头往上移动。当向上移动箭头与顶部的箭头模板重合时，你需要用脚踩一下

踏板上的相同箭头。不需要踩箭头时，踩箭头并不会受到惩罚，但当需要踩箭头时，必须踩

一下，哪怕已经有一只脚放在了该箭头上。很多舞曲的速度快，需要来回倒腾步子，所以最

好写一个程序来帮助你选择一个轻松的踩踏方式，使得能量消耗最少。

为了简单起见，将一个八分音符作为一个基本时间单位，每个时间单位要么需要踩一个

箭头（不会同时需要踩两个箭头），要么什么都不需要踩。在任意时刻，你的左右脚应放在

不同的两个箭头上，且每个时间单位内只有一只脚能动（移动和/或踩箭头），不能跳跃。

另外，你必须面朝前方以看到屏幕（即：你不能把左脚放到右箭头上，并且右脚放到左箭头

上）。

当你执行一个动作（移动和/或踩）时，消耗的能量这样计算：

□如果这只脚上个时间单位没有任何动作，消耗1单位能量。

□如果这只脚上个时间单位没有移动，消耗3单位能量。

□如果这只脚上个时间单位移动到相邻箭头，消耗5单位能量。

□如果这只脚上个时间单位移动到相对箭头（上到下，或者左到右），消耗7单位能量。

正常情况下，你的左脚不能放到右箭头上（或者反之），但有一种情况例外：如果你的

左脚在上箭头或者下箭头，你可以临时扭着身子用右脚踩左箭头，但是在你的右脚移出左箭

头之前，你的左脚都不能移到另一个箭头上。类似地，右脚在上箭头或者下箭头时，你也可

以临时用左脚踩右箭头。一开始，你的左脚在左箭头上，右脚在右箭头上。

输入包含最多100组数据，每组数据包含一个长度不超过70的字符串，即各个时间单位 需要踩的箭头。L和R分别表示左右箭头，“”表示不需要踩箭头。输出应是一个长度和输入 相同的字符串，表示每个时间单位执行动作的脚。L和R分别是左右脚，“”表示不踩。比 如，.RDLU的最优解是RLRLR ,第一次是把右脚放在下箭头上。

【分析】

虽然本题的条件比较杂乱，但总的来说不难发现：可以按“箭头”划分阶段，再记录一下 左右脚的位置以及上次左脚有没有踩，就可以顺利地动态规划了。

具体来说，用硪/，＜3力X）表示已经踩了 /个箭头（效），左右脚分别在箭头＜3和上，且上 一个周期移动的脚的集合为（ X=0表示没有脚移动，X=1表示左脚移动，X=2表示右脚移 动），则最终答案为硪0，1,2，0）。4个箭头的编号为0-上，1-左，2-右，3-下。

如果下一步是“.”，有3种决策：左脚移动到另一个箭头；右脚移动到另一个箭头；不

动。注意，虽然这次移动什么箭头都不会踩到，但还是要输出移动的脚。

如果下一步是4个箭头之一，有两种决策：左脚移动到该箭头；右脚移动到该箭头。注

意不要枚举不符合题目要求的移动方式。

例题9-19 团队分组( Team them up!, ACM/ICPC NEERC 2001, UVa1627)

有打（^＜100 ）个人，把他们分成非空的两组，使得每个人都被分到一组，且同组中的人 相互认识。要求两组的成员人数尽量接近。多解时输出任意方案，无解时输出No Solution。

例如， 1认识2， 3， 5；2认识1， 3， 4， 5；3认识1， 2， 5， 4认识1， 2， 3， 5认识1， 2， 3， 4（注意4 认识1但1不认识4），则可以分两组：｛1，3，5｝和｛2，4｝。

【分析】

设两个组的编号为0和1。因为同组中的人相互认识，所以如果有两个人a和b不是相互认 识，那么a和b只能分到两个不同的组。这样，如果已知某个人是第0组，那么不认识它的所 有人都应该是第1组。而不认识这些人的所有人都应该是0组，依此类推。这样，如果把“不 相互认识”关系看成一个图，则每个连通分量都可以独立推导（推导过程中可能遇到矛盾， 此时原问题无解）。例如，上面的样例对应图9-16 （注意a认识b，但b不认识a，也应该连一 条边）。

图9-16 团队分组样例示意图

对于连通分量{1,3,4,5}，假设1在组0，可以推导出3,4,5都在组1；反过来，如果1在组 1 ,可以推导出3,4,5都在组0。设组0比组1的人数多d个，可以总结出如表9-1所示。

表9-1 组0和组1人数分布

|           | 情况1                              | 情况2                             |
| --------- | ---------------------------------- | --------------------------------- |
| 连通分量1 | 组0 : {2};组1 : {}（d加1 ）        | 组0： {};组1： {2}（ d 减1）      |
| 连通分量2 | 组0 : {4};组1 : {1,3,5} （ d减2 ） | 组0： {1,3,5};组1： {4}（d加 2 ） |

可以看到，每个连通分量的两种情况分别对应于d加一个值或者减一个值，最终目标是d 的绝对值尽量少。想到了什么？没错！是0-1背包问题，只是没有“体积”，而“重量”有正有 负，最后也不是要“重量”最大，而是最接近0。

例题 9-20 装满水的 气球（ Dropping water balloons, UVa 10934）

一年一度的新生周活动开始了，你们做好了大量的装满水的气球，准备拿来恶搞那些可 怜的新生。活动开始之前，你们突然发现一个问题：这些气球实在是太硬了，很难把它们打 破（如果打不破，它们就没有任何意义了）。甚至从好几层高的楼顶上把它们扔到地面，也 打不破。你的任务是借助一个n层的高楼确定气球的硬度（所有气球硬度相同）。

实验过程是这样的：每次你拿着一个气球爬到第/层楼，将它摔到地面。如果气球破 了，说明它的硬度不超过广如果没破，说明硬度至少为/。注意，气球不会被实验所“磨

损”。换句话说，如果在某层楼上往下摔，气球没破，那么在同一层楼不管再摔多少次它也

不会破。

给你&个气球用来实验(可以打破它们)。你的任务是求出至少需要多少次实验，才能 确定气球的硬度(或者得出结论：站在最高层也摔不破)。

输入每行包含两个整数屯《 ( 1<^<100 , 1<«<264 ),输出最少需要的实验次数。如果63 次不够，输出“More than 63 trials needed”。

【分析】

用状态硪/J)表示用/个球实验/次所能测试的楼的最高层数。根据动态规划的常见思路， 我们考虑第一次决策，设测试楼层为女。

如果气球破了，说明前^1层必须能用/-1个球实验J-1次测出来，也就是说，取^=成/-1, 1)+1是最优的。

如果气球没有破，则相当于把第奸1层楼看作1楼以后继续。因此在第&层楼之上还可以 测成/J-1)层楼，即成/J) = k+d(/J-1) = d(/-1J-1) + 1 + d(/J-1)。

例题9-21 修缮长城( Fixing the Great Wall, ACM/ICPC CERC 2004, UVa1336)

长城被看作一条直线段，有n ( 1<n<1000 )个损坏点需要用机器人GWARR修缮。可以 用三元组(〜，^4)描述第/个损坏点的参数，其中〜是位置，是立刻修缮(即时刻=0时开始修 缮)的费用，dz是单位时间增加的修缮费用。换句话说，如果在时刻开始修缮第/个损坏

点，费用为q+Zd。上述参数满足 1<^<500000 , 0<c/<50000 , 1<d/<50000。

修缮的时间忽略不计，GWARR的速度恒定为v ( 1<v<100 ),因此从修缮点/走到修缮 点J需要|〜-~|/v单位的时间。初始坐标为^ ( 1<x<500000 )。输入保证损坏点的位置各不相 同，且GWARR的初始位置不与任何一个损坏点重合。

你的任务是找到修缮所有点的最小费用(用截尾法保留整数部分)。输入保证最小费用

不超过109。

分析】

首先将所有修缮点按照坐标从小到大排序，不难发现在任意时候，已修复的点一定是一

个连续的区间，因此可以考虑用成/，/，幻表示修复完（/，/），且当前位置为&（A=0表示在左端 点/，A=1表示在右端点/ ）时已经发生的总费用。

但是这样会带来一个问题：今后的费用无法计算，因为不知道当前时间。不过没关系，

谁说必须当费用发生以后才能计算？可以事先把还没有发生但是肯定会发生的费用累加到答

案中，然后“时钟归零”。事实上，在前面已经用过一次这种技巧了，那就是例题“颜色的长

度”。

设硪/，M）表示修复完（/，/），且当前位置为女（含义同上）时，已经发生的总费用与所 有“肯定会发生的未来费用”之和，使用刷表法，则一共只有两个决策。

决策1 :往左走，修理点/-1，转移到硪/-1，/，0）。假设当前点为/» （ k=0时p=i，否则p=/ ） 则到达点i-1的时间为HA^-Api/v。在这段时间里，所有未修理点（即点卜i-1和/+1 1 ）的

费用都增加了Z，需要把这些点的总费用（sumj（1，i-1）+sumj（/+1，《）*Z累加到状态值中，然后 点i-1的修理费用就只有cz-1 了。即用成i，/，k）+（sum_^（1，i-1 ）+sum_成/•+1，《））*Z+ci-1来更新成i-1，j，0）。其中sum_^（i，j）表示点i〜j的所有礁之和。

决策2 :往右走，修理点j+1，转移到硪ij+1,1）。和决策1很类似，方程略。

状态有0（«2）个，每个状态只有两个决策，因此时间复杂度为0（«2）。

例题9-22 越大越好( Bigger is Better, ACM/ICPC Xi'an 2006, UVa12105)

你的任务是用不超过《 （ «<100 ）根火柴摆一个尽量大的，能被rn （ m<3000 ）整除的正整 数。例如，《=6和m=3，解为666。无解输出-1，如图9-17所示。

图9-17 火柴数字

分析】

一般来说，整数是从左往右一位一位写的，因此不难想到这样的动态规划算法：用硪i/l 表示用i根火柴能拼出的“除以m余数为/’的最大数，然后用刷表法，枚举在最右边添加的数 字k ,用成i/)*10+k更新成i+c(k),    (/*10+k)%m),其中c(k)表示数字k需要的火柴数。状态

有C>(nm)个，每个状态只有“在右边添加数字0〜9”这10个决策，看上去不错。可惜这个算法 有个缺点：状态值是高精度整数，因此实际计算量比较大。

还有一个算法，虽然有些难想，但是效率很高：用硪i/)表示拼出一个“除以m余数 为/的i位数”至少需要多少火柴(若无解，d(i/)为正无穷)。状态转移方程和上面类似，留给 读者思考。因为此处只关心位数，这个算法并不涉及高精度整数。

如何根据d(i/)计算出题目要求的答案呢？首先确定最大的位数w (即让d(i,0)不是正无穷 的最大i ),因为位数越大，整数就越大(不允许有前导0 ,因为不划算)。接下来从左到右 依次确定各个数字。

例如，假定m=7 ,并且已经确定最大的整数是3位数。首先试着让最高位为9。如果可以 摆出形如9ab的整数，它一定是最大的。是否可以摆出9ab呢？因为900除以7的余数为4 ,后 两位"ab"除以7的余数应为3。如果d(2,3)+c(9)<n ,说明火柴足够摆出9ab ,否则说明最高位不 能是9。重复这个过程，直到所有数字都被确定为止。这个过程需要快速算出形如x000…的 整数除以m的余数，可以通过一个预处理完成，留给读者思考[^](#bookmark12)。

例题9-23 有趣的游戏( Fun Game, ACM/ICPC Beijing 2004, UVa1204)

一些小孩(至少有两个)围成一圈做游戏。每一轮从某个小孩开始往他左边或右边传手 帕。一个小孩拿到手帕后(包括第一个小孩)在手帕上写下自己的性别，男孩写B ,女孩写 G,然后按相同方向传给下一个小孩，每一轮可能在任何一个小孩写完后停止。现在游戏已 经进行了n轮，已知n轮中每轮手帕上留下的字，求最少可能有几个小孩。2<n<16。每轮手帕 上的字数不超过100。

例如，若3轮的手帕上分别留下BGGB , BGBGG , GGGBGB ,则至少有9个小孩。一种 可能性是GGGBGBGGB。

【分析】

首先可以看出，如果有一个字符串完全包含于其他某个字符串，那么这个字符串将对结

果没有影响，所以先预处理去掉这些字符串。后面将看到这会给动态规划带来方便。

在解决原题之前，先看一个简化版：小孩排成一行(而不是一圈)，且传递手帕总是从 左到右的。那么问题就等价于：找一个最短的字符串，使得输入的n个字符串都是它的连续 子串。

可以把这个问题转化为一个多阶段决策过程：每次选择一个字符串“粘”在当前最后一个 字符串的“尾巴”上(重叠部分必须相等)。因为之前已经排除了“相互包含”的情况，所以每 次选择的字符串的头部一定可以“粘”在当前最后一个字符串的内部，并且可以露出一部 分“尾巴”。例如题目中的例子，s1=BGGB, s2=BGBGG, 83=6<^303,则决策过程如图9-18 所示。

最终得到的字符串长度等于所有n个字符串的长度之和，减去每个串(除了第一个串)

与前一个串的最大重叠长度。对于上面的例子，s1, s2, s3的长度之和为15 , s2和s3的最大重 叠长度为3 , s1和s2的最大重叠长度为3 ,因此最终得到的字符串长度为15-3-3=9。注意上 述“最大重叠长度”不是对称的，例如，若s2在右边，s2和s3可以重叠3个字符，但如果s2在左 边，则只能重叠2个字符。

这个过程启发我们使用动态规划。用d(i/)来表示已经选过的字符串集合为i ,最后一个 串为/时，可以减去的重叠部分总长。如图9-19所示，假设已经选择了字符串1, 6, 4，其中最 后一个字符串为4 ,即状态d({1,4,6},    4)。假设接下来选择字符串3 ,并且已经得到了3粘在4

尾巴上时的最大重叠长度为5 ,则可以用d({1,4,6}，4)+5来更新d({1,3,4,6}，3)。

S3

si



图9-19 已选字符串1,6,4的情况



GGGBGB

BGGB



图9-18 决策过程

现在已经解决了简化版问题，原题只有两点不同：

( 1)原题中，手帕有两种不同的方向，因此选择每个串之后，还要确定是把它直接粘 上呢，还是反过来粘，因此状态d(ij)中的/有2n种可能，每次的决策也变成2n个，时间复杂 度不变，只是常数略有增加。

( 2)原题中，所有小孩组成一个圈，因此需要考虑如何把链变成圈。一种方法是在状 态中增加一维，用来记录第一个串是哪个，这样就可以在最后一次决策时计算最后一个串和

第一个串的公共部分。这样做并没有错，但是因为状态多了一维，时间复杂度也将变大。其

实，不需要给状态增加一维，而只需规定第一个串的正向串放在最前面，在动态规划结束之

后检查所有/为全集的状态，考虑第一个串和最后一个串的重叠部分即可，细节请参考代码

仓库。另外还有一个地方要注意：输入字符串不一定是圈的一部分，它可能绕了好几圈（想

一想，上述算法是否能正确处理这种情况）。本题还有一个小陷阱：题目明确说明至少有两

个小孩，所以如果算出的结果为1，应输出2。

这样，即把简化版问题的解扩展成了原题的解法，时间复杂度仍是O（n2*2n）。

例题9-24 书架( Bookcase, ACM/ICPC NWERC 2006, UVa12099)

有打（3<n<70 ）本书，每本书有一个高度什和宽度％ （ 150<什<300 , 5<%<30 ）。现在要

构建一个三层的书架，你可以选择将n本书放在书架的哪一层。设三层高度（该层书的最大 高度）之和为力，书架总宽度（即每层总宽度的最大值）为w,则要求A*w尽量小。

【分析】

如果所有书的高度都相等，本题就是“分成3个子集，使得元素和的最大值尽量小”，而

这是0-1背包类型的问题。这提示我们需要把宽度写到状态里。

首先将所有的书按照高度从大到小排序。不妨设高度最大的书安排在第1层，且第2层的 高度大于等于第3层的高度，然后设状态d（/J，k）表示安排完前/本书，第2层书的宽度之和 为J ,第3层书的宽度之和为kB寸，第2层高度和第3层高度和的最小值。

为什么不记录第1层的高度？因为最高的书在第1层，意味着这一层永远都不会比它更高 了；为什么不记录第1层的宽度？因为目前3层的总宽度等于前/本书的总宽度，只要知道了 第2、3层的宽度，就能算出第1层的宽度。另外，因为这些书已经按照高度从大到小排序 了，一旦3层都放了书， 3层的高度都不会变了，因此：

□如果只有前两层放了书，当且仅当往第3层放书/时，第3层高度会从0变到马。

□如果只有第1层放了书，当且仅当往第2层放书/时，第2层高度会从0变到马。

用刷表法，每个状态d（/J，k）有3种方式更新其他状态：

□把书/放在第1层，用d（/J，k）更新d（/+1J，k）,因为第1层高度不变。

□把书i放在第2层，用d（ij，k）+fj，Hz）更新d（i+1j+W，k），其中＞，h）=h，其他/值为0。

□把书i放在第3层，用d（i，j，k）+fk，H更新d（i+1，j，k+Wi），/函数的定义同上。

这个算法看上去不错，但是仔细一算，状态总数为70 * 2100 * 2100，太大了——就算作 用时间能接受，所占用的空间也无法接受，因此无法使用记忆化搜索，而只能用递推，配合 滚动数组（由于是0-1背包式的递推，i那一维可以完全省略）。

如何优化呢？出乎大多数选手的意料[（13）](#bookmark16)，本题的“标准优化”并没有降低理论时间复杂

度，只是让程序的实际运行效率高了很多。优化有两种：

□ j+k不应该超过前i本书的宽度之和，因此有用的状态比70*2100*2100少得多。

□假设第i层书的总宽度为腳y，如果醫2〉醫1+30 （ 30是一本书的宽度上限），那么可以

把第2层的一本书放到第1层来，则前两层高度之和不会变大，书架宽度（即两层总宽度

的最大值）也不会变大。因此，只需要计算满足醫^腳戸。且醫3＜腳2+30的状态，因

此j＜（2100+30）/2 = 1065，k＜（2100+60）/3 = 720。

强烈建议读者实现优化前后的两个版本，比较二者的效果。

例题9-25 轻松爬山( Easy Climb, NWERC 2008, UVa12170)

输入正整数d*«个正整数hh h2，…，hn，可以修改除了h，hn的其他数，要求修改后相邻 两个数之差的绝对值不超过d，且修改费用最小。设hz修改之后的值为h'z，则修改费用

为|hi-h'i|+|h2-h'2|+...+|hn-h'n|。无解输出-1。K100，d＜109。

【分析】

本题是一个多阶段决策过程：依次确定每个hz修改成什么数。可惜d的范围太大，如果

甩/X    幻表示已经修改i个数，其中第i个数改成时还需要的最小费用，则状态总数高

达 0（nd）。

为了更好地分析问题，先来看看简化版：n=3时，只有^是可以修改的，而且修改之后 必须同时在［hrd，h+d］和［h3-d，h3+d］内，即［max^^hj-d，mi^h^hj+d］。如果这个区间是空 的，说明无解；否则h2要么不变，要么改成max^^hQ-d或者mi^h^hQ+d。

这个例子至少说明了：修改后的值并不是随便选的，至少在n=3时，修改后的值只有3种 选择：h2, max^^hj-d和mi^h^hj+d。

用类似的推理，可以得到这样的结论：每个数在修改之后一定可以写成hp+kd ,其中 1<p<n , -n<k<n ,这样，上述状态/(⑶中的“x”就只有0(n2)种可能了，状态总数为0(n3)。

不难写出状态转移方程:f(i，x)=內-xl+minf-1，y) | x-d<y<x+d｝。如果按照x从小到大的

顺序计算，满足x-d<y<x+d的f(i- 1，y)就是i-1阶段状态值序列的一个滑动窗口。使用前面介绍 过的单调队列，可以在平摊0(1)的时间复杂度内计算出f(i，x),因此本题的总时间复杂度 为 O(n3)。

例题 9-26    一个 调度问题( A Scheduling Problem, ACM/ICPC Kaoshiung 2006,

UVa1380)

有打(n<200 )个恰好需要一天完成的任务，要求用最少的时间完成所有任务。任务可以 并行完成，但必须满足一些约束。约束分有向和无向两种，其中A^B表示A必须在B之前完 成，A-B表示A和B不能在同一天完成。输入保证约束图是将一棵n ( n<200 )个结点的树的某 些边定向后得到的。例如，图9-20表示1和2不能在同一天完成， 1必须在3之前， 3必须在5之 前， 2必须在4之前， 4必须在6之前。

可以使用如下定理:忽略无向边之后，设图上的最长链(即包含点数最多的路径)包 含k个点，则答案为k或者k+1。对于上面的例子，忽略无向边后的最长链是2->4->6 ,包含3 个结点。

【分析】

如果树中所有边都为有向边，那么答案就是最长链上的点数:先将度为0的点全部安排 在第一天，将这些点删去，然后将新的度为0的点安排在第二天，这样就可以在k天内安排 完。这样，原问题转化为:将树中的所有无向边定向，使得树中的最长链最短。

根据题目中的定理，设原图中有向边组成的最长链上有k个点，那么最终的答案不是k就 是k+1，接下来只需要判断是否可以通过无向边定向使得最长链的点数为k。即使没有题目中 的那个定理，也可以二分答案x ,然后判断是否能让最长链的点数不超过x。不管是哪种情 况，问题的关键就是：给定一个x ,判断是否可以给无向边定向，使得最长链点数不超

设Ai)表示以i为根的子树内的边全部定向后，最长链点数不超过的前提下，形如“后代 到i”(如图9-21中的M'-〉M-〉i)的最长链的最小值，同理可以定义g(i)表示形如“i到后代”(如 图9-21中的i-〉v-〉v')的最长链的最小值。达不到的状态(即“最长链点数不超过^”这个前提 无法满足)定义为正无穷。

1

2

3

图9-20 调度问题示意图



图9-21 最长链



如何计算Z(i)和g(i)呢？为了叙述方便，用w表示i的某个子结点，则w和i之间的边有3种 情况：w-〉i , i->w和i-w ,其中前两种是有向边，最后一种是无向边。按照从易到难的顺序, 分两种情况讨论。

情况1 :如果f与州的所有边都是有向边，直接计算即可。令广⑺等于形如w-^的狄的Xw)的最大值加1 , g'(i)等于形如i-〉w的w的g(w)的最大值加1 ,则以i为根的子树内， 经过i的最长链点数等于f7(i)+g'(i)。如果这个值大于^，则f(i)和g(i)为正无穷，否

贝f’)=/(0，g(i)=g'(i)。

情况2 :如果f与某些w之间存在无向边，则需要确定每条f-w定向成w->f还是f->w。由 于定向完成之后，仍需要按照情况1的方法计算，所以问题的关键是分析“定向”操作会如何 影响八i)和g'(i)。

求/(i)时，目标是/\i)+g'(i)Sx的前提T/(i)最小。首先把所有没定向的/>)从小到大排 序。假定把/值第p小的w定向为w-〉i，那么最好“顺便”把前p小的全部变成w-〉i的，因为这样 做不会让T(i)变大，但有可能让g'(i)变小，百利而无一害。所以只需要枚举p，把/值前P小 的w都定向为w-〉i，其他定向为i-〉w，然后计算/(i)。用相同的方法可以计算g(i)。最后判断根 结点的/值是否无穷大即可。

值得一提的是：因为本题规模较小，还有一个更为简单的动态规划算法，不用关心有向 链，而是直接设状态表示d(ij)能否给根节点为i的子树安排时间，使得根节点i恰好在第/天完 成，状态转移方程留给读者思考。

例题9-27 方块消除( Blocks, UVa10559)

有《 ( n<200 )个带颜色方格排成一列，相同颜色的方块连成一个区域。游戏时，可以任

选一个区域消去。设这个区域包含的方块数为x，则将得到个分值，然后右边所有方块就 会向左移一格。如图9-22所示是一个游戏局面和最优消除方式。

Sc4)re = o    Score' ,6    Score = 25    Score *29

图9-22游戏局面和最优消除方式

你的任务是求出最高可能的得分。

【分析】

为了叙述方便，设左数第i个方块的颜色为我i］。按照线性结构动态规划的常见思路，

设d(ij)表示子序列i~j的最大得分，但是似乎无法用d(i，k)和d(kj)来计算d(ij)，因为可 能i~k和k~j各剩下一些，拼起来以后消除。如XAXBXCXDXEX，实际上是把A和E全部单 个消除以后再消除X的。怎么办呢？

在最优矩阵链乘中，枚举的是“最后一次乘法”的位置。本题是不是也可以枚举“最后一

个方块什么时候消掉”呢？这个问题的答案有两种可能：直接把它所在的一段消掉；把它和

左边的某段拼起来以后一起消。第一种情况容易处理，但第二种情况就没那么简单了。

具体来说，设与/•同色的方块可以向左延伸到加(即4^]=4[^+1]= .=4/]),

且A[q]=A[j] , A[q]不等于A[q+1]，则上述第二种情况就是指先把q+1 了-1这一段消掉，

把^〜j这一段和以q为右端点的那一段拼起来，如图9-23所示。注意i~j全部同色时找不到这 样的q ,但此时可以直接计算出结果。下面忽略这种情况。

|      |      | ???  |      |
| ---- | ---- | ---- | ---- |
|      |      |      |      |

7    P    J

图9-23消掉与拼接方块

不过，把这两段拼起来以后仍然不一定立刻消除，还可能要和更左边的另一段拼起 来……是不是很复杂？但有一点是可以肯定的，那就是q+11这一段肯定可以先消掉(拖 到后面再消也得不到什么好处)。那么现在就把它消掉(得分是硪q+1，-1))，得到一个“子 序列i~q的右边再拼上j^+1个与A[q]同色的方块”的奇怪状态，如图9-24所示。

图 9-24 消掉后的奇怪状态

由此可知，在状态中增加一维，来表达“右边拼上一些方块”，即用成i；M)表示“原序列中 的方块i~j右边再拼上&个颜色等于A j]的方块所得到的新序列”的最大得分，则决策有两种。

决策1 :直接消去方块j ,转移到硪i，^-1，0)+j^+&+1)2。

决策2 :枚举q使得A[q]=Aj]且A[q]不等于A[q+1],转移到硪q+1，^-1，0)+<<i，q，    j-p+k

+1)。

状态有0(n3)个，决策有0(n)个，时间复杂度为0(n4)。如果采用记忆化搜索，很多状态 都达不到，而且q的取值范围往往很小，所以对于大部分数据，这个算法的的运行效率都很

高。

例题9-28 独占访问2( Exclusive Access 2, ACM/ICPC NEERC 2009, UVa1439)

在一个庞大的系统里运行着n （ 1<n<100 ）个守护进程。每个进程恰好用到两个资源。这 些资源不支持并发访问，所以这些进程通过锁来保证互斥访问。每个进程的主循环如下：

loop forever DoSomeNonCriticalWork() P.lock()

Q.lock()

WorkWithResourcesPandQ()

Q.unlock()

P.unlock()

end loop

注意，P和0的顺序是至关重要的。如果某进程用到了消息队列和数据库，“先获取数据 库的锁”与“先获取消息队列的锁”可能会产生截然不同的效果。给定每个进程所需要的两种 资源，你的任务是确定每个进程获取锁的顺序，使得进程永远不会死锁，且最坏情况下，等 待链的最大长度最短。

在本题中，一个长度为n的等待链是一个不同资源和不同进程的交替序列：及0 c0 R c^.R, cn RnH ,其中进程c已经获取R.的锁，正在等待的锁。当^^^^时死锁，否则说明 已获取RnH的锁的进程正在执行操作（而非等待中）。

输入n和每个进程需要的两个资源，用两个L~Z之间的大写字符表示（因此一共有15种 资源）。输出包含两行，第一行为最坏情况下等待链的最大长度m,以下n行每行输出两个 字符，表示该进程获取锁的顺序（先获取第一个字符对应资源的锁）。

【分析】

本题初看起来毫无头绪，甚至连数学模型都难以建立。注意，每个进程恰好需要两个资

源，而等待链的定义是资源和进程的交替序列，可以联想到图论中的概念：每条边恰好连接

两个点，路径的定义是点和边的交替序列。

因此，可以把资源看成点，进程看成无向边，此时的任务实际上就是把无向边定向，使

得不存在圈（它对应于死锁），且最长路（即最长等待链）最短。

接下来需要一点创造性思维：把结点分成p层，从左到右编号为0，1, 2，...，使得同层结

点之间没有边。对于任意一条边,把它定向成“从层编号小的点指向层编号大的点”。例 如，若M在第5层，V在第2层，则定向为V-〉M。定向之后的有向图肯定没有圈，且最长路包含 的点数不超过p （想一想，为什么），所以直观上，p应该是越小越好。

事实上，可以证明[^4）](#bookmark4)当p取最小值时，最长路恰好包含p个结点，而且这个结果是所有 定向方案中最优的。这样，就成功地把问题转化为了“结点分层”问题，而这个“结点分层”问 题实际上就是之前学过的色数问题：把图中的结点染成尽量少的颜色，使得相邻结点颜色不

同。套用前面学过的动态规划算法，在0（3勺时间内即解决了问题，其中k<15 ,为资源的最 大数目。

本题是关于“建模与问题转换”的一道经典问题，请读者仔细体会。

例题9-29 整数传输( Integer Transmission, ACM/ICPC Beijing 2007, UVa1228)

你要在一个仿真网络中传输一个n比特的非负整数k。各比特从左到右传输，第i个比特 的发送时刻为i。每个比特的网络延迟总是为0〜之间的实数（因此从左到右第i个比特的到 达时刻为i〜i+d之间）。若同时有多个比特到达，实际收到的顺序任意。求实际收到的整数 有多少种，以及它们的最小值和最大值。例如，n=3 ,表1 , k=2 （二进制为010 ）时实际收到 的整数的二进制可能是001（1）、010（2）和100（4）。 1<n<64， 0<d<n， 0<k<2n。

【分析】

为了简化问题，首先可以规定：所有0按照原来的顺序依次收到，所有的1也按照原来的

顺序依次收到，只是0和1可能交错。这个规定非常重要，请读者仔细体会。

最小值和最大值可以用贪心法得到（留给读者思考），关键在于统计可能收到的整数数 目。给定一个整数P ,如何判断它是否可能被收到呢？来看一个例子。

例如，k=11001010 , d=3 ,需要判断P=00111001是否可以得到。一共有8个比特，则发 送时刻为1〜8 ,接收时刻是1〜12。不难发现，接收时刻可以限制为1〜8 ,因为同一时刻接 收的比特可以任意排列，所以把一个比特延迟到时刻9〜12不会有任何好处。可以手算出一 种方案，如图9-25所示。

图9-25手算方案

上图的意思是：&的比特1和比特2均延迟到时刻4 ,比特7延迟到时刻8。不难发现，对于 任意给定的P ,都可以用贪心法求解：从左到右依次考虑P的每一个比特。如果是0，则接 收女中没有收到的最左边的0 ；如果是1，则接收&中没有收到的最左边的1。

仔细推敲这个过程，可以得到一个结论：在任意时刻，&中已收到的比特中最右边的那 个比特一定没有延迟（理论上可以延迟，但不会得到更优的解）。如图9-26所 示，k=111011001110，框中的比特是已收到的比特，则最右边那个已收到比特（即左数第3 个0）无延迟，即接收时刻和发送时刻均为8。

这样就可以动态规划了[^](#bookmark7) ：用成/J）表示k的前/个0和前/个1收到以后可能形成的整数个

数，则只有两种转移方式：

如果下一个收到的比特可以是0，则成/+1J）需要加上硪/力。

如果下一个收到的比特可以是1，则硪/J+1）需要加上硪/力。

所以问题的关键就是：如何判断下一个收到的比特是否可以为0或者1？还是刚才那个例 子，因为已经收到了3个0和4个1，所以状态是成3,4）。假设下一个收到的比特是0，则左数第 5个1（发送时刻为6）至少得延迟到第4个0的发送时刻（即时刻12），如图9-27所示。如 果^<12-6=6，说明假设不成立。

moil涵liio hioili55|iiio

一般地，设第i （ i^0 ）个0的发送时刻为Zz ,第i个1的发送时刻为Oz ,则当且仅 当Cj+^Zz时硪ij）可以转移到成i+1j）,即下一个收到的比特为0。同理，当且仅 当Z+企Cj时，成ij）可以转移到成ij+1）。另外，使用上述公式时别忘了判断1和0是否已经全 部收完。

状态有C（«2）个，每个状态只有两个决策，因此总时间复杂度为C（«2）。

例题9-30 给孩子起名( The Best Name for Your Baby, ACM/ICPC Yokohama 2006, UVa1375)

给一个包含《条规则的上下文无关文法和长度/ （ 1<«<50 , 0</<20 ）,求出满足该文法的 串中，长度恰好为l的字典序最小串。如果不存在，输出单个字符“-”。

“满足文法”是指可以不断使用规则，把单个大写字母S变成这个串。每条规则形如 A一a ,其中A是一个大写字母（表示非终结符），a是一个由大小写字母组成的字符串（长 度不超过10 ,且可以为空串）。该规则的含义是可以用字符串a来替换当前字符串中的大写 字母A （如果有多个A ,每次只替换一个）。

例如，有4条规则：S->aAB , A—>空串，A—>Aa , B->AbbA ,那么aabb满足该文法，因 为 S^aAB （规则 1 ） ^aB （规则2 ） ^aAbbA （规则4 ） ^aAabbA （规则 3 ） ^aAabb （规则 2 ） ^aabb （规则2 ）。

【分析】

题目中的文法比较复杂，首先把它们简化一下。例如S-〉ABaA拆成3个：S-〉APi , Pi_ 〉BP2 , P2-〉aA。这样，所有规则都变成了A-〉BC的形式，规则总数不超过50*10=500。为了 叙述方便，文法拆分后的所有大小字母和小写字母统称为符号。

接下来试着动态规划：硪i，£）表示符号i能变成的、长度为£且字典序最小的串。如果符 号i不能变成长度为£的串，则硪i，£）无定义。例如，符号i是小写字母且£不等于1时，d（i，£）无 定义。是不是可以这样转移呢：

d（i，£） = min{d（j，p） + d（k，£-p） | 存在规则i-〉jk，0<p<£}

逻辑上没问题，但是如果直接写一个记忆化搜索，程序可能会无限递归：如果有两个规 则A-〉BC , B-〉AC ,则d（4£）的计算需要调用dCB，£）,而计算dCB，£）时又会调用d（4，£）……

怎么办呢？注意到上述情况只有p=0或者p=£时才会出现，大多数情况下还是可以按 照Z从小到大的顺序计算的。所以可以特殊处理£相同时的所谓“同层状态转移”。

具体做法如下：首先从小到大枚举£。对于给定的£ ,先只考虑0<p<£ ,计算出所有d（i，£） 的中间结果，然后把所有有定义的d（i，£）放到一个优先队列中，按照从小到大的顺序处理。 处理d（i，£）时，看看是否有符号/洞足：d（/，0）为空串，并且存在规则Z-〉i/或者Z-〉/i。如果存 在，把d（Z，£）赋值为d（i，£）并加入优先队列中。这个过程类似第11章中将要介绍的Dijkstra ,请

读者仔细体会[（16）](#bookmark10)。

例题9-31 送匹萨( Pizza Delivery, ACM/ICPC Daejeon 2012, UVa1628)

你是一个匹萨店的老板，有一天突然收到了n个客户的订单（n<100 ）。你所在的小镇只 有一条笔直的大街，其中位置0是你的匹萨店，第i个客户的家在位置pz。如果你选择给第it 客户送餐，他将会支付你^乂元，其中是你到达他家的时刻。当然，如果你到的太晚，使 得？Zz<0 ,你可以路过他家但是不进去给他送餐，免得他反过来找你要钱。

你只有一个送餐车，因此只能往返地送餐，如图9-28所示就是一个路线。图中的第一行 是位置，第二行是图上的路线对应的总收益为12 （ c4付3元，c2付3元，c5付5元，^付1 元）。

-6    -3    -10    2    5



27    10    2    5

图9-28送餐路线



20



不过图9-28所示路线并不是最优的。最优路线是0-〉^-〉^-%-〉^ ,总收益是32。你的任

务是求出最大收益。

分析】

本题是不是似曾相识？没错，本节开头的“修缮长城”一题和本题很像，但是有一个重大

的不同：在本题中，可以“放弃”一些订单，所以无法像“修缮长城”那样规定“路过的点总是

顺便修好”，也无法“准确地提前累加未来的费用”。如果要准确地判断每个客户是否有“未来

费用”，必须记录当前时间，因为无法“提前知道”某个客户是否要送餐，只有等到达一个客

户时发现收益变“负”，才会决定放弃它。

看上去很麻烦对吗？其实也不必过于沮丧。本题并不是纯粹的“加强版”，也有条件在本

题中被弱化了。例如，所有客户的“单位时间罚款”是一样的，所以并不需要知道具体还有哪

些客户没有到达，而只需要知道有多少客户没有到达。另一个弱化条件是：《的范围变小，

所以时间复杂度可以略有提高。如果本题的解法仍是动态规划，这就意味着每个状态的决策

数可以增加，或者维数可以增加。

上述分析方式其实与动态规划本身并没有什么关系，但却是一种非常重要的思维过程，

值得读者仔细体会。下面是本题的解法，建议读者自行思考片刻以后再看。

设成/J，k，）表示不考虑/勺的客户（已经送过餐或者已经决定放弃），目前位置是（尸0 表示在/ ,，p=1表示在/），还要给k个人送餐的最大收益。第一个送餐的人/以及送餐总人 数k都需要枚举，最终答案是max{^（/，/，k-1，0） + （ei-pi\）*k | 1<k<n},这里的化刺）*&就是指从0 到，2的过程中，所有k个送餐客户的罚款总和。状态转移方程留给读者思考——对于已经阅读 到这里的读者，相信这不难做到的。



###### 9.6 训练参考

动态规划是算法竞赛的宠儿——几乎所有算法竞赛中都会出现动态规划的题目。本章虽 然也包含一些知识点和理论讲解，但重中之重是那些经典题目（例如，LIS、LCS、最优矩阵 链乘、树的重心和TSP等）和例题。本章的例题数量是本书目前为止最多的，难度也是最大 的。建议读者先掌握不带星号的例题，然后逐步学习带一个星号的例题和两个星号的例题。 有些例题比较复杂，甚至需要反复理解才能掌握。例题列表如表9-2所示。

表9-2 例题列表

| 类别      | 题号     | 题目名称（英文）            | 备注                                  |
| --------- | -------- | --------------------------- | ------------------------------------- |
| 例题9-1   | UVa1025  | A Spy in the Metro          | DAG的动态规划                         |
| 例题9-2   | UVa437   | The Tower of Babylon        | DAG的动态规划                         |
| 例题9-3   | UVa1347  | Tour                        | 经典问题                              |
| 例题9-4   | UVa116   | Unidirectional TSP          | 多段图的最短路；字典序最小解          |
| 例题9-5   | UVa12563 | Jin Ge Jin Qu [h]ao         | 0-1背包问题                           |
| 例题9-6   | UVa11400 | Lighting System Design      | 线性结构上的动态规划                  |
| 例题9-7   | UVa11584 | Partitioning by Palindromes | 线性结构上的动态规划；优化            |
| 例题9-8   | UVa1625  | Color Length                | 类似于LCS的动态 规划；指标函数 的分解 |
| 例题9-9   | UVa10003 | Cutting Sticks              | 类似于最优矩阵链乘的动态规划          |
| 例题9-10  | UVa1626  | Brackets Sequence           | 递归结构的动态规划                    |
| *例题9-11 | UVa1331  | Minimax Triangulation       | 类似于最优三角剖分的动态规划          |

| 例题9-12  | UVa12186 | Another Crisis           | 树形动态规划                                   |
| --------- | -------- | ------------------------ | ---------------------------------------------- |
| 例题9-13  | UVa1220  | Party at Hali-Bula       | 树形动态规划；解的唯一性                       |
| 例题9-14  | UVa1218  | Perfect Service          | 树形动态规划；状态转移方程的优化               |
| 例题9-15  | UVa10817 | Headmaster's Headache    | 集合的动态规划；位运算                         |
| 例题9-16  | UVa1252  | Twenty Questions         | 集合的动态规划；时间优化                       |
| *例题9-17 | UVa1412  | Fund Management          | 复杂状态的动态规划；和指标函数值有关的状态转移 |
| 例题9-18  | UVa10618 | Tango Tango Insurrection | 多阶段决策问题                                 |
| 例题9-19  | UVa1627  | Team them up!            | 图论模型；0-1背包                              |
| 例题9-20  | UVa10934 | Dropping water balloons  | 经典问题                                       |
| 例题9-21  | UVa1336  | Fixing the Great Wall    | 动态规划中“未来费用”的计算                     |
| 例题9-22  | UVa12105 | Bigger is Better         | 用动态规划辅助其他算法                         |
| *例题9-23 | UVa1204  | Fun Game                 | 字符串集合的动态规划                           |
| *例题9-24 | UVa12099 | Bookcase                 | 类似0-1背包问题的动态规划；状态优化            |
| *例题9-25 | UVa12170 | Easy Climb               | 最优解的特征分析；用单调队列优化动态规划       |
|           |          |                          |                                                |

| *例题9-26  | UVa1380  | A Scheduling Problem        | 树的动态规划(复杂)               |
| ---------- | -------- | --------------------------- | -------------------------------- |
| **例题9-27 | UVa10559 | Blocks                      | 给状态增加维度                   |
| *例题9-28  | UVa1439  | Exclusive Access 2          | 图论模型；Dilworth定理           |
| **例题9-29 | UVa1228  | Integer Transmission        | 深入分析问题                     |
| **例题9-30 | UVa1375  | The Best Name for Your Baby | 上下文无关文法；有“环”的动态规划 |
| **例题9-31 | UVa1628  | Pizza Delivery              | 深入分析问题                     |

下面是一些形形色色的动态规划问题，难度各异。建议读者阅读所有题目，然后认真

思考每一道题。对于能写出状态转移方程的题目，尽量编程提交。

习题9-1 最长的滑雪路径( Longest Run on a Snowboard, UVa 10285)

在一个^*C ( ^，C<100 )的整数矩阵上找一条高度严格递减的最长路。起点任意，但每 次只能沿着上下左右4个方向之一走一格，并且不能走出矩阵外。如图9-29所示，最长路就 是按照高度25, 24, 23，...，2, 1这样走，长度为25。矩阵中的数均为0〜100。

| 1    | 2       | 3            | 4    | 5    |
| ---- | ------- | ------------ | ---- | ---- |
| 16   | 17      | 18           | 19   | 6    |
| 15   | 24      | 25           | 20   | 7    |
| 14   | 23      | 22           | 21   | 8    |
| 13   | 12      | 11           | 10   | 9    |
|      | 图 9-29 | 最长路径示例 |      |      |

习题9-2 免费糖果( Free Candies, UVa 10118)

桌上有4堆糖果，每堆有#(#<40 )颗。佳佳有一个最多可以装5颗糖的小篮子。他每次 选择一堆糖果，把最顶上的一颗拿到篮子里。如果篮子里有两颗颜色相同的糖果，佳佳就把 它们从篮子里拿出来放到自己的口袋里。如果篮子满了而里面又没有相同颜色的糖果，游戏 结束，口袋里的糖果就归他了。当然，如果佳佳足够聪明，他有可能把堆里的所有糖果都拿 走。为了拿到尽量多的糖果，佳佳该怎么做呢？

习题9-3 切蛋糕( Cake Slicing, ACM/ICPC Nanjing 2007, UVa1629)

有一个《行讲列(1<« , m<20 )的网格蛋糕上有一些樱桃。每次可以用一刀沿着网格线把 蛋糕切成两块，并且只能够直切不能拐弯。要求最后每一块蛋糕上恰好有一个樱桃，且切割 线总长度最小。如图9-30所示是一种切割方法。

图9-30蛋糕切法示例

习题 9-4 串折叠(Folding, ACM/ICPC NEERC 2002, UVa1630 )

给出一个由大写字母组成的长度为《 ( 1<^<100 )的串，“折叠”成一个尽量短的串。例 如，AAAAAAAAAABABABCCD折叠成9(A)3(AB)CCD。折叠是可以嵌套的，例 如，NEERCYESYESYESNEERCYESYESYES可以折叠成2(NEERC3(YES))。多解时可以输出

任意解。

习题9-5    邮票和信圭寸(Stamps and Envelope Size, ACM/ICPC World Finals 1995,

UVa242)

假定一张信封最多贴5张邮票，如果只能贴1分和3分的邮票，可以组成面值1〜13以及 15 ,但不能组成面值14。我们说：对于邮票组合｛1,3｝以及数量上限5=5 ,最大连续邮资为 13。1〜13和15的组成方法如表9-3所示。

表9-3 1~ 3和15的组成方法

| 1=1          | 2=1+1      | 3=3          | 4=1+3      |
| ------------ | ---------- | ------------ | ---------- |
| 6=3+3        | 7=1+3+3    | 8=1+1+3+3    | 9=3+3+3    |
| 11=1+1+3+3+3 | 12=3+3+3+3 | 13=1+3+3+3+3 | 14无法表示 |

5=1+1+3

10=1+3+3+3

15=3+3+3+3+3

输入5( 5<10)和若干邮票组合(邮票面值不超过100)，选出最大连续邮资最大的一个 组合。如果有多个并列，邮票组合中邮票的张数应最多。如果还有并列，邮票从大到小排序 后字典序应最大。

习题9-6 电子人的基因(Cyborg Genes, UVa 10723 )

输入两个A~Z组成的字符串(长度均不超过30 ),找一个最短的串，使得输入的两个 串均是它的子序列(不一定连续出现)。你的程序还应统计长度最短的串的个数。例 如，ABAAXGF和AABXFGA的最优解之一为AABAAXGFGA , —共有9个解。

习题9-7 密码锁(Locker, Tianjin 2012, UVa1631 )

有一个n ( n<1000 )位密码锁，每位都是0〜9 ,可以循环旋转。每次可以让1〜3个相邻 数字同时往上或者往下转一格。例如， 567890-〉567901(最后3位向上转)。输入初始状态 和终止状态(长度不超过1000)，问最少要转几次。例如， 111111到222222至少转2次，由 896521到183995则要转12次。

习题9-8 阿里巴巴( Alibaba, ACM/ICPC SEERC 2004, UVa1632)

直线上有打(n<10000 )个点，其中第i个点的坐标是〜，且它会在或秒之后消失。Alibaba 可以从任意位置出发，求访问完所有点的最短时间。无解输出No solution。

习题9-9 仓 库守卫( Storage Keepers, UVa10163)

你有n ( n<100 )个相同的仓库。有rn ( m<30 )个人应聘守卫，第i个应聘者的能力值 为 Pi( 1<PZ<1000 )。每个仓库只能有一^个守卫，但一^个守卫可以看守多个仓库。如果应聘 者i看守&个仓库，则每个仓库的安全系数为P/尺的整数部分。没人看守的仓库安全系数为0。

你的任务是招聘一些守卫，使得所有仓库的最小安全系数最大，在此前提下守卫的能力

值总和(这个值等于你所需支付的工资总和)应最小。

习题9-10 照亮体育馆( Barisal Stadium, UVa10641)

输入一个凸n ( 3<n<30 )边形体育馆和多边形外的m ( 1<m<1000 )个点光源，每个点光 源都有一个费用值。选择一组点光源，照亮整个多边形，使得费用值总和尽量小。如图9-31 所示，多边形ABCDEF可以被两组光源｛1,2,3｝和｛4,5,6｝照亮。光源的费用决定了哪组解更 优。

图 9-31 被点光源照亮的多边形



习题9-11    禁止的回文子串( Dyslexic Gollum, ACM/ICPC Amritapuri 2012,

UVa1633)

输入正整数《和^( 1<n<400 , 1<k<10 ),求长度为n的01串中有多少个不含长度至少 为k的回文连续子串。例如，n=k=3时只有4个串满足条件：001, 011, 100, 110。

习题9-12 保卫Zonk ( Protecting Zonk, ACM/ICPC Dhaka 2006, UVa12093 )

给定一个有n ( n<10000 )个结点的无根树。有两种装置A和B ,每种都有无限多个。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-186.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-187.jpg)



在某个结点X使用A装置需要C1 ( C1<1000 )的花费，并且此时与结点X相连的边都被覆 盖。

在某个结点X使用B装置需要C2 ( C2<1000 )的花费，并且此时与结点X相连的边以及与 结点X相连的点相连的边都被覆盖。

求覆盖所有边的最小花费。

习题9-13 叠盘子( Stacking Plates, ACM/ICPC World Finals 2012, UVa1289)

有打(1<n<50 )堆盘子，第i堆盘子有氏个盘子(1<h<50 ),从上到下直径不减。所有盘 子的直径均不超过10000。有如下两种操作。

□    split :把一堆盘子从某个位置处分成上下两堆。

□    join:把一堆盘子放到另一堆盘子的顶端，要求是底部盘子的直径不超过顶端盘子 的直径。

你的任务是用最少的操作把所有盘子叠成一堆。

习题9-14 圆和多边形( Telescope, ACM/ICPC Tsukuba 2000, UVa1543)

给你一个圆和圆周上的打(3<n<40 )个不同点。请选择其中的m ( 3<m<n )个，按照在圆 周上的顺序连成一个m边形，使得它的面积最大。例如，在图9-32中，右上方的多边形最 大。

习题9-15 学习向量( Learning Vector, ACM/ICPC Dhaka 2012, UVa12589)

输入n个向量(人乂)( 0<x , y<50 ),要求选出女个，从(0,0)开始画，使得画出来的折线

与义轴围成的图形面积最大。例如，4个向量是(3,5)，(0,2), (2,2), (3,0),可以依次画(2,2)，(3,0), (3,5)，围成的面积是21.5，如图9-33所示。输出最大面积的两倍。 1<k<n<50。

习题9-16 野餐( The Picnic, ACM/ICPC NWERC 2002, UVa1634)

输入rn ( m<100 )个点，选出其中若干个点，以这些点为顶点组成一个面积最大的凸多 边形，使得内部没有输入点(边界上可以有)。输入点的坐标各不相同，且至少有3个点不 共线，如图9-34所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-189.jpg)



图 9-34 输入点



习题9-17 佳佳的筷子( Chopsticks, UVa 10271)

中国人吃饭喜欢用筷子。佳佳与常人不同，他的一套筷子有3只，两根短筷子和一只比 较长的(一般用来穿香肠之类的食物)。两只较短的筷子的长度应该尽可能接近，但是最长 那只的长度无须考虑。如果一套筷子的长度分别是, B , C ( A<B<C),则用(A-B)2的值表 示这套筷子的质量，这个值越小，这套筷子的质量越高。

佳佳请朋友吃饭，并准备为每人准备一套这种特殊的筷子。佳佳有# ( K1000 )只筷 子，他希望找到一种办法搭配好尺+8套筷子，使得这些筷子的质量值和最小。保证筷子足 够，即 3X+24<#。

提示：需要证明一个猜想。

习题9-18 棒球投手( Pitcher Rotation, ACM/ICPC Kaosiung 2006, UVa1379)

你经营着一支棒球队。在接下来的g+10天中会有容(3<g<200 )场比赛，其中每天最多一 场比赛。你已经分析出你的n ( 5<n<100 )个投手中每个人对阵所有m ( 3<m<30 )个对手的胜 率(一个n*m矩阵)，要求给出作战计划(即每天使用哪个投手)，使得总获胜场数的期望 值最大。注意，一个投手在上场一次后至少要休息4天。

提示：如果直接记录前4天中每天上场的投手编号1〜n ,时间和空间都无法承受。

习题9-19 花环( Garlands, ACM/ICPC CERC 2009, UVa1443)

你的任务是用n ( n<40000 )条等长细绳组成一个花环。每条细绳上都有一颗珍珠，重量 为( 1<wz<10000 )。花环应由讲(2<m<10000 )个片段组成，每个片段必须包含连续的偶

数条细绳。每个片段的一半称为“半段”(两个半段包含相同数量的细绳)，每个“半段”最多 能有^( 1<必10000 )条细绳。你的任务是让最重的半段尽量轻。如图9-35所示，12条细绳的 最优解是如下的3个片段，最重的半段的重量为6(左数第1, 4, 6个半段)。

图9-35 12条细绳的最优解

习题9-20 山路( Mountain Road, NWERC 2009, UVa12222)

有一条狭窄的山路只有一个车道，因此不能有两辆相反方向的车同时驶入。另外，为了 确保安全，对于山路上的任意一点，相邻的两辆同向行驶的车通过它的时间间隔不能少于10 秒。给定n ( 1<n<200 )辆车的行驶方向、到达时刻(对于往右开的车来说是到达山路左端点 的时刻，而对于往左开的车来说是指到达右端点的时刻)，以及行驶完山路的最短时间(为 了保证安全，实际行驶时间可以高于这个值)，输出最后一辆车离开山路的最早时刻。输入 保证任意两辆车的到达时刻均不相同。

提示：本题的主算法并不难，但是实现细节需要仔细推敲。

习题9-21 周期( Period, ACM/ICPC Seoul 2006, UVa1371)

两个串的编辑距离为进行的修改、删除和插入操作次数的最小值（每次一个字符）。如 图9-36所示，d=abcdefg和5=ahcefig的编辑距离为3。

如果可以分成若干部分，使得每部分和y的编辑距离都不超过^ ,则y是的近似周期。 例如，_x=abcdabcabb , y=abc , 可以分解为abcd+abc+abb , 3部分和y的编辑距离分别为1， 0， 1 ,因此y是的1-近似周期。

输入由小写字母组成的和y ,求最小的&使得y是的近似周期。|y|<50 , |<5000。

提示：直接想出的动态规划算法很可能太慢，要想办法降低时间复杂度。

习题9-22 俄罗斯套娃( Matryoshka, ACM/ICPC World Finals 2013, UVa 1579)

桌上有n （ n<500 ）个套娃排成一行，你的任务是把它们套成若干个套娃组，使得每个套 娃组内的套娃编号恰好是从1开始的连续编号。操作规则如下：

□只能把小的套在大的里面，大小相等的套娃相互不能套。

□每次只能把两个相邻的套娃组合并成一个套娃组。

□ 一旦有两个套娃属于同一个组，它们永远都属于同一个组（只有与相邻组合并的过程中 会临时拆散）。

执行合并操作的前后，所有套娃都是关闭的。为了合并两个套娃组，你需要交替地把一 些套娃打开、重新套起来、关闭。例如，为了合并［1， 2， 6］和［4］，需要打开套娃6和4；为了 合并［1， 2， 5］和［3， 4］，需要打开套娃5， 4， 3（只有先打开4才能打开3）。要求打开/关闭的总 次数最少。无解输出impossible。例如，“1 2 3 24 1 3”需要打开7次，如表9-4所示。

| 操作前            | 操作后            | 打开的套娃 |
| ----------------- | ----------------- | ---------- |
| 1 2 3 2 4 1 3     | [1 2] 3 2 4 1 3   | 2          |
| [1 2] 3 2 4 1 3   | [1 2 3] 2 4 1 3   | 3          |
| [1 2 3] 2 4 1 3   | [1 2 3] [2 4] 1 3 | 4          |
| [1 2 3] [2 4] 1 3 | [1 2 3] [2 4 1] 3 | 4, 2       |
| [1 2 3] [2 4 1] 3 | [1 2 3] [2 4 1 3] | 4, 3       |

习题9-23    优化最大值电路( Minimizing Maximizer, ACM/ICPC CERC 2003,

UVa1322)

所谓Maximizer ,就是一个《输入1输出的硬件电路，它可以用若干个串行Sorter来实现， 其中每个Sorter(ij)表示把第/勺个输入从小到大排序。最后一个Sorter的第《个输出就是整个 Maximizer的输出。输入一^个由m个Sorter组成的Maximizer ,保留尽量少的Sorter (顺序不 变)，使得Maximizer仍能正常工作。^<50000 , m<500000。

[(1)](#bookmark25)    注意这个函数的工作方式并不像它表面显示的那样一一如果把-1改成-2 ,并不是在把所有d值都初始化为-2 !请只用

0和-1作为“批量赋值”的参数。

[(2)](#bookmark27)    输出的最后会有一个多余空格，并且没有回车符。在使用时，应在主程序调用print_ans后加一个回车符。如果比赛 明确规定行末不允许有多余空格，则可以像前面介绍的那样加一个变量first来帮助判断。

[(3)](#bookmark29)    如果状态比较复杂，推荐用STL中的map而不是普通数组保存状态值。这样，判断状态S是否算过只需用 if(d. count(S))即可。

[(4)](#bookmark31)    第二个人走到/ + 1时本应转移到曲,/ + 1)，但是根据此处规定，必须写成曲• + 1,/)。

[(5)](#bookmark33)    还有《劲歌金曲2》和《劲歌金曲3》，但本题不予考虑。

[(6)](#bookmark35)    显然大多数歌的长度都大于3分钟，但是KTV可以“切歌”，因此这里的“长度”实际上是指“想唱的时间长度”。

[(7)](#bookmark37)    判断回文也可以用动态规划，读者不妨一试。

[(8)](#bookmark39)    虽然思路很清晰，但具体实现还需要斟酌，建议读者独立完成。

[(9)](#bookmark41)    如何判断/-/是否为多边形的对角线？限于篇幅，本书没有对计算几何进行专门讨论，请读者参考《算法竞赛入门经

典——训练指南》的几何部分。

[(10)](#bookmark43)    所谓NPC，即NP-完全问题(NP-Complete Problem )，是指一类目前还没有找到多项式算法的问题。它的确切定义

超出了本书的范围。

[(11)](#bookmark45)    完整实现见代码仓库。

[(12)](#bookmark47)    其实还有一个更简单的做法，既不需要高精度，也不需要“反着想”，参见代码仓库。

[(13)](#bookmark49)    本题的解法看上去比较常规，但是在NWERC这样较高水平的比赛中，却没有队伍做出来。

[(14)](#bookmark51)    证明思路是从定向方案构造分层图。先把所有路径的起点作为第0层。

[(15)](#bookmark53)    准确地说这不是动态规划，而是组合数学中的递推，因为本题不是最优化问题，而是计数问题。不过解决两个问 题的思路是相同的，所以很多人把组合数学中的递推也算作动态规划。

[(16)](#bookmark55)    本题在实现上有一些细节需要注意，建议参考代码仓库。
